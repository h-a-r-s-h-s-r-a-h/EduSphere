{"Given an integer A, how many structurally unique BST\u2019s (binary search trees) exist that can store values 1\u2026A? Input Format: The first and the only argument of input contains the integer, A. Output Format: Return an integer, representing the answer asked in problem statement. Constraints: 1 <= A <= 18 Example: Input 1: A = 3 Output 1: 5 Explanation 1: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3": "class Solution:\n    # @param A : integer\n    # @return an integer\n    def numTrees(self, A):\n        n=A\n        dp=[0] * (n + 1)\n        dp[0],dp[1] = 1, 1\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[i-j]*dp[j-1]\n        return dp[n]\n\n\n\n", "Given two strings A and B, find the minimum number of steps required to convert A to B. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: * Insert a character * Delete a character * Replace a character Input Format: The first argument of input contains a string, A. The second argument of input contains a string, B. Output Format: Return an integer, representing the minimum number of steps required. Constraints: 1 <= length(A), length(B) <= 450 Examples: Input 1: A = \"abad\" B = \"abac\" Output 1: 1 Explanation 1: Operation 1: Replace d with c. Input 2: A = \"Anshuman\" B = \"Antihuman\" Output 2: 2 Explanation 2: => Operation 1: Replace s with t. => Operation 2: Insert i.": "class Solution:\n    # @param A : string\n    # @param B : string\n    # @return an integer\n    def minDistance(self, A, B):\n        ans=self.solve(A,B,len(A),len(B))\n        return ans\n\n\n    # def solve(self, A, B, n, m):\n    #     if (n==0):\n    #         return m\n    #     if (m==0):\n    #         return n\n        \n    #     if (A[n-1]==B[m-1]):\n    #         return self.solve(A,B,n-1,m-1)\n    #     else:\n    #         return 1+min(self.solve(A,B,n-1,m-1), self.solve(A,B,n-1,m), self.solve(A,B,n,m-1))\n    \n    def solve(self, A, B, n, m):\n        t=[[0]*(m+1) for _ in range (n+1)]\n\n        for i in range (1,n+1):\n            t[i][0]=i\n        for i in range (1,m+1):\n            t[0][i]=i\n        \n        for i in range (1,n+1):\n            for j in range (1,m+1):\n                if (A[i-1]==B[j-1]):\n                    t[i][j]=t[i-1][j-1]\n                else:\n                    t[i][j]=1+min(t[i-1][j-1], t[i-1][j], t[i][j-1])\n        return t[n][m]\n\n\n", "Given an array of non-negative integers, A, of length N, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Return the minimum number of jumps required to reach the last index. If it is not possible to reach the last index, return -1. Problem Constraints 1 <= N <= 106 0 <= A[i] <= 50000 Input Format The first and the only argument contains an integer array, A. Output Format Return an integer, representing the answer as described in the problem statement. Example Input Input 1:A = [2, 1, 1] Input 2:A = [2, 3, 1, 1, 4] Example Output Output 1:1 Output 1:2 Example Explanation Explanation 1:The shortest way to reach index 2 is Index 0 -> Index 2 that requires only 1 jump. Explanation 2:The shortest way to reach index 4 is Index 0 -> Index 1 -> Index 4 that requires 2 jumps.": "class Solution:\n\t# @param A : list of integers\n\t# @return an integer\n\tdef jump(self, A):\n\t    \n\t    last = len(A) - 1\n\t    jumps = 0\n\t    reachable = 0      # reachable with current number of jumps \n\t    next_reachable = 0 # reachable with one additionnal jump\n\t    for i, x in enumerate(A):\n\t        \n\t        if reachable >= last:\n\t            break \n\t        \n\t        if reachable < i:\n\t            reachable = next_reachable\n\t            jumps += 1\n\t            if reachable < i:\n\t                return -1\n\t        next_reachable = max(next_reachable, i+x)\n\t    \n\t    return jumps\n\t            \n\n\t    \n\t        \n\t        \n\t        \n\n\n\n", "Given a 2D integer array A of size M x N, you need to find a path from top left to bottom right which minimizes the sum of all numbers along its path. NOTE: You can only move either down or right at any point in time. Input Format First and only argument is an 2D integer array A of size M x N. Output Format Return a single integer denoting the minimum sum of a path from cell (1, 1) to cell (M, N). Example Input Input 1: A = [ [1, 3, 2] [4, 3, 1] [5, 6, 1] ] Example Output Output 1: 8 Example Explanation Explanation 1: The path is 1 -> 3 -> 2 -> 1 -> 1 So ( 1 + 3 + 2 + 1 + 1) = 8": "class Solution:\n    # @param A : list of list of integers\n    # @return an integer\n    def minPathSum(self, A):\n        n = len(A)\n        m = len(A[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n        dp[n-1][m-1] = A[n-1][m-1]\n        for i in range(n-1,-1,-1):\n            for j in range(m-1,-1,-1):\n                if j == m-1:\n                    if i != n-1:\n                        dp[i][j] = A[i][j] + dp[i+1][j]\n                elif i==n-1:\n                    dp[i][j] = A[i][j] + dp[i][j+1]\n                else:    \n                    dp[i][j] = A[i][j] + min(dp[i][j+1], dp[i+1][j])\n        return dp[0][0]\n\n\n\n", "Given a string A, partition A such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of A. Problem Constraints 1 <= length(A) <= 501 Input Format The first and the only argument contains the string A. Output Format Return an integer, representing the minimum cuts needed. Example Input Input 1: A = \"aba\" Input 2: A = \"aab\" Example Output Output 1: 0 Output 2: 1 Example Explanation Explanation 1: \"aba\" is already a palindrome, so no cuts are needed. Explanation 2: Return 1 since the palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.": "import sys\nfrom functools import lru_cache\nsys.setrecursionlimit(100000)\nclass Solution:\n    # @param A : string\n    # @return an integer\n    @lru_cache(100000)\n    def minCut(self, s):\n        return 0 if s[::-1] == s else min(1 + self.minCut(s[i:]) for i in range(1, len(s)) if s[:i][::-1] == s[:i])\n            \n\n\n\n", "Implement wildcard pattern matching with support for '?' and '*' for strings A and B. * '?' : Matches any single character. * '*' : Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Problem Constraints 1 <= |A|, |B| <= 9e4 Input Format The first argument of input contains a string A. The second argument of input contains a string B. Output Format Return 0 or 1: => 0 : If the patterns do not match. => 1 : If the patterns match. Example Input Input 1: A = \"aa\" B = \"a\" Input 2: A = \"aa\" B = \"aa\" Input 3: A = \"aaa\" B = \"aa\" Input 4: A = \"aa\" B = \"*\" Input 5: A = \"aa\" B = \"a*\" Input 6: A = \"ab\" B = \"?*\" Input 7: A = \"aab\" B = \"c*a*b\" Example Output Output 1:0 Output 2:1 Output 3:0 Output 4:1 Output 5:1 Output 6:1 Output 7:0": "class Solution:\r\n    # @param s : string\r\n    # @param p : string\r\n    # @return an integer\r\n    def isMatch(self, s, p):\r\n        if len(p) - p.count('*') > len(s):\r\n            return 0\r\n        DP = [True] + [False]*len(s)\r\n        for c in p:\r\n            if c == '*':\r\n                for n in range(1, len(s)+1):\r\n                    DP[n] = DP[n-1] or DP[n]\r\n            else:\r\n                for n in range(len(s)-1, -1, -1):\r\n                    DP[n+1] = DP[n] and (c == s[n] or c == '?')\r\n            DP[0] = DP[0] and c == '*'\r\n        return 1 if DP[-1] else 0", "Given a binary tree T, find the maximum path sum. The path may start and end at any node in the tree. Problem Constraints 1 <= Number of Nodes <= 7e4 -1000 <= Value of Node in T <= 1000 Input Format The first and the only argument contains a pointer to the root of T, A. Output Format Return an integer representing the maximum sum path. Example Input Input 1: 1 / \\ 2 3 Input 2: 20 / \\ -10 20 / \\ -10 -50 Example Output Output 1: 6 Output 2: 40 Example Explanation Explanation 1: The path with maximum sum is: 2 -> 1 -> 3 Explanation 2: The path with maximum sum is: 20 -> 20": "# Definition for a  binary tree node\n# class TreeNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.left = None\n#        self.right = None\n\nclass Solution:\n    # @param A : root node of tree\n    # @return an integer\n    def maxPathSum(self, A):\n        max_path_sum = float(\"-inf\")\n        \n        def get_max_sum(root, memo):\n            if root in memo:\n                return memo[root]\n                \n            nonlocal max_path_sum\n            if not root:\n                return 0\n            \n            left_sum = max(get_max_sum(root.left, memo), 0)\n            right_sum = max(get_max_sum(root.right, memo), 0)\n            \n            current_max_sum = root.val + left_sum + right_sum\n            max_path_sum = max(max_path_sum, current_max_sum)\n            \n            memo[root] = root.val + max(left_sum, right_sum) \n            return memo[root]\n        \n        get_max_sum(A, {})\n        return max_path_sum\n\n\n", "Say you have an array, A, for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Return the maximum possible profit. Problem Constraints 0 <= len(A) <= 7e5 1 <= A[i] <= 1e7 Input Format The first and the only argument is an array of integers, A. Output Format Return an integer, representing the maximum possible profit. Example Input Input 1: A = [1, 2] Input 2: A = [1, 4, 5, 2, 4] Example Output Output 1: 1 Output 2: 4 Example Explanation Explanation 1: Buy the stock on day 0, and sell it on day 1. Explanation 2: Buy the stock on day 0, and sell it on day 2.": "class Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def maxProfit(self, A):\n        n = len(A)\n        max_profit = 0\n        dp = [0] * n\n        for i in range(n-2, -1, -1):\n            dp[i] = max(A[i+1], dp[i+1])\n            \n        for i in range(n-1):\n            max_profit = max(max_profit, dp[i] - A[i])\n                \n        return max_profit\n\n\n", "Say you have an array, A, for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most 2 transactions. Return the maximum possible profit. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Problem Constraints 1 <= length(A) <= 7e5 1 <= A[i] <= 1e7 Input Format The first and only argument is an integer array, A. Output Format Return an integer, representing the maximum possible profit. Example Input Input 1: A = [1, 2, 1, 2] Input 2: A = [7, 2, 4, 8, 7] Example Output Output 1: 2 Output 2: 6 Example Explanation Explanation 1: Day 0 : Buy Day 1 : Sell Day 2 : Buy Day 3 : Sell Explanation 2: Day 1 : Buy Day 3 : Sell": "INF = float('inf')\n\nclass Solution:\n\t# @param A : tuple of integers\n\t# @return an integer\n\tdef maxProfit(self, A):\n\t    ''' For one transaction, we can do it linearly:\n\t           price that day - minimum seen so far.\n\t           \n\t        For two transactions, we evaluates this at day i + best for remaining days.\n\t    '''\n\t    \n\t    # Best solutions based on increasing starting days\n\t    # We are doing it backward\n\t    bystart = []\n\t    high = -INF # maximum so far\n\t    best = 0\n\t    for x in reversed(A):\n\t        best = max(best, high-x)\n\t        bystart.append(best)\n\t        high = max(high, x)\n\t        \n\t    low = INF # minimum so far\n\t    best = 0\n\t    total = 0\n\t    for x, best2 in zip(A, reversed(bystart)):\n\t        best = max(best, x-low)\n\t        total = max(total, best+best2)\n\t        low = min(low, x)\n\t    \n\t    return total\n\t    \n\t    \n\t    \n\t       \n\n\n", "Say you have an array, A, for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Problem Constraints 0 <= len(A) <= 1e5 1 <= A[i] <= 1e7 Input Format The first and only argument is an array of integers, A. Output Format Return an integer, representing the maximum possible profit. Example Input Input 1: A = [1, 2, 3] Input 2: A = [5, 2, 10] Example Output Output 1: 2 Output 2: 8 Example Explanation Explanation 1: => Buy a stock on day 0. => Sell the stock on day 1. (Profit +1) => Buy a stock on day 1. => Sell the stock on day 2. (Profit +1) Overall Profit = 2 Explanation 2: => Buy a stock on day 1. => Sell the stock on on day 2. (Profit +8) Overall profit = 8": "class Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def maxProfit(self, A):\n        p=0\n        for i in range(len(A)-1):\n            if A[i]<A[i+1]:\n                p+= (A[i+1]-A[i])\n        return p\n\n\n", "A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 Given an encoded message A containing digits, determine the total number of ways to decode it modulo 109 + 7. Problem Constraints 1 <= |A| <= 105 Input Format The first and the only argument is a string A. Output Format Return a single integer denoting the total number of ways to decode it modulo 109 + 7. Example Input Input 1: A = \"8\" Input 2: A = \"12\" Example Output Output 1: 1 Output 2: 2 Example Explanation Explanation 1: Given encoded message \"8\", it could be decoded as only \"H\" (8). The number of ways decoding \"8\" is 1. Explanation 2: Given encoded message \"12\", it could be decoded as \"AB\" (1, 2) or \"L\" (12). The number of ways decoding \"12\" is 2.": "class Solution:\n    # @param A : string\n    # @return an integer\n    def numDecodings(self, A):\n        A=list(A)\n        n=len(A)\n        x=[0]*(n+1);\n        x[0]=1;\n        x[1]=1\n        if(A[0]=='0'):\n            return 0\n        for i in range(1,n):\n            if(int(A[i-1]+A[i])<=26 and int(A[i-1]+A[i])>0):\n                f=1\n            else:\n                f=0\n            if(A[i]=='0'):\n                x[i+1]=x[i-1]*f\n                if(x[i+1]==0):\n                    x[n]=0\n                    break\n                x[i]=0\n            else:\n                x[i+1]=x[i]+x[i-1]*f\n        return x[n]\n            \n            \n\n\n", "Find the contiguous subarray within an array (containing at least one number) which has the largest product. Return an integer corresponding to the maximum product possible. Example : Input : [2, 3, -2, 4] Return : 6 Possible with [2, 3]": "class Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def maxProduct(self, A):\n        assert len(A) > 0\n        ans = A[0]\n        ma, mi = 1, 1\n        for a in A:\n            ma, mi = max(a, a*ma, a*mi), min(a, a*ma, a*mi)\n            ans = max(ans, ma, mi)\n        return ans\n            \n\n\n", "Given a grid of size m * n, lets assume you are starting at (1,1) and your goal is to reach (m,n). At any instance, if you are on (x,y), you can either go to (x, y + 1) or (x + 1, y). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Example : There is one obstacle in the middle of a 3x3 grid as illustrated below. [ [0,0,0], [0,1,0], [0,0,0] ] The total number of unique paths is 2. Note: m and n will be at most 100.": "class Solution:\n    # @param A : list of list of integers\n    # @return an integer\n    def uniquePathsWithObstacles(self, A):\n        x=[[0]*len(A[0]) for i in range(len(A))]\n        \n        \n        for i in range(len(A)):\n            for j in range(len(A[0])):\n                if A[i][j]==0:\n                    if j==0 and i==0:\n                        x[i][j]=1\n                    elif j==0:\n                        x[i][j]=x[i-1][j]\n                    elif i==0:\n                        x[i][j]=x[i][j-1]\n                    else:\n                        x[i][j]=x[i-1][j]+x[i][j-1]\n        #print(x)\n        return x[len(A)-1][len(A[0])-1]\n                    \n                    \n\n\n\n", "Given two sequences A, B, count number of unique ways in sequence A, to form a subsequence that is identical to the sequence B. Subsequence : A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u201cACE\u201d is a subsequence of \u201cABCDE\u201d while \u201cAEC\u201d is not). Input Format: The first argument of input contains a string, A. The second argument of input contains a string, B. Output Format: Return an integer representing the answer as described in the problem statement. Constraints: 1 <= length(A), length(B) <= 700 Example : Input 1: A = \"abc\" B = \"abc\" Output 1: 1 Explanation 1: Both the strings are equal. Input 2: A = \"rabbbit\" B = \"rabbit\" Output 2: 3 Explanation 2: These are the possible removals of characters: => A = \"ra_bbit\" => A = \"rab_bit\" => A = \"rabb_it\" Note: \"_\" marks the removed character.": "def findSubsequenceCount(S, T): \n  \n    m = len(T) \n    n = len(S) \n  \n    # T can't appear as a subsequence in S \n    if m > n: \n        return 0\n  \n    # mat[i][j] stores the count of  \n    # occurrences of T(1..i) in S(1..j). \n    mat = [[0 for _ in range(n + 1)] \n              for __ in range(m + 1)] \n  \n    # Initializing first column with all 0s. x \n    # An empty string can't have another \n    # string as suhsequence \n    for i in range(1, m + 1): \n        mat[i][0] = 0\n  \n    # Initializing first row with all 1s.  \n    # An empty string is subsequence of all. \n    for j in range(n + 1): \n        mat[0][j] = 1\n  \n    # Fill mat[][] in bottom up manner \n    for i in range(1, m + 1): \n        for j in range(1, n + 1): \n  \n            # If last characters don't match,  \n            # then value is same as the value  \n            # without last character in S. \n            if T[i - 1] != S[j - 1]: \n                mat[i][j] = mat[i][j - 1] \n                  \n            # Else value is obtained considering two cases. \n            # a) All substrings without last character in S \n            # b) All substrings without last characters in \n            # both. \n            else: \n                mat[i][j] = (mat[i][j - 1] + \n                             mat[i - 1][j - 1]) \n  \n    return mat[m][n] \nclass Solution:\n\t# @param A : string\n\t# @param B : string\n\t# @return an integer\n\tdef numDistinct(self, A, B):\n\t    return findSubsequenceCount(A,B)\n", "Given a 2D binary matrix filled with 0\u2019s and 1\u2019s, find the largest rectangle containing all ones and return its area. Bonus if you can solve it in O(n^2) or less. Example : A : [ 1 1 1 0 1 1 1 0 0 ] Output : 4 As the max area rectangle is created by the 2x2 rectangle created by (0,1), (0,2), (1,1) and (1,2)": "class Solution:\n    # @param A : list of list of integers\n    # @return an integer\n    def maximalRectangle(self, A):\n        n=len(A)\n        m=len(A[0])\n        for i in range(m):\n            s=0\n            for j in range(n):\n                if A[j][i]==1:\n                    s+=1\n                    A[j][i]=s\n                else:\n                    s=0\n        resultArea=0\n        for i in range(n):\n            firstMinLeft=[]\n            firstMinRight=[]\n            st=[]\n            for j in range(m):\n                while st and st[-1][0]>=A[i][j]:\n                    st.pop()\n                if st:\n                    firstMinLeft.append(st[-1][1])\n                else:\n                    firstMinLeft.append(-1)\n                st.append((A[i][j],j))\n            st=[]\n            for j in range(m-1,-1,-1):\n                while st and st[-1][0]>=A[i][j]:\n                    st.pop()\n                if st:\n                    firstMinRight.append(st[-1][1])\n                else:\n                    firstMinRight.append(m)\n                st.append((A[i][j],j))\n            firstMinRight=firstMinRight[::-1]\n            for j in range(m):\n                area=(firstMinRight[j]-firstMinLeft[j]-1)*A[i][j]\n                resultArea=max(area,resultArea)\n        return resultArea\n            \n            \n            \n            \n                \n\n\n\n", "Find the longest increasing subsequence of a given array of integers, A. In other words, find a subsequence of array in which the subsequence's elements are in strictly increasing order, and in which the subsequence is as long as possible. In this case, return the length of the longest increasing subsequence. Problem Constraints 1 <= length(A) <= 2500 0 <= A[i] <= 2500 Input Format The first and the only argument is an integer array A. Output Format Return an integer representing the length of the longest increasing subsequence. Example Input Input 1: A = [1, 2, 1, 5] Input 2: A = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15] Example Output Output 1: 3 Output 2: 6 Example Explanation Explanation 1: The longest increasing subsequence: [1, 2, 5] Explanation 2: The possible longest increasing subsequences: [0, 2, 6, 9, 13, 15] or [0, 4, 6, 9, 11, 15] or [0, 4, 6, 9, 13, 15]": "from bisect import insort,bisect_left,bisect_right\nclass Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def lis(self, A):\n        d = [A[0]]\n        n = len(A)\n        for i in range(1,n):\n            if d[-1] < A[i]:\n                d.append(A[i])\n            else:\n                idx = bisect_left(d,A[i])\n                d[idx] = A[i]\n            \n        return len(d)\n\n\n", "N children are standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: * Each child must have at least one candy. * Children with a higher rating get more candies than their neighbors. What is the minimum number of candies you must give? Problem Constraints 1 <= N <= 105 -109 <= A[i] <= 109 Input Format The first and only argument is an integer array A representing the rating of children. Output Format Return an integer representing the minimum candies to be given. Example Input Input 1: A = [1, 2] Input 2: A = [1, 5, 2, 1] Example Output Output 1: 3 Output 2: 7 Example Explanation Explanation 1: The candidate with 1 rating gets 1 candy and candidate with rating 2 cannot get 1 candy as 1 is its neighbor. So rating 2 candidate gets 2 candies. In total, 2 + 1 = 3 candies need to be given out. Explanation 2: Candies given = [1, 3, 2, 1]": "class Solution:\n    # @param A : list of integers\n    # @return an integer\n    def candy(self, A):\n        n = len(A)\n        arr = [1 for i in range(n)]\n        for i in range(1, n):\n            if A[i] > A[i-1]:\n                arr[i] = arr[i-1] + 1\n        for i in range(n-2, -1, -1):\n            if A[i] > A[i+1] and arr[i] <= arr[i+1]:\n                arr[i] = arr[i+1] + 1\n         \n        return sum(arr)\n            \n\n\n\n", "Given an array of size N, find the majority element. The majority element is the element that appears more than floor(N/2) times. You may assume that the array is non-empty and the majority element always exist in the array. Problem Constraints 1 <= |A| <= 106 1 <= Ai <= 109 Input Format The first argument is an integer array A. Output Format Return the majority element. Example Input A = [2, 1, 2] Example Output 2 Example Explanation 2 occurs 2 times which is greater than 3/2.": "class Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def majorityElement(self, A):\n        my_freq_map = {k:0 for k in set(A)}\n        N = len(A)\n        for el in A:\n            my_freq_map[el] += 1\n            if my_freq_map[el]>(N//2):\n                return el\n\n\n", "Given two integer arrays A and B of size N. There are N gas stations along a circular route, where the amount of gas at station i is A[i]. You have a car with an unlimited gas tank and it costs B[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the minimum starting gas station's index if you can travel around the circuit once, otherwise return -1. You can only travel in one direction. i to i+1, i+2, ... n-1, 0, 1, 2.. Completing the circuit means starting at i and ending up at i again. Problem Constraints 1 <= |A| <= 5 * 105 |A| == |B| 0 <= Ai <= 5 * 103 0 <= Bi <= 5 * 103 Input Format The first argument given is the integer array A. The second argument given is the integer array B. Output Format Return the minimum starting gas station's index if you can travel around the circuit once, otherwise return -1. Example Input A = [1, 2] B = [2, 1] Example Output 1 Example Explanation If you start from index 0, you can fill in A[0] = 1 amount of gas. Now your tank has 1 unit of gas. But you need B[0] = 2 gas to travel to station 1. If you start from index 1, you can fill in A[1] = 2 amount of gas. Now your tank has 2 units of gas. You need B[1] = 1 gas to get to station 0. So, you travel to station 0 and still have 1 unit of gas left over. You fill in A[0] = 1 unit of additional gas, making your current gas = 2. It costs you B[0] = 2 to get to station 1, which you do and complete the circuit.": "class Solution:\n    # @param gas : tuple of integers\n    # @param cost : tuple of integers\n    # @return an integer\n    def canCompleteCircuit(self, gas, cost):\n        cumm_gas, cum_cost = 0,0\n        tank,start = 0,0\n        for i in range(len(gas)):\n            cumm_gas += gas[i]\n            cum_cost += cost[i]\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                tank = 0\n                start = i+1\n        if cumm_gas < cum_cost: return -1\n        return start", "What is Algorithm | Introduction to Algorithms -  ": ["# Python3 program to add three numbers\n# with the help of above designed\n# algorithm\n \n \nif __name__ == '__main__':\n \n    # Variables to take the input of\n    # the 3 numbers\n    num1 = num2 = num3 = 0\n \n    # Variable to store the resultant sum\n    sum = 0\n \n    # Take the 3 numbers as input\n    num1 = int(input('Enter the 1st number: '))\n \n    num2 = int(input('Enter the 2nd number: '))\n \n    num3 = int(input('Enter the 3rd number: '))\n \n    # Calculate the sum using + operator\n    # and store it in variable sum\n    sum = num1 + num2 + num3\n \n    # Print the sum\n    print('\\nSum of the 3 numbers is:', sum)\n"], "Introduction to Bitwise Algorithms - Data Structures and Algorithms Tutorial -  ": ["a = 7\nb = 4\nresult = a & b\nprint(result)\n# This code is contributed by akashish__\n", "a = 12\nb = 25\nresult = a | b\nprint(result)\n \n# This code is contributed by garg28harsh.\n", "a = 12\nb = 25\nresult = a ^ b\nprint(result)\n \n# This code is contributed by garg28harsh.\n", "a = 0\nprint('Value of a without using NOT operator: ' , a)\nprint('Inverting using NOT operator (with sign bit): ' , (~a))\nprint('Inverting using NOT operator (without sign bit): ' , int(not(a)))\n#  This code is contributed by akashish__\n", "# Python code for the above approach\n \nnum1 = 1024\n \nbt1 = bin(num1)[2:].zfill(32)\nprint(bt1)\n \nnum2 = num1 << 1\nbt2 = bin(num2)[2:].zfill(32)\nprint(bt2)\n \nnum3 = num1 << 2\nbitset13 = bin(num3)[2:].zfill(16)\nprint(bitset13)\n \n# This code is contributed by Prince Kumar\n", "# num = number, pos = position at which we want to set the bit\ndef set(num, pos):\n    # First step = Shift '1'\n    # Second step = Bitwise OR\n    num |= (1 << pos)\n    print(num)\n \n \nnum, pos = 4, 1\n \nset(num, pos)\n \n# This code is contributed by sarajadhav12052009\n", "# First Step: Getting which have all '1's except the\n# given position\n \n \ndef unset(num, pos):\n    # Second Step: Bitwise AND this number with the given number\n    num &= (~(1 << pos))\n    print(num)\n \n \nnum, pos = 7, 1\n \nunset(num, pos)\n", "def toggle(num, pos):\n    # First Step: Shifts '1'\n    # Second Step: XOR num\n    num ^= (1 << pos)\n    print(num)\n \n \nnum, pos = 4, 1\n \ntoggle(num, pos)\n \n# This code is contributed by sarajadhav12052009\n", "# code\ndef at_position(num, pos):\n    bit = num & (1 << pos)\n    return bit\n \n \nnum = 5\npos = 0\nbit = at_position(num, pos)\nprint(bit)\n", "# Python program for the above approach\n \nnum = 12\nans = num << 1\nprint(ans)\n \n# This code is contributed by Shubham Singh\n", "# Python program for the above approach\n \nnum = 12\nans = num >> 1\nprint(ans)\n \n# This code is contributed by Shubham Singh\n", "def countBits(n):\n    # Initializing a variable count to 0\n    count = 0\n    while n:\n        # If the last bit is 1, count will be incremented by 1 in this step.\n        count += n & 1\n        # Using the right shift operator. The bits will be shifted one position to the right.\n        n >>= 1\n    return count\n"], "Introduction to Divide and Conquer Algorithm - Data Structure and Algorithm Tutorials -  ": ["# Python3 code to demonstrate Divide and\n# Conquer Algorithm\n \n# Function to find the maximum no.\n# in a given array.\n \n \ndef DAC_Max(a, index, l):\n    max = -1\n    if(l - 1 == 0):\n        return arr[index]\n    if (index >= l - 2):\n        if (a[index] > a[index + 1]):\n            return a[index]\n        else:\n            return a[index + 1]\n \n    # Logic to find the Maximum element\n    # in the given array.\n    max = DAC_Max(a, index + 1, l)\n \n    if (a[index] > max):\n        return a[index]\n    else:\n        return max\n \n# Function to find the minimum no.\n# in a given array.\n \n \ndef DAC_Min(a, index, l):\n    min = 0\n    if(l - 1 == 0):\n        return arr[index]\n    if (index >= l - 2):\n        if (a[index] < a[index + 1]):\n            return a[index]\n        else:\n            return a[index + 1]\n \n    # Logic to find the Minimum element\n    # in the given array.\n    min = DAC_Min(a, index + 1, l)\n \n    if (a[index] < min):\n        return a[index]\n    else:\n        return min\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # Defining the variables\n    min, max = 0, -1\n \n    # Initializing the array\n    a = [70, 250, 50, 80, 140, 12, 14]\n \n    # Recursion - DAC_Max function called\n    max = DAC_Max(a, 0, 7)\n \n    # Recursion - DAC_Max function called\n    min = DAC_Min(a, 0, 7)\n    print('The minimum number in a given array is : ', min)\n    print('The maximum number in a given array is : ', max)\n \n# This code is contributed by 29AjayKumar\n"], "Introduction to Recursion - Data Structure and Algorithm Tutorials -  ": ["# A Python 3 program to\n# demonstrate working of\n# recursion\n \n \ndef printFun(test):\n \n    if (test < 1):\n        return\n    else:\n \n        print(test, end=' ')\n        printFun(test-1)  # statement 2\n        print(test, end=' ')\n        return\n \n# Driver Code\ntest = 3\nprintFun(test)\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# Python code to implement Fibonacci series\n \n# Function for fibonacci\ndef fib(n):\n \n    # Stop condition\n    if (n == 0):\n        return 0\n \n    # Stop condition\n    if (n == 1 or n == 2):\n        return 1\n \n    # Recursion function\n    else:\n        return (fib(n - 1) + fib(n - 2))\n \n \n# Driver Code\n \n# Initialize variable n.\nn = 5;\nprint('Fibonacci series of 5 numbers is :',end=' ')\n \n# for loop to print the fibonacci series.\nfor i in range(0,n): \n    print(fib(i),end=' ')\n", "# Python3 code to implement factorial\n \n# Factorial function\ndef f(n):\n \n    # Stop condition\n    if (n == 0 or n == 1):\n        return 1;\n \n    # Recursive condition\n    else:\n        return n * f(n - 1);\n \n \n# Driver code\nif __name__=='__main__':\n \n    n = 5;\n    print('factorial of',n,'is:',f(n))\n     \n    # This code is contributed by pratham76.\n", "def factorial(n):\n    # Base case: if n is 0 or 1, return 1\n    if n == 0 or n == 1:\n        return 1\n \n    # Recursive case: if n is greater than 1, call the function with n-1 and multiply by n\n    else:\n        return n * factorial(n-1)\n \n# Call the factorial function and print the result\nresult = factorial(5)\nprint(result)  # Output: 120\n"], "Introduction to Pattern Searching - Data Structure and Algorithm Tutorial -  ": ["# Python program for above approach \ndef search(pat, txt): \n    M = len(pat) \n    N = len(txt) \n    for i in range(N-M): \n        for j in range(M): \n            k = j+1\n            if(txt[i+j] != pat[j]): \n                break\n        if(k == M): \n            print('Pattern found at index ', i) \n  \ntxt = 'AABAACAADAABAAABAA'\npat = 'AABA'\nsearch(pat, txt) \n  \n# This code is contributed by ishankhandelwals.\n", "# Python program for implementation of KMP pattern searching \n# algorithm \ndef computeLPSArray(pat, M, lps): \n    len = 0  # length of the previous longest prefix suffix \n  \n    lps[0]  # lps[0] is always 0 \n    i = 1\n  \n    # the loop calculates lps[i] for i = 1 to M-1 \n    while i < M: \n        if pat[i] == pat[len]: \n            len += 1\n            lps[i] = len\n            i += 1\n        else: \n            # This is tricky. Consider the example. \n            # AAACAAAA and i = 7. The idea is similar \n            # to search step. \n            if len != 0: \n                len = lps[len-1] \n  \n            # Also, note that we do not increment i here \n            else: \n                lps[i] = 0\n                i += 1\n  \ndef KMPSearch(pat, txt): \n    M = len(pat) \n    N = len(txt) \n  \n    # create lps[] that will hold the longest prefix suffix \n    # values for pattern \n    lps = [0]*M \n    j = 0  # index for pat[] \n  \n    # Preprocess the pattern (calculate lps[] array) \n    computeLPSArray(pat, M, lps) \n  \n    i = 0  # index for txt[] \n    while (N - i) >= (M - j): \n        if pat[j] == txt[i]: \n            j += 1\n            i += 1\n  \n        if j == M: \n            print('Found pattern at index:', i-j) \n            j = lps[j-1] \n  \n        # mismatch after j matches \n        elif i < N and pat[j] != txt[i]: \n            # Do not match lps[0..lps[j-1]] characters, \n            # they will match anyway \n            if j != 0: \n                j = lps[j-1] \n            else: \n                i += 1\n  \ntxt = 'ABABDABACDABABCABAB'\npat = 'ABABCABAB'\nKMPSearch(pat, txt) \n  \n# This code is contributed by ishankhandelwals.\n", "# d is the number of characters in the input alphabet \nd = 256\n  \n''' pat -> pattern \ntxt -> text \nq -> A prime number '''\ndef search(pat, txt, q): \n      \n    M = len(pat) \n    N = len(txt) \n    p = 0 # hash value for pattern \n    t = 0 # hash value for txt \n    h = 1\n  \n    # The value of h would be 'pow(d, M-1)%q' \n    for i in range(M - 1): \n        h = (h * d) % q \n  \n    # Calculate the hash value of pattern and first \n    # window of text \n    for i in range(M): \n        p = (d * p + ord(pat[i])) % q \n        t = (d * t + ord(txt[i])) % q \n  \n    # Slide the pattern over text one by one \n    for i in range(N - M + 1): \n        # Check the hash values of current window of text \n        # and pattern. If the hash values match then only \n        # check for characters one by one \n        if p == t: \n            # Check for characters one by one \n            for j in range(M): \n                if txt[i + j] != pat[j]: \n                    break\n            # if p == t and pat[0...M-1] = txt[i, i+1, \n            # ...i+M-1] \n            if j == M - 1: \n                print('Pattern found at index ' + str(i)) \n  \n        # Calculate hash value for next window of text: \n        # Remove leading digit, add trailing digit \n        if i < N - M: \n            t = (d * (t - ord(txt[i]) * h) + ord(txt[i + M])) % q \n            # We might get negative value of t, converting \n            # it to positive \n            if t < 0: \n                t = (t + q) \n  \n# Driver code \ntxt = 'GEEKS FOR GEEKS'\npat = 'GEEK'\n  \n# we mod to avoid overflowing of value but we should \n# take as big q as possible to avoid the collison \nq = float('inf') \n  \n# Function Call \nsearch(pat, txt, q) \n  \n# This code is contributed by akashish__ \n", "# A Python program that implements Z algorithm for pattern \n# searching \n# Fills Z array for given string str[] \ndef getZarr(string, Z): \n    n = len(string) \n      \n    # [L, R] make a window which matches with prefix of s \n    L, R, k = 0, 0, 0\n    Z[0] = n \n  \n    for i in range(1, n): \n        \n      # if i>R nothing matches so we will calculate. \n        # Z[i] using naive way. \n        if i > R: \n            L, R = i, i \n              \n            # R-L = 0 in starting, so it will start \n            # checking from 0'th index. For example, \n            # for 'ababab' and i = 1, the value of R \n            # remains 0 and Z[i] becomes 0. For string \n            # 'aaaaaa' and i = 1, Z[i] and R become 5 \n            while R < n and string[R - L] == string[R]: \n                R += 1\n            Z[i] = R - L \n            R -= 1\n        else: \n            \n          # k = i-L so k corresponds to number which \n            # matches in [L, R] interval. \n            k = i - L \n              \n            # if Z[k] is less than remaining interval \n            # then Z[i] will be equal to Z[k]. \n            # For example, str = 'ababab', i = 3, R = 5 \n            # and L = 2 \n            if Z[k] < R - i + 1: \n                Z[i] = Z[k] \n                  \n            # For example str = 'aaaaaa' and i = 2, R is 5, \n            # L is 0 \n            else: \n                \n              # else start from R and check manually \n                L = i \n                while R < n and string[R - L] == string[R]: \n                    R += 1\n                Z[i] = R - L \n                R -= 1\n                  \n# prints all occurrences of pattern in text using Z algo \ndef search(text, pattern): \n    \n  # Create concatenated string 'P$T' \n    concat = pattern + '$' + text \n    l = len(concat) \n  \n    # Construct Z array \n    Z = [0] * l \n    getZarr(concat, Z) \n  \n    # now looping through Z array for matching condition \n    for i in range(l): \n        \n      # if Z[i] (matched region) is equal to pattern \n        # length we got the pattern \n        if Z[i] == len(pattern): \n            print('Pattern found at index', i - len(pattern) - 1) \n  \n# Driver program \nif __name__ == '__main__': \n    text = 'GEEKS FOR GEEKS'\n    pattern = 'GEEK'\n    search(text, pattern) \n      \n# This code is contributed by akashish__ \n"], "Dynamic Programming (DP) Tutorial with Problems -  ": ["# Python program to Returns the number of arrangements to form 'n'\ndef solve(n):\n  # Base case\n    if(n < 0):\n        return 0\n    if(n == 0):\n        return 1\n    return solve(n-1)+solve(n-3)+solve(n-5)\n \n  # This code is contributed by ishankhandelwals.\n", "# Initialize to -1\ndp = []\n \n# This function returns the number of\n# arrangements to form 'n'\ndef solve(n):\n    # base case\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n \n# Checking if already calculated\n    if dp[n] != -1:\n        return dp[n]\n \n# Storing the result and returning\n    dp[n] = solve(n-1) + solve(n-3) + solve(n-5)\n    return dp[n]\n \n  # This code is contributed by ishankhandelwals.\n", "# Function to find nth fibonacci number\ndef fib(n):\n    if (n <= 1):\n        return n\n    x = fib(n - 1)\n    y = fib(n - 2)\n \n    return x + y\n \nn = 5;\n \n# Function Call\nprint(fib(n))\n \n#contributed by akashish__\n", "# Helper Function\ndef fibo_helper(n, ans):\n  # Base case\n  if (n <= 1):\n    return n\n \n  # To check if output already exists\n  if (ans[n] is not -1):\n    return ans[n]\n \n  # Calculate output\n  x = fibo_helper(n - 1, ans)\n  y = fibo_helper(n - 2, ans)\n \n  # Saving the output for future use\n  ans[n] = x + y\n \n  # Returning the final output\n  return ans[n]\n \n \ndef fibo(n):\n  ans = [-1]*(n+1)\n \n  # Initializing with -1\n  #for (i = 0; i <= n; i++) {\n  for i in range(0,n+1):\n    ans[i] = -1\n     \n  return fibo_helper(n, ans)\n \n \n# Code\nn = 5\n \n# Function Call\nprint(fibo(n))\n# contributed by akashish__\n", "# Python3 code for the above approach:\n \n# Function for calculating the nth\n# Fibonacci number\ndef fibo(n):\n  ans = [None] * (n + 1)\n \n  # Storing the independent values in the\n  # answer array\n  ans[0] = 0\n  ans[1] = 1\n \n  # Using the bottom-up approach\n  for i in range(2,n+1):\n    ans[i] = ans[i - 1] + ans[i - 2]\n \n  # Returning the final index\n  return ans[n]\n \n# Drivers code\nn = 5\n \n# Function Call\nprint(fibo(n))\n#contributed by akashish__\n", "# Python code for the above approach\n \n# Function for calculating the nth Fibonacci number\ndef fibo(n):\n    prevPrev, prev, curr = 0, 1, 1\n    # Using the bottom-up approach\n    for i in range(2, n+1):\n        curr = prev + prevPrev\n        prevPrev = prev\n        prev = curr\n    # Returning the final answer\n    return curr\n \n# Drivers code\nn = 5\n# Function Call\nprint(fibo(n))\n"], "Bucket Sort - Data Structures and Algorithms Tutorials -  ": ["# Python3 program to sort an array\n# using bucket sort\n \n \ndef insertionSort(b):\n    for i in range(1, len(b)):\n        up = b[i]\n        j = i - 1\n        while j >= 0 and b[j] > up:\n            b[j + 1] = b[j]\n            j -= 1\n        b[j + 1] = up\n    return b\n \n \ndef bucketSort(x):\n    arr = []\n    slot_num = 10  # 10 means 10 slots, each\n    # slot's size is 0.1\n    for i in range(slot_num):\n        arr.append([])\n \n    # Put array elements in different buckets\n    for j in x:\n        index_b = int(slot_num * j)\n        arr[index_b].append(j)\n \n    # Sort individual buckets\n    for i in range(slot_num):\n        arr[i] = insertionSort(arr[i])\n \n    # concatenate the result\n    k = 0\n    for i in range(slot_num):\n        for j in range(len(arr[i])):\n            x[k] = arr[i][j]\n            k += 1\n    return x\n \n \n# Driver Code\nx = [0.897, 0.565, 0.656,\n     0.1234, 0.665, 0.3434]\nprint('Sorted Array is')\nprint(bucketSort(x))\n \n# This code is contributed by\n# Oneil Hsiao\n"], "Radix Sort - Data Structures and Algorithms Tutorials -  ": ["# Python program for implementation of Radix Sort\n# A function to do counting sort of arr[] according to\n# the digit represented by exp.\n \n \ndef countingSort(arr, exp1):\n \n    n = len(arr)\n \n    # The output array elements that will have sorted arr\n    output = [0] * (n)\n \n    # initialize count array as 0\n    count = [0] * (10)\n \n    # Store count of occurrences in count[]\n    for i in range(0, n):\n        index = arr[i] // exp1\n        count[index % 10] += 1\n \n    # Change count[i] so that count[i] now contains actual\n    # position of this digit in output array\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n \n    # Build the output array\n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp1\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n \n    # Copying the output array to arr[],\n    # so that arr now contains sorted numbers\n    i = 0\n    for i in range(0, len(arr)):\n        arr[i] = output[i]\n \n# Method to do Radix Sort\n \n \ndef radixSort(arr):\n \n    # Find the maximum number to know number of digits\n    max1 = max(arr)\n \n    # Do counting sort for every digit. Note that instead\n    # of passing digit number, exp is passed. exp is 10^i\n    # where i is current digit number\n    exp = 1\n    while max1 / exp >= 1:\n        countingSort(arr, exp)\n        exp *= 10\n \n \n# Driver code\narr = [170, 45, 75, 90, 802, 24, 2, 66]\n \n# Function Call\nradixSort(arr)\n \nfor i in range(len(arr)):\n    print(arr[i], end=' ')\n \n# This code is contributed by Mohit Kumra\n# Edited by Patrick Gallagher\n"], "Counting Sort - Data Structures and Algorithms Tutorials -  ": ["def count_sort(input_array):\n    # Finding the maximum element of input_array.\n    M = max(input_array)\n \n    # Initializing count_array with 0\n    count_array = [0] * (M + 1)\n \n    # Mapping each element of input_array as an index of count_array\n    for num in input_array:\n        count_array[num] += 1\n \n    # Calculating prefix sum at every index of count_array\n    for i in range(1, M + 1):\n        count_array[i] += count_array[i - 1]\n \n    # Creating output_array from count_array\n    output_array = [0] * len(input_array)\n \n    for i in range(len(input_array) - 1, -1, -1):\n        output_array[count_array[input_array[i]] - 1] = input_array[i]\n        count_array[input_array[i]] -= 1\n \n    return output_array\n \n# Driver code\nif __name__ == '__main__':\n    # Input array\n    input_array = [4, 3, 12, 1, 5, 5, 3, 9]\n \n    # Output array\n    output_array = count_sort(input_array)\n \n    for num in output_array:\n        print(num, end=' ')\n"], "Heap Sort - Data Structures and Algorithms Tutorials -  ": ["# Python program for implementation of heap Sort\n \n# To heapify subtree rooted at index i.\n# n is size of heap\n \n \ndef heapify(arr, N, i):\n    largest = i  # Initialize largest as root\n    l = 2 * i + 1     # left = 2*i + 1\n    r = 2 * i + 2     # right = 2*i + 2\n \n    # See if left child of root exists and is\n    # greater than root\n    if l < N and arr[largest] < arr[l]:\n        largest = l\n \n    # See if right child of root exists and is\n    # greater than root\n    if r < N and arr[largest] < arr[r]:\n        largest = r\n \n    # Change root, if needed\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n \n        # Heapify the root.\n        heapify(arr, N, largest)\n \n# The main function to sort an array of given size\n \n \ndef heapSort(arr):\n    N = len(arr)\n \n    # Build a maxheap.\n    for i in range(N//2 - 1, -1, -1):\n        heapify(arr, N, i)\n \n    # One by one extract elements\n    for i in range(N-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # swap\n        heapify(arr, i, 0)\n \n \n# Driver's code\nif __name__ == '__main__':\n    arr = [12, 11, 13, 5, 6, 7]\n \n    # Function call\n    heapSort(arr)\n    N = len(arr)\n \n    print('Sorted array is')\n    for i in range(N):\n        print('%d' % arr[i], end=' ')\n# This code is contributed by Mohit Kumra\n"], "QuickSort - Data Structure and Algorithm Tutorials -  ": ["# Python3 implementation of QuickSort\n \n \n# Function to find the partition position\ndef partition(array, low, high):\n \n    # Choose the rightmost element as pivot\n    pivot = array[high]\n \n    # Pointer for greater element\n    i = low - 1\n \n    # Traverse through all elements\n    # compare each element with pivot\n    for j in range(low, high):\n        if array[j] <= pivot:\n \n            # If element smaller than pivot is found\n            # swap it with the greater element pointed by i\n            i = i + 1\n \n            # Swapping element at i with element at j\n            (array[i], array[j]) = (array[j], array[i])\n \n    # Swap the pivot element with\n    # the greater element specified by i\n    (array[i + 1], array[high]) = (array[high], array[i + 1])\n \n    # Return the position from where partition is done\n    return i + 1\n \n \n# Function to perform quicksort\ndef quicksort(array, low, high):\n    if low < high:\n \n        # Find pivot element such that\n        # element smaller than pivot are on the left\n        # element greater than pivot are on the right\n        pi = partition(array, low, high)\n \n        # Recursive call on the left of pivot\n        quicksort(array, low, pi - 1)\n \n        # Recursive call on the right of pivot\n        quicksort(array, pi + 1, high)\n \n \n# Driver code\nif __name__ == '__main__':\n    array = [10, 7, 8, 9, 1, 5]\n    N = len(array)\n \n    # Function call\n    quicksort(array, 0, N - 1)\n    print('Sorted array:')\n    for x in array:\n        print(x, end=' ')\n \n# This code is contributed by Adnan Aliakbar\n"], "Merge Sort - Data Structure and Algorithms Tutorials -  ": ["# Python program for implementation of MergeSort\n \n \ndef mergeSort(arr):\n    if len(arr) > 1:\n \n         # Finding the mid of the array\n        mid = len(arr)//2\n \n        # Dividing the array elements\n        L = arr[:mid]\n \n        # Into 2 halves\n        R = arr[mid:]\n \n        # Sorting the first half\n        mergeSort(L)\n \n        # Sorting the second half\n        mergeSort(R)\n \n        i = j = k = 0\n \n        # Copy data to temp arrays L[] and R[]\n        while i < len(L) and j < len(R):\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n \n        # Checking if any element was left\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n \n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n \n \n# Code to print the list\ndef printList(arr):\n    for i in range(len(arr)):\n        print(arr[i], end=' ')\n    print()\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [12, 11, 13, 5, 6, 7]\n    print('Given array is')\n    printList(arr)\n    mergeSort(arr)\n    print('\\nSorted array is ')\n    printList(arr)\n \n# This code is contributed by Mayank Khanna\n"], "Insertion Sort - Data Structure and Algorithm Tutorials -  ": [], "Bubble Sort - Data Structure and Algorithm Tutorials -  ": ["# Optimized Python program for implementation of Bubble Sort\n \n \ndef bubbleSort(arr):\n    n = len(arr)\n     \n    # Traverse through all array elements\n    for i in range(n):\n        swapped = False\n \n        # Last i elements are already in place\n        for j in range(0, n-i-1):\n \n            # Traverse the array from 0 to n-i-1\n            # Swap if the element found is greater\n            # than the next element\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if (swapped == False):\n            break\n \n \n# Driver code to test above\nif __name__ == '__main__':\n    arr = [64, 34, 25, 12, 22, 11, 90]\n \n    bubbleSort(arr)\n \n    print('Sorted array:')\n    for i in range(len(arr)):\n        print('%d' % arr[i], end=' ')\n \n# This code is modified by Suraj krushna Yadav\n"], "Selection Sort \u2013 Data Structure and Algorithm Tutorials -  ": ["# Python program for implementation of Selection\n# Sort\nimport sys\nA = [64, 25, 12, 22, 11]\n \n# Traverse through all array elements\nfor i in range(len(A)):\n     \n    # Find the minimum element in remaining \n    # unsorted array\n    min_idx = i\n    for j in range(i+1, len(A)):\n        if A[min_idx] > A[j]:\n            min_idx = j\n             \n    # Swap the found minimum element with \n    # the first element        \n    A[i], A[min_idx] = A[min_idx], A[i]\n \n# Driver code to test above\nprint ('Sorted array')\nfor i in range(len(A)):\n    print('%d' %A[i],end=' , ') \n"], "Binary Search - Data Structure and Algorithm Tutorials -  ": ["# Python3 code to implement iterative Binary\n# Search.\n \n \n# It returns location of x in given array arr\ndef binarySearch(arr, l, r, x):\n \n    while l <= r:\n \n        mid = l + (r - l) // 2\n \n        # Check if x is present at mid\n        if arr[mid] == x:\n            return mid\n \n        # If x is greater, ignore left half\n        elif arr[mid] < x:\n            l = mid + 1\n \n        # If x is smaller, ignore right half\n        else:\n            r = mid - 1\n \n    # If we reach here, then the element\n    # was not present\n    return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n \n    # Function call\n    result = binarySearch(arr, 0, len(arr)-1, x)\n    if result != -1:\n        print('Element is present at index', result)\n    else:\n        print('Element is not present in array')\n", "# Python3 Program for recursive binary search.\n \n \n# Returns index of x in arr if present, else -1\ndef binarySearch(arr, l, r, x):\n \n    # Check base case\n    if r >= l:\n \n        mid = l + (r - l) // 2\n \n        # If element is present at the middle itself\n        if arr[mid] == x:\n            return mid\n \n        # If element is smaller than mid, then it\n        # can only be present in left subarray\n        elif arr[mid] > x:\n            return binarySearch(arr, l, mid-1, x)\n \n        # Else the element can only be present\n        # in right subarray\n        else:\n            return binarySearch(arr, mid + 1, r, x)\n \n    # Element is not present in the array\n    else:\n        return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n     \n    # Function call\n    result = binarySearch(arr, 0, len(arr)-1, x)\n     \n    if result != -1:\n        print('Element is present at index', result)\n    else:\n        print('Element is not present in array')\n"], "Linear Search Algorithm - Data Structure and Algorithms Tutorials -  ": ["# Python3 code to linearly search x in arr[]. \n  \n  \ndef search(arr, N, x): \n  \n    for i in range(0, N): \n        if (arr[i] == x): \n            return i \n    return -1\n  \n  \n# Driver Code \nif __name__ == '__main__': \n    arr = [2, 3, 4, 10, 40] \n    x = 10\n    N = len(arr) \n  \n    # Function call \n    result = search(arr, N, x) \n    if(result == -1): \n        print('Element is not present in array') \n    else: \n        print('Element is present at index', result) \n"], "Worst, Average and Best Case Analysis of Algorithms -  ": ["# Python 3 implementation of the approach\n \n# Linearly search x in arr[]. If x is present\n# then return the index, otherwise return -1\n \n \ndef search(arr, x):\n    for index, value in enumerate(arr):\n        if value == x:\n            return index\n    return -1\n \n \n# Driver's Code\nif __name__ == '__main__':\n    arr = [1, 10, 30, 15]\n    x = 30\n \n    # Function call\n    print(x, 'is present at index',\n          search(arr, x))\n", "# Python 3 implementation of the approach\n \n \ndef getsum(arr, n):\n    if n % 2 == 0:  # if (n) is even\n        return 0\n \n    Sum = 0\n    for i in range(n):\n        Sum += arr[i]\n    return Sum  # if (n) is odd\n \n \n# Driver's Code\nif __name__ == '__main__':\n  arr1 = [1, 2, 3, 4]  # Declaring an array of even length\n  n1 = len(arr1)\n  arr2 = [1, 2, 3, 4, 5]  # Declaring an array of odd length\n  n2 = len(arr2)\n \n# Function call\nprint(getsum(arr1, n1))  # print 0 because (n) is even\n \nprint(getsum(arr2, n2))  # print sum of array because (n) is odd\n \n# This code is contributed by Syed Maruf Ali\n"], "Introduction to Map \u2013 Data Structure and Algorithm Tutorials -  ": ["# Python program to count frequencies of array items \nfrom collections import defaultdict \n  \ndef countFreq(arr): \n    freq = defaultdict(int) \n  \n    # Traverse through array elements and count frequencies \n    for i in arr: \n        freq[i] += 1\n  \n    # Traverse through dictionary and print frequencies \n    for key, value in freq.items(): \n        print(key, value) \n  \n# Driver code \nif __name__ == '__main__': \n    arr = [1, 2, 3, 3, 4, 5, 5, 5] \n    countFreq(arr) \n"], "Introduction to Set \u2013 Data Structure and Algorithm Tutorials -  ": ["# set of letters \nGEEK = {10, 5, 12, 4} \n  \n# adding 's' \nGEEK.add(15) \nprint('Letters are:', GEEK) \n  \n# adding 's' again \nGEEK.add(10) \nprint('Letters are:', GEEK) \n  \n# check if set contain an element \nprint(5 in GEEK) \n  \n# removing an element from set \nGEEK.remove(5) \nprint(GEEK) \n  \n# print max element of set \nprint(max(GEEK)) \n  \n# print min element of set \nprint(min(GEEK)) \n  \n# printing size of the set \nprint(len(GEEK)) \n", "# Python program to demonstrate various functions of set \n  \n# Creating an empty set \nset = set() \n  \n# Use add() method to add elements into the set \nset.add(1) \nset.add(2) \nset.add(3) \nset.add(4) \nset.add(5) \n  \n# Displaying the set \nprint('Set:', set) \n  \n# Creating an iterator \nvalue = iter(set) \n  \n# Displaying the values after iterating through the iterator \nprint('The iterator values are:') \nwhile True: \n    try: \n        print(next(value)) \n    except StopIteration: \n        break\n"], "Introduction to Heap - Data Structure and Algorithm Tutorials -  ": ["# Python code to depict \n# the implementation of a max heap. \n  \nclass MaxHeap: \n    # A pointer pointing to the elements \n    # in the array in the heap. \n    arr = [] \n  \n    # Maximum possible size of \n    # the Max Heap. \n    maxSize = 0\n  \n    # Number of elements in the \n    # Max heap currently. \n    heapSize = 0\n  \n    # Constructor function. \n    def __init__(self, maxSize): \n        self.maxSize = maxSize \n        self.arr = [None]*maxSize \n        self.heapSize = 0\n  \n    # Heapifies a sub-tree taking the \n    # given index as the root. \n    def MaxHeapify(self, i): \n        l = self.lChild(i) \n        r = self.rChild(i) \n        largest = i \n        if l < self.heapSize and self.arr[l] > self.arr[i]: \n            largest = l \n        if r < self.heapSize and self.arr[r] > self.arr[largest]: \n            largest = r \n        if largest != i: \n            temp = self.arr[i] \n            self.arr[i] = self.arr[largest] \n            self.arr[largest] = temp \n            self.MaxHeapify(largest) \n  \n    # Returns the index of the parent \n    # of the element at ith index. \n    def parent(self, i): \n        return (i - 1) // 2\n  \n    # Returns the index of the left child. \n    def lChild(self, i): \n        return (2 * i + 1) \n  \n    # Returns the index of the \n    # right child. \n    def rChild(self, i): \n        return (2 * i + 2) \n  \n    # Removes the root which in this \n    # case contains the maximum element. \n    def removeMax(self): \n        # Checking whether the heap array \n        # is empty or not. \n        if self.heapSize <= 0: \n            return None\n        if self.heapSize == 1: \n            self.heapSize -= 1\n            return self.arr[0] \n  \n        # Storing the maximum element \n        # to remove it. \n        root = self.arr[0] \n        self.arr[0] = self.arr[self.heapSize - 1] \n        self.heapSize -= 1\n  \n        # To restore the property \n        # of the Max heap. \n        self.MaxHeapify(0) \n  \n        return root \n  \n    # Increases value of key at \n    # index 'i' to new_val. \n    def increaseKey(self, i, newVal): \n        self.arr[i] = newVal \n        while i != 0 and self.arr[self.parent(i)] < self.arr[i]: \n            temp = self.arr[i] \n            self.arr[i] = self.arr[self.parent(i)] \n            self.arr[self.parent(i)] = temp \n            i = self.parent(i) \n  \n    # Returns the maximum key \n    # (key at root) from max heap. \n    def getMax(self): \n        return self.arr[0] \n  \n    def curSize(self): \n        return self.heapSize \n  \n    # Deletes a key at given index i. \n    def deleteKey(self, i): \n        # It increases the value of the key \n        # to infinity and then removes \n        # the maximum value. \n        self.increaseKey(i, float('inf')) \n        self.removeMax() \n  \n    # Inserts a new key 'x' in the Max Heap. \n    def insertKey(self, x): \n        # To check whether the key \n        # can be inserted or not. \n        if self.heapSize == self.maxSize: \n            print('\\nOverflow: Could not insertKey\\n') \n            return\n  \n        # The new key is initially \n        # inserted at the end. \n        self.heapSize += 1\n        i = self.heapSize - 1\n        self.arr[i] = x \n  \n        # The max heap property is checked \n        # and if violation occurs, \n        # it is restored. \n        while i != 0 and self.arr[self.parent(i)] < self.arr[i]: \n            temp = self.arr[i] \n            self.arr[i] = self.arr[self.parent(i)] \n            self.arr[self.parent(i)] = temp \n            i = self.parent(i) \n  \n  \n# Driver program to test above functions. \nif __name__ == '__main__': \n    # Assuming the maximum size of the heap to be 15. \n    h = MaxHeap(15) \n  \n    # Asking the user to input the keys: \n    k, i, n = 6, 0, 6\n    print('Entered 6 keys:- 3, 10, 12, 8, 2, 14 \\n') \n    h.insertKey(3) \n    h.insertKey(10) \n    h.insertKey(12) \n    h.insertKey(8) \n    h.insertKey(2) \n    h.insertKey(14) \n  \n    # Printing the current size \n    # of the heap. \n    print('The current size of the heap is '\n          + str(h.curSize()) + '\\n') \n  \n    # Printing the root element which is \n    # actually the maximum element. \n    print('The current maximum element is ' + str(h.getMax()) \n          + '\\n') \n  \n    # Deleting key at index 2. \n    h.deleteKey(2) \n  \n    # Printing the size of the heap \n    # after deletion. \n    print('The current size of the heap is '\n          + str(h.curSize()) + '\\n') \n  \n    # Inserting 2 new keys into the heap. \n    h.insertKey(15) \n    h.insertKey(5) \n    print('The current size of the heap is '\n          + str(h.curSize()) + '\\n') \n    print('The current maximum element is ' + str(h.getMax()) \n          + '\\n')\n"], "Introduction to Tree - Data Structure and Algorithm Tutorials -  ": ["# python program to demonstrate some of the above\n# terminologies\n \n# Function to add an edge between vertices x and y\n \n# Function to print the parent of each node\n \n \ndef printParents(node, adj, parent):\n \n    # current node is Root, thus, has no parent\n    if (parent == 0):\n        print(node, '->Root')\n    else:\n        print(node, '->', parent)\n \n    # Using DFS\n    for cur in adj[node]:\n        if (cur != parent):\n            printParents(cur, adj, node)\n \n# Function to print the children of each node\n \n \ndef printChildren(Root, adj):\n \n    # Queue for the BFS\n    q = []\n \n    # pushing the root\n    q.append(Root)\n \n    # visit array to keep track of nodes that have been\n    # visited\n    vis = [0]*len(adj)\n \n    # BFS\n    while (len(q) > 0):\n        node = q[0]\n        q.pop(0)\n        vis[node] = 1\n        print(node, '-> ', end=' ')\n \n        for cur in adj[node]:\n            if (vis[cur] == 0):\n                print(cur, ' ', end=' ')\n                q.append(cur)\n        print('\\n')\n \n# Function to print the leaf nodes\n \n \ndef printLeafNodes(Root, adj):\n \n    # Leaf nodes have only one edge and are not the root\n    for i in range(0, len(adj)):\n        if (len(adj[i]) == 1 and i != Root):\n            print(i, end=' ')\n    print('\\n')\n \n# Function to print the degrees of each node\n \n \ndef printDegrees(Root, adj):\n \n    for i in range(1, len(adj)):\n        print(i, ': ', end=' ')\n \n        # Root has no parent, thus, its degree is equal to\n        # the edges it is connected to\n        if (i == Root):\n            print(len(adj[i]))\n        else:\n            print(len(adj[i])-1)\n \n# Driver code\n \n \n# Number of nodes\nN = 7\nRoot = 1\n \n# Adjacency list to store the tree\nadj = []\nfor i in range(0, N+1):\n    adj.append([])\n \n# Creating the tree\nadj[1].append(2)\nadj[2].append(1)\n \nadj[1].append(3)\nadj[3].append(1)\n \nadj[1].append(4)\nadj[4].append(1)\n \nadj[2].append(5)\nadj[5].append(2)\n \nadj[2].append(6)\nadj[6].append(2)\n \nadj[4].append(7)\nadj[7].append(4)\n \n# Printing the parents of each node\nprint('The parents of each node are:')\nprintParents(Root, adj, 0)\n \n# Printing the children of each node\nprint('The children of each node are:')\nprintChildren(Root, adj)\n \n# Printing the leaf nodes in the tree\nprint('The leaf nodes of the tree are:')\nprintLeafNodes(Root, adj)\n \n# Printing the degrees of each node\nprint('The degrees of each node are:')\nprintDegrees(Root, adj)\n \n# This code is contributed by rj13to.\n"], "Introduction of B-Tree -  ": ["class Node:\n    def __init__(self):\n        self.n = 0\n        self.key = [0] * MAX_KEYS\n        self.child = [None] * MAX_CHILDREN\n        self.leaf = True\n \ndef BtreeSearch(x, k):\n    i = 0\n    while i < x.n and k >= x.key[i]:\n        i += 1\n    if i < x.n and k == x.key[i]:\n        return x\n    if x.leaf:\n        return None\n    return BtreeSearch(x.child[i], k)\n", "# Create a node\nclass BTreeNode:\n  def __init__(self, leaf=False):\n    self.leaf = leaf\n    self.keys = []\n    self.child = []\n \n \n# Tree\nclass BTree:\n  def __init__(self, t):\n    self.root = BTreeNode(True)\n    self.t = t\n \n    # Insert node\n  def insert(self, k):\n    root = self.root\n    if len(root.keys) == (2 * self.t) - 1:\n      temp = BTreeNode()\n      self.root = temp\n      temp.child.insert(0, root)\n      self.split_child(temp, 0)\n      self.insert_non_full(temp, k)\n    else:\n      self.insert_non_full(root, k)\n \n    # Insert nonfull\n  def insert_non_full(self, x, k):\n    i = len(x.keys) - 1\n    if x.leaf:\n      x.keys.append((None, None))\n      while i >= 0 and k[0] < x.keys[i][0]:\n        x.keys[i + 1] = x.keys[i]\n        i -= 1\n      x.keys[i + 1] = k\n    else:\n      while i >= 0 and k[0] < x.keys[i][0]:\n        i -= 1\n      i += 1\n      if len(x.child[i].keys) == (2 * self.t) - 1:\n        self.split_child(x, i)\n        if k[0] > x.keys[i][0]:\n          i += 1\n      self.insert_non_full(x.child[i], k)\n \n    # Split the child\n  def split_child(self, x, i):\n    t = self.t\n    y = x.child[i]\n    z = BTreeNode(y.leaf)\n    x.child.insert(i + 1, z)\n    x.keys.insert(i, y.keys[t - 1])\n    z.keys = y.keys[t: (2 * t) - 1]\n    y.keys = y.keys[0: t - 1]\n    if not y.leaf:\n      z.child = y.child[t: 2 * t]\n      y.child = y.child[0: t - 1]\n \n  # Print the tree\n  def print_tree(self, x, l=0):\n    print('Level ', l, ' ', len(x.keys), end=':')\n    for i in x.keys:\n      print(i, end=' ')\n    print()\n    l += 1\n    if len(x.child) > 0:\n      for i in x.child:\n        self.print_tree(i, l)\n \n  # Search key in the tree\n  def search_key(self, k, x=None):\n    if x is not None:\n      i = 0\n      while i < len(x.keys) and k > x.keys[i][0]:\n        i += 1\n      if i < len(x.keys) and k == x.keys[i][0]:\n        return (x, i)\n      elif x.leaf:\n        return None\n      else:\n        return self.search_key(k, x.child[i])\n       \n    else:\n      return self.search_key(k, self.root)\n \n \ndef main():\n  B = BTree(3)\n \n  for i in range(10):\n    B.insert((i, 2 * i))\n \n  B.print_tree(B.root)\n \n  if B.search_key(8) is not None:\n    print('\\nFound')\n  else:\n    print('\\nNot Found')\n \n \nif __name__ == '__main__':\n  main()\n"], "Introduction to Binary Search Tree - Data Structure and Algorithm Tutorials -  ": ["# Python program to insert a node\n# in a BST\n \n# Given Node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Function to do inorder traversal of BST\ndef inorder(root):\n    if root is not None:\n        inorder(root.left)\n        print(root.key, end=' ')\n        inorder(root.right)\n \n# Driver Code\nif __name__ == '__main__':\n    '''\n    Let us create following BST\n          50\n       /     \\\n      30      70\n     /  \\    /  \\\n    20  40  60   80\n    '''\n    root = None\n \n    # Inserting value 50\n    root = insert(root, 50)\n \n    # Inserting value 30\n    insert(root, 30)\n \n    # Inserting value 20\n    insert(root, 20)\n \n    # Inserting value 40\n    insert(root, 40)\n \n    # Inserting value 70\n    insert(root, 70)\n \n    # Inserting value 60\n    insert(root, 60)\n \n    # Inserting value 80\n    insert(root, 80)\n \n    # Print the BST\n    inorder(root)\n     \n#This code is contributed by japmeet01\n", "# Python program to implement\n# inorder traversal of BST\n \n# Given Node node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to create a new BST node\ndef newNode(item):\n    temp = Node(item)\n    temp.key = item\n    temp.left = temp.right = None\n    return temp\n \n# Function to insert a new node with\n# given key in BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return newNode(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Function to do inorder traversal of BST\ndef inorder(root):\n    if root:\n        inorder(root.left)\n        print(root.key, end=' ')\n        inorder(root.right)\n \n# Driver Code\nif __name__ == '__main__':\n     \n    # Let us create following BST \n    #          50 \n    #       /     \\ \n    #     30      70 \n    #    /  \\    /  \\ \n    #  20   40  60   80 \n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    inorder(root)\n#This code is contributed by japmeet01\n", "# Python program to implement preorder traversal\nclass Node:\n    # Constructor to create a new node\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\n \n \ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Function to do preorder traversal of BST\n \n \ndef preOrder(root):\n    if root:\n        print(root.key, end=' ')\n        preOrder(root.left)\n        preOrder(root.right)\n \n \n# Driver Code\nif __name__ == '__main__':\n    '''\n        Let us create following BST\n              50\n           /     \\\n          30      70\n         /  \\    /  \\\n       20   40  60   80\n   '''\n    root = None\n    keys = [50, 30, 20, 40, 70, 60, 80]\n \n    # Creating the BST\n    for key in keys:\n        root = insert(root, key)\n \n    # Function Call\n    preOrder(root)\n#This code is contributed by japmeet01\n", "# Python program to print total count of nodes in BST\n \n# Define the Node class\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with given key in BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Function to do postorder traversal of BST\ndef postOrder(root):\n    if root:\n        postOrder(root.left)\n        postOrder(root.right)\n        print(root.key, end=' ')\n \n# Driver code\nif __name__ == '__main__':\n    # Let us create following BST \n    #           50 \n    #        /     \\ \n    #       30      70 \n    #      /  \\    /  \\ \n    #    20   40  60   80 \n \n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function call\n    postOrder(root)\n \n    #This code is contributed by japmeet01\n", "# Python program to implement\n# level order traversal\nimport queue\n \n# Given Node node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Returns height of the BST\ndef height(node):\n    if node is None:\n        return 0\n    else:\n        # Compute the depth of each subtree\n        lDepth = height(node.left)\n        rDepth = height(node.right)\n \n        # Use the larger one\n        if lDepth > rDepth:\n            return (lDepth + 1)\n        else:\n            return (rDepth + 1)\n \n# Print nodes at a given level\ndef printGivenLevel(root, level):\n    if root is None:\n        return\n    if level == 1:\n        print(root.key, end=' ')\n    elif level > 1:\n        # Recursive call\n        printGivenLevel(root.left, level - 1)\n        printGivenLevel(root.right, level - 1)\n \n# Function to line by line print\n# level order traversal of a tree\ndef printLevelOrder(root):\n    h = height(root)\n    for i in range(1, h+1):\n        printGivenLevel(root, i)\n        print()\n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #          50\n    #       /     \\\n    #      30      70\n    #     /  \\    /  \\\n    #   20   40  60   80\n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    printLevelOrder(root)\n     \n    #This code is contributed by japmeet01\n", "# Python program to print nodes at a given level\n \n# Given Node node\n \n \nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\n \n \ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Print nodes at a given level\n \n \ndef printGivenLevel(root, level):\n    if root is None:\n        return\n    if level == 1:\n        print(root.key, end=' ')\n    elif level > 1:\n        # Recursive Call\n        printGivenLevel(root.left, level - 1)\n        printGivenLevel(root.right, level - 1)\n \n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #           50\n    #        /     \\\n    #       30      70\n    #      /  \\    /  \\\n    #     20   40  60   80\n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    printGivenLevel(root, 2)\n \n    # This code is contributed by japmeet01\n", "# Python program to print all\n# leaf nodes of a BST\n \n# Given Node node\nclass Node:\n    def __init__(self, item):\n        self.key = item\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Function to print leaf nodes\n# from left to right\ndef printLeafNodes(root):\n    # If node is null, return\n    if not root:\n        return\n \n    # If node is leaf node,\n    # print its data\n    if not root.left and not root.right:\n        print(root.key, end=' ')\n \n    # If left child exists,\n    # check for leaf recursively\n    if root.left:\n        printLeafNodes(root.left)\n \n    # If right child exists,\n    # check for leaf recursively\n    if root.right:\n        printLeafNodes(root.right)\n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #          50\n    #        /    \\\n    #      30      70\n    #     /  \\    /  \\\n    #   20   40  60   80\n \n    # Creating the BST\n    root = None\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    printLeafNodes(root)\n \n    #This code is contributed by japmeet01\n", "# Python program to print all\n# non leaf nodes of a BST\n \n# Given Node node\n \n \nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\n \n \ndef insert(root, key):\n    # If the tree is empty, return a new node\n    if root is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < root.key:\n        root.left = insert(root.left, key)\n    elif key > root.key:\n        root.right = insert(root.right, key)\n \n    # Return the node pointer\n    return root\n \n# Function to print all non-leaf\n# nodes in a tree\n \n \ndef printNonLeafNode(root):\n    # Base Cases\n    if root is None or (root.left is None and root.right is None):\n        return\n \n    # If current node is non-leaf,\n    if root.left is not None or root.right is not None:\n        print(root.key, end=' ')\n \n    # If root is Not NULL and its one\n    # of its child is also not NULL\n    printNonLeafNode(root.left)\n    printNonLeafNode(root.right)\n \n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #           50\n    #        /     \\\n    #      30       70\n    #     /  \\     /  \\\n    #   20   40   60   80\n \n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    printNonLeafNode(root)\n \n    # This code is contributed by japmeet01\n", "# Python program to print right view of a BST\nimport sys\n \n# Given Node node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    else:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Function to print the right view\n# of a binary tree.\ndef rightViewUtil(root, level, max_level):\n    # Base Case\n    if root is None:\n        return\n \n    # If this is the last Node of its level\n    if (max_level[0] < level):\n        print('\\t', root.key, end='')\n        max_level[0] = level\n \n    # Recur for right subtree first,\n    # then left subtree\n    rightViewUtil(root.right, level + 1, max_level)\n    rightViewUtil(root.left, level + 1, max_level)\n \n# Wrapper over rightViewUtil()\ndef rightView(root):\n    max_level = [0]\n    rightViewUtil(root, 1, max_level)\n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #        50\n    #     /     \\\n    #    30      70\n    #   /  \\    /  \\\n    #  20  40  60  80\n \n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    rightView(root)\n     \n    #This code is contributed by japmeet01\n", "# Python program to print\n# left view of a BST\n \n# Given Node node\n \n \nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\n \n \ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Function to print left view of\n# binary tree\n \n \ndef leftViewUtil(root, level, max_level):\n    # Base Case\n    if root is None:\n        return\n \n    # If this is the first node\n    # of its level\n    if max_level[0] < level:\n        print(root.key, end=' ')\n        max_level[0] = level\n \n    # Recur for left and right subtrees\n    leftViewUtil(root.left, level + 1, max_level)\n    leftViewUtil(root.right, level + 1, max_level)\n \n# Wrapper over leftViewUtil()\n \n \ndef leftView(root):\n    max_level = [0]\n    leftViewUtil(root, 1, max_level)\n \n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #          50\n    #        /    \\\n    #      30      70\n    #     /  \\    /  \\\n    #   20   40  60   80\n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    leftView(root)\n     \n    #This code is contributed by japmeet01\n", "# Python program to print\n# height of a BST\nimport sys\n \n# Given Node node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\ndef insert(root, key):\n    # If the tree is empty, return a new node\n    if root is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < root.key:\n        root.left = insert(root.left, key)\n    elif key > root.key:\n        root.right = insert(root.right, key)\n \n    # Return the node pointer\n    return root\n \n# Returns height of the BST\ndef height(node):\n    if node is None:\n        return 0\n    else:\n        # Compute the depth of each subtree\n        lDepth = height(node.left)\n        rDepth = height(node.right)\n \n        # Use the larger one\n        if lDepth > rDepth:\n            return lDepth + 1\n        else:\n            return rDepth + 1\n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #           50\n    #        /      \\\n    #       30       70\n    #      /  \\     /  \\\n    #    20   40   60   80\n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    print(' ', height(root))\n     \n    #This code is contributed by japmeet01\n", "# Python program to delete a node of BST\n \n# Given Node node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\ndef insert(root, key):\n    # If the tree is empty, return a new node\n    if root is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < root.key:\n        root.left = insert(root.left, key)\n    elif key > root.key:\n        root.right = insert(root.right, key)\n \n    # Return the node pointer\n    return root\n \n# Function to do inorder traversal of BST\ndef inorder(root):\n    if root:\n        inorder(root.left)\n        print(root.key, end=' ')\n        inorder(root.right)\n \n# Function that returns the node with minimum\n# key value found in that tree\ndef minValueNode(node):\n    current = node\n \n    # Loop down to find the leftmost leaf\n    while current and current.left is not None:\n        current = current.left\n \n    return current\n \n# Function that deletes the key and\n# returns the new root\ndef deleteNode(root, key):\n    # base Case\n    if root is None:\n        return root\n \n    # If the key to be deleted is\n    # smaller than the root's key,\n    # then it lies in left subtree\n    if key < root.key:\n        root.left = deleteNode(root.left, key)\n \n    # If the key to be deleted is\n    # greater than the root's key,\n    # then it lies in right subtree\n    elif key > root.key:\n \n        root.right = deleteNode(root.right, key)\n \n    # If key is same as root's key,\n    # then this is the node\n    # to be deleted\n    else:\n \n        # Node with only one child\n        # or no child\n        if root.left is None:\n            temp = root.right\n            root = None\n            return temp\n        elif root.right is None:\n            temp = root.left\n            root = None\n            return temp\n \n        # Node with two children:\n        # Get the inorder successor(smallest\n        # in the right subtree)\n        temp = minValueNode(root.right)\n \n        # Copy the inorder successor's\n        # content to this node\n        root.key = temp.key\n \n        # Delete the inorder successor\n        root.right = deleteNode(root.right, temp.key)\n \n    return root\n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #          50\n    #       /     \\\n    #      30      70\n    #     /  \\    /  \\\n    #    20   40 60   80\n \n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    root = deleteNode(root, 60)\n    inorder(root)\n     \n    #This code is contributed by japmeet01\n", "# Given Node node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Function that returns the node with minimum\n# key value found in that tree\ndef minValueNode(node):\n    current = node\n \n    # Loop down to find the leftmost leaf\n    while current and current.left is not None:\n        current = current.left\n \n    return current\n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #           50\n    #        /     \\\n    #       30      70\n    #      /  \\    /  \\\n    #     20  40  60   80\n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    print(minValueNode(root).key)\n     \n    #This code is contributed by japmeet01\n", "# Python program to print total\n# count of nodes in BST\n \n# Given Node node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to create a new BST node\ndef newNode(item):\n    temp = Node(item)\n    return temp\n \n# Function to insert a new node with\n# given key in BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return newNode(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Function to get the total count of\n# nodes in a binary tree\ndef nodeCount(node):\n    if node is None:\n        return 0\n \n    else:\n        return nodeCount(node.left) + nodeCount(node.right) + 1\n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #          50\n    #        /     \\\n    #       30      70\n    #      /  \\    /  \\\n    #    20   40  60   80\n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    # Function Call\n    print(nodeCount(root))\n    #This code is contributed by japmeet01\n", "# Python program to delete a BST\n \n# Given Node node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node with\n# given key in BST\ndef insert(node, key):\n    # If the tree is empty, return a new node\n    if node is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < node.key:\n        node.left = insert(node.left, key)\n    elif key > node.key:\n        node.right = insert(node.right, key)\n \n    # Return the node pointer\n    return node\n \n# Function to do inorder traversal of BST\ndef inorder(root):\n    if root is not None:\n        inorder(root.left)\n        print(root.key, end=' ')\n        inorder(root.right)\n \n# Function to delete the BST\ndef emptyBST(root):\n    if root is not None:\n        # Traverse to left subtree\n        emptyBST(root.left)\n \n        # Traverse to right subtree\n        emptyBST(root.right)\n \n        print('\\nReleased node:', root.key)\n        # Require for free memory\n        del root\n \n# Driver Code\nif __name__ == '__main__':\n    # Let us create following BST\n    #           50\n    #        /     \\\n    #       30      70\n    #      /  \\    /  \\\n    #    20   40  60   80\n    root = None\n \n    # Creating the BST\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    print('BST before deleting:')\n    inorder(root)\n \n    # Function Call\n    emptyBST(root)\n    #This code is contributed by japmeet01\n"], "Introduction to Binary Tree - Data Structure and Algorithm Tutorials -  ": [], "Introduction to Generic Trees (N-ary Trees) -  ": [], "Introduction to Queue - Data Structure and Algorithm Tutorials -  ": ["# Creating an empty queue\n \n# A structure to represent a queue\n \n \nclass Queue:\n        # constructor\n    def __init__(self, cap):\n        self.cap = cap\n        self.front = 0\n        self.size = 0\n        self.rear = cap - 1\n        self.arr = [0] * cap\n \n    # Function to create a queue of given capacity\n    # It initializes size of queue as 0\n    def createQueue(self):\n        return Queue(self.cap)\n \n# This code is contributed by Tapesh (tapeshdua420)\n", "class QNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n \n # This code is contributed by Tapesh (tapeshdua420)\n", "# Function to add an item to the queue.\n# It changes rear and size\n \n \ndef EnQueue(self, item):\n    if self.isFull():\n        print('Full')\n        return\n    self.rear = (self.rear + 1) % (self.capacity)\n    self.Q[self.rear] = item\n    self.size = self.size + 1\n    print('% s enqueued to queue' % str(item))\n# This code is contributed by Susobhan Akhuli\n", "# Function to remove an item from queue.\n# It changes front and size\n \n \ndef DeQueue(self):\n    if self.isEmpty():\n        print('Queue is empty')\n        return\n \n    print('% s dequeued from queue' % str(self.Q[self.front]))\n    self.front = (self.front + 1) % (self.capacity)\n    self.size = self.size - 1\n# This code is contributed by Susobhan Akhuli\n", "# Function to get front of queue\ndef que_front(self):\n        if self.isempty():\n            return 'Queue is empty'\n        return self.Q[self.front]\n \n# This code is contributed By Susobhan Akhuli\n", "def rear(queue):\n    if queue.empty():\n        print('Queue is empty.')\n        return None\n \n    rear_element = None\n    while not queue.empty():\n        rear_element = queue.get()\n \n    return rear_element\n", "# Queue is empty when size is 0\ndef isEmpty(self):\n    return self.size == 0\n# This code is contributed by Susobhan Akhuli\n", "# Queue is full when size becomes\n# equal to the capacity\n \n \ndef isFull(self):\n    return self.size == self.capacity\n \n# This code is contributed by Susobhan Akhuli\n", "# Python3 program for array implementation of queue\n \n# Class Queue to represent a queue\n \n \nclass Queue:\n \n    # __init__ function\n    def __init__(self, capacity):\n        self.front = self.size = 0\n        self.rear = capacity - 1\n        self.Q = [None]*capacity\n        self.capacity = capacity\n \n    # Queue is full when size becomes\n    # equal to the capacity\n    def isFull(self):\n        return self.size == self.capacity\n \n    # Queue is empty when size is 0\n    def isEmpty(self):\n        return self.size == 0\n \n    # Function to add an item to the queue.\n    # It changes rear and size\n    def EnQueue(self, item):\n        if self.isFull():\n            print('Full')\n            return\n        self.rear = (self.rear + 1) % (self.capacity)\n        self.Q[self.rear] = item\n        self.size = self.size + 1\n        print('% s enqueued to queue' % str(item))\n \n    # Function to remove an item from queue.\n    # It changes front and size\n    def DeQueue(self):\n        if self.isEmpty():\n            print('Empty')\n            return\n \n        print('% s dequeued from queue' % str(self.Q[self.front]))\n        self.front = (self.front + 1) % (self.capacity)\n        self.size = self.size - 1\n \n    # Function to get front of queue\n    def que_front(self):\n        if self.isEmpty():\n            print('Queue is empty')\n \n        print('Front item is', self.Q[self.front])\n \n    # Function to get rear of queue\n    def que_rear(self):\n        if self.isEmpty():\n            print('Queue is empty')\n        print('Rear item is',  self.Q[self.rear])\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    queue = Queue(30)\n    queue.EnQueue(10)\n    queue.EnQueue(20)\n    queue.EnQueue(30)\n    queue.EnQueue(40)\n    queue.DeQueue()\n    queue.que_front()\n    queue.que_rear()\n# This code is contributed by Susobhan Akhuli\n"], "Introduction to Stack - Data Structure and Algorithm Tutorials -  ": ["# Python program for implementation of stack \n  \n# import maxsize from sys module  \n# Used to return -infinite when stack is empty \nfrom sys import maxsize \n  \n# Function to create a stack. It initializes size of stack as 0 \ndef createStack(): \n    stack = [] \n    return stack \n  \n# Stack is empty when stack size is 0 \ndef isEmpty(stack): \n    return len(stack) == 0\n  \n# Function to add an item to stack. It increases size by 1 \ndef push(stack, item): \n    stack.append(item) \n    print(item + ' pushed to stack ') \n      \n# Function to remove an item from stack. It decreases size by 1 \ndef pop(stack): \n    if (isEmpty(stack)): \n        return str(-maxsize -1) # return minus infinite \n      \n    return stack.pop() \n  \n# Function to return the top from stack without removing it \ndef peek(stack): \n    if (isEmpty(stack)): \n        return str(-maxsize -1) # return minus infinite \n    return stack[len(stack) - 1] \n  \n# Driver program to test above functions     \nstack = createStack() \npush(stack, str(10)) \npush(stack, str(20)) \npush(stack, str(30)) \nprint(pop(stack) + ' popped from stack') \n", "# Python program for linked list implementation of stack \n  \n# Class to represent a node \n  \n  \nclass StackNode: \n  \n    # Constructor to initialize a node \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n  \n  \nclass Stack: \n  \n    # Constructor to initialize the root of linked list \n    def __init__(self): \n        self.root = None\n  \n    def isEmpty(self): \n        return True if self.root is None else False\n  \n    def push(self, data): \n        newNode = StackNode(data) \n        newNode.next = self.root \n        self.root = newNode \n        print ('% d pushed to stack' % (data)) \n  \n    def pop(self): \n        if (self.isEmpty()): \n            return float('-inf') \n        temp = self.root \n        self.root = self.root.next\n        popped = temp.data \n        return popped \n  \n    def peek(self): \n        if self.isEmpty(): \n            return float('-inf') \n        return self.root.data \n  \n  \n# Driver code \nstack = Stack() \nstack.push(10) \nstack.push(20) \nstack.push(30) \n  \nprint ('% d popped from stack' % (stack.pop())) \nprint ('Top element is % d ' % (stack.peek())) \n  \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007) \n"], "Introduction to Linked List - Data Structure and Algorithm Tutorials -  ": ["# Node class \nclass Node: \n  \n    # Function to initialize the node object \n    def __init__(self, data): \n        self.data = data  # Assign data \n        self.next = None  # Initialize next as null \n  \n# Linked List class \n  \n  \nclass LinkedList: \n  \n    # Function to initialize the Linked List object \n    def __init__(self): \n        self.head = None\n", "# Node of a doubly linked list \nclass Node: \n    def __init__(self, next=None, prev=None, data=None): \n        self.next = next  # reference to next node in DLL \n        self.prev = prev  # reference to previous node in DLL \n        self.data = data \n"], "Insertion in Doubly Circular Linked List -  ": ["# Function to insert at the end\ndef insertEnd(value):\n    global start\n \n    # If the list is empty, create a\n    # single node circular and doubly list\n    if (start == None):\n \n        new_node = Node(0)\n        new_node.data = value\n        new_node.next = new_node.prev = new_node\n        start = new_node\n        return\n \n    # If list is not empty\n \n    # Find last node */\n    last = (start).prev\n \n    # Create Node dynamically\n    new_node = Node(0)\n    new_node.data = value\n \n    # Start is going to be next of new_node\n    new_node.next = start\n \n    # Make new node previous of start\n    (start).prev = new_node\n \n    # Make last previous of new node\n    new_node.prev = last\n \n    # Make new node next of old last\n    last.next = new_node\n \n    # This code is contributed by shivanisinghss2110\n", "# Function to insert Node at the beginning\n# of the List,\n \n \ndef insertBegin(value):\n    global start\n \n    # Pointer points to last Node\n    last = (start).prev\n \n    new_node = Node(0)\n    new_node.data = value  # Inserting the data\n \n    # setting up previous and\n    # next of new node\n    new_node.next = start\n    new_node.prev = last\n \n    # Update next and previous pointers\n    # of start and last.\n    last.next = (start).prev = new_node\n \n    # Update start pointer\n    start = new_node\n \n    # This code is contributed by shivanisinghss2110\n", "# Function to insert node with value as value1.\n# The new node is inserted after the node with\n# with value2\n \n \ndef insertAfter(value1, value2):\n    global start\n    new_node = Node(0)\n    new_node.data = value1  # Inserting the data\n \n    # Find node having value2 and\n    # next node of it\n    temp = start\n    while (temp.data != value2):\n        temp = temp.next\n    next = temp.next\n \n    # insert new_node between temp and next.\n    temp.next = new_node\n    new_node.prev = temp\n    new_node.next = next\n    next.prev = new_node\n \n# this code is contributed by shivanisinghss2110\n", "# Python3 program to illustrate inserting\n# a Node in a Circular Doubly Linked list\n# in begging, end and middle\n \n# Structure of a Node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n \n# Function to insert at the end\n \n \ndef insertEnd(value):\n    global start\n \n    # If the list is empty, create a\n    # single node circular and doubly list\n    if (start == None):\n \n        new_node = Node(0)\n        new_node.data = value\n        new_node.next = new_node.prev = new_node\n        start = new_node\n        return\n \n    # If list is not empty\n \n    # Find last node */\n    last = (start).prev\n \n    # Create Node dynamically\n    new_node = Node(0)\n    new_node.data = value\n \n    # Start is going to be next of new_node\n    new_node.next = start\n \n    # Make new node previous of start\n    (start).prev = new_node\n \n    # Make last previous of new node\n    new_node.prev = last\n \n    # Make new node next of old last\n    last.next = new_node\n \n# Function to insert Node at the beginning\n# of the List,\n \n \ndef insertBegin(value):\n    global start\n \n    # Pointer points to last Node\n    last = (start).prev\n \n    new_node = Node(0)\n    new_node.data = value  # Inserting the data\n \n    # setting up previous and\n    # next of new node\n    new_node.next = start\n    new_node.prev = last\n \n    # Update next and previous pointers\n    # of start and last.\n    last.next = (start).prev = new_node\n \n    # Update start pointer\n    start = new_node\n \n# Function to insert node with value as value1.\n# The new node is inserted after the node with\n# with value2\n \n \ndef insertAfter(value1, value2):\n    global start\n    new_node = Node(0)\n    new_node.data = value1  # Inserting the data\n \n    # Find node having value2 and\n    # next node of it\n    temp = start\n    while (temp.data != value2):\n        temp = temp.next\n    next = temp.next\n \n    # insert new_node between temp and next.\n    temp.next = new_node\n    new_node.prev = temp\n    new_node.next = next\n    next.prev = new_node\n \n \ndef display():\n    global start\n    temp = start\n \n    print('Traversal in forward direction:')\n    while (temp.next != start):\n \n        print(temp.data, end=' ')\n        temp = temp.next\n \n    print(temp.data)\n \n    print('Traversal in reverse direction:')\n    last = start.prev\n    temp = last\n    while (temp.prev != last):\n \n        print(temp.data, end=' ')\n        temp = temp.prev\n \n    print(temp.data)\n \n \n# Driver Code\nif __name__ == '__main__':\n    global start\n \n    # Start with the empty list\n    start = None\n \n    # Insert 5. So linked list becomes 5.None\n    insertEnd(5)\n \n    # Insert 4 at the beginning. So linked\n    # list becomes 4.5\n    insertBegin(4)\n \n    # Insert 7 at the end. So linked list\n    # becomes 4.5.7\n    insertEnd(7)\n \n    # Insert 8 at the end. So linked list\n    # becomes 4.5.7.8\n    insertEnd(8)\n \n    # Insert 6, after 5. So linked list\n    # becomes 4.5.6.7.8\n    insertAfter(6, 5)\n \n    print('Created circular doubly linked list is: ')\n    display()\n \n# This code is contributed by Arnab kundu\n"], "Introduction to Circular Linked List -  ": ["# Class Node, similar to the linked list \nclass Node: \n    def __init__(self,data): \n        self.data = data \n        self.next = None\n", "# Initialize the Nodes. \none = Node(3) \ntwo = Node(5) \nthree = Node(9) \n  \n# Connect nodes \none.next = two \ntwo.next = three \nthree.next = one\n", "# Python program to delete a given key from linked list \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n  \n# Function to insert a node at the \n# beginning of a Circular linked list \n  \n  \ndef push(head, data): \n    # Create a new node and make head as next of it. \n    newP = Node(data) \n    newP.next = head \n  \n    # If linked list is not NULL then \n    # set the next of last node \n    if head != None: \n        # Find the node before head and \n        # update next of it. \n        temp = head \n        while (temp.next != head): \n            temp = temp.next\n        temp.next = newP \n    else: \n        newP.next = newP \n    head = newP \n    return head \n  \n# Function to print nodes in a given circular linked list \n  \n  \ndef printList(head): \n    if head == None: \n        print('List is Empty') \n        return\n    temp = head.next\n    print(head.data, end=' ') \n    if (head != None): \n        while (temp != head): \n            print(temp.data, end=' ') \n            temp = temp.next\n    print() \n  \n# Function to delete a given node \n# from the list \n  \n  \ndef deleteNode(head, key): \n    # If linked list is empty \n    if (head == None): \n        return\n  \n    # If the list contains only a \n    # single node \n    if (head.data == key and head.next == head): \n        head = None\n        return\n  \n    last = head \n  \n    # If head is to be deleted \n    if (head.data == key): \n        # Find the last node of the list \n        while (last.next != head): \n            last = last.next\n  \n        # Point last node to the next of \n        # head i.e. the second node \n        # of the list \n        last.next = head.next\n        head = last.next\n        return\n  \n    # Either the node to be deleted is \n    # not found or the end of list \n    # is not reached \n    while (last.next != head and last.next.data != key): \n        last = last.next\n  \n    # If node to be deleted was found \n    if (last.next.data == key): \n        d = last.next\n        last.next = d.next\n        d = None\n    else: \n        print('Given node is not found in the list!!!') \n  \n  \n# Driver code \n# Initialize lists as empty \nhead = None\n  \n# Created linked list will be \n# 2->5->7->8->10 \nhead = push(head, 2) \nhead = push(head, 5) \nhead = push(head, 7) \nhead = push(head, 8) \nhead = push(head, 10) \n  \nprint('List Before Deletion: ') \nprintList(head) \n  \ndeleteNode(head, 7) \nprint('List After Deletion: ') \nprintList(head) \n"], "Insertion in a Doubly Linked List -  ": ["# Adding a node at the front of the list\ndef push(self, new_data):\n \n    # 1 & 2: Allocate the Node & Put in the data\n    new_node = Node(data=new_data)\n \n    # 3. Make next of new node as head and previous as NULL\n    new_node.next = self.head\n    new_node.prev = None\n \n    # 4. change prev of head node to new node\n    if self.head is not None:\n        self.head.prev = new_node\n \n    # 5. move the head to point to the new node\n    self.head = new_node\n \n# This code is contributed by jatinreaper\n", "# Given a node as prev_node, insert\n# a new node after the given node\n \n \ndef insertAfter(self, prev_node, new_data):\n \n    # Check if the given prev_node is NULL\n    if prev_node is None:\n        print('This node doesn't exist in DLL')\n        return\n \n    # 1. allocate node  & \n    # 2. put in the data\n    new_node = Node(data=new_data)\n \n    # 3. Make next of new node as next of prev_node\n    new_node.next = prev_node.next\n \n    # 4. Make the next of prev_node as new_node\n    prev_node.next = new_node\n \n    # 5. Make prev_node as previous of new_node\n    new_node.prev = prev_node\n \n    # 6. Change previous of new_node's next node\n    if new_node.next is not None:\n        new_node.next.prev = new_node\n \n#  This code is contributed by jatinreaper\n", "# Given a node as prev_node, insert\n# a new node after the given node\n \n \ndef insertAfter(self, next_node, new_data):\n \n    # Check if the given next_node is NULL\n    if next_node is None:\n        print('This node doesn't exist in DLL')\n        return\n \n    # 1. Allocate node  & \n    # 2. Put in the data\n    new_node = Node(data=new_data)\n \n    # 3. Make previous of new node as previous of prev_node\n    new_node.prev = next_node.prev\n \n    # 4. Make the previous of next_node as new_node\n    next_node.prev = new_node\n \n    # 5. Make next_node as next of new_node\n    new_node.next = next_node\n \n    # 6. Change next of new_node's previous node\n    if new_node.prev is not None:\n        new_node.prev.next = new_node\n    else:\n        head = new_node\n \n#  This code is contributed by jatinreaper\n", "# Add a node at the end of the DLL\ndef append(self, new_data):\n \n    # 1. allocate node \n    # 2. put in the data\n    new_node = Node(data=new_data)\n    last = self.head\n \n    # 3. This new node is going to be the\n    # last node, so make next of it as NULL\n    new_node.next = None\n \n    # 4. If the Linked List is empty, then\n    #  make the new node as head\n    if self.head is None:\n        new_node.prev = None\n        self.head = new_node\n        return\n \n    # 5. Else traverse till the last node\n    while (last.next is not None):\n        last = last.next\n \n    # 6. Change the next of last node\n    last.next = new_node\n    # 7. Make last node as previous of new node */\n    new_node.prev = last\n \n#  This code is contributed by jatinreaper\n"], "Introduction to Matrix or Grid - Data Structure and Algorithms Tutorial -  ": ["arr = [ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8 ], [ 9, 10, 11, 12] ] \n  \nfor i in range(0,3): \n  for j in range(0,4): \n      \n    print(arr[i][j],end = ' ') \n  print('') \n  \n# This code is contributed by akashish__ \n", "# Python code for above approach \ndef searchInMatrix(arr, x): \n    # m=4,n=5 \n    for i in range(0, 4): \n        for j in range(0, 5): \n            if(arr[i][j] == x): \n                return 1\n    return\n  \nx = 8\narr = [[0, 6, 8, 9, 11], \n       [20, 22, 28, 29, 31], \n       [36, 38, 50, 61, 63], \n       [64, 66, 100, 122, 128]] \nif(searchInMatrix(arr, x)): \n    print('YES') \nelse: \n    print('NO') \n  \n    # This code is contributed by ishankhandelwals.\n", "# Python3 Program to print the Diagonals of a Matrix \nMAX = 100\n  \n# Function to print the Principal Diagonal \ndef printPrincipalDiagonal(mat, n): \n    print('Principal Diagonal: ',end='') \n  \n    for i in range(0,n): \n        for j in range(0,n): \n  \n            # Condition for principal diagonal \n            if (i == j): \n                print(mat[i][j] , ', ', end='') \n    print('') \n  \n# Function to print the Secondary Diagonal \ndef printSecondaryDiagonal(mat, n): \n    print('Secondary Diagonal: ',end = '') \n  \n    for i in range(0,n): \n        for j in range(0,n): \n  \n            # Condition for secondary diagonal \n            if ((i + j) == (n - 1)): \n                print(mat[i][j] , ', ', end = '') \n    print('') \n  \n# Driver code \nn = 4\na = [ [ 1, 2, 3, 4 ], \n                    [ 5, 6, 7, 8 ], \n                    [ 1, 2, 3, 4 ], \n                    [ 5, 6, 7, 8 ] ] \n  \nprintPrincipalDiagonal(a, n) \nprintSecondaryDiagonal(a, n) \n  \n# This code is contributed by akashish__ \n", "# Python Implementation to sort the given matrix \ndef sortMat(mat, n):  \n    \n    # temporary matrix of size n^2  \n    temp = [0]*n*n  \n    k = 0\n    \n    # copy the elements of matrix one by one  \n    # leto temp[]  \n    for i in range(0, n):  \n        for j in range(0, n):  \n            temp[k] = mat[i][j]  \n            k += 1\n    \n    # sort temp[]  \n    temp.sort(reverse = True)  \n    \n    # copy the elements of temp[] one by one  \n    # in mat[][]  \n    k = 0\n    for i in range(0, n):  \n        for j in range(0, n):  \n            mat[i][j] = temp[k]  \n            k += 1\n    \n# function to print the given matrix  \ndef printMat(mat, n):  \n    for i in range(0, n):  \n        for j in range(0, n):  \n            print(mat[i][j], end = ' ')  \n        print('')  \n    \n# Driver program to test above  \nmat = [[5, 4, 7],  \n       [1, 3, 8],  \n       [2, 9, 6]]  \nn = 3\n    \nprint('Original Matrix:')  \nprintMat(mat, n)  \nsortMat(mat, n)  \nprint('\\nMatrix After Sorting:')  \nprintMat(mat, n) \n  \n# This code is contributed by ishankhandelwals.\n", "# Python program for left rotation of matrix by 180 \nR = 4\nC = 4\n  \n# Function to rotate the matrix by 180 degree \ndef reverseColumns(arr):  \n  for i in range(C):  \n    for j in range(0, int(C / 2)):  \n      x = arr[j][i]  \n      arr[j][i] = arr[C - 1 - j][i]  \n      arr[C - 1 - j][i] = x  \n  \n# Function for transpose of matrix  \ndef transpose(arr):  \n  for i in range(R):  \n    for j in range(i, C):  \n      x = arr[j][i]  \n      arr[j][i] = arr[i][j]  \n      arr[i][j] = x  \n  \n# Function for display the matrix  \ndef printMatrix(arr):  \n  for i in range(R):  \n    for j in range(C):  \n      print(arr[i][j], end = ' ')  \n    print()  \n  \n# Function to anticlockwise rotate matrix  \n# by 180 degree  \ndef rotate180(arr):  \n  transpose(arr)  \n  reverseColumns(arr)  \n  transpose(arr)  \n  reverseColumns(arr)  \n  \n# Driven code  \narr = [[1, 2, 3, 4 ],  \n              [ 5, 6, 7, 8 ],  \n              [ 9, 10, 11, 12 ],  \n              [ 13, 14, 15, 16 ]]  \nrotate180(arr)  \nprintMatrix(arr) \n  \n# This code is contributed by akashish__\n", "# Python program to find unique \n# element in matrix \n  \n# Function that calculate unique element \ndef unique(mat, n, m): \n    maximum = 0\n    flag = 0\n    for i in range(n): \n        for j in range(m): \n            # Find maximum element in \n            # a matrix \n            if maximum < mat[i][j]: \n                maximum = mat[i][j] \n  \n    # Take 1-D array of (maximum + 1) \n    # size \n    b = [0] * (maximum + 1) \n    for i in range(n): \n        for j in range(m): \n            y = mat[i][j] \n            b[y] += 1\n  \n    # print unique element \n    for i in range(1, maximum+1): \n        if b[i] == 1: \n            print(i, end=' ') \n    flag = 1\n  \n    if flag == 0: \n        print('No unique element in the matrix') \n  \nR = 4\nC = 4\nmat = [[1, 2, 3, 20], \n       [5, 6, 20, 25], \n       [1, 3, 5, 6], \n       [6, 7, 8, 15]] \n  \n# function that calculate unique element \nunique(mat, R, C) \n  \n# This code is contributed by lokesh.\n"], "Given a string A and a dictionary of words B, determine if A can be segmented into a space-separated sequence of one or more dictionary words. Problem Constraints 1 <= len(A) <= 6500 1 <= len(B) <= 10000 1 <= len(B[i]) <= 20 Input Format The first argument is a string, A. The second argument is an array of strings, B. Output Format Return 0 / 1 ( 0 for false, 1 for true ) for this problem. Example Input Input 1: A = \"myinterviewtrainer\", B = [\"trainer\", \"my\", \"interview\"] Input 2:A = \"a\" B = [\"aaa\"] Example Output Output 1:1 Output 2:0 Example Explanation Explanation 1:Return 1 ( corresponding to true ) because \"myinterviewtrainer\" can be segmented as \"my interview trainer\". Explanation 2: Return 0 ( corresponding to false ) because \"a\" cannot be segmented as \"aaa\".": "class Solution:\n    # @param s, a string\n    # @param dict, a set of string\n    # @return a boolean\n    def wordBreak(self, s, word_dict):\n        stack = [1]\n        for i in range (0, len(s)):\n            stack.append(0)\n            for j in range(i,-1,-1):\n                if stack[j] and s[j:i+1] in word_dict:\n                    stack[i+1] = 1\n                    break\n        return stack[len(s)]", "Learn Data Structures with Javascript | DSA Tutorial -  ": [], "JavaScript Cheat Sheet - A Basic Guide to JavaScript -  ": [], "CSS Cheat Sheet - A Basic Guide to CSS -  ": [], "HTML Cheat Sheet - A Basic Guide to HTML -  ": [], "Prototype Design Pattern -  ": [], "Iterator Pattern -  ": [], "Command Pattern -  ": [], "Adapter Pattern -  ": [], "Singleton Design Pattern | Implementation -  ": [], "Observer Pattern | Set 1 (Introduction) -  ": [], "Understanding PyTorch Lightning DataModules -  ": ["# import module \nimport torch  \n  \n# To get the layers and losses for our model \nfrom torch import nn  \nimport pytorch_lightning as pl  \n  \n# To get the activation function for our model \nimport torch.nn.functional as F  \n  \n# To get MNIST data and transforms \nfrom torchvision import datasets, transforms \n  \n# To get the optimizer for our model \nfrom torch.optim import SGD  \n  \n# To get random_split to split training \n# data into training and validation data \n# and DataLoader to create dataloaders for train,  \n# valid and test data to be returned \n# by our data module \nfrom torch.utils.data import random_split, DataLoader  \n  \nclass model(pl.LightningModule):  \n    def __init__(self):  \n        super(model, self).__init__()  \n          \n        # Defining our model architecture \n        self.fc1 = nn.Linear(28*28, 256)  \n        self.fc2 = nn.Linear(256, 128)  \n        self.out = nn.Linear(128, 10)  \n          \n        # Defining learning rate \n        self.lr = 0.01\n          \n        # Defining loss  \n        self.loss = nn.CrossEntropyLoss()  \n    \n    def forward(self, x): \n        \n          # Defining the forward pass of the model \n        batch_size, _, _, _ = x.size()  \n        x = x.view(batch_size, -1)  \n        x = F.relu(self.fc1(x))  \n        x = F.relu(self.fc2(x))  \n        return self.out(x)  \n    \n    def configure_optimizers(self): \n        \n          # Defining and returning the optimizer for our model \n        # with the defines parameters \n        return torch.optim.SGD(self.parameters(), lr = self.lr)  \n    \n    def training_step(self, train_batch, batch_idx):  \n        \n          # Defining training steps for our model \n        x, y = train_batch  \n        logits = self.forward(x)  \n        loss = self.loss(logits, y)  \n        return loss  \n    \n    def validation_step(self, valid_batch, batch_idx):  \n        \n        # Defining validation steps for our model \n        x, y = valid_batch  \n        logits = self.forward(x)  \n        loss = self.loss(logits, y) \n  \nclass DataModuleMNIST(pl.LightningDataModule): \n    def __init__(self): \n        super().__init__() \n          \n        # Directory to store MNIST Data \n        self.download_dir = '' \n          \n        # Defining batch size of our data \n        self.batch_size = 32\n          \n        # Defining transforms to be applied on the data \n        self.transform = transforms.Compose([ \n            transforms.ToTensor() \n        ]) \n  \n    def prepare_data(self): \n        \n          # Downloading our data \n        datasets.MNIST(self.download_dir,  \n                       train = True, download = True) \n          \n        datasets.MNIST(self.download_dir, \n                       train = False, download = True) \n  \n    def setup(self, stage=None): \n        \n          # Loading our data after applying the transforms \n        data = datasets.MNIST(self.download_dir, \n                              train = True,  \n                              transform = self.transform) \n          \n        self.train_data, self.valid_data = random_split(data, \n                                                        [55000, 5000]) \n  \n        self.test_data = datasets.MNIST(self.download_dir, \n                                        train = False, \n                                        transform = self.transform) \n  \n    def train_dataloader(self): \n        \n          # Generating train_dataloader \n        return DataLoader(self.train_data,  \n                          batch_size = self.batch_size) \n  \n    def val_dataloader(self): \n        \n          # Generating val_dataloader \n        return DataLoader(self.valid_data, \n                          batch_size = self.batch_size) \n  \n    def test_dataloader(self): \n        \n        # Generating test_dataloader \n        return DataLoader(self.test_data, \n                          batch_size = self.batch_size) \n  \nclf = model()  \nmnist = DataModuleMNIST()  \ntrainer = pl.Trainer() \ntrainer.fit(clf, mnist)  \n"], "Getting Started with PyTorch -  ": ["# importing torch\nimport torch\n \n# creating a tensors\nt1=torch.tensor([1, 2, 3, 4])\nt2=torch.tensor([[1, 2, 3, 4],\n                 [5, 6, 7, 8],\n                 [9, 10, 11, 12]])\n \n# printing the tensors:\nprint('Tensor t1: \\n', t1)\nprint('\\nTensor t2: \\n', t2)\n \n# rank of tensors\nprint('\\nRank of t1: ', len(t1.shape))\nprint('Rank of t2: ', len(t2.shape))\n \n# shape of tensors\nprint('\\nRank of t1: ', t1.shape)\nprint('Rank of t2: ', t2.shape)\n", "# importing torch module\nimport torch\nimport numpy as np\n \n# list of values to be stored as tensor\ndata1 = [1, 2, 3, 4, 5, 6]\ndata2 = np.array([1.5, 3.4, 6.8,\n                9.3, 7.0, 2.8])\n \n# creating tensors and printing \nt1 = torch.tensor(data1)\nt2 = torch.Tensor(data1)\nt3 = torch.as_tensor(data2)\nt4 = torch.from_numpy(data2)\n \nprint('Tensor: ',t1, 'Data type: ', t1.dtype,'\\n')\nprint('Tensor: ',t2, 'Data type: ', t2.dtype,'\\n')\nprint('Tensor: ',t3, 'Data type: ', t3.dtype,'\\n')\nprint('Tensor: ',t4, 'Data type: ', t4.dtype,'\\n')\n", "# import torch module\nimport torch \n \n# defining tensor\nt = torch.tensor([[1, 2, 3, 4],\n                 [5, 6, 7, 8],\n                 [9, 10, 11, 12]])\n \n# reshaping the tensor\nprint('Reshaping')\nprint(t.reshape(6, 2))\n \n# resizing the tensor\nprint('\\nResizing')\nprint(t.resize(2, 6))\n \n# transposing the tensor\nprint('\\nTransposing')\nprint(t.transpose(1, 0))\n", "# import torch module\nimport torch \n \n# defining two tensors\nt1 = torch.tensor([1, 2, 3, 4])\nt2 = torch.tensor([5, 6, 7, 8])\n \n# adding two tensors\nprint('tensor2 + tensor1')\nprint(torch.add(t2, t1))\n \n# subtracting two tensor\nprint('\\ntensor2 - tensor1')\nprint(torch.sub(t2, t1))\n \n# multiplying two tensors\nprint('\\ntensor2 * tensor1')\nprint(torch.mul(t2, t1))\n \n# diving two tensors\nprint('\\ntensor2 / tensor1')\nprint(torch.div(t2, t1))\n", "# importing torch\nimport torch\n \n# creating a tensor\nt1=torch.tensor(1.0, requires_grad = True)\nt2=torch.tensor(2.0, requires_grad = True)\n \n# creating a variable and gradient\nz=100 * t1 * t2\nz.backward()\n \n# printing gradient\nprint('dz/dt1 : ', t1.grad.data)\nprint('dz/dt2 : ', t2.grad.data)\n", "class Model (nn.Module) : \n \n         def __init__(self): \n \n              super(Model, self).__init__()\n \n              self.linear = torch.nn.Linear(1, 1)  \n \n      def forward(self, x):\n \n              y_pred = self.linear(x)\n \n             return y_pred\n", "# importing torch\nimport torch\n \n# training input(X) and output(y)\nX = torch.Tensor([[1], [2], [3],\n                [4], [5], [6]])\ny = torch.Tensor([[5], [10], [15],\n                  [20], [25], [30]])\n \nclass Model(torch.nn.Module):\n \n    # defining layer\n    def __init__(self):\n        super(Model, self).__init__()\n        self.linear = torch.nn.Linear(1, 1) \n     \n    # implementing forward pass\n    def forward(self, x):\n        y_pred = self.linear(x)\n        return y_pred\n \nmodel = torch.nn.Linear(1 , 1)\n \n# defining loss function and optimizer\nloss_fn = torch.nn.L1Loss()\noptimizer = torch.optim.Adam(model.parameters(), lr = 0.01 )\n \nfor epoch in range(1000):\n    \n    # predicting y using initial weights\n    y_pred = model(X.requires_grad_())\n \n    # loss calculation\n    loss = loss_fn(y_pred, y)\n \n    # calculating gradients\n    loss.backward()\n \n    # updating weights\n    optimizer.step()\n \n    optimizer.zero_grad()\n \n# testing on new data    \nX = torch.Tensor([[7], [8]])\npredicted = model(X)\nprint(predicted)\n"], "Introduction to TensorFlow -  ": [], "Top 50 R Interview Questions & Answers (2023)": [], "Top Python Interview Questions and Answers (2023)": ["try:\nraise ExceptionGroup('Example ExceptionGroup', (\nTypeError('Example TypeError'),\nValueError('Example ValueError'),\nKeyError('Example KeyError'),\nAttributeError('Example AttributeError')\n))\nexcept* TypeError:\n...\nexcept* ValueError as e:\n...\nexcept* (KeyError, AttributeError) as e:\n...\n", "match term:\n   case pattern-1:\n   action-1\n   case pattern-2:\n   action-2\n   case pattern-3:\n   action-3\n   case _:\n   action-default\n", "names = ['Jacob', 'Joe', 'Jim']\n \nif (name := input('Enter a name: ')) in names:\n    print(f'Hello, {name}!')\nelse:\n    print('Name not found.')\n"], "Data analysis using R -  ": [], "Data Analysis with Python -  ": ["import numpy as np\n  \nb = np.empty(2, dtype = int)\nprint('Matrix b : \\n', b)\n  \na = np.empty([2, 2], dtype = int)\nprint('\\nMatrix a : \\n', a)\n  \nc = np.empty([3, 3])\nprint('\\nMatrix c : \\n', c)\n", "import numpy as np\n  \nb = np.zeros(2, dtype = int)\nprint('Matrix b : \\n', b)\n  \na = np.zeros([2, 2], dtype = int)\nprint('\\nMatrix a : \\n', a)\n  \nc = np.zeros([3, 3])\nprint('\\nMatrix c : \\n', c)\n", "import numpy as np\n \n# Defining both the matrices\na = np.array([5, 72, 13, 100])\nb = np.array([2, 5, 10, 30])\n \n# Performing addition using arithmetic operator\nadd_ans = a+b\nprint(add_ans)\n \n# Performing addition using numpy function\nadd_ans = np.add(a, b)\nprint(add_ans)\n \n# The same functions and operations can be used for\n# multiple matrices\nc = np.array([1, 2, 3, 4])\nadd_ans = a+b+c\nprint(add_ans)\n \nadd_ans = np.add(a, b, c)\nprint(add_ans)\n", "import numpy as np\n \n# Defining both the matrices\na = np.array([5, 72, 13, 100])\nb = np.array([2, 5, 10, 30])\n \n# Performing subtraction using arithmetic operator\nsub_ans = a-b\nprint(sub_ans)\n \n# Performing subtraction using numpy function\nsub_ans = np.subtract(a, b)\nprint(sub_ans)\n", "import numpy as np\n \n# Defining both the matrices\na = np.array([5, 72, 13, 100])\nb = np.array([2, 5, 10, 30])\n \n# Performing multiplication using arithmetic\n# operator\nmul_ans = a*b\nprint(mul_ans)\n \n# Performing multiplication using numpy function\nmul_ans = np.multiply(a, b)\nprint(mul_ans)\n", "import numpy as np\n \n# Defining both the matrices\na = np.array([5, 72, 13, 100])\nb = np.array([2, 5, 10, 30])\n \n# Performing division using arithmetic operators\ndiv_ans = a/b\nprint(div_ans)\n \n# Performing division using numpy functions\ndiv_ans = np.divide(a, b)\nprint(div_ans)\n", "# Python program to demonstrate \n# the use of index arrays.\nimport numpy as np\n  \n# Create a sequence of integers from\n# 10 to 1 with a step of -2\na = np.arange(10, 1, -2) \nprint('\\n A sequential array with a negative step: \\n',a)\n  \n# Indexes are specified inside the np.array method.\nnewarr = a[np.array([3, 1, 2 ])]\nprint('\\n Elements at these indices are:\\n',newarr)\n", "# Python program for basic slicing.\nimport numpy as np\n \n# Arrange elements from 0 to 19\na = np.arrange(20)\nprint('\\n Array is:\\n ',a)\n \n# a[start:stop:step]\nprint('\\n a[-8:17:1] = ',a[-8:17:1])\n \n# The : operator means all elements till the end.\nprint('\\n a[10:] = ',a[10:])\n", "# Python program for indexing using basic slicing with ellipsis\nimport numpy as np\n \n# A 3 dimensional array.\nb = np.array([[[1, 2, 3],[4, 5, 6]],\n            [[7, 8, 9],[10, 11, 12]]])\n \nprint(b[...,1]) #Equivalent to b[: ,: ,1 ]\n", "import numpy as np\n \nmacros = np.array([\n[0.8, 2.9, 3.9],\n[52.4, 23.6, 36.5],\n[55.2, 31.7, 23.9],\n[14.4, 11, 4.9]\n])\n \n# Create a new array filled with zeros,\n# of the same shape as macros.\nresult = np.zeros_like(macros)\n \ncal_per_macro = np.array([3, 3, 8])\n \n# Now multiply each row of macros by\n# cal_per_macro. In Numpy, `*` is\n# element-wise multiplication between two arrays.\nfor i in range(macros.shape[0]):\n    result[i, :] = macros[i, :] * cal_per_macro\n \nresult\n", "import numpy as np\n \nv = np.array([12, 24, 36])\nw = np.array([45, 55])\n \n# To compute an outer product we first\n# reshape v to a column vector of shape 3x1\n# then broadcast it against w to yield an output\n# of shape 3x2 which is the outer product of v and w\nprint(np.reshape(v, (3, 1)) * w)\n \nX = np.array([[12, 22, 33], [45, 55, 66]])\n \n# x has shape 2x3 and v has shape (3, )\n# so they broadcast to 2x3,\nprint(X + v)\n \n# Add a vector to each column of a matrix X has\n# shape 2x3 and w has shape (2, ) If we transpose X\n# then it has shape 3x2 and can be broadcast against w\n# to yield a result of shape 3x2.\n \n# Transposing this yields the final result\n# of shape 2x3 which is the matrix.\nprint((X.T + w).T)\n \n# Another solution is to reshape w to be a column\n# vector of shape 2X1 we can then broadcast it\n# directly against X to produce the same output.\nprint(X + np.reshape(w, (2, 1)))\n \n# Multiply a matrix by a constant, X has shape 2x3.\n# Numpy treats scalars as arrays of shape();\n# these can be broadcast together to shape 2x3.\nprint(X * 2)\n", "import pandas as pd\nimport numpy as np\n \n \n# Creating empty series\nser = pd.Series()\n \nprint(ser)\n \n# simple array\ndata = np.array(['g', 'e', 'e', 'k', 's'])\n \nser = pd.Series(data)\nprint(ser)\n", "import pandas as pd\n \n# Calling DataFrame constructor\ndf = pd.DataFrame()\nprint(df)\n \n# list of strings\nlst = ['Geeks', 'For', 'Geeks', 'is',\n            'portal', 'for', 'Geeks']\n \n# Calling DataFrame constructor on list\ndf = pd.DataFrame(lst)\ndf\n", "import pandas as pd\n \n# Reading the CSV file\ndf = pd.read_csv('Iris.csv')\n \n# Printing top 5 rows\ndf.head()\n", "import pandas as pd\n \n# Reading the CSV file\ndf = pd.read_csv('Iris.csv')\n \n# applying filter function\ndf.filter(['Species', 'SepalLengthCm', 'SepalLengthCm']).head()\n", "# importing pandas module\nimport pandas as pd\n \n# Define a dictionary containing employee data\ndata1 = {'Name': ['Jai', 'Anuj', 'Jai', 'Princi',\n                  'Gaurav', 'Anuj', 'Princi', 'Abhi'],\n         'Age': [27, 24, 22, 32,\n                 33, 36, 27, 32],\n         'Address': ['Nagpur', 'Kanpur', 'Allahabad', 'Kannuaj',\n                     'Jaunpur', 'Kanpur', 'Allahabad', 'Aligarh'],\n         'Qualification': ['Msc', 'MA', 'MCA', 'Phd',\n                           'B.Tech', 'B.com', 'Msc', 'MA']}\n \n# Convert the dictionary into DataFrame\ndf = pd.DataFrame(data1)\n \nprint('Original Dataframe')\ndisplay(df)\n \n# applying groupby() function to\n# group the data on Name value.\ngk = df.groupby('Name')\n \n# Let's print the first entries\n# in all the groups formed.\nprint('After Creating Groups')\ngk.first()\n", "# importing pandas module\nimport pandas as pd\n \n# importing numpy as np\nimport numpy as np\n \n# Define a dictionary containing employee data\ndata1 = {'Name': ['Jai', 'Anuj', 'Jai', 'Princi',\n                  'Gaurav', 'Anuj', 'Princi', 'Abhi'],\n         'Age': [27, 24, 22, 32,\n                 33, 36, 27, 32],\n         'Address': ['Nagpur', 'Kanpur', 'Allahabad', 'Kannuaj',\n                     'Jaunpur', 'Kanpur', 'Allahabad', 'Aligarh'],\n         'Qualification': ['Msc', 'MA', 'MCA', 'Phd',\n                                  'B.Tech', 'B.com', 'Msc', 'MA']}\n \n \n# Convert the dictionary into DataFrame\ndf = pd.DataFrame(data1)\n \n# performing aggregation using\n# aggregate method\n \ngrp1 = df.groupby('Name')\n \ngrp1.aggregate(np.sum)\n", "# importing pandas module\nimport pandas as pd \n  \n# Define a dictionary containing employee data \ndata1 = {'key': ['K0', 'K1', 'K2', 'K3'],\n         'Name':['Jai', 'Princi', 'Gaurav', 'Anuj'], \n        'Age':[27, 24, 22, 32],} \n    \n# Define a dictionary containing employee data \ndata2 = {'key': ['K0', 'K1', 'K2', 'K3'],\n         'Address':['Nagpur', 'Kanpur', 'Allahabad', 'Kannuaj'], \n        'Qualification':['Btech', 'B.A', 'Bcom', 'B.hons']} \n  \n# Convert the dictionary into DataFrame  \ndf = pd.DataFrame(data1)\n  \n# Convert the dictionary into DataFrame  \ndf1 = pd.DataFrame(data2) \n   \n \ndisplay(df, df1) \n \n# combining series and dataframe\nres = pd.concat([df, df1], axis=1)\n  \nres\n", "# importing pandas module\nimport pandas as pd \n  \n# Define a dictionary containing employee data \ndata1 = {'key': ['K0', 'K1', 'K2', 'K3'],\n         'Name':['Jai', 'Princi', 'Gaurav', 'Anuj'], \n        'Age':[27, 24, 22, 32],} \n    \n# Define a dictionary containing employee data \ndata2 = {'key': ['K0', 'K1', 'K2', 'K3'],\n         'Address':['Nagpur', 'Kanpur', 'Allahabad', 'Kannuaj'], \n        'Qualification':['Btech', 'B.A', 'Bcom', 'B.hons']} \n  \n# Convert the dictionary into DataFrame  \ndf = pd.DataFrame(data1)\n  \n# Convert the dictionary into DataFrame  \ndf1 = pd.DataFrame(data2) \n   \n \ndisplay(df, df1) \n \n# using .merge() function\nres = pd.merge(df, df1, on='key')\n  \nres\n", "# importing pandas module\nimport pandas as pd \n   \n# Define a dictionary containing employee data \ndata1 = {'Name':['Jai', 'Princi', 'Gaurav', 'Anuj'], \n        'Age':[27, 24, 22, 32]} \n     \n# Define a dictionary containing employee data \ndata2 = {'Address':['Allahabad', 'Kannuaj', 'Allahabad', 'Kannuaj'], \n        'Qualification':['MCA', 'Phd', 'Bcom', 'B.hons']} \n   \n# Convert the dictionary into DataFrame  \ndf = pd.DataFrame(data1,index=['K0', 'K1', 'K2', 'K3'])\n   \n# Convert the dictionary into DataFrame  \ndf1 = pd.DataFrame(data2, index=['K0', 'K2', 'K3', 'K4'])\n  \n \ndisplay(df, df1)  \n \n# joining dataframe\nres = df.join(df1)\n  \nres\n", "# Python program to show pyplot module\nimport matplotlib.pyplot as plt\n \n \nplt.plot([1, 2, 3, 4], [1, 4, 9, 16])\nplt.axis([0, 6, 0, 20])\nplt.show()\n", "import matplotlib.pyplot as plt\nimport pandas as pd\n \ndf = pd.read_csv('Iris.csv')\n \n# This will plot a simple bar chart\nplt.bar(df['Species'], df['SepalLengthCm'])\n \n# Title to the plot\nplt.title('Iris Dataset')\n \n# Adding the legends\nplt.legend(['bar'])\nplt.show()\n", "import matplotlib.pyplot as plt\nimport pandas as pd\n \ndf = pd.read_csv('Iris.csv')\n \nplt.hist(df['SepalLengthCm'])\n \n# Title to the plot\nplt.title('Histogram')\n \n# Adding the legends\nplt.legend(['SepalLengthCm'])\nplt.show()\n", "import matplotlib.pyplot as plt\nimport pandas as pd\n \ndf = pd.read_csv('Iris.csv')\n \nplt.scatter(df['Species'], df['SepalLengthCm'])\n \n# Title to the plot\nplt.title('Scatter Plot')\n \n# Adding the legends\nplt.legend(['SepalLengthCm'])\nplt.show()\n", "import matplotlib.pyplot as plt\nimport pandas as pd\n \ndf = pd.read_csv('Iris.csv')\n \nplt.boxplot(df['SepalWidthCm'])\n \n# Title to the plot\nplt.title('Box Plot')\n \n# Adding the legends\nplt.legend(['SepalWidthCm'])\nplt.show()\n", "import matplotlib.pyplot as plt\nimport pandas as pd\n \ndf = pd.read_csv('Iris.csv')\n \nplt.imshow(df.corr() , cmap = 'autumn' , interpolation = 'nearest' )\n   \nplt.title('Heat Map')\nplt.show()\n", "df.shape\n", "df.info()\n", "df.describe()\n", "df.isnull().sum()\n", "data = df.drop_duplicates(subset ='Species',)\ndata\n", "df.value_counts('Species')\n", "# importing packages\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n \nsns.scatterplot(x='SepalLengthCm', y='SepalWidthCm',\n                hue='Species', data=df, )\n \n# Placing Legend outside the Figure\nplt.legend(bbox_to_anchor=(1, 1), loc=2)\n \nplt.show()\n", "# importing packages\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n \nsns.scatterplot(x='PetalLengthCm', y='PetalWidthCm',\n                hue='Species', data=df, )\n \n# Placing Legend outside the Figure\nplt.legend(bbox_to_anchor=(1, 1), loc=2)\n \nplt.show()\n", "# importing packages\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n \nsns.pairplot(df.drop(['Id'], axis = 1), \n             hue='Species', height=2)\n", "data.corr(method='pearson')\n", "# importing packages\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n \nsns.heatmap(df.corr(method='pearson').drop(\n  ['Id'], axis=1).drop(['Id'], axis=0),\n            annot = True);\n \nplt.show()\n", "# importing packages\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n# Load the dataset\ndf = pd.read_csv('Iris.csv')\n \nsns.boxplot(x='SepalWidthCm', data=df)\n", "# Importing\nimport sklearn\nfrom sklearn.datasets import load_boston\nimport pandas as pd\nimport seaborn as sns\n \n# Load the dataset\ndf = pd.read_csv('Iris.csv')\n \n# IQR\nQ1 = np.percentile(df['SepalWidthCm'], 25,\n                interpolation = 'midpoint')\n \nQ3 = np.percentile(df['SepalWidthCm'], 75,\n                interpolation = 'midpoint')\nIQR = Q3 - Q1\n \nprint('Old Shape: ', df.shape)\n \n# Upper bound\nupper = np.where(df['SepalWidthCm'] >= (Q3+1.5*IQR))\n \n# Lower bound\nlower = np.where(df['SepalWidthCm'] <= (Q1-1.5*IQR))\n \n# Removing the Outliers\ndf.drop(upper[0], inplace = True)\ndf.drop(lower[0], inplace = True)\n \nprint('New Shape: ', df.shape)\n \nsns.boxplot(x='SepalWidthCm', data=df)\n"], "Data visualization with R and ggplot2 -  ": [], "Getting Started with Plotly in R -  ": [], "Data Visualization in R -  ": [], "Python Seaborn Tutorial -  ": ["# importing packages  \nimport seaborn as sns  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# setting the title using Matplotlib \nplt.title('Title using Matplotlib Function') \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# setting the x limit of the plot \nplt.xlim(5) \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# changing the theme to dark \nsns.set_style('dark') \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# Removing the spines \nsns.despine() \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# changing the figure size \nplt.figure(figsize = (2, 4)) \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# Removing the spines \nsns.despine() \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# Setting the scale of the plot \nsns.set_context('paper') \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n  \ndef plot(): \n    sns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \nwith sns.axes_style('darkgrid'): \n      \n    # Adding the subplot \n    plt.subplot(211) \n    plot() \n      \nplt.subplot(212) \nplot()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt \n  \n# current colot palette \npalette = sns.color_palette() \n  \n# plots the color palette as a \n# horizontal array \nsns.palplot(palette) \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt \n  \n# current colot palette \npalette = sns.color_palette('PiYG', 11) \n  \n# diverging color palette \nsns.palplot(palette) \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt \n  \n# current colot palette \npalette = sns.color_palette('Greens', 11) \n  \n# sequential color palette \nsns.palplot(palette) \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \ndef plot(): \n    sns.lineplot(x='sepal_length', y='sepal_width', data=data) \n  \n# setting the default color palette \nsns.set_palette('vlag') \nplt.subplot(211) \n  \n# plotting with the color palette \n# as vlag \nplot() \n  \n# setting another default color palette \nsns.set_palette('Accent') \nplt.subplot(212) \nplot() \n  \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \ndef graph(): \n    sns.lineplot(x='sepal_length', y='sepal_width', data=data) \n  \n# Creating a new figure with width = 5 inches \n# and height = 4 inches \nfig = plt.figure(figsize =(5, 4))  \n  \n# Creating first axes for the figure \nax1 = fig.add_axes([0.1, 0.1, 0.8, 0.8])  \n  \n# plotting the graph \ngraph() \n  \n# Creating second axes for the figure \nax2 = fig.add_axes([0.5, 0.5, 0.3, 0.3]) \n  \n# plotting the graph \ngraph() \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \ndef graph(): \n    sns.lineplot(x='sepal_length', y='sepal_width', data=data) \n  \n# Adding the subplot at the specified \n# grid position \nplt.subplot(121) \ngraph() \n  \n# Adding the subplot at the specified \n# grid position \nplt.subplot(122) \ngraph() \n  \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \ndef graph(): \n    sns.lineplot(x='sepal_length', y='sepal_width', data=data) \n  \n# adding the subplots \naxes1 = plt.subplot2grid ( \n  (7, 1), (0, 0), rowspan = 2,  colspan = 1)  \ngraph() \n  \naxes2 = plt.subplot2grid ( \n  (7, 1), (2, 0), rowspan = 2, colspan = 1)  \ngraph() \n    \naxes3 = plt.subplot2grid ( \n  (7, 1), (4, 0), rowspan = 2, colspan = 1) \ngraph()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nplot = sns.FacetGrid(data, col='species') \nplot.map(plt.plot, 'sepal_width') \n  \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('flights') \n  \nplot = sns.PairGrid(data) \nplot.map(plt.plot) \n  \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \n# creating the relplot \nsns.relplot(x='sepal_width', y='species', data=data) \n  \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.scatterplot(x='sepal_length', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.lineplot(x='sepal_length', y='species', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.barplot(x='species', y='sepal_length', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.countplot(x='species', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.boxplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.violinplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.stripplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.swarmplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.factorplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.histplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.distplot(data['sepal_width']) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.jointplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.pairplot(data=data, hue='species') \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.rugplot(data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.kdeplot(x='sepal_length', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('tips') \n  \nsns.lmplot(x='total_bill', y='tip', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('tips') \n  \nsns.regplot(x='total_bill', y='tip', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('tips') \n  \n# correlation between the different parameters  \ntc = data.corr() \n  \nsns.heatmap(tc) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('tips') \n  \n# correlation between the different parameters  \ntc = data.corr() \n  \nsns.clustermap(tc) \nplt.show()\n"], "Python Plotly tutorial -  ": ["import plotly.express as px  \n  \n  \n# Creating the Figure instance \nfig = px.line(x=[1,2, 3], y=[1, 2, 3])  \n  \n# printing the figure instance \nprint(fig)\n", "import plotly.express as px  \n  \n  \n# Creating the Figure instance \nfig = px.line(x=[1, 2, 3], y=[1, 2, 3])  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# plotting the line chart \nfig = px.line(df, x='species', y='petal_width')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# plotting the bar chart \nfig = px.bar(df, x='sepal_width', y='sepal_length')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# plotting the histogram \nfig = px.histogram(df, x='sepal_length', y='petal_width')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# plotting the scatter chart \nfig = px.scatter(df, x='species', y='petal_width')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# plotting the bubble chart \nfig = px.scatter(df, x='species', y='petal_width',  \n                 size='petal_length', color='species')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the tips dataset \ndf = px.data.tips()  \n  \n# plotting the pie chart \nfig = px.pie(df, values='total_bill', names='day')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the tips dataset \ndf = px.data.tips()  \n  \n# plotting the box chart \nfig = px.box(df, x='day', y='total_bill')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the tips dataset \ndf = px.data.tips()  \n  \n# plotting the violin chart \nfig = px.violin(df, x='day', y='total_bill') \n  \n# showing the plot \nfig.show()\n", "import plotly.figure_factory as ff  \n  \n# Data to be plotted \ndf = [dict(Task='A', Start='2020-01-01', Finish='2009-02-02'),  \n    dict(Task='Job B', Start='2020-03-01', Finish='2020-11-11'),  \n    dict(Task='Job C', Start='2020-08-06', Finish='2020-09-21')]  \n  \n# Creating the plot \nfig = ff.create_gantt(df)  \nfig.show()\n", "import plotly.graph_objects as go  \n  \n  \n# Creating the X, Y value that will \n# change the values of Z as a function \nfeature_x = np.arange(0, 50, 2)  \nfeature_y = np.arange(0, 50, 3)  \n  \n# Creating 2-D grid of features  \n[X, Y] = np.meshgrid(feature_x, feature_y)  \n  \nZ = np.cos(X / 2) + np.sin(Y / 4)  \n  \n# plotting the figure \nfig = go.Figure(data =\n    go.Contour(x = feature_x, y = feature_y, z = Z))  \n  \nfig.show()\n", "import plotly.graph_objects as go  \n  \n  \nfeature_x = np.arange(0, 50, 2)  \nfeature_y = np.arange(0, 50, 3)  \n  \n# Creating 2-D grid of features  \n[X, Y] = np.meshgrid(feature_x, feature_y)  \n  \nZ = np.cos(X / 2) + np.sin(Y / 4)  \n  \n# plotting the figure \nfig = go.Figure(data =\n     go.Heatmap(x = feature_x, y = feature_y, z = Z,))  \n  \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# Calculating the error field \ndf['error'] = df['petal_length']/100\n  \n# plotting the scatter chart \nfig = px.scatter(df, x='species', y='petal_width', \n                error_x='error', error_y='error')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# data to be plotted \ndf = px.data.tips()  \n  \n# plotting the figure \nfig = px.line_3d(df, x='sex', y='day',  \n                 z='time', color='sex')  \n  \nfig.show() \n", "import plotly.express as px  \n  \n# Data to be plotted \ndf = px.data.iris()  \n  \n# Plotting the figure \nfig = px.scatter_3d(df, x = 'sepal_width',  \n                    y = 'sepal_length',  \n                    z = 'petal_width',  \n                    color = 'species')  \n  \nfig.show() \n", "import plotly.graph_objects as go  \nimport numpy as np  \n  \n# Data to be plotted \nx = np.outer(np.linspace(-2, 2, 30), np.ones(30))  \ny = x.copy().T  \nz = np.cos(x ** 2 + y ** 2)  \n  \n# plotting the figure \nfig = go.Figure(data=[go.Surface(x=x, y=y, z=z)])  \n  \nfig.show()\n", "import plotly.graph_objects as px \nimport numpy as np \n  \n  \n# creating random data through randomint \n# function of numpy.random \nnp.random.seed(42) \n  \n# Data to be Plotted \nrandom_x = np.random.randint(1, 101, 100) \nrandom_y = np.random.randint(1, 101, 100) \n  \nplot = px.Figure(data=[px.Scatter( \n    x=random_x, \n    y=random_y, \n    mode='markers',) \n]) \n  \n# Add dropdown \nplot.update_layout( \n    updatemenus=[ \n        dict( \n            buttons=list([ \n                dict( \n                    args=['type', 'scatter'], \n                    label='Scatter Plot', \n                    method='restyle'\n                ), \n                dict( \n                    args=['type', 'bar'], \n                    label='Bar Chart', \n                    method='restyle'\n                ) \n            ]), \n            direction='down', \n        ), \n    ] \n) \n  \nplot.show() \n", "import plotly.graph_objects as px \nimport pandas as pd \n  \n# reading the database \ndata = pd.read_csv('tips.csv') \n  \n  \nplot = px.Figure(data=[px.Scatter( \n    x=data['day'], \n    y=data['tip'], \n    mode='markers',) \n]) \n  \n# Add dropdown \nplot.update_layout( \n    updatemenus=[ \n        dict( \n            type='buttons', \n            direction='left', \n            buttons=list([ \n                dict( \n                    args=['type', 'scatter'], \n                    label='Scatter Plot', \n                    method='restyle'\n                ), \n                dict( \n                    args=['type', 'bar'], \n                    label='Bar Chart', \n                    method='restyle'\n                ) \n            ]), \n        ), \n    ] \n) \n  \nplot.show() \n", "import plotly.graph_objects as px  \nimport plotly.express as go  \nimport numpy as np  \n  \ndf = go.data.tips()  \n  \nx = df['total_bill']  \ny = df['day']  \n  \nplot = px.Figure(data=[px.Scatter(  \n    x=x,  \n    y=y,  \n    mode='lines',)  \n])  \n  \nplot.update_layout(  \n    xaxis=dict(  \n        rangeselector=dict(  \n            buttons=list([  \n                dict(count=1,  \n                    step='day',  \n                    stepmode='backward'),  \n            ])  \n        ),  \n        rangeslider=dict(  \n            visible=True\n        ),  \n    )  \n)  \n  \nplot.show()  \n"], "Python Bokeh tutorial - Interactive Data Visualization with Bokeh -  ": ["# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Line Graph')  \n  \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [5, 4, 3, 2, 1]  \n  \n# plotting the line graph  \ngraph.line(x, y)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules \nfrom bokeh.plotting import figure, output_file, show \n  \n# instantiating the figure object \ngraph = figure(title='Bokeh Line Graph') \n  \n# the points to be plotted \nx = [1, 2, 3, 4, 5] \ny = [5, 4, 3, 2, 1] \n  \n# plotting the 1st line graph \ngraph.line(x, x, legend_label='Line 1') \n  \n# plotting the 2nd line graph with a \n# different color \ngraph.line(y, x, legend_label='Line 2', \n           line_color='green') \n  \n# displaying the model \nshow(graph) \n", "# importing the modules \nfrom bokeh.plotting import figure, output_file, show \n  \n# instantiating the figure object \ngraph = figure(title='Bokeh Line Graph') \n  \n# the points to be plotted \nx = [1, 2, 3, 4, 5] \ny = [5, 4, 3, 2, 1] \n  \n# plotting the 1st line graph \ngraph.line(x, x, legend_label='Line 1') \n  \n# plotting the 2nd line graph with a \n# different color \ngraph.line(y, x, legend_label='Line 2', \n           line_color='green') \n  \ngraph.legend.title = 'Title of the legend'\ngraph.legend.location ='top_left'\ngraph.legend.label_text_font_size = '17pt'\n  \n# displaying the model \nshow(graph) \n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Line Graph')  \n  \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [5, 4, 3, 2, 1]  \n  \n# plotting the line graph  \ngraph.line(x, y)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Bar Graph')  \n  \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [1, 2, 3, 4, 5]   \n  \n# height / thickness of the plot \nheight = 0.5\n  \n# plotting the bar graph  \ngraph.hbar(x, right = y, height = height)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Bar Graph')  \n  \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [1, 2, 3, 4, 5]   \n  \n# height / thickness of the plot \nwidth = 0.5\n  \n# plotting the bar graph  \ngraph.vbar(x, top = y, width = width)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \nfrom bokeh.palettes import magma  \nimport random  \n  \n      \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Scatter Graph')  \n  \n# points to be plotted  \nx = [n for n in range(256)]  \ny = [random.random() + 1 for n in range(256)]  \n  \n  \n# plotting the graph  \ngraph.scatter(x, y)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \nfrom bokeh.palettes import magma  \nimport random  \n  \n      \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Patch Plo')  \n  \n# points to be plotted  \nx = [n for n in range(256)]  \ny = [random.random() + 1 for n in range(256)]  \n  \n# plotting the graph  \ngraph.patch(x, y)  \n  \n# displaying the model  \nshow(graph)\n", "# Implementation of bokeh function  \n      \nimport numpy as np  \nfrom bokeh.plotting import figure, output_file, show  \n      \ny = [1, 2, 3, 4, 5]  \nx1 = [2, 4, 5, 2, 4]  \nx2 = [1, 2, 2, 3, 6]  \n  \np = figure(plot_width=300, plot_height=300)  \n  \n# area plot  \np.harea(x1=x1, x2=x2, y=y,fill_color='green')  \n  \nshow(p)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n          \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Wedge Graph')  \n      \n# the points to be plotted  \nx = 0\ny = 0\n  \n# radius of the wedge  \nradius = 15\n  \n# start angle of the wedge  \nstart_angle = 1\n  \n# end angle of the wedge  \nend_angle = 2\n  \n# plotting the graph  \ngraph.wedge(x, y, radius = radius,  \n            start_angle = start_angle,  \n            end_angle = end_angle)  \n      \n# displaying the model  \nshow(graph)  \n", "import numpy as np  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# creating the figure object \nplot = figure(plot_width = 300, plot_height = 300)  \n  \nplot.circle(x = [1, 2, 3], y = [3, 7, 5], size = 20)  \n  \nshow(plot)  \n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n      \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Oval Graph')  \n      \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [i * 2 for i in x]  \n  \n# plotting the graph  \ngraph.oval(x, y,  \n        height = 0.5,  \n        width = 1)  \n      \n# displaying the model  \nshow(graph)  \n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Triangle Graph')  \n      \n# the points to be plotted  \nx = 1\ny = 1\n  \n# plotting the graph  \ngraph.triangle(x, y, size = 150)  \n      \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n          \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Rectangle Graph', match_aspect = True)  \n  \n# the points to be plotted  \nx = 0\ny = 0\nwidth = 10\nheight = 5\n  \n# plotting the graph  \ngraph.rect(x, y, width, height)  \n      \n# displaying the model  \nshow(graph)  \n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n      \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Multiple Polygons Graph')  \n      \n# the points to be plotted  \nxs = [[[[1, 1, 3, 4]]]]  \nys = [[[[1, 3, 2 ,1]]]]  \n      \n# plotting the graph  \ngraph.multi_polygons(xs, ys)  \n      \n# displaying the model  \nshow(graph)  \n", "from bokeh.io import output_file, show \nfrom bokeh.layouts import column \nfrom bokeh.plotting import figure \n  \n  \nx = [1, 2, 3, 4, 5, 6] \ny0 = x \ny1 = [i * 2 for i in x] \ny2 = [i ** 2 for i in x] \n  \n# create a new plot \ns1 = figure(width=200, plot_height=200) \ns1.circle(x, y0, size=10, alpha=0.5) \n  \n# create another one \ns2 = figure(width=200, height=200) \ns2.triangle(x, y1, size=10, alpha=0.5) \n  \n# create and another \ns3 = figure(width=200, height=200) \ns3.square(x, y2, size=10, alpha=0.5) \n  \n# put all the plots in a VBox \np = column(s1, s2, s3) \n  \n# show the results \nshow(p)\n", "from bokeh.io import output_file, show \nfrom bokeh.layouts import row \nfrom bokeh.plotting import figure \n  \n  \nx = [1, 2, 3, 4, 5, 6] \ny0 = x \ny1 = [i * 2 for i in x] \ny2 = [i ** 2 for i in x] \n  \n# create a new plot \ns1 = figure(width=200, plot_height=200) \ns1.circle(x, y0, size=10, alpha=0.5) \n  \n# create another one \ns2 = figure(width=200, height=200) \ns2.triangle(x, y1, size=10, alpha=0.5) \n  \n# create and another \ns3 = figure(width=200, height=200) \ns3.square(x, y2, size=10, alpha=0.5) \n  \n# put all the plots in a VBox \np = row(s1, s2, s3) \n  \n# show the results \nshow(p)\n", "from bokeh.io import output_file, show \nfrom bokeh.layouts import gridplot \nfrom bokeh.plotting import figure \n  \n  \nx = [1, 2, 3, 4, 5, 6] \ny0 = x \ny1 = [i * 2 for i in x] \ny2 = [i ** 2 for i in x] \n  \n# create a new plot \ns1 = figure() \ns1.circle(x, y0, size=10, alpha=0.5) \n  \n# create another one \ns2 = figure() \ns2.triangle(x, y1, size=10, alpha=0.5) \n  \n# create and another \ns3 = figure() \ns3.square(x, y2, size=10, alpha=0.5) \n  \n# put all the plots in a grid \np = gridplot([[s1, None], [s2, s3]], plot_width=200, plot_height=200) \n  \n# show the results \nshow(p)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh ToolBar', toolbar_location='below')  \n  \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [1, 2, 3, 4, 5]   \n  \n# height / thickness of the plot \nwidth = 0.5\n  \n# plotting the scatter graph  \ngraph.scatter(x, y)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# file to save the model  \noutput_file('gfg.html')  \n          \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Hiding Glyphs')  \n  \n# plotting the graph  \ngraph.vbar(x = 1, top = 5,  \n        width = 1, color = 'violet',  \n        legend_label = 'Violet Bar')  \ngraph.vbar(x = 2, top = 5,  \n        width = 1, color = 'green',  \n        legend_label = 'Green Bar')  \ngraph.vbar(x = 3, top = 5,  \n        width = 1, color = 'yellow',  \n        legend_label = 'Yellow Bar')  \ngraph.vbar(x = 4, top = 5,  \n        width = 1, color = 'red',  \n        legend_label = 'Red Bar')  \n  \n# enable hiding of the glyphs  \ngraph.legend.click_policy = 'hide'\n  \n# displaying the model  \nshow(graph)  \n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# file to save the model  \noutput_file('gfg.html')  \n          \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Hiding Glyphs')  \n  \n# plotting the graph  \ngraph.vbar(x = 1, top = 5,  \n        width = 1, color = 'violet',  \n        legend_label = 'Violet Bar',  \n        muted_alpha=0.2)  \ngraph.vbar(x = 2, top = 5,  \n        width = 1, color = 'green',  \n        legend_label = 'Green Bar',  \n        muted_alpha=0.2)  \ngraph.vbar(x = 3, top = 5,  \n        width = 1, color = 'yellow',  \n        legend_label = 'Yellow Bar',  \n        muted_alpha=0.2)  \ngraph.vbar(x = 4, top = 5,  \n        width = 1, color = 'red',  \n        legend_label = 'Red Bar',  \n        muted_alpha=0.2)  \n  \n# enable hiding of the glyphs  \ngraph.legend.click_policy = 'mute'\n  \n# displaying the model  \nshow(graph)  \n", "from bokeh.io import show \nfrom bokeh.models import Button, CustomJS \n  \nbutton = Button(label='GFG') \nbutton.js_on_click(CustomJS( \n  code='console.log('button: click!', this.toString())')) \n  \nshow(button)\n", "from bokeh.io import show \nfrom bokeh.models import CheckboxGroup, CustomJS \n  \nL = ['First', 'Second', 'Third'] \n  \n# the active parameter sets checks the selected value  \n# by default \ncheckbox_group = CheckboxGroup(labels=L, active=[0, 2]) \n  \ncheckbox_group.js_on_click(CustomJS(code=''' \n    console.log('checkbox_group: active=' + this.active, this.toString()) \n''')) \n  \nshow(checkbox_group)\n", "from bokeh.io import show \nfrom bokeh.models import RadioGroup, CustomJS \n  \nL = ['First', 'Second', 'Third'] \n  \n# the active parameter sets checks the selected value  \n# by default \nradio_group = RadioGroup(labels=L, active=1) \n  \nradio_group.js_on_click(CustomJS(code=''' \n    console.log('radio_group: active=' + this.active, this.toString()) \n''')) \n  \nshow(radio_group) \n", "from bokeh.io import show \nfrom bokeh.models import CustomJS, Slider \n  \nslider = Slider(start=1, end=20, value=1, step=2, title='Slider') \n  \nslider.js_on_change('value', CustomJS(code=''' \n    console.log('slider: value=' + this.value, this.toString()) \n''')) \n  \nshow(slider)\n", "from bokeh.io import show \nfrom bokeh.models import CustomJS, Dropdown \n  \nmenu = [('First', 'First'), ('Second', 'Second'), ('Third', 'Third')] \n  \ndropdown = Dropdown(label='Dropdown Menu', button_type='success', menu=menu) \n  \ndropdown.js_on_event('menu_item_click', CustomJS( \n    code='console.log('dropdown: ' + this.item, this.toString())')) \n  \nshow(dropdown)\n", "from bokeh.plotting import figure, output_file, show \nfrom bokeh.models import Panel, Tabs \nimport numpy as np \nimport math \n  \n  \nfig1 = figure(plot_width=300, plot_height=300) \n  \nx = [1, 2, 3, 4, 5] \ny = [5, 4, 3, 2, 1] \n  \nfig1.line(x, y, line_color='green') \ntab1 = Panel(child=fig1, title='Tab 1') \n  \nfig2 = figure(plot_width=300, plot_height=300) \n  \nfig2.line(y, x, line_color='red') \ntab2 = Panel(child=fig2, title='Tab 2') \n  \nall_tabs = Tabs(tabs=[tab1, tab2]) \n  \nshow(all_tabs)\n"], "Matplotlib Tutorial -  ": ["import matplotlib.pyplot as plt \n  \n# initializing the data \nx = [10, 20, 30, 40] \ny = [20, 30, 40, 50] \n  \n# plotting the data \nplt.plot(x, y) \n  \n# Adding the title \nplt.title('Simple Plot') \n  \n# Adding the labels \nplt.ylabel('y-axis') \nplt.xlabel('x-axis') \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nplt.plot([1, 2, 3, 4], [1, 4, 9, 16])  \nplt.axis([0, 6, 0, 20])  \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \n  \n# Creating a new figure with width = 5 inches \n# and height = 4 inches \nfig = plt.figure(figsize =(5, 4))  \n  \n# Creating a new axes for the figure \nax = fig.add_axes([1, 1, 1, 1])  \n  \n# Adding the data to be plotted \nax.plot([2, 3, 4, 5, 5, 6, 6], \n        [5, 7, 1, 3, 4, 6 ,8]) \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \n  \n# Creating a new figure with width = 5 inches \n# and height = 4 inches \nfig = plt.figure(figsize =(5, 4))  \n  \n# Creating first axes for the figure \nax1 = fig.add_axes([1, 1, 1, 1])  \n  \n# Creating second axes for the figure \nax2 = fig.add_axes([1, 0.5, 0.5, 0.5]) \n  \n# Adding the data to be plotted \nax1.plot([2, 3, 4, 5, 5, 6, 6],  \n         [5, 7, 1, 3, 4, 6 ,8]) \nax2.plot([1, 2, 3, 4, 5],  \n         [2, 3, 4, 5, 6]) \n  \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \n# Creating the axes object with argument as  \n# [left, bottom, width, height] \nax = plt.axes([1, 1, 1, 1])\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \nfig = plt.figure(figsize = (5, 4)) \n  \n# Adding the axes to the figure \nax = fig.add_axes([1, 1, 1, 1]) \n  \n# plotting 1st dataset to the figure \nax1 = ax.plot([1, 2, 3, 4], [1, 2, 3, 4]) \n  \n# plotting 2nd dataset to the figure \nax2 = ax.plot([1, 2, 3, 4], [2, 3, 4, 5]) \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \nx = [3, 1, 3]  \ny = [3, 2, 1]  \n  \n# Creating a new figure with width = 5 inches \n# and height = 4 inches \nfig = plt.figure(figsize =(5, 4))  \n  \n# Creating first axes for the figure \nax = fig.add_axes([0.1, 0.1, 0.8, 0.8])  \n  \n# Adding the data to be plotted \nax.plot(x, y) \nax.set_xlim(1, 2) \nax.set_xticklabels(( \n  'one', 'two', 'three', 'four', 'five', 'six'))  \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \n  \n# Creating a new figure with width = 5 inches \n# and height = 4 inches \nfig = plt.figure(figsize =(5, 4))  \n  \n# Creating first axes for the figure \nax1 = fig.add_axes([0.1, 0.1, 0.8, 0.8])  \n  \n# Creating second axes for the figure \nax2 = fig.add_axes([0.5, 0.5, 0.3, 0.3]) \n  \n# Adding the data to be plotted \nax1.plot([5, 4, 3, 2, 1], [2, 3, 4, 5, 6]) \nax2.plot([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [3, 1, 3]  \ny = [3, 2, 1]  \nz = [1, 3, 1]  \n  \n# Creating figure object  \nplt.figure()  \n  \n# adding first subplot  \nplt.subplot(121)  \nplt.plot(x, y)  \n  \n# adding second subplot  \nplt.subplot(122)  \nplt.plot(z, y)\n", "import matplotlib.pyplot as plt  \n  \n# Creating the figure and subplots \n# according the argument passed \nfig, axes = plt.subplots(1, 2) \n  \n# plotting the data in the 1st subplot \naxes[0].plot([1, 2, 3, 4], [1, 2, 3, 4]) \n  \n# plotting the data in the 1st subplot only \naxes[0].plot([1, 2, 3, 4], [4, 3, 2, 1]) \n  \n# plotting the data in the 2nd subplot only \naxes[1].plot([1, 2, 3, 4], [1, 1, 1, 1])\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [3, 1, 3]  \ny = [3, 2, 1]  \nz = [1, 3, 1]  \n  \n# adding the subplots \naxes1 = plt.subplot2grid ( \n  (7, 1), (0, 0), rowspan = 2,  colspan = 1)  \naxes2 = plt.subplot2grid ( \n  (7, 1), (2, 0), rowspan = 2, colspan = 1)  \naxes3 = plt.subplot2grid ( \n  (7, 1), (4, 0), rowspan = 2, colspan = 1)  \n  \n# plotting the data \naxes1.plot(x, y) \naxes2.plot(x, z) \naxes3.plot(z, y)\n", "import matplotlib.pyplot as plt  \n  \n# data to display on plots  \nx = [3, 1, 3]  \ny = [3, 2, 1]  \nplt.plot(x, y) \nplt.plot(y, x) \n  \n# Adding the legends \nplt.legend(['blue', 'orange']) \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [3, 1, 3]  \ny = [3, 2, 1]  \n  \n# This will plot a simple line chart \n# with elements of x as x axis and y \n# as y axis \nplt.plot(x, y) \nplt.title('Line Chart') \n  \n# Adding the legends \nplt.legend(['Line']) \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [3, 1, 3, 12, 2, 4, 4]  \ny = [3, 2, 1, 4, 5, 6, 7]  \n  \n# This will plot a simple bar chart \nplt.bar(x, y) \n  \n# Title to the plot \nplt.title('Bar Chart') \n  \n# Adding the legends \nplt.legend(['bar']) \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [1, 2, 3, 4, 5, 6, 7, 4]  \n# This will plot a simple histogram \nplt.hist(x, bins = [1, 2, 3, 4, 5, 6, 7]) \n# Title to the plot \nplt.title('Histogram') \n# Adding the legends \nplt.legend(['bar']) \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [3, 1, 3, 12, 2, 4, 4] \ny = [3, 2, 1, 4, 5, 6, 7] \n  \n# This will plot a simple scatter chart \nplt.scatter(x, y) \n  \n# Adding legend to the plot \nplt.legend('A') \n  \n# Title to the plot \nplt.title('Scatter chart') \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [1, 2, 3, 4]  \n  \n# this will explode the 1st wedge \n# i.e. will separate the 1st wedge \n# from the chart \ne  =(0.1, 0, 0, 0) \n  \n# This will plot a simple pie chart \nplt.pie(x, explode = e) \n  \n# Title to the plot \nplt.title('Pie chart') \nplt.show()\n", "import matplotlib.pyplot as plt  \n# Creating the figure object \nfig = plt.figure() \n  \n# keeping the projection = 3d \n# creates the 3d plot \nax = plt.axes(projection = '3d')\n", "import matplotlib.pyplot as plt  \nx = [1, 2, 3, 4, 5] \ny = [1, 4, 9, 16, 25] \nz = [1, 8, 27, 64, 125] \n# Creating the figure object \nfig = plt.figure() \n# keeping the projection = 3d \n# creates the 3d plot \nax = plt.axes(projection = '3d') \nax.plot3D(z, y, x)\n", "# importing required libraries  \nimport matplotlib.pyplot as plt  \nimport matplotlib.image as img  \n# reading the image  \ntestImage = img.imread('g4g.png')  \n# displaying the image  \nplt.imshow(testImage)  \n"], "Implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Return 0 / 1 ( 0 for false, 1 for true ) for this problem Problem Constraints 1 <= |A| <= 5 * 103 1 <= |B| <= 5 * 103 Input Format The first argument is a string A. The second argument is a string A. Output Format Return an integer, 0 / 1 ( 0 for false, 1 for true ) for this problem Example Input isMatch(\"aa\",\"a\") \u2192 0 isMatch(\"aa\",\"aa\") \u2192 1 isMatch(\"aaa\",\"aa\") \u2192 0 isMatch(\"aa\", \"a*\") \u2192 1 isMatch(\"aa\", \".*\") \u2192 1 isMatch(\"ab\", \".*\") \u2192 1 isMatch(\"aab\", \"c*a*b\") \u2192 1": "import sys\nsys.setrecursionlimit(15000000)\nclass Solution:\n    # @param A : string\n    # @param B : string\n    # @return an integer\n    def isMatch(self, A, B):\n\n        cache = {}\n\n        def dfs(i, j):\n            if (i,j) in cache:\n                return cache[(i,j)]\n            if i >= len(A) and j >= len(B):\n                return True\n            if j >= len(B):\n                return False\n\n            match =  i < len(A) and (A[i] == B[j] or B[j] == \".\")\n\n            if (j+1) < len(B) and B[j+1] == \"*\":\n                cache[(i,j)] = dfs(i, j+2) or (match and dfs(i+1, j))\n                return cache[(i,j)]\n            if match:\n                cache[(i,j)] = dfs(i+1, j+1)\n                return cache[(i,j)]\n            cache[(i,j)] = False\n            return False\n        \n        return int(dfs(0, 0))\n\n\n", "Fabric.js -  ": [], "D3.js -  ": [], "Spectre CSS -  ": [], "Bootstrap Cheatsheet - A Basic Guide to Bootstrap -  ": [], "jQuery Cheat Sheet \u2013 A Basic Guide to jQuery -  ": [], "Angular Cheat Sheet - A Basic Guide to Angular -  ": [], "Given an array of non-negative integers, A, you are initially positioned at the 0th index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Input Format: The first and the only argument of input will be an integer array A. Output Format: Return an integer, representing the answer as described in the problem statement. => 0 : If you cannot reach the last index. => 1 : If you can reach the last index. Constraints: 1 <= len(A) <= 106 0 <= A[i] <= 30 Examples: Input 1: A = [2,3,1,1,4] Output 1: 1 Explanation 1: Index 0 -> Index 2 -> Index 3 -> Index 4 Input 2: A = [3,2,1,0,4] Output 2: 0 Explanation 2: There is no possible path to reach the last index.": "class Solution:\n    # @param A : list of integers\n    # @return an integer\n    def canJump(self, a):\n        \n        # This variable denotes the maximum array elem we can jump\n        # initially it is zero\n        max_jump = 0\n        for i in range(len(a)):\n            # If this index not reachable than return 0\n            if i > max_jump:\n                return 0\n            #update max jump\n            max_jump = max(max_jump, i + a[i])\n        return 1\n\n\n\n", "Given A, B, C, find whether C is formed by the interleaving of A and B. Input Format:* The first argument of input contains a string, A. The second argument of input contains a string, B. The third argument of input contains a string, C. Output Format: Return an integer, 0 or 1: => 0 : False => 1 : True Constraints: 1 <= length(A), length(B), length(C) <= 150 Examples: Input 1: A = \"aabcc\" B = \"dbbca\" C = \"aadbbcbcac\" Output 1: 1 Explanation 1: \"aa\" (from A) + \"dbbc\" (from B) + \"bc\" (from A) + \"a\" (from B) + \"c\" (from A) Input 2: A = \"aabcc\" B = \"dbbca\" C = \"aadbbbaccc\" Output 2: 0 Explanation 2: It is not possible to get C by interleaving A and B.": "class Solution:\n    # @param A : string\n    # @param B : string\n    # @param C : string\n    # @return an integer\n    \n    def isInterleave(self, A, B, C):\n\n        if len(C)!=len(A)+len(B):\n            return 0\n\n        if len(A)==0:\n            return 1 if B==C else 0\n        if len(B)==0:\n            return 1 if A==C else 0\n        if C[-1]==A[-1] and C[-1]!=B[-1]:\n            return self.isInterleave(A[:-1],B,C[:-1])\n        elif C[-1]==B[-1] and C[-1]!=A[-1]:\n            return self.isInterleave(A,B[:-1],C[:-1])\n        elif C[-1]==B[-1] and C[-1]==A[-1]:\n            return 1 if (self.isInterleave(A[:-1],B,C[:-1]) + self.isInterleave(A,B[:-1],C[:-1])>0) else 0\n        else:\n            return 0\n\n\n\n", "Introduction to Programming Languages -  ": ["# Python program for sum of 2 numbers\na = 10\nb = 15\nadd = a + b  # perform addition operation\nprint(f'Sum of {a} and {b} is: {add} ')\n \n# This code is contributed by Susobhan Akhuli\n"], "Given a string A and a dictionary of words B, add spaces in A to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note : Make sure the strings are sorted in your result. Input Format: The first argument is a string, A. The second argument is an array of strings, B. Output Format: Return a vector of strings representing the answer as described in the problem statement. Constraints: 1 <= len(A) <= 50 1 <= len(B) <= 25 1 <= len(B[i]) <= 20 Examples: Input 1: A = \"b\" B = [\"aabbb\"] Output 1: [] Input 1: A = \"catsanddog\", B = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"] Output 1: [\"cat sand dog\", \"cats and dog\"]": "class Solution:\n    # @param A : string\n    # @param B : list of strings\n    # @return an integer\n    def wordBreak(self, s, d):\n        wls = sorted(list(set(map(len, d))))\n        d = {k:1 for k in d}\n\n        arr = [0] * (len(s) + 1)\n        arr[0] = [\"\"]\n\n        i = 0\n        while i < len(s):\n            for j in wls:\n                if i + j > len(s):\n                    break\n                else:\n                    w = s[i:i + j]\n                    if w in d:\n                        if not arr[i + j]:\n                            arr[i + j] = [a + \" \" + w for a in arr[i]]\n                        else:\n                            arr[i + j] += [a + \" \" + w for a in arr[i]]\n\n            while True:\n                i += 1\n                if i == len(s) or arr[i]:\n                    break\n        if arr[-1]:\n            return sorted([s.strip() for s in arr[-1]])\n        else:\n            return []\n\n\n", "Mathematical and Geometric Algorithms - Data Structure and Algorithm Tutorials -  ": ["# Python3 program to demonstrate Basic Euclidean Algorithm \n  \n  \n# Function to return gcd of a and b \ndef gcd(a, b): \n    if a == 0: \n        return b \n  \n    return gcd(b % a, a) \n  \n  \n# Driver code \nif __name__ == '__main__': \n    a = 10\n    b = 15\n  \n    # Function call \n    print('GCD(',a,',', b,') = ', gcd(a, b)) \n", "# Python3 code to implement binary exponentiation \n  \n  \n# Function to utilise the binary exponentiation \ndef power(x, y): \n      \n    # Initialize result \n    res = 1\n  \n    # Check till the number becomes zero \n    while (y > 0): \n  \n        # If y is odd, multiply x with result \n        if ((y & 1) != 0): \n            res = res * x \n  \n        # y = y/2 \n        y = y >> 1\n          \n        # Change x to x^2 \n        x = x * x \n  \n    return res \n  \n  \n# Driver Code \nif __name__ == '__main__': \n    x = 2\n    y = 5\n      \n    # Function call \n    print('Power is', power(x, y))\n", "# Python3 program to compute modular power \n  \n  \n# Iterative Function to calculate (x^y)%p in O(log y) \ndef power(x, y, p): \n  \n    # Initialize result \n    res = 1\n  \n    # Update x if it is more than or equal to p \n    x = x % p \n  \n    # In case x is divisible by p; \n    if (x == 0): \n        return 0\n  \n    while (y > 0): \n        # If y is odd, multiply x with result \n        if ((y & 1) == 1): \n            res = (res * x) % p \n  \n        # y = y/2 \n        y = y >> 1\n        x = (x * x) % p \n  \n    return res \n  \n  \n# Driver Code \nif __name__ == '__main__': \n    x = 2\n    y = 5\n    p = 13\n  \n    # Function call \n    print('Power is', power(x, y, p)) \n", "# Python program to print all primes smaller than \n# or equal to n using Sieve of Eratosthenes \n  \n  \ndef SieveOfEratosthenes(n): \n  \n    # Create a boolean array 'prime[0..n]' and \n    # initialize all entries as true. \n    # A value in prime[i] will finally be false \n    # if i is Not a prime, else true. \n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n  \n        # If prime[p] is not changed, then it is a prime \n        if (prime[p] == True): \n  \n            # Update all multiples of p \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n  \n    # Print all prime numbers \n    for p in range(2, n+1): \n        if prime[p]: \n            print(p, end=' ') \n  \n  \n# Driver code \nif __name__ == '__main__': \n    n = 30\n    print('Following are the prime numbers' \\ \n    ' smaller than or equal to', n) \n  \n    # Function call \n    SieveOfEratosthenes(n) \n"], "Given a string A containing just the characters \u2019(\u2018 and \u2019)\u2019. Find the length of the longest valid (well-formed) parentheses substring. Input Format: The only argument given is string A. Output Format: Return the length of the longest valid (well-formed) parentheses substring. Constraints: 1 <= length(A) <= 750000 For Example Input 1: A = \"(()\" Output 1: 2 Explanation 1: The longest valid parentheses substring is \"()\", which has length = 2. Input 2: A = \")()())\" Output 2: 4 Explanation 2: The longest valid parentheses substring is \"()()\", which has length = 4.": "class Solution:\n    # @param A : string\n    # @return an integer\n    def longestValidParentheses(self, A):\n        dpMap = dict()\n\n        def dp(i):\n            if i in dpMap:\n                return dpMap[i]\n\n            if i >= len(A) or A[i] == ')':\n                return i-1\n\n            ans = i-1\n            if i+1 < len(A):\n                if A[i+1] == ')':\n                    ans = i+1 + dp(i+2)-(i+2)+1\n                elif dp(i+1) != i:\n                    j = dp(i+1)+1\n                    if j < len(A) and A[j] == ')':\n                        ans = j + dp(j+1)-(j+1)+1\n\n            dpMap[i] = ans\n            return ans\n        \n        # print ([dp(i) for i in range(len(A))])\n        return max(dp(i)-i+1 for i in reversed(range(len(A))))\n\n\n\n", "Merge two unsorted linked lists to get a sorted list -  ": ["# Python3 program for the \n# above approach\n \n# Create structure for a node\nclass node:\n   \n    def __init__(self, x):\n       \n        self.data = x\n        self.next = None\n \n# Function to print the linked \n# list\ndef setData(head):\n \n    # Store the head of the \n    # linked list into a \n    # temporary node* and \n    # iterate\n    tmp = head\n \n    while (tmp != None):\n        print(tmp.data,\n              end = ' -> ')\n        tmp = tmp.next\n \n# Function takes the head of the\n# LinkedList and the data as\n# argument and if no LinkedList\n# exists, it creates one with the\n# head pointing to first node.\n# If it exists already, it appends\n# given node at end of the last node\ndef getData(head, num):\n \n    # Create a new node\n    temp = node(-1)\n    tail = head\n \n    # Insert data into the temporary\n    # node and point it's next to NULL\n    temp.data = num\n    temp.next = None\n \n    # Check if head is null, create a\n    # linked list with temp as head\n    # and tail of the list\n    if (head == None):\n        head = temp\n        tail = temp\n \n    # Else insert the temporary node\n    # after the tail of the existing\n    # node and make the temporary node\n    # as the tail of the linked list\n    else:\n        while (tail != None):\n            if (tail.next == None):\n                tail.next = temp\n                tail = tail.next\n            tail = tail.next\n \n    # Return the list\n    return head\n \n# Function to concatenate the \n# two lists\ndef mergelists(head1,head2):\n \n    tail = head1\n \n    # Iterate through the head1 to \n    # find the last node join the \n    # next of last node of head1 \n    # to the 1st node of head2\n    while (tail != None):\n        if (tail.next == None\n            and head2 != None):\n            tail.next =head2\n            break\n        tail = tail.next\n \n    # return the concatenated \n    # lists as a single list \n    # - head1\n    return head1\n \n# Sort the linked list using\n# bubble sort\ndef sortlist(head1):\n   \n    curr = head1\n    temp = head1\n \n    # Compares two adjacent elements\n    # and swaps if the first element\n    # is greater than the other one.\n    while (curr.next != None):\n        temp = curr.next\n        while (temp != None):\n            if (temp.data < curr.data):\n                t = temp.data\n                temp.data = curr.data\n                curr.data = t\n            temp = temp.next\n        curr = curr.next\n \n# Driver Code\nif __name__ == '__main__':\n   \n    head1 = node(-1)\n    head2 = node(-1)\n \n    head1 = None\n    head2 = None\n \n    # Given Linked List 1\n    head1 = getData(head1, 4)\n    head1 = getData(head1, 7)\n    head1 = getData(head1, 5)\n \n    # Given Linked List 2\n    head2 = getData(head2, 2)\n    head2 = getData(head2, 1)\n    head2 = getData(head2, 8)\n    head2 = getData(head2, 1)\n \n    # Merge the two lists\n    # in a single list\n    head1 = mergelists(head1,head2)\n \n    # Sort the unsorted merged list\n    sortlist(head1)\n \n    # Print the final\n    # sorted merged list\n    setData(head1)\n \n# This code is contributed by Mohit Kumar 29\n"], "Check if two nodes are on same path in a tree | Set 2 -  ": ["# Python3 program to check if two nodes\n# are on same path in a tree without\n# using any extra space\n \n# Function to filter\n# the return Values\ndef filter(x, y, z):\n     \n    if (x != -1 and y != -1):\n        return z\n     \n    return y if x == -1 else x\n \n# Utility function to check if nodes\n# are on same path or not\ndef samePathUtil(mtrx, vrtx, v1, v2, i):\n     \n    ans = -1\n \n    # Condition to check\n    # if any vertex\n    # is equal to given two\n    # vertex or not\n    if (i == v1 or i == v2):\n        return i\n     \n    for j in range(0, vrtx):\n         \n        # Check if the current\n        # position has 1\n        if (mtrx[i][j] == 1):\n             \n            # Recursive call\n            ans = filter(ans, \n                         samePathUtil(mtrx, vrtx, \n                                   v1, v2, j), i)\n         \n    # Return LCA\n    return ans\n \n# Function to check if nodes\n# lies on same path or not\ndef isVertexAtSamePath(mtrx, vrtx, v1, v2, i):\n     \n    lca = samePathUtil(mtrx, vrtx, v1 - 1,\n                                   v2 - 1, i)\n \n    if (lca == v1 - 1 or lca == v2 - 1):\n        return True\n \n    return False\n \n# Driver code\nvrtx = 7\nedge = 6\n \nmtrx = [ [ 0, 1, 1, 1, 0, 0, 0 ] ,\n         [ 0, 0, 0, 0, 1, 0, 0 ],\n         [ 0, 0, 0, 0, 0, 1, 0 ],\n         [ 0, 0, 0, 0, 0, 0, 1 ],\n         [ 0, 0, 0, 0, 0, 0, 0 ],\n         [ 0, 0, 0, 0, 0, 0, 0 ],\n         [ 0, 0, 0, 0, 0, 0, 0 ] ]\n \nv1 = 1\nv2 = 5\n \nif (isVertexAtSamePath(mtrx, vrtx, v1, v2, 0)):\n    print('Yes')\nelse:\n    print('No')\n \n# This code is contributed by sanjoy_62\n"], "Shortest path in a complement graph -  ": ["from collections import defaultdict\nfrom queue import Queue\n \n# Function to find the shortest path\n# in the complement graph\ndef bfs(start, n, edges):\n    # Initially all vertices are undiscovered\n    undiscovered = set(range(1, n+1))\n \n    # Distance from the starting node\n    distance_node = [float('inf') for i in range(n+1)]\n    distance_node[start] = 0\n \n    q = Queue()\n    q.put(start)\n \n    # Continue until queue is not empty and\n    # there are still undiscovered vertices\n    while undiscovered and not q.empty():\n        cur = q.get()\n        undiscovered.remove(cur)\n \n        # Find the complement vertices of cur\n        complement_vertex = [x for x in undiscovered if x not in edges[cur]]\n \n        for x in complement_vertex:\n            # Check if optimal change in distance\n            if distance_node[x] > distance_node[cur] + 1:\n                distance_node[x] = distance_node[cur] + 1\n                q.put(x)\n \n    # Print the result\n    distance_node[3]+=1\n    print(*distance_node[1:n+1])\n \n# Main function\nif __name__ == '__main__':\n    n = 5\n    m = 4\n \n    # Using an adjacency list for edges\n    edges = defaultdict(list)\n    edges[1].extend([2, 3])\n    edges[3].extend([1, 4, 5])\n \n    bfs(1, n, edges)\n"], "Java JDK 21: New Features of Java 21 -  ": [], "Introduction to Max-Heap \u2013 Data Structure and Algorithm Tutorials -  ": ["# program to insert new element to Heap\n \n# Function to heapify ith node in a Heap\n# of size n following a Bottom-up approach\n \n \ndef heapify(arr, n, i):\n    parent = int(((i-1)/2))\n    # For Max-Heap\n    # If current node is greater than its parent\n    # Swap both of them and call heapify again\n    # for the parent\n    if arr[parent] > 0:\n        if arr[i] > arr[parent]:\n            arr[i], arr[parent] = arr[parent], arr[i]\n            # Recursively heapify the parent node\n            heapify(arr, n, parent)\n# Function to insert a new node to the Heap\n \n \ndef insertNode(arr, key):\n    global n\n    # Increase the size of Heap by 1\n    n += 1\n    # Insert the element at end of Heap\n    arr.append(key)\n    # Heapify the new node following a\n    # Bottom-up approach\n    heapify(arr, n, n-1)\n# A utility function to print array of size n\n \n \ndef printArr(arr, n):\n    for i in range(n):\n        print(arr[i], end=' ')\n \n \n# Driver Code\n# Array representation of Max-Heap\n'''\n        10\n    / \\\n    5 3\n    / \\\n    2 4\n'''\narr = [10, 5, 3, 2, 4, 1, 7]\nn = 7\nkey = 15\ninsertNode(arr, key)\nprintArr(arr, n)\n# Final Heap will be:\n'''\n    15\n    / \\\n5     10\n/ \\ /\n2 4 3\n \nCode is written by Rajat Kumar....\n'''\n", "# Python 3 program for implement deletion in Heaps\n \n# To heapify a subtree rooted with node i which is\n# an index of arr[] and n is the size of heap\ndef heapify(arr, n, i):\n \n    largest = i #Initialize largest as root\n    l = 2 * i + 1 # left = 2*i + 1\n    r = 2 * i + 2 # right = 2*i + 2\n \n    #If left child is larger than root\n    if (l < n and arr[l] > arr[largest]):\n        largest = l\n \n    #If right child is larger than largest so far\n    if (r < n and arr[r] > arr[largest]):\n        largest = r\n \n    # If largest is not root\n    if (largest != i):\n        arr[i],arr[largest]=arr[largest],arr[i]\n \n        #Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n \n#Function to delete the root from Heap\ndef deleteRoot(arr):\n    global n\n \n    # Get the last element\n    lastElement = arr[n - 1]\n \n    # Replace root with last element\n    arr[0] = lastElement\n \n    # Decrease size of heap by 1\n    n = n - 1\n \n    # heapify the root node\n    heapify(arr, n, 0)\n \n# A utility function to print array of size n\ndef printArray(arr, n):\n \n    for i in range(n):\n        print(arr[i],end=' ')\n    print()\n \n# Driver Code\nif __name__ == '__main__':\n \n    # Array representation of Max-Heap\n    #     10\n    #     / \\\n    # 5 3\n    # / \\\n    # 2 4\n    arr = [ 10, 5, 3, 2, 4 ]\n \n    n = len(arr)\n \n    deleteRoot(arr)\n \n    printArray(arr, n)\n     \n    # This code is contributed by Rajat Kumar.\n", "import heapq\n \n# Create a max heap with some elements using a list\nmax_heap = [1,2,3,4,5,6,7,8,9]\nheapq.heapify(max_heap)\n \n# Get the peak element (i.e., the largest element)\npeak_element = heapq.nlargest(1, max_heap)[0]\n \n# Print the peak element\nprint('Peak element:', peak_element)\n", "import heapq\n \nmax_heap = [10, 8, 7, 6, 5, 3, 2, 1] # example max heap\nheapq._heapify_max(max_heap)\n \nelement = 6 # element to search for\nfound = False\n \n# Copy the max heap to a temporary list and search for the element\ntemp = list(max_heap)\nwhile temp:\n    if heapq._heappop_max(temp) == element:\n        found = True\n        break\n \nif found:\n    print('Element found in the max heap.')\nelse:\n    print('Element not found in the max heap.')\n"], "Traveling Salesman Problem using Branch And Bound -  ": ["# Python3 program to solve \n# Traveling Salesman Problem using \n# Branch and Bound.\nimport math\nmaxsize = float('inf')\n \n# Function to copy temporary solution\n# to the final solution\ndef copyToFinal(curr_path):\n    final_path[:N + 1] = curr_path[:]\n    final_path[N] = curr_path[0]\n \n# Function to find the minimum edge cost \n# having an end at the vertex i\ndef firstMin(adj, i):\n    min = maxsize\n    for k in range(N):\n        if adj[i][k] < min and i != k:\n            min = adj[i][k]\n \n    return min\n \n# function to find the second minimum edge \n# cost having an end at the vertex i\ndef secondMin(adj, i):\n    first, second = maxsize, maxsize\n    for j in range(N):\n        if i == j:\n            continue\n        if adj[i][j] <= first:\n            second = first\n            first = adj[i][j]\n \n        elif(adj[i][j] <= second and\n             adj[i][j] != first):\n            second = adj[i][j]\n \n    return second\n \n# function that takes as arguments:\n# curr_bound -> lower bound of the root node\n# curr_weight-> stores the weight of the path so far\n# level-> current level while moving\n# in the search space tree\n# curr_path[] -> where the solution is being stored\n# which would later be copied to final_path[]\ndef TSPRec(adj, curr_bound, curr_weight, \n              level, curr_path, visited):\n    global final_res\n     \n    # base case is when we have reached level N \n    # which means we have covered all the nodes once\n    if level == N:\n         \n        # check if there is an edge from\n        # last vertex in path back to the first vertex\n        if adj[curr_path[level - 1]][curr_path[0]] != 0:\n             \n            # curr_res has the total weight\n            # of the solution we got\n            curr_res = curr_weight + adj[curr_path[level - 1]]\\\n                                        [curr_path[0]]\n            if curr_res < final_res:\n                copyToFinal(curr_path)\n                final_res = curr_res\n        return\n \n    # for any other level iterate for all vertices\n    # to build the search space tree recursively\n    for i in range(N):\n         \n        # Consider next vertex if it is not same \n        # (diagonal entry in adjacency matrix and \n        #  not visited already)\n        if (adj[curr_path[level-1]][i] != 0 and\n                            visited[i] == False):\n            temp = curr_bound\n            curr_weight += adj[curr_path[level - 1]][i]\n \n            # different computation of curr_bound \n            # for level 2 from the other levels\n            if level == 1:\n                curr_bound -= ((firstMin(adj, curr_path[level - 1]) +\n                                firstMin(adj, i)) / 2)\n            else:\n                curr_bound -= ((secondMin(adj, curr_path[level - 1]) +\n                                 firstMin(adj, i)) / 2)\n \n            # curr_bound + curr_weight is the actual lower bound \n            # for the node that we have arrived on.\n            # If current lower bound < final_res, \n            # we need to explore the node further\n            if curr_bound + curr_weight < final_res:\n                curr_path[level] = i\n                visited[i] = True\n                 \n                # call TSPRec for the next level\n                TSPRec(adj, curr_bound, curr_weight, \n                       level + 1, curr_path, visited)\n \n            # Else we have to prune the node by resetting \n            # all changes to curr_weight and curr_bound\n            curr_weight -= adj[curr_path[level - 1]][i]\n            curr_bound = temp\n \n            # Also reset the visited array\n            visited = [False] * len(visited)\n            for j in range(level):\n                if curr_path[j] != -1:\n                    visited[curr_path[j]] = True\n \n# This function sets up final_path\ndef TSP(adj):\n     \n    # Calculate initial lower bound for the root node \n    # using the formula 1/2 * (sum of first min + \n    # second min) for all edges. Also initialize the \n    # curr_path and visited array\n    curr_bound = 0\n    curr_path = [-1] * (N + 1)\n    visited = [False] * N\n \n    # Compute initial bound\n    for i in range(N):\n        curr_bound += (firstMin(adj, i) +\n                       secondMin(adj, i))\n \n    # Rounding off the lower bound to an integer\n    curr_bound = math.ceil(curr_bound / 2)\n \n    # We start at vertex 1 so the first vertex \n    # in curr_path[] is 0\n    visited[0] = True\n    curr_path[0] = 0\n \n    # Call to TSPRec for curr_weight \n    # equal to 0 and level 1\n    TSPRec(adj, curr_bound, 0, 1, curr_path, visited)\n \n# Driver code\n \n# Adjacency matrix for the given graph\nadj = [[0, 10, 15, 20],\n       [10, 0, 35, 25],\n       [15, 35, 0, 30],\n       [20, 25, 30, 0]]\nN = 4\n \n# final_path[] stores the final solution \n# i.e. the // path of the salesman.\nfinal_path = [None] * (N + 1)\n \n# visited[] keeps track of the already\n# visited nodes in a particular path\nvisited = [False] * N\n \n# Stores the final minimum weight\n# of shortest tour.\nfinal_res = maxsize\n \nTSP(adj)\n \nprint('Minimum cost :', final_res)\nprint('Path Taken : ', end = ' ')\nfor i in range(N + 1):\n    print(final_path[i], end = ' ')\n \n# This code is contributed by ng24_7\n"], "Job Assignment Problem using Branch And Bound -  ": [], "N Queen Problem using Branch And Bound -  ": ["''' Python3 program to solve N Queen Problem \nusing Branch or Bound '''\n \nN = 8\n \n''' A utility function to print solution '''\ndef printSolution(board):\n    for i in range(N):\n        for j in range(N):\n            print(board[i][j], end = ' ')\n        print()\n \n''' A Optimized function to check if \na queen can be placed on board[row][col] '''\ndef isSafe(row, col, slashCode, backslashCode, \n           rowLookup, slashCodeLookup, \n                       backslashCodeLookup):\n    if (slashCodeLookup[slashCode[row][col]] or\n        backslashCodeLookup[backslashCode[row][col]] or\n        rowLookup[row]):\n        return False\n    return True\n \n''' A recursive utility function \n   to solve N Queen problem '''\ndef solveNQueensUtil(board, col, slashCode, backslashCode, \n                     rowLookup, slashCodeLookup,\n                     backslashCodeLookup):\n                         \n    ''' base case: If all queens are \n       placed then return True '''\n    if(col >= N):\n        return True\n    for i in range(N):\n        if(isSafe(i, col, slashCode, backslashCode, \n                  rowLookup, slashCodeLookup,\n                  backslashCodeLookup)):\n                     \n            ''' Place this queen in board[i][col] '''\n            board[i][col] = 1\n            rowLookup[i] = True\n            slashCodeLookup[slashCode[i][col]] = True\n            backslashCodeLookup[backslashCode[i][col]] = True\n             \n            ''' recur to place rest of the queens '''\n            if(solveNQueensUtil(board, col + 1, \n                                slashCode, backslashCode, \n                                rowLookup, slashCodeLookup, \n                                backslashCodeLookup)):\n                return True\n             \n            ''' If placing queen in board[i][col] \n            doesn't lead to a solution,then backtrack '''\n             \n            ''' Remove queen from board[i][col] '''\n            board[i][col] = 0\n            rowLookup[i] = False\n            slashCodeLookup[slashCode[i][col]] = False\n            backslashCodeLookup[backslashCode[i][col]] = False\n             \n    ''' If queen can not be place in any row in \n    this column col then return False '''\n    return False\n \n''' This function solves the N Queen problem using \nBranch or Bound. It mainly uses solveNQueensUtil()to \nsolve the problem. It returns False if queens \ncannot be placed,otherwise return True or \nprints placement of queens in the form of 1s. \nPlease note that there may be more than one \nsolutions,this function prints one of the \nfeasible solutions.'''\ndef solveNQueens():\n    board = [[0 for i in range(N)] \n                for j in range(N)]\n     \n    # helper matrices \n    slashCode = [[0 for i in range(N)] \n                    for j in range(N)]\n    backslashCode = [[0 for i in range(N)] \n                        for j in range(N)]\n     \n    # arrays to tell us which rows are occupied \n    rowLookup = [False] * N\n     \n    # keep two arrays to tell us \n    # which diagonals are occupied \n    x = 2 * N - 1\n    slashCodeLookup = [False] * x\n    backslashCodeLookup = [False] * x\n     \n    # initialize helper matrices \n    for rr in range(N):\n        for cc in range(N):\n            slashCode[rr][cc] = rr + cc\n            backslashCode[rr][cc] = rr - cc + 7\n     \n    if(solveNQueensUtil(board, 0, slashCode, backslashCode, \n                        rowLookup, slashCodeLookup, \n                        backslashCodeLookup) == False):\n        print('Solution does not exist')\n        return False\n         \n    # solution found \n    printSolution(board)\n    return True\n \n# Driver Code\nsolveNQueens()\n \n# This code is contributed by SHUBHAMSINGH10\n"], "8 puzzle Problem using Branch And Bound -  ": ["# Python3 program to print the path from root \n# node to destination node for N*N-1 puzzle \n# algorithm using Branch and Bound\n# The solution assumes that instance of \n# puzzle is solvable\n \n# Importing copy for deepcopy function\nimport copy\n \n# Importing the heap functions from python \n# library for Priority Queue\nfrom heapq import heappush, heappop\n \n# This variable can be changed to change\n# the program from 8 puzzle(n=3) to 15 \n# puzzle(n=4) to 24 puzzle(n=5)...\nn = 3\n \n# bottom, left, top, right\nrow = [ 1, 0, -1, 0 ]\ncol = [ 0, -1, 0, 1 ]\n \n# A class for Priority Queue\nclass priorityQueue:\n     \n    # Constructor to initialize a\n    # Priority Queue\n    def __init__(self):\n        self.heap = []\n \n    # Inserts a new key 'k'\n    def push(self, k):\n        heappush(self.heap, k)\n \n    # Method to remove minimum element \n    # from Priority Queue\n    def pop(self):\n        return heappop(self.heap)\n \n    # Method to know if the Queue is empty\n    def empty(self):\n        if not self.heap:\n            return True\n        else:\n            return False\n \n# Node structure\nclass node:\n     \n    def __init__(self, parent, mat, empty_tile_pos,\n                 cost, level):\n                      \n        # Stores the parent node of the \n        # current node helps in tracing \n        # path when the answer is found\n        self.parent = parent\n \n        # Stores the matrix\n        self.mat = mat\n \n        # Stores the position at which the\n        # empty space tile exists in the matrix\n        self.empty_tile_pos = empty_tile_pos\n \n        # Stores the number of misplaced tiles\n        self.cost = cost\n \n        # Stores the number of moves so far\n        self.level = level\n \n    # This method is defined so that the \n    # priority queue is formed based on \n    # the cost variable of the objects\n    def __lt__(self, nxt):\n        return self.cost < nxt.cost\n \n# Function to calculate the number of \n# misplaced tiles ie. number of non-blank\n# tiles not in their goal position\ndef calculateCost(mat, final) -> int:\n     \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if ((mat[i][j]) and\n                (mat[i][j] != final[i][j])):\n                count += 1\n                 \n    return count\n \ndef newNode(mat, empty_tile_pos, new_empty_tile_pos,\n            level, parent, final) -> node:\n                 \n    # Copy data from parent matrix to current matrix\n    new_mat = copy.deepcopy(mat)\n \n    # Move tile by 1 position\n    x1 = empty_tile_pos[0]\n    y1 = empty_tile_pos[1]\n    x2 = new_empty_tile_pos[0]\n    y2 = new_empty_tile_pos[1]\n    new_mat[x1][y1], new_mat[x2][y2] = new_mat[x2][y2], new_mat[x1][y1]\n \n    # Set number of misplaced tiles\n    cost = calculateCost(new_mat, final)\n \n    new_node = node(parent, new_mat, new_empty_tile_pos,\n                    cost, level)\n    return new_node\n \n# Function to print the N x N matrix\ndef printMatrix(mat):\n     \n    for i in range(n):\n        for j in range(n):\n            print('%d ' % (mat[i][j]), end = ' ')\n             \n        print()\n \n# Function to check if (x, y) is a valid\n# matrix coordinate\ndef isSafe(x, y):\n     \n    return x >= 0 and x < n and y >= 0 and y < n\n \n# Print path from root node to destination node\ndef printPath(root):\n     \n    if root == None:\n        return\n     \n    printPath(root.parent)\n    printMatrix(root.mat)\n    print()\n \n# Function to solve N*N - 1 puzzle algorithm\n# using Branch and Bound. empty_tile_pos is\n# the blank tile position in the initial state.\ndef solve(initial, empty_tile_pos, final):\n     \n    # Create a priority queue to store live\n    # nodes of search tree\n    pq = priorityQueue()\n \n    # Create the root node\n    cost = calculateCost(initial, final)\n    root = node(None, initial, \n                empty_tile_pos, cost, 0)\n \n    # Add root to list of live nodes\n    pq.push(root)\n \n    # Finds a live node with least cost,\n    # add its children to list of live \n    # nodes and finally deletes it from \n    # the list.\n    while not pq.empty():\n \n        # Find a live node with least estimated\n        # cost and delete it from the list of \n        # live nodes\n        minimum = pq.pop()\n \n        # If minimum is the answer node\n        if minimum.cost == 0:\n             \n            # Print the path from root to\n            # destination;\n            printPath(minimum)\n            return\n \n        # Generate all possible children\n        for i in range(4):\n            new_tile_pos = [\n                minimum.empty_tile_pos[0] + row[i],\n                minimum.empty_tile_pos[1] + col[i], ]\n                 \n            if isSafe(new_tile_pos[0], new_tile_pos[1]):\n                 \n                # Create a child node\n                child = newNode(minimum.mat,\n                                minimum.empty_tile_pos,\n                                new_tile_pos,\n                                minimum.level + 1,\n                                minimum, final,)\n \n                # Add child to list of live nodes\n                pq.push(child)\n \n# Driver Code\n \n# Initial configuration\n# Value 0 is used for empty space\ninitial = [ [ 1, 2, 3 ], \n            [ 5, 6, 0 ], \n            [ 7, 8, 4 ] ]\n \n# Solvable Final configuration\n# Value 0 is used for empty space\nfinal = [ [ 1, 2, 3 ], \n          [ 5, 8, 6 ], \n          [ 0, 7, 4 ] ]\n \n# Blank tile coordinates in \n# initial configuration\nempty_tile_pos = [ 1, 2 ]\n \n# Function call to solve the puzzle\nsolve(initial, empty_tile_pos, final)\n \n# This code is contributed by Kevin Joshi\n"], "Implementation of 0/1 Knapsack using Branch and Bound -  ": [], "0/1 Knapsack using Least Cost Branch and Bound -  ": [], "Generate Binary Strings of length N using Branch and Bound -  ": ["from queue import Queue\n \n# Creating a Node class\nclass Node:\n    def __init__(self, parent, level, N):\n        self.parent = parent\n        self.level = level\n        self.soln = [0]*N\n        self.child = []\n \n# Queue that maintains the list of live Nodes\nQ = Queue()\n \n# Utility function to generate binary strings of length n\ndef generate(n):\n    # If list is full print combination\n    if n.level == N:\n        print(''.join(str(x) for x in n.soln))\n    else:\n        # Create a new list for new combination\n        n.child = []\n \n        l = n.level\n \n        # iterate while length is not equal to n\n        for i in range(2):\n            x = Node(n, l + 1, N)\n            x.soln[:l] = n.soln[:l]\n            x.soln[l] = i\n            n.child.append(x)\n            Q.put(x)\n \n# Driver code\nif __name__ == '__main__':\n    # Initiate Generation\n    # Create a root Node\n    N = 3\n    root = Node(None, 0, N)\n \n    # Instantiate the Queue\n    Q.put(root)\n \n    while not Q.empty():\n        E = Q.get()\n        generate(E)\n"], "0/1 Knapsack using Branch and Bound -  ": ["from queue import Queue \nfrom typing import List\n  \n  \nclass KnapsackNode: \n    def __init__(self, items: List[int], value: int, weight: int): \n        self.items = items \n        self.value = value \n        self.weight = weight \n  \n  \nclass Item: \n    def __init__(self, value: int, weight: int): \n        self.value = value \n        self.weight = weight \n        self.ratio = value / weight \n  \n  \nclass Knapsack: \n    def __init__(self, maxWeight: int, items: List[Item]): \n        self.maxWeight = maxWeight \n        self.items = items \n  \n    def solve(self) -> int: \n        self.items.sort(key=lambda x: x.ratio, reverse=True) \n        bestValue = 0\n        queue = [KnapsackNode([], 0, 0)] \n  \n        while queue: \n            node = queue.pop(0) \n            i = len(node.items) \n  \n            if i == len(self.items): \n                bestValue = max(bestValue, node.value) \n            else: \n                item = self.items[i] \n                withItem = KnapsackNode( \n                    node.items + [i], \n                    node.value + item.value, \n                    node.weight + item.weight \n                ) \n                if self.isPromising(withItem, self.maxWeight, bestValue): \n                    queue.append(withItem) \n                withoutItem = KnapsackNode( \n                    node.items, \n                    node.value, \n                    node.weight \n                ) \n                if self.isPromising(withoutItem, self.maxWeight, bestValue): \n                    queue.append(withoutItem) \n  \n        return bestValue \n  \n    def isPromising(self, node: KnapsackNode, maxWeight: int, bestValue: int) -> bool: \n        return node.weight <= maxWeight and node.value + self.getBound(node) > bestValue \n  \n    def getBound(self, node: KnapsackNode) -> float: \n        remainingWeight = self.maxWeight - node.weight \n        bound = node.value \n  \n        for i in range(len(node.items), len(self.items)): \n            item = self.items[i] \n  \n            if remainingWeight >= item.weight: \n                bound += item.value \n                remainingWeight -= item.weight \n            else: \n                bound += remainingWeight * item.ratio \n                break\n  \n        return bound \n", "items = [ \n    Item(60, 10), \n    Item(100, 20), \n    Item(120, 30) \n] \nknapsack = Knapsack(50, items) \nbestValue = knapsack.solve() \nprint('Best value: ' + str(bestValue))\n"], "You are climbing a stair case and it takes A steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Input Format: The first and the only argument contains an integer A, the number of steps. Output Format: Return an integer, representing the number of ways to reach the top. Constrains: 1 <= A <= 36 Example : Input 1: A = 2 Output 1: 2 Explanation 1: [1, 1], [2] Input 2: A = 3 Output 2: 3 Explanation 2: [1 1 1], [1 2], [2 1]": "class Solution:\n    # @param A : integer\n    # @return an integer\n    def climbStairs(self, A):\n        res = [1, 1]\n        for i in range(2, A+1):\n            res.append(res[i-1] + res[i-2])\n        return res[A]\n        \n\n\n", "TCS Coding Practice Question | Checking Prime Number -  ": ["import sys\n \n# checking prime or not\ndef is_prime(number):\n    if number <= 1:\n        return False\n \n    sqrt_number = int(number ** 0.5)\n \n    # Loop to check if number has any factor\n    # other than 1 and number itself\n \n    for i in range(2, sqrt_number + 1):\n        # Since i is a factor of number\n        # number is not prime\n        if number % i == 0:\n            return False\n \n    return True\n \nif __name__ == '__main__':\n \n    # Check if length of argv is not equal to 2\n    if len(sys.argv) != 2:\n        print('Usage: python prime_check.py <number>')\n        sys.exit(1)\n \n    # Get the command line argument and\n    # Convert it from string type to integer type\n    # using function 'int(sys.argv[1])'\n    number = int(sys.argv[1])\n \n    if is_prime(number):\n        print(number, 'is prime.')\n    else:\n        print(number, 'is not prime.')\n \n#puligokulakishorereddy\n"], "Prime Numbers -  ": ["# Python3 program to check whether a number\n# is prime or not using recursion\n \n# Function check whether a number\n# is prime or not\n \n \ndef isPrime(n, i):\n \n    # Corner cases\n    if (n == 0 or n == 1):\n        return False\n \n    # Checking Prime\n    if (n == i):\n        return True\n \n    # Base cases\n    if (n % i == 0):\n        return False\n \n    i += 1\n \n    return isPrime(n, i)\n \n \n# Driver Code\nif (isPrime(35, 2)):\n    print('true')\nelse:\n    print('false')\n \n#  This code is contributed by bunnyram19\n", "# A school method based Python3 program\n# to check if a number is prime\n \n \n# import sqrt from math module\nfrom math import sqrt\n \n \n \n# Function check whether a number\n# is prime or not\ndef isPrime(n):\n \n    # Corner case\n    if (n <= 1):\n        return False\n \n    # Check from 2 to sqrt(n)\n    for i in range(2, int(sqrt(n))+1):\n        if (n % i == 0):\n            return False\n \n    return True\n \n \n# Driver Code\nif __name__ == '__main__':\n    if isPrime(11):\n        print('true')\n    else:\n        print('false')\n \n# This code is contributed by Sachin Bisht\n", "import math\n \ndef is_prime(n: int) -> bool:\n     \n    # Check if n=1 or n=0\n    if n <= 1:\n        return 'false'\n     \n    # Check if n=2 or n=3\n    if n == 2 or n == 3:\n        return 'true'\n     \n    # Check whether n is divisible by 2 or 3\n    if n % 2 == 0 or n % 3 == 0:\n        return 'false'\n     \n    # Check from 5 to square root of n\n    # Iterate i by (i+6)\n    for i in range(5, int(math.sqrt(n))+1, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return 'false'\n \n    return 'true'\n \nif __name__ == '__main__':\n    print(is_prime(11))\n"], "TCS Coding Practice Question | Checking Leap Year -  ": ["#  Python program to check if N is a leap year\n#  using command line arguments\n \nclass GFG:\n    # Function to check\n    # if year is a leap year or not\n    @staticmethod\n    def isLeapYear(year):\n        if ((year % 4 == 0 and year % 100 != 0) or year % 400 == 0):\n            return 1\n        else:\n            return 0\n \nif __name__ == '__main__':\n        import sys\n        \n        # Check if length of args array is\n        # greater than 1\n        if len(sys.argv) > 1:\n         \n            # Get the command line argument and\n        # Convert it from string type to integer type\n            n = int(sys.argv[1])\n            \n            # Check if n is a leap year\n            if GFG.isLeapYear(n) == 1:\n                print('Yes')\n            else:\n                print('No')\n        else:\n            print('No command line arguments found\\nUse : python3 GFG.py <number>')\n \n #puligokulakishorereddy\n"], "Program to check if a given year is leap year -  ": ["# Python3 implementation to check \n# if the year is a leap year \n# using macros\n \n# Macro to check if a year \n# is a leap year\ndef ISLP(y):\n  if((y % 400 == 0) or\n     (y % 100 != 0) and\n     (y % 4 == 0)): \n    return 1;\n  else:\n    return 0;\n \n# Driver code\nif __name__=='__main__':\n \n  year = 2020;\n  print(ISLP(year));\n \n  # This code is contributed by  Pratham76.\n", "def checkYear(year): \n    \n    # Return true if year is a multiple \n    # of 4 and not multiple of 100. \n    # OR year is multiple of 400. \n    import calendar\n    return(calendar.isleap(year)) \n    \n# Driver Code  \nyear = 2000\nif (checkYear(year)): \n    print('Leap Year') \nelse: \n    print('Not a Leap Year') \n        \n# This code is contributed by Chin\n"], "TCS Coding Practice Question | Greatest of 3 Numbers -  ": [], "C program to Find the Largest Number Among Three Numbers -  ": [], "TCS Coding Practice Question | Concatenate 2 Strings -  ": [], "String Concatenation in C++ -  ": [], "TCS Coding Practice Question | Swap two Numbers -  ": [], "How to swap two numbers without using a temporary variable? -  ": ["x = 10\ny = 5\n \n# Code to swap 'x' and 'y'\n \n# x now becomes 15\nx = x + y\n \n# y becomes 10\ny = x - y\n \n# x becomes 5\nx = x - y\nprint('After Swapping: x =', x, ' y =', y)\n \n# This code is contributed\n# by Sumit Sudhakar\n", "# Python3 program to\n# swap two numbers\n# without using\n# temporary variable\nx = 10\ny = 5\n \n# code to swap\n# 'x' and 'y'\n \nif y == 0:\n    y = x\n    x = 0\nelif x == 0:\n    x = y\n    y = 0\nelse:\n    x = x * y\n    y = x // y\n    x = x // y\n \n \nprint('After Swapping: x =',\n      x, ' y =', y)\n \n# This code is contributed\n# by @ajit\n", "# Python3 code to swap using XOR\n \nx = 10\ny = 5\n \n# Code to swap 'x' and 'y'\nx = x ^ y; # x now becomes 15 (1111)\ny = x ^ y; # y becomes 10 (1010)\nx = x ^ y; # x becomes 5 (0101)\n \nprint ('After Swapping: x = ', x, ' y =', y)\n \n# This code is contributed by\n# Sumit Sudhakar\n", "def swap(xp, yp):\n \n    xp[0] = xp[0] ^ yp[0]\n    yp[0] = xp[0] ^ yp[0]\n    xp[0] = xp[0] ^ yp[0]\n \n \n# Driver code\nx = [10]\nswap(x, x)\nprint('After swap(&x, &x): x = ', x[0])\n \n# This code is contributed by SHUBHAMSINGH10\n", "# Python3 program of above approach\ndef swap(xp, yp):\n \n    # Check if the two addresses are same\n    if (xp[0] == yp[0]):\n        return\n    xp[0] = xp[0] + yp[0]\n    yp[0] = xp[0] - yp[0]\n    xp[0] = xp[0] - yp[0]\n \n \n# Driver Code\nx = [10]\nswap(x, x)\nprint('After swap(&x, &x): x = ', x[0])\n \n# This code is contributed by SHUBHAMSINGH10\n", "# Python3 program to swap two numbers\n \n# Function to swap the numbers\n \n \ndef swap(a, b):\n \n    # Same as a = a + b\n    a = (a & b) + (a | b)\n \n    # Same as b = a - b\n    b = a + (~b) + 1\n \n    # Same as a = a - b\n    a = a + (~b) + 1\n \n    print('After Swapping: a = ', a, ', b = ', b)\n \n \n# Driver code\na = 5\nb = 10\n \n# Function call\nswap(a, b)\n \n# This code is contributed by bunnyram19\n", "# Python3 program to swap two numbers\n \n# Function to swap the numbers \ndef swap(x, y):\n  x , y = y, x \n  print('After Swapping: x = ', x, ', y = ', y)\n   \n# Driver code\nx = 10\ny = 5\n  \n# Function call\nswap(x, y)\n  \n# This code is contributed by kothavvsaakash\n"], "TCS Coding Practice Question | LCM of 2 Numbers -  ": [], "Program to find LCM of two numbers -  ": ["# Python program to find LCM of two numbers \n  \n# Recursive function to return gcd of a and b \ndef gcd(a,b): \n    if a == 0: \n        return b \n    return gcd(b % a, a) \n  \n# Function to return LCM of two numbers \ndef lcm(a,b): \n    return (a // gcd(a,b))* b \n  \n# Driver program to test above function \na = 15 \nb = 20\nprint('LCM of', a, 'and', b, 'is', lcm(a, b)) \n  \n# This code is contributed by Danish Raza \n", "# Python program to find LCM of two numbers \n  \n# Function to return LCM of two numbers \ndef LCM(a, b): \n    greater = max(a, b) \n    smallest = min(a, b) \n    for i in range(greater, a*b+1, greater): \n        if i % smallest == 0: \n            return i \n  \n# Driver program to test above function \nif __name__ == '__main__': \n    a = 10\n    b = 5\n    print('LCM of', a, 'and', b, 'is', LCM(a, b)) \n"], "TCS Coding Practice Question | HCF or GCD of 2 Numbers -  ": [], "Program to Find GCD or HCF of Two Numbers -  ": ["# Python program to find GCD of two numbers\n \n \n# Function to find gcd of two numbers\ndef gcd(a, b):\n \n    # Find minimum of a and b\n    result = min(a, b)\n \n    while result:\n        if a % result == 0 and b % result == 0:\n            break\n        result -= 1\n \n    # Return the gcd of a and b\n    return result\n \n \n# Driver Code\nif __name__ == '__main__':\n    a = 98\n    b = 56\n    print(f'GCD of {a} and {b} is {gcd(a, b)}')\n \n \n# This code is contributed by Soham Mirikar\n", "# Python program to find GCD of two numbers\n \n \n# Recursive function to return gcd of a and b\ndef gcd(a, b):\n \n    # Everything divides 0\n    if (a == 0):\n        return b\n    if (b == 0):\n        return a\n \n    # Base case\n    if (a == b):\n        return a\n \n    # a is greater\n    if (a > b):\n        return gcd(a-b, b)\n    return gcd(a, b-a)\n \n \n# Driver code\nif __name__ == '__main__':\n    a = 98\n    b = 56\n    if(gcd(a, b)):\n        print('GCD of', a, 'and', b, 'is', gcd(a, b))\n    else:\n        print('not found')\n \n# This code is contributed by Danish Raza\n", "def gcd(a, b):\n    # Everything divides 0\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n \n    # Base case\n    if a == b:\n        return a\n \n    # a is greater\n    if a > b:\n        if a % b == 0:\n            return b\n        return gcd(a - b, b)\n    if b % a == 0:\n        return a\n    return gcd(a, b - a)\n \n# Driver code\na = 98\nb = 56\nprint(f'GCD of {a} and {b} is {gcd(a, b)}')\n", "# Recursive function to return gcd of a and b\ndef gcd(a,b):\n     \n    # Everything divides 0 \n    if (b == 0):\n         return a\n    return gcd(b, a%b)\n \n# Driver program to test above function\na = 98\nb = 56\nif(gcd(a, b)):\n    print('GCD of', a, 'and', b, 'is', gcd(a, b))\nelse:\n    print('not found')\n \n# This code is contributed by Danish Raza\n", "# Itervative function to return gcd of a and b\n \n \ndef gcd(a, b):\n \n    # Everything divides 0\n    while(a > 0 and b > 0):\n        if (a > b):\n            a = a % b\n        else:\n            b = b % a\n \n    if (a == 0):\n        return b\n    return a\n \n \n# Driver code\nif __name__ == '__main__':\n    a = 98\n    b = 56\n    if(gcd(a, b)):\n        print('GCD of', a, 'and', b, 'is', gcd(a, b))\n    else:\n        print('not found')\n", "# Python program to find gcd using inbuilt function using math library\nimport math\n \n#Driver code\nif __name__ == '__main__':\n  a = 98\n  b = 56\n  gcd_result = math.gcd(a, b) # inbuilt function gcd() using math library\n \n  print('The gcd of a and b is', gcd_result)\n \n# This code is contributed by guptapratik\n"], "TCS Coding Practice Question | Average of 2 Numbers -  ": [], "Compute average of two numbers without overflow -  ": ["# Python 3 code to compute \n# average of two numbers\nimport sys\nfrom math import floor\n \nINT_MAX = 2147483647\n \n# Function to compute \n# average of two numbers\ndef compute_average(a, b):\n    return floor((a + b) / 2)\n \n# Driver code\nif __name__ == '__main__':\n     \n    # Assigning maximum integer value\n    a = INT_MAX\n    b = -INT_MAX - 1\n \n    # Average of two equal numbers \n    # is the same number\n    print('Actual average : ', INT_MAX)\n \n    # Function to get the \n    # average of 2 numbers\n    print('Computed average : ', \n           compute_average(a, b))\n \n# This code is contributed by\n# Surendra_Gangwar\n", "# Python code to compute \n# average of two numbers \nINT_MAX=2147483647\n \n# Function to compute \n# average of two numbers \ndef compute_average(a,b): \n \n    return (a // 2) + (b // 2) + ((a % 2 + b % 2) // 2)\n \n# Driver code \nif __name__ =='__main__':\n    # Assigning maximum integer value \n    a = INT_MAX\n    b = INT_MAX \n \n    # Average of two equal \n    # numbers is the same number \n    print( 'Actual average : ',INT_MAX)\n \n    # Function to get the \n    # average of 2 numbers \n    print( 'Computed average : ',\n            compute_average(a, b))\n \n     \n# This code is contributed\n# Shubham Singh(SHUBHAMSINGH10)\n"], "TCS Coding Practice Question | Factorial of a Number -  ": [], "Program for factorial of a number -  ": [], "TCS Coding Practice Question | Fibonacci Series -  ": ["# Python program to print the Fibonacii Series\n# using command line arguments\nclass GFG:\n \n    # Function to print Fibonacii Series   \n    @staticmethod\n    def fib(n):\n        a = 0\n        b = 1\n        i = 0\n        if n <= 1:\n            print(a, end=' ')\n        else:\n            print(a, b, end=' ')\n            for i in range(3, n+1):\n                c = a + b\n                a = b\n                b = c\n                print(c, end=' ')\n            print()\n    \n     \n    if __name__ == '__main__':\n        import sys\n        \n         \n        # Check if length of args array is\n        # greater than 1\n        if len(sys.argv) > 1:\n            # Get the command line argument\n            # Convert from to String type to Integer type\n            num = int(sys.argv[1])\n            # Print Fibonacii Series   \n            fib(num)\n        else:\n            print('No command line arguments found\\nUse : python3 GFG.py <number>')\n             \n #puligokulakishorereddy\n"], "Nth Fibonacci Number -  ": ["# Function for nth fibonacci number - Space Optimisation\n# Taking 1st two fibonacci numbers as 0 and 1\n \n \ndef fibonacci(n):\n    a = 0\n    b = 1\n    if n < 0:\n        print('Incorrect input')\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n \n# Driver Program\n \n \nprint(fibonacci(9))\n \n# This code is contributed by Saket Modi\n", "# Fibonacci series using recursion\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n \n \nif __name__ == '__main__':\n    n = 9\n    print(n, 'th Fibonacci Number: ')\n    print(fibonacci(n))\n \n # This code is contributed by Manan Tyagi.\n", "# Fibonacci Series using Dynamic Programming\ndef fibonacci(n):\n \n    # Taking 1st two fibonacci numbers as 0 and 1\n    f = [0, 1]\n \n    for i in range(2, n+1):\n        f.append(f[i-1] + f[i-2])\n    return f[n]\n \n \nprint(fibonacci(9))\n", "# Fibonacci Series using\n# Optimized Method\n \n# function that returns nth\n# Fibonacci number\n \n \ndef fib(n):\n \n    F = [[1, 1],\n         [1, 0]]\n    if (n == 0):\n        return 0\n    power(F, n - 1)\n \n    return F[0][0]\n \n \ndef multiply(F, M):\n \n    x = (F[0][0] * M[0][0] +\n         F[0][1] * M[1][0])\n    y = (F[0][0] * M[0][1] +\n         F[0][1] * M[1][1])\n    z = (F[1][0] * M[0][0] +\n         F[1][1] * M[1][0])\n    w = (F[1][0] * M[0][1] +\n         F[1][1] * M[1][1])\n \n    F[0][0] = x\n    F[0][1] = y\n    F[1][0] = z\n    F[1][1] = w\n \n# Optimized version of\n# power() in method 4\n \n \ndef power(F, n):\n \n    if(n == 0 or n == 1):\n        return\n    M = [[1, 1],\n         [1, 0]]\n \n    power(F, n // 2)\n    multiply(F, F)\n \n    if (n % 2 != 0):\n        multiply(F, M)\n \n \n# Driver Code\nif __name__ == '__main__':\n    n = 9\n    print(fib(n))\n \n# This code is contributed\n# by ChitraNayal\n"], "TCS Coding Practice Question | Check Odd or Even -  ": [], "Check whether a given number is even or odd -  ": ["# A simple Python3 code \n# to check for even or odd \n  \n# Returns true if n is even, else odd \n  \n  \ndef isEven(n): \n    return (n % 2 == 0) \n  \n  \n# Driver code \nn = 101\nprint('Even' if isEven(n) else 'Odd') \n  \n# This code is contributed by 'Sharad_Bhardwaj'. \n", "# A Python3 code program \n# to check for even or odd \n  \n# Returns true if n is even, else odd \n  \n  \ndef isEven(n): \n  \n    # n&1 is 1, then odd, else even \n    return (not(n & 1)) \n  \n  \n# Driver code \nn = 101\nprint('Even' if isEven(n) else 'Odd') \n  \n# This code is contributed by 'Sharad_Bhardwaj'. \n", "a = 4\nif a == (a >> 1) << 1: \n    print('Number is Even:', a) \nelse: \n    print('Number is Odd:', a) \n"], "TCS Coding Practice Question | Check Armstrong Number -  ": [], "Program for Armstrong Numbers -  ": ["# python3 >= 3.6 for typehint support\n# This example avoids the complexity of ordering\n# through type conversions & string manipulation\n \n \ndef isArmstrong(val: int) -> bool:\n    '''val will be tested to see if its an Armstrong number. \n    Arguments:\n        val {int} -- positive integer only. \n    Returns:\n        bool -- true is /false isn't\n    '''\n \n    # break the int into its respective digits\n    parts = [int(_) for _ in str(val)]\n \n    # begin test.\n    counter = 0\n    for _ in parts:\n        counter += _**3\n    return (counter == val)\n \n \n# Check Armstrong number\nprint(isArmstrong(153))\n \nprint(isArmstrong(1253))\n", "n = 153\ntemp = n\np = 0\n \n# function to calculate\n# the sum of individual digits\nwhile (n > 0):\n    rem = n % 10\n    p = (p) + (rem * rem * rem)\n    n = n // 10\nif temp == p:\n    print('armstrong')\nelse:\n    print('not a armstrong number')\n \n    # This code is contributed by ksrikanth0498.\n", "# Python3 Program to find Nth Armstrong Number\nimport math\nimport sys\n \n# Function to find Nth Armstrong Number\n \n \ndef NthArmstrong(n):\n \n    count = 0\n \n    # upper limit from integer\n    for i in range(1, sys.maxsize):\n \n        num = i\n        rem = 0\n        digit = 0\n        sum = 0\n \n        # Copy the value for num in num\n        num = i\n \n        # Find total digits in num\n        digit = int(math.log10(num) + 1)\n \n        # Calculate sum of power of digits\n        while(num > 0):\n            rem = num % 10\n            sum = sum + pow(rem, digit)\n            num = num // 10\n \n        # Check for Armstrong number\n        if(i == sum):\n            count += 1\n        if(count == n):\n            return i\n \n \n# Driver Code\nn = 12\nprint(NthArmstrong(n))\n \n# This code is contributed by chandan_jnu\n", "def armstrong(n):\n    number = str(n)\n \n    n = len(number)\n    output = 0\n    for i in number:\n        output = output+int(i)**n\n \n    if output == int(number):\n        return(True)\n    else:\n        return(False)\n \n \nprint(armstrong(153))\nprint(armstrong(1253))\n", "def armstrong(n):\n    number = str(n)\n \n    n = len(number)\n    output = 0\n    for i in number:\n        output = output+int(i)**n\n \n    if output == int(number):\n        return(True)\n    else:\n        return(False)\n \n \narm_list = []\n \nnums = range(10, 1000)\n \nfor i in nums:\n    if armstrong(i):\n        arm_list.append(i)\n    else:\n        pass\n \nprint(arm_list)\n"], "Command Line Arguments in C/C++ -  ": [], "First element of every K sets having consecutive elements with exactly K prime factors less than N -  ": ["# Python3 program for the above approach\nx = 2000021\n \n# For storing smallest prime factor\nv = [0] * x\n \n# Function construct smallest \n# prime factor array \ndef sieve():\n \n    v[1] = 1\n \n    # Mark smallest prime factor for\n    # every number to be itself\n    for i in range(2, x):\n        v[i] = i \n \n    # separately mark spf for every\n    # even number as 2\n    for i in range(4, x, 2):\n        v[i] = 2\n \n    i = 3\n    while (i * i < x):\n \n        # Check if i is prime\n        if (v[i] == i):\n \n            # Mark SPF for all numbers\n            # divisible by i\n            for j in range(i * i, x, i):\n \n                # Mark spf[i] if it is \n                # not previously marked\n                if (v[j] == j):\n                    v[j] = i\n \n        i += 1\n \n# Function for counts total number \n# of prime factors \ndef prime_factors(n):\n \n    s = set()\n \n    while (n != 1):\n        s.add(v[n])\n        n = n // v[n]\n \n    return len(s)\n \n# Function to print elements of sets \n# of K consecutive elements having \n# K prime factors \ndef distinctPrimes(m, k):\n \n    # To store the result\n    result = []\n \n    for i in range(14, m + k):\n \n        # Count number of prime\n        # factors of number\n        count = prime_factors(i)\n \n        # If number has exactly K\n        # factors push in result[]\n        if (count == k):\n            result.append(i)\n \n    p = len(result)\n \n    for index in range(p - 1):\n        element = result[index]\n        count = 1\n        z = index\n \n        # Iterate till we get K consecutive\n        # elements in result[]\n        while (z < p - 1 and count <= k and\n               result[z] + 1 == result[z + 1]):\n \n            # Count sequence until K\n            count += 1\n            z += 1\n \n        # Print the element if count >= K\n        if (count >= k):\n            print(element, end = ' ')\n \n# Driver Code\nif __name__ == '__main__':\n     \n    # To construct spf[]\n    sieve()\n \n    # Given N and K\n    N = 1000\n    K = 3\n \n    # Function call\n    distinctPrimes(N, K)\n \n# This code is contributed by himanshu77\n"], "The Skyline Problem | Set 2 -  ": ["# pyton equivalent code\nfrom functools import cmp_to_key\n \ndef func(a, b):\n    if(a[0] != b[0]):\n        return a[0] - b[0]\n    else:\n        return a[1] - b[1]\n     \ndef createSkyline(buildings):\n     \n    wall = []\n    N = len(buildings)\n    left = 0\n    height = 0\n    right = 0\n    for i in range(N):\n        left = buildings[i][0]\n        height = buildings[i][1]\n        right = buildings[i][2]\n        wall.append([left, -height])\n        wall.append([right, height])\n     \n    letter_cmp_key = cmp_to_key(func)\n    wall.sort(key = letter_cmp_key)\n    # wall.sort(func)\n \n    skyline = []\n    leftWallHeight = set()\n    leftWallHeight.add(0)\n     \n    top = 0\n    for w in wall:\n        if w[1] < 0:\n            leftWallHeight.add(-w[1])\n        else:\n            leftWallHeight.remove(w[1])\n             \n        curTop = max(leftWallHeight)\n        if curTop != top:\n            top = curTop;\n            skyline.append([w[0], top])\n \n    return skyline\n \ndef printSkyline(buildings):\n \n    skyline = createSkyline(buildings)\n    print('Skyline for given buildings:')\n    temp = '{'\n     \n    for it in skyline:\n        temp = temp + '{' + str(it[0]) + ',' + str(it[1]) + '} '\n \n    print(temp + '}')\n \n \nbuildings = [[1, 11, 5], [2, 6, 7], [3, 13, 9], [12, 7, 16],\n[14, 3, 25], [19, 18, 22], [23, 13, 29], [24, 4, 28]]\n \nprintSkyline(buildings)\n \n# The code is contributed by Nidhi goel. \n"], "Difference Between sum of degrees of odd and even degree nodes in an Undirected Graph -  ": ["# Python3 implementation to print the\n# Difference Between sum of degrees\n# of odd degree nodes and even \n# degree nodes.\n \n# Function to print the difference\n# Between sum of degrees of odd\n# degree nodes and even degree nodes.\ndef OddEvenDegree(N, M, edges):\n \n    # To store Adjacency \n    # List of a Graph\n    Adj = [[] for i in range(N + 1)]\n      \n    EvenSum = 0;\n    OddSum = 0;\n  \n    # Make Adjacency List\n    for i in range(M):\n        x = edges[i][0];\n        y = edges[i][1];\n  \n        Adj[x].append(y);\n        Adj[y].append(x);\n  \n    # Traverse each vertex\n    for i in range(1, N + 1):\n  \n        # Find size of \n        # Adjacency List\n        x = len(Adj[i])\n  \n        # If length of Adj[i] is\n        # an odd number, add\n        # length in OddSum\n        if (x % 2 != 0):\n            OddSum += x;        \n        else:\n             \n            # If length of Adj[i] is\n            # an even number, add \n            # length in EvenSum\n            EvenSum += x;        \n      \n    return abs(OddSum - EvenSum);\n \n# Driver code\nif __name__ == '__main__':\n     \n    # Vertices and Edges\n    N = 4\n    M = 6\n  \n    # Edges\n    edges = [[1, 2], [1, 3], \n             [1, 4], [2, 3], \n             [2, 4], [3, 4]]\n  \n    # Function Call\n    print(OddEvenDegree(N, M, \n                        edges));\n \n# This code is contributed by rutvik_56\n"], "Find all divisors of N2 using N -  ": ["# Python3 code to print all\n# divisors of N*N using \nfrom math import sqrt\n \n# Function to find Divisor of N\ndef DivisorOfN(v, marked, n):\n    # sqrt(N) approach\n    # to find divisors of N\n    for i in range(1,int(sqrt(n)) + 1, 1):\n        if (n % i == 0):\n            if (n // i == i):\n                v.append(i)\n                marked[i] = True\n            else:\n                v.append(i)\n                v.append(n // i)\n                marked[i] = True\n                marked[n // i] = True\n \n# Function to print all divisor of N*N\ndef PrintDivisors(n):\n    # Vector v to store divisors of n\n    v = []\n \n    # Map to avoid repeated divisors\n    marked = {i:False for i in range(1000)}\n \n    # Store all divisor of n\n    DivisorOfN(v, marked, n)\n \n    size = len(v)\n \n    # Iterating over vector v\n    # to generate divisors of N*N\n    for i in range(size):\n        for j in range(i,size,1):\n            check = v[i] * v[j]\n \n            # Checking if element is\n            # already present\n            if (marked[check] != True):\n                v.append(v[i] * v[j])\n \n                # marking element true\n                # after adding in vector\n                marked[v[i] * v[j]] = True\n \n    v.sort(reverse = False)\n \n    print('Divisors of',n * n,'are: ',end = '')\n    for i in range(len(v)):\n        print(v[i],end = ' ')\n     \n    print('\\n',end = '')\n \n# Driver Code\nif __name__ == '__main__':\n    PrintDivisors(4)\n    PrintDivisors(8)\n    PrintDivisors(10)\n \n# This code is contributed by Bhupendra_Singh\n"], "The Ultimate Beginner's Guide For DSA -  ": ["geeks = 'Hello World';\n"], "Given a linked list A, swap every two adjacent nodes and return its head. NOTE: Your algorithm should use only constant space. You may not modify the values in the list; only nodes themselves can be changed. Problem Constraints 1 <= |A| <= 106 Input Format The first and the only argument of input contains a pointer to the head of the given linked list. Output Format Return a pointer to the head of the modified linked list. Example Input Input 1: A = 1 -> 2 -> 3 -> 4 Input 2: A = 7 -> 2 -> 1 Example Output Output 1: 2 -> 1 -> 4 -> 3 Output 2: 2 -> 7 -> 1 Example Explanation Explanation 1: In the first example (1, 2) and (3, 4) are the adjacent nodes. Swapping them will result in 2 -> 1 -> 4 -> 3 Explanation 2: In the second example, 3rd element i.e. 1 does not have an adjacent node, so it won't be swapped.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    def swapPairs(self, A):\n        # Check if the linked list is empty or\n        # only has a single element.\n        if A==None:\n            return None\n        elif A.next==None:\n            return A\n        \n        # Keep changing the pointers of pairs\n        # while traversing the linked list.\n        head = A\n        head = head.next\n        prev = head\n        while A!=None:\n            if A.next==None:\n                break\n            temp = A.next\n            A.next = A.next.next\n            temp.next = A\n            if prev!=head:\n                prev.next = temp\n            prev = A\n            A = A.next\n        \n        return head\n\n\n\n", "Object Oriented Programming (OOPs) Concept in Java -  ": [], "TCS Coding Practice Question | Check Palindrome Number -  ": [], "Check if a number is Palindrome -  ": ["# A recursive Python3 program to check \n# whether a given number is palindrome or not \n  \n# A function that returns true  \n# only if num contains one digit \ndef oneDigit(num): \n      \n    # comparison operation is faster  \n    # than division operation. So  \n    # using following instead of  \n    # 'return num / 10 == 0;' \n    return ((num >= 0) and\n            (num < 10)) \n  \n# A recursive function to find  \n# out whether num is palindrome \n# or not. Initially, dupNum  \n# contains address of a copy of num. \ndef isPalUtil(num, dupNum): \n      \n    # Base case (needed for recursion \n    # termination): This statement \n    # mainly compares the first digit \n    # with the last digit \n    if oneDigit(num): \n        return (num == (dupNum[0]) % 10) \n  \n    # This is the key line in this  \n    # method. Note that all recursive \n    # calls have a separate copy of \n    # num, but they all share same \n    # copy of *dupNum. We divide num \n    # while moving up the recursion tree \n    if not isPalUtil(num //10, dupNum): \n        return False\n  \n    # The following statements are \n    # executed when we move up the \n    # recursion call tree \n    dupNum[0] = dupNum[0] //10\n  \n    # At this point, if num%10  \n    # contains i'th digit from  \n    # beginning, then (*dupNum)%10  \n    # contains i'th digit from end \n    return (num % 10 == (dupNum[0]) % 10) \n  \n# The main function that uses  \n# recursive function isPalUtil() \n# to find out whether num is  \n# palindrome or not \ndef isPal(num): \n    # If num is negative,  \n    # make it positive \n    if (num < 0): \n        num = (-num) \n  \n    # Create a separate copy of  \n    # num, so that modifications  \n    # made to address dupNum  \n    # don't change the input number. \n    dupNum = [num] # *dupNum = num \n  \n    return isPalUtil(num, dupNum) \n  \n# Driver Code \nn = 12321\nif isPal(n): \n    print('Yes') \nelse: \n    print('No') \n  \nn = 12\nif isPal(n) : \n    print('Yes') \nelse: \n    print('No') \n  \nn = 88\nif isPal(n) : \n    print('Yes') \nelse: \n    print('No') \n  \nn = 8999\nif isPal(n) : \n    print('Yes') \nelse: \n    print('No') \n  \n# This code is contributed by mits \n", "# Python3 implementation of the above approach \n  \n# function to check palindrome \ndef checkPalindrome(str): \n    \n    # Run loop from 0 to len/2 \n    for i in range(0, len(str)//2): \n        if str[i] != str[len(str)-i-1]: \n            return False\n            \n    # If the above loop doesn't  \n    #return then it is palindrome \n    return True\n  \n  \n# Driver code \nst = '112233445566778899000000998877665544332211'\nif(checkPalindrome(st) == True): \n    print('it is a palindrome') \nelse: \n    print('It is not a palindrome') \n", "# Python3 program to check if a number is Palindrome \n  \n# Function to check Palindrome \ndef checkPalindrome(n): \n  \n    reverse = 0\n    temp = n \n    while (temp != 0): \n        reverse = (reverse * 10) + (temp % 10) \n        temp = temp // 10\n      \n    return (reverse == n) # if it is true then it will return 1; \n                   # else if false it will return 0; \n  \n# driver code \nn = 7007\nif (checkPalindrome(n) == 1): \n    print('Yes') \n  \nelse: \n    print('No') \n  \n# This code is contributed by shinjanpatra\n"], "TCS Coding Practice Question | Reverse a Number -  ": [], "Write a program to reverse digits of a number -  ": ["# Python 3 program to reverse digits \n# of a number \nrev_num = 0\nbase_pos = 1\n  \n# Recursive function to reverse \n# digits of num \n  \n  \ndef reverseDigits(num): \n    global rev_num \n    global base_pos \n    if(num > 0): \n        reverseDigits((int)(num / 10)) \n        rev_num += (num % 10) * base_pos \n        base_pos *= 10\n    return rev_num \n  \n  \n# Driver Code \nnum = 4562\nprint('Reverse of no. is ', \n      reverseDigits(num)) \n  \n# This code is contributed by Rajput-Ji \n", "# util functions \ndef number_length(num): \n  \n  # Return length of given number \n    return len(str(num)) \n  \n# reverse a given number \n  \n  \ndef rev_number(number): \n    if (number % 10) == number: \n        return number \n  \n    last = number % 10\n    remaining = number // 10\n    l = number_length(remaining) \n  \n    return last*pow(10, l) + rev_number(remaining) \n  \n  \ndef main(): \n    number = 123456\n    print(rev_number(number)) \n  \n  \n# driver code \nif __name__ == '__main__': \n    main() \n  \n    # This code is contributed by talktoanmol \n", "# Python 3 program to reverse a number \n  \n  \ndef reversDigits(num): \n  \n    # converting number to string \n    string = str(num) \n  \n    # reversing the string \n    string = list(string) \n    string.reverse() \n    string = ''.join(string) \n  \n    # converting string to integer \n    num = int(string) \n  \n    # returning integer \n    return num \n  \n  \n# Driver code \nif __name__ == '__main__': \n  \n    num = 4562\n    print('Reverse of no. is ', reversDigits(num)) \n  \n    # This code is contributed by ukasp. \n", "# Python 3 program to reverse a number \n  \n  \ndef reversDigits(num): \n  \n    # converting number to string \n    string = str(num) \n  \n    # reversing the string \n    string = string[::-1] \n  \n    # converting string to integer \n    num = int(string) \n  \n    # returning integer \n    return num \n  \n  \n# Driver code \nif __name__ == '__main__': \n  \n    num = 4562\n    print('Reverse of no. is ', reversDigits(num)) \n  \n    # This code is contributed by Susobhan Akhuli \n", "# Python program to reverse a number. \nimport math \nn = 1234\nrev1 = 0\nrev2 = 0\n  \n# Find no of digits in number store it in size and divide size into two parts. \nsize = int(math.log10(n))+1\nmid = size//2\n  \n# Divide the given number in to two parts. \nfirst_half = n//10**mid \nsecond_half = n % 10**mid \n  \n# Iterate the loop upto half no of digits in number. \nfor i in range(mid): \n# Reverse the First half digits and second half digits concurrently \n    rem = first_half % 10\n    rev1 = 10*rev1+rem \n    rem = second_half % 10\n    rev2 = 10*rev2+rem \n    first_half = first_half//10\n    second_half = second_half//10\n      \n# Concate Last half with First Half \nprint('Original no:', n) \nif(size % 2 == 0): \n    print('Reversed no:', rev2*10**mid+rev1) \nelse: \n    print('Reversed no:', (rev2*10**mid+rev1)*10+first_half) \n      \n#This code contributed by SR DHANUSH\n"], "TCS Coding Practice Question | Reverse a String -  ": [], "Reverse a string in Java -  ": [], "TCS Coding Practice Question | Palindrome String -  ": [], "C Program to Check for Palindrome String -  ": [], "TCS Coding Practice Question | Sum of Digits of a number -  ": [], "Program for Sum of the digits of a given number -  ": ["# Python 3 program to\n# compute sum of digits in\n# number.\n \n# Function to get sum of digits\n \n \ndef getSum(n):\n \n    sum = 0\n    while (n != 0):\n \n        sum = sum + int(n % 10)\n        n = int(n/10)\n \n    return sum\n \n \n# Driver code\nif __name__ == '__main__':\n    n = 687\n \n    # Function call\n    print(getSum(n))\n", "# Function to get sum of digits\n \n \ndef getSum(n):\n \n    sum = 0\n \n    # Single line that calculates sum\n    while(n > 0):\n        sum += int(n % 10)\n        n = int(n/10)\n \n    return sum\n \n \n# Driver code\nif __name__ == '__main__':\n    n = 687\n \n    # Function call\n    print(getSum(n))\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# Python program to compute\n# sum of digits in number.\n \n \ndef sumDigits(no):\n    return 0 if no == 0 else int(no % 10) + sumDigits(int(no/10))\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Function call\n    print(sumDigits(687))\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# Python3 implementation of the above approach\ndef getSum(n):\n    # Initializing sum to 0\n    sum = 0\n    # Traversing through string\n    for i in n:\n        # Converting char to int\n        sum = sum + int(i)\n \n    return sum\n \n# Driver code\n \n \nif __name__ == '__main__':\n    n = '123456789123456789123422'\n \n    # Function call\n    print(getSum(n))\n", "# Python3 program for the above approach\n \n# Function to check sum\n# of digit using tail recursion\n \n \ndef sum_of_digit(n, val):\n \n    if (n < 10):\n        val = val + n\n        return val\n \n    return sum_of_digit(n // 10, (n % 10) + val)\n \n# Driver code\n \n \nif __name__ == '__main__':\n    num = 12345\n \n    # Function call\n    result = sum_of_digit(num, 0)\n \n    print('Sum of digits is', result)\n \n# This code is contributed by subhammahato348\n"], "TCS Coding Practice Question | Prime Numbers upto N -  ": [], "Print all prime numbers less than or equal to N -  ": ["# Python3 program to print  \n# all primes less than N \n  \n# Function to check whether  \n# a number is prime or not . \ndef isPrime(n): \n      \n    # Corner case \n    if n <= 1 : \n        return False\n  \n    # check from 2 to n-1 \n    for i in range(2, n): \n        if n % i == 0: \n            return False\n  \n    return True\n  \n# Function to print primes \ndef printPrime(n): \n    for i in range(2, n + 1): \n        if isPrime(i): \n            print(i, end = ' ') \n  \n# Driver code \nif __name__ == '__main__' : \n    n = 7\n    # function calling \n    printPrime(n) \n      \n# This code is contributed  \n# by Ankit Rai \n", "# function to check if the number is  \n# prime or not  \ndef isPrime(n) : \n    # Corner cases \n    if (n <= 1) : \n        return False\n    if (n <= 3) : \n        return True\n   \n    # This is checked so that we can skip  \n    # middle five numbers in below loop \n    if (n % 2 == 0 or n % 3 == 0) : \n        return False\n   \n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n   \n    return True \n  \n# print all prime numbers  \n# less than equal to N  \ndef printPrime(n): \n    for i in range(2, n + 1): \n        if isPrime(i): \n            print (i, end =' ')  \n   \nn = 7            \nprintPrime(n)  \n"], "Given a list, rotate the list to the right by k places, where k is non-negative. Problem Constraints 1 <= B <= 109 Input Format The first argument is ListNode A, pointing to the head of the list. The second argument is an integer B, representing the value of k. Output Format Return the rotated list. Example Input A = 1->2->3->4->5->NULL B = 2 Example Output 4->5->1->2->3->NULL Example Explanation Given list: A = 1->2->3->4->5->NULL Given B = 2; After rotating A once, A = 5->1->2->3->4->NULL After rotating A again, A = 4->5->1->2->3->NULL Hence after rotating the given list A, for B = 2, return 4->5->1->2->3->NULL": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @param B : integer\n    # @return the head node in the linked list\n    def rotateRight(self, A, B):\n        head = A\n        last = None\n        length = 0\n        \n        # get length of list as well as the last node of the current list\n        while A:\n            last = A\n            A = A.next\n            length += 1\n        \n        # because B can be greater than length of list...normalize B\n        B %= length\n        \n        if B == 0:\n            return head\n        \n        cur = head\n        \n        # get to the point where you will detach the list and rotate it\n        for i in range(length - B - 1):\n            cur = cur.next\n        \n        rotated_head = cur.next\n        cur.next = None\n        last.next = head\n        \n        return rotated_head\n\n\n\n", "Find the longest path in a matrix with given constraints -  ": ["# Python3 program to find the longest path in a matrix\n# with given constraints\n \nn = 3\n# Returns length of the longest path beginning with mat[i][j].\n# This function mainly uses lookup table dp[n][n]\n \n \ndef findLongestFromACell(i, j, mat, dp):\n    # Base case\n    if (i < 0 or i >= n or j < 0 or j >= n):\n        return 0\n \n    # If this subproblem is already solved\n    if (dp[i][j] != -1):\n        return dp[i][j]\n \n    # To store the path lengths in all the four directions\n    x, y, z, w = -1, -1, -1, -1\n \n    # Since all numbers are unique and in range from 1 to n * n,\n    # there is atmost one possible direction from any cell\n    if (j < n-1 and ((mat[i][j] + 1) == mat[i][j + 1])):\n        x = 1 + findLongestFromACell(i, j + 1, mat, dp)\n \n    if (j > 0 and (mat[i][j] + 1 == mat[i][j-1])):\n        y = 1 + findLongestFromACell(i, j-1, mat, dp)\n \n    if (i > 0 and (mat[i][j] + 1 == mat[i-1][j])):\n        z = 1 + findLongestFromACell(i-1, j, mat, dp)\n \n    if (i < n-1 and (mat[i][j] + 1 == mat[i + 1][j])):\n        w = 1 + findLongestFromACell(i + 1, j, mat, dp)\n \n    # If none of the adjacent fours is one greater we will take 1\n    # otherwise we will pick maximum from all the four directions\n    dp[i][j] = max(x, max(y, max(z, max(w, 1))))\n    return dp[i][j]\n \n \n# Returns length of the longest path beginning with any cell\ndef finLongestOverAll(mat):\n    result = 1  # Initialize result\n \n    # Create a lookup table and fill all entries in it as -1\n    dp = [[-1 for i in range(n)]for i in range(n)]\n \n    # Compute longest path beginning from all cells\n    for i in range(n):\n        for j in range(n):\n            if (dp[i][j] == -1):\n                findLongestFromACell(i, j, mat, dp)\n            # Update result if needed\n            result = max(result, dp[i][j])\n    return result\n \n \n# Driver program\nmat = [[1, 2, 9],\n       [5, 3, 8],\n       [4, 6, 7]]\nprint('Length of the longest path is ', finLongestOverAll(mat))\n \n# this code is improved by sahilshelangia\n"], "Find the largest interval that contains exactly one of the given N integers. -  ": ["# Python3 implementation of the approach\n \n# Function to return the maximum\n# size of the required interval\ndef maxSize(v, n):\n \n    # Insert the borders for array\n    v.append(0)\n    v.append(100001)\n    n += 2\n \n    # Sort the elements in ascending order\n    v = sorted(v)\n \n    # To store the maximum size\n    mx = 0\n    for i in range(1, n - 1):\n \n        # To store the range [L, R] such that\n        # only v[i] lies within the range\n        L = v[i - 1] + 1\n        R = v[i + 1] - 1\n \n        # Total integers in the range\n        cnt = R - L + 1\n        mx = max(mx, cnt)\n     \n \n    return mx\n \n \n# Driver code\nv = [ 200, 10, 5]\nn = len(v)\n \nprint(maxSize(v, n))\n \n# This code is contributed by mohit kumar 29\n"], "Given a singly linked list L: L0 \u2192 L1 \u2192 \u2026 \u2192 Ln-1 \u2192 Ln, reorder it to: L0 \u2192 Ln \u2192 L1 \u2192 Ln-1 \u2192 L2 \u2192 Ln-2 \u2192 \u2026 You must do this in-place without altering the nodes\u2019 values. For example, Given {1,2,3,4}, reorder it to {1,4,2,3}.": "# Definition for singly-linked list.\n# class ListNode:\n#\tdef __init__(self, x):\n#\t\tself.val = x\n#\t\tself.next = None\n\n\nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    def reorderList(self, head):\n        \"\"\" Modifies input linked list in-place. Returns head of a new list.\n        Time complexity: O(n). Space complexity: O(1), n is len(linked list).\n        \"\"\"\n        # modifiy the list only if it has more than one node\n        if not head or not head.next:\n            return head\n            \n        # find the middle of the list using slow and fast pointers algorithm\n        prev = None  # last node of the left half of the list\n        slow = fast = head\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        prev.next = None  # detach left half of the list from the right half\n        # reverse right half of the list\n        prev = None\n        curr = slow  # slow is the start of the right half\n        while curr:\n            link = curr.next\n            curr.next = prev\n            prev = curr\n            curr = link\n        # prev now points to the head of reversed right half\n        # combine left and right half, attach it to dummy node\n        dummy = ListNode(None)\n        tail = dummy  # current tail of a new list\n        while head:  # left list is always gonna be shorter\n            link = head.next  # save link to the next node in the left list\n            head.next = prev\n            tail.next = head  # attach connected 2 nodes to the tail\n            tail = prev  # update tail\n            head = link  # move to the next node in left list\n            prev = prev.next\n        # if the length of the original list was odd, right half is gonna have\n        # 1 node more than the left half\n        if prev:\n            tail.next = prev\n        return dummy.next  # return new head\n\n\n\n", "Program to find equation of a plane passing through 3 points -  ": [], "Program to find slope of a line -  ": [], "Digit DP | Introduction -  ": ["# Given two integers a and b. The task is to\n# print sum of all the digits appearing in the\n# integers between a and b\n \n# Memoization for the state results\ndp = [[[-1 for i in range(2)] for j in range(180)]for k in range(20)]\n \n# Stores the digits in x in a list digit\ndef getDigits(x, digit):\n    while x:\n        digit.append(x % 10)\n        x //= 10\n         \n# Return sum of digits from 1 to integer in digit list\ndef digitSum(index, sumof, tight, digit):\n   \n    # Base case\n    if index == -1:\n        return sumof\n       \n        # Checking if already calculated this state\n    if dp[index][sumof][tight] != -1 and tight != 1:\n        return dp[index][sumof][tight]\n    ret = 0\n     \n    # Calculating range value\n    k = digit[index] if tight else 9\n    for i in range(0, k+1):\n       \n        # Calculating newTight value for nextstate\n        newTight = tight if digit[index] == i else 0\n         \n        # Fetching answer from next state\n        ret += digitSum(index-1, sumof+i, newTight, digit)\n    if not tight:\n        dp[index][sumof][tight] = ret\n    return ret\n   \n# Returns sum of digits in numbers from a to b\ndef rangeDigitSum(a, b):\n    digitA = []\n     \n    # Storing digits of a-1 in digitA\n    getDigits(a-1, digitA)\n     \n    # Finding sum of digits from 1 to 'a-1' which is passed as digitA\n    ans1 = digitSum(len(digitA)-1, 0, 1, digitA)\n    digitB = []\n     \n    # Storing digits of b in digitB\n    getDigits(b, digitB)\n     \n    # Finding sum of digits from 1 to 'b' which is passed as digitB\n    ans2 = digitSum(len(digitB)-1, 0, 1, digitB)\n    return ans2-ans1\n \n \na, b = 123, 1024\nprint('digit sum for given range: ', rangeDigitSum(a, b))\n \n# This code is contributed by rupasriachanta421\n"], "Bitmasking and Dynamic Programming | Travelling Salesman Problem -  ": ["import sys\nimport math\nfrom collections import deque\n \nINF = 99999999\nMAXR = 12\nMAXC = 12\nMAXMASK = 2048\nMAXHOUSE = 12\n \n# stores distance taking source\n# as every dirty tile\ndist = [[[INF for _ in range(MAXHOUSE)]\n         for _ in range(MAXC)] for _ in range(MAXR)]\n \n# memoization for dp states\ndp = [[-1 for _ in range(MAXMASK)] for _ in range(MAXHOUSE)]\n \n# stores coordinates for\n# dirty tiles\ndirty = []\n \n# Directions\nX = [-1, 0, 0, 1]\nY = [0, 1, -1, 0]\n \narr = [['' for _ in range(21)] for _ in range(21)]\n \n# len : number of dirty tiles + 1\n# limit : 2 ^ len -1\n# r, c : number of rows and columns\nlen, limit, r, c = 0, 0, 0, 0\n \n# Returns true if current position\n# is safe to visit\n# else returns false\n# Time Complexity : O(1)\n \n \ndef safe(x, y):\n    if x >= r or y >= c or x < 0 or y < 0:\n        return False\n    if arr[x][y] == '#':\n        return False\n    return True\n \n# runs BFS traversal at tile idx\n# calculates distance to every cell\n# in the grid\n# Time Complexity : O(r*c)\n \n \ndef getDist(idx):\n    # visited array to track visited cells\n    vis = [[False for _ in range(21)] for _ in range(21)]\n \n    # getting current position\n    cx, cy = dirty[idx]\n \n    # initializing queue for bfs\n    pq = deque()\n    pq.append((cx, cy))\n \n    # initializing the dist to max\n    # because some cells cannot be visited\n    # by taking source cell as idx\n    for i in range(r+1):\n        for j in range(c+1):\n            dist[i][j][idx] = INF\n \n    # base conditions\n    vis[cx][cy] = True\n    dist[cx][cy][idx] = 0\n \n    while pq:\n        x = pq.popleft()\n        for i in range(4):\n            cx = x[0] + X[i]\n            cy = x[1] + Y[i]\n            if safe(cx, cy):\n                if vis[cx][cy]:\n                    continue\n                vis[cx][cy] = True\n                dist[cx][cy][idx] = dist[x[0]][x[1]][idx] + 1\n                pq.append((cx, cy))\n \n# Dynamic Programming state transition recursion\n# with memoization. Time Complexity: O(n*n*2 ^ n)\n \n \ndef solve(idx, mask):\n    # goal state\n    if mask == limit:\n        return dist[0][0][idx]\n \n    # if already visited state\n    if dp[idx][mask] != -1:\n        return dp[idx][mask]\n \n    ret = float('inf')\n \n    # state transition relation\n    for i in range(len):\n        if (mask & (1 << i)) == 0:\n            new_mask = mask | (1 << i)\n            ret = min(ret, solve(i, new_mask) +\n                      dist[dirty[i][0]][dirty[i][1]][idx])\n \n    # adding memoization and returning\n    dp[idx][mask] = ret\n    return ret\n \n \ndef init():\n    global dirty, dirty_count, arr, r, c, LIMIT_MASK\n    dirty = []\n    dirty_count = 0  # initialize the variable before using\n    for i in range(r):\n        for j in range(c):\n            if (arr[i][j] == '*'):\n                dirty.append((i, j))\n                dirty_count += 1\n    dirty_length = dirty_count\n    LIMIT_MASK = (1 << dirty_count) - 1\n \n \nif __name__ == '__main__':\n    # Test case #1:\n    #     .....*.\n    #     ...#...\n    #     .*.#.*.\n    #     .......\n \n    A = [['.', '.', '.', '.', '.', '*', '.'],\n         ['.', '.', '.', '#', '.', '.', '.'],\n         ['.', '*', '.', '#', '.', '*', '.'],\n         ['.', '.', '.', '.', '.', '.', '.']\n         ]\n \n    r = 4\n    c = 7\n \n    print('The given grid : ')\n \n    for i in range(r):\n        for j in range(c):\n            print(A[i][j], end=' ')\n            arr[i][j] = A[i][j]\n        print()\n \n    # - initialization\n    # - precalculations\n    init()\n \n    ans = solve(0, 1)\n \n    print('Minimum distance for the given grid : ', end='')\n    print(ans)\n \n    # Test Case #2\n    #     ...#...\n    #     ...#.*.\n    #     ...#...\n    #     .*.#.*.\n    #     ...#...\n \n    Arr = [['.', '.', '.', '#', '.', '.', '.'],\n           ['.', '.', '.', '#', '.', '*', '.'],\n           ['.', '.', '.', '#', '.', '.', '.'],\n           ['.', '*', '.', '#', '.', '*', '.'],\n           ['.', '.', '.', '#', '.', '.', '.']\n           ]\n \n    r = 5\n    c = 7\n \n    print('The given grid : ')\n \n    for i in range(r):\n        for j in range(c):\n            print(Arr[i][j], end=' ')\n            arr[i][j] = Arr[i][j]\n        print()\n \n    # - initialization\n    # - precalculations\n    init()\n    ans = solve(0, 1)\n    print('Minimum distance for the given grid : ', end='')\n    if ans >= INF:\n        print('not possible')\n    else:\n        print(ans)\n"], "Bitmasking and Dynamic Programming | Set 1 (Count ways to assign unique cap to every person) -  ": [], "Steps for how to solve a Dynamic Programming Problem -  ": ["# Returns the number of arrangements to \n# form 'n' \ndef solve(n):\n   \n  # Base case\n  if n < 0:\n    return 0\n  if n == 0:\n    return 1\n   \n  return (solve(n - 1) +\n          solve(n - 3) +\n          solve(n - 5))\n \n# This code is contributed by GauriShankarBadola\n", "# This function returns the number of\n# arrangements to form 'n'\n \n# lookup dictionary/hashmap is initialized\ndef solve(n, lookup = {}):\n     \n    # Base cases\n    # negative number can't be \n    # produced, return 0\n    if n < 0:\n        return 0\n \n    # 0 can be produced by not \n    # taking any number whereas \n    # 1 can be produced by just taking 1\n    if n == 0:\n        return 1\n \n    # Checking if number of way for\n    # producing n is already calculated \n    # or not if calculated, return that,\n    # otherwise calculate and then return\n    if n not in lookup:\n        lookup[n] = (solve(n - 1) +\n                     solve(n - 3) +\n                     solve(n - 5))\n                      \n    return lookup[n]\n \n# This code is contributed by GauriShankarBadola\n"], "Overlapping Subproblems Property in Dynamic Programming | DP-1 -  ": [], "Optimal Substructure Property in Dynamic Programming | DP-2 -  ": ["# The number of vertices in the graph\nN = 100010\n \n# The adjacency matrix representation of the graph\nadj = [[0 for j in range(N)] for i in range(N)]\n \n# The array for storing the shortest distances between the vertices\ndist = [[0 for j in range(N)] for i in range(N)]\n \ndef floyd():\n    global N, adj, dist\n    # Initialize the distances with the weights of the edges\n    for i in range(N):\n        for j in range(N):\n            dist[i][j] = adj[i][j]\n \n    # Solve the subproblems using the optimal substructure property\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                # Relax the edge (i, j) using the vertex k as the intermediate vertex\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n \nif __name__ == '__main__':\n    # Read the input\n    n = int(input())\n    for i in range(n):\n        line = input().strip().split()\n        for j in range(n):\n            adj[i][j] = int(line[j])\n            if adj[i][j] == 0:\n                # There is no edge between the vertices\n                adj[i][j] = sys.maxsize\n \n    # Solve the shortest path problem\n    floyd()\n \n    # Print the shortest distances between the vertices\n    for i in range(n):\n        for j in range(n):\n            print(i, j, dist[i][j])\n"], "Tabulation vs Memoization -  ": ["def fibonacci(n, cache={}):\n    if n in cache:\n        return cache[n]\n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 1\n    else:\n        result = fibonacci(n-1) + fibonacci(n-2)\n    cache[n] = result\n    return result\n", "def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        table = [0] * (n + 1)\n        table[0] = 0\n        table[1] = 1\n        for i in range(2, n+1):\n            table[i] = table[i-1] + table[i-2]\n        return table[n]\n"], "Algorithm to Solve Sudoku | Sudoku Solver -  ": ["# N is the size of the 2D matrix   N*N\nN = 9\n \n# A utility function to print grid\ndef printing(arr):\n    for i in range(N):\n        for j in range(N):\n            print(arr[i][j], end = ' ')\n        print()\n \n# Checks whether it will be\n# legal to assign num to the\n# given row, col\ndef isSafe(grid, row, col, num):\n   \n    # Check if we find the same num\n    # in the similar row , we\n    # return false\n    for x in range(9):\n        if grid[row][x] == num:\n            return False\n \n    # Check if we find the same num in\n    # the similar column , we\n    # return false\n    for x in range(9):\n        if grid[x][col] == num:\n            return False\n \n    # Check if we find the same num in\n    # the particular 3*3 matrix,\n    # we return false\n    startRow = row - row % 3\n    startCol = col - col % 3\n    for i in range(3):\n        for j in range(3):\n            if grid[i + startRow][j + startCol] == num:\n                return False\n    return True\n \n# Takes a partially filled-in grid and attempts\n# to assign values to all unassigned locations in\n# such a way to meet the requirements for\n# Sudoku solution (non-duplication across rows,\n# columns, and boxes) */\ndef solveSudoku(grid, row, col):\n   \n    # Check if we have reached the 8th\n    # row and 9th column (0\n    # indexed matrix) , we are\n    # returning true to avoid\n    # further backtracking\n    if (row == N - 1 and col == N):\n        return True\n       \n    # Check if column value  becomes 9 ,\n    # we move to next row and\n    # column start from 0\n    if col == N:\n        row += 1\n        col = 0\n \n    # Check if the current position of\n    # the grid already contains\n    # value >0, we iterate for next column\n    if grid[row][col] > 0:\n        return solveSudoku(grid, row, col + 1)\n    for num in range(1, N + 1, 1):\n       \n        # Check if it is safe to place\n        # the num (1-9)  in the\n        # given row ,col  ->we\n        # move to next column\n        if isSafe(grid, row, col, num):\n           \n            # Assigning the num in\n            # the current (row,col)\n            # position of the grid\n            # and assuming our assigned\n            # num in the position\n            # is correct\n            grid[row][col] = num\n \n            # Checking for next possibility with next\n            # column\n            if solveSudoku(grid, row, col + 1):\n                return True\n \n        # Removing the assigned num ,\n        # since our assumption\n        # was wrong , and we go for\n        # next assumption with\n        # diff num value\n        grid[row][col] = 0\n    return False\n \n# Driver Code\n \n# 0 means unassigned cells\ngrid = [[3, 0, 6, 5, 0, 8, 4, 0, 0],\n        [5, 2, 0, 0, 0, 0, 0, 0, 0],\n        [0, 8, 7, 0, 0, 0, 0, 3, 1],\n        [0, 0, 3, 0, 1, 0, 0, 8, 0],\n        [9, 0, 0, 8, 6, 3, 0, 0, 5],\n        [0, 5, 0, 0, 9, 0, 6, 0, 0],\n        [1, 3, 0, 0, 0, 0, 2, 5, 0],\n        [0, 0, 0, 0, 0, 0, 0, 7, 4],\n        [0, 0, 5, 2, 0, 6, 3, 0, 0]]\n \nif (solveSudoku(grid, 0, 0)):\n    printing(grid)\nelse:\n    print('no solution  exists ')\n \n    # This code is contributed by sudhanshgupta2019a\n", "# A Backtracking program \n# in Python to solve Sudoku problem\n \n# A Utility Function to print the Grid\ndef print_grid(arr):\n    for i in range(9):\n        for j in range(9):\n            print (arr[i][j], end = ' '),\n        print ()\n \n         \n# Function to Find the entry in \n# the Grid that is still  not used\n# Searches the grid to find an \n# entry that is still unassigned. If\n# found, the reference parameters \n# row, col will be set the location\n# that is unassigned, and true is \n# returned. If no unassigned entries\n# remains, false is returned.\n# 'l' is a list  variable that has \n# been passed from the solve_sudoku function\n# to keep track of incrementation \n# of Rows and Columns\ndef find_empty_location(arr, l):\n    for row in range(9):\n        for col in range(9):\n            if(arr[row][col]== 0):\n                l[0]= row\n                l[1]= col\n                return True\n    return False\n \n# Returns a boolean which indicates \n# whether any assigned entry\n# in the specified row matches \n# the given number.\ndef used_in_row(arr, row, num):\n    for i in range(9):\n        if(arr[row][i] == num):\n            return True\n    return False\n \n# Returns a boolean which indicates \n# whether any assigned entry\n# in the specified column matches \n# the given number.\ndef used_in_col(arr, col, num):\n    for i in range(9):\n        if(arr[i][col] == num):\n            return True\n    return False\n \n# Returns a boolean which indicates \n# whether any assigned entry\n# within the specified 3x3 box \n# matches the given number\ndef used_in_box(arr, row, col, num):\n    for i in range(3):\n        for j in range(3):\n            if(arr[i + row][j + col] == num):\n                return True\n    return False\n \n# Checks whether it will be legal \n# to assign num to the given row, col\n# Returns a boolean which indicates \n# whether it will be legal to assign\n# num to the given row, col location.\ndef check_location_is_safe(arr, row, col, num):\n     \n    # Check if 'num' is not already \n    # placed in current row,\n    # current column and current 3x3 box\n    return (not used_in_row(arr, row, num) and\n           (not used_in_col(arr, col, num) and\n           (not used_in_box(arr, row - row % 3, \n                           col - col % 3, num))))\n \n# Takes a partially filled-in grid \n# and attempts to assign values to\n# all unassigned locations in such a \n# way to meet the requirements\n# for Sudoku solution (non-duplication \n# across rows, columns, and boxes)\ndef solve_sudoku(arr):\n     \n    # 'l' is a list variable that keeps the \n    # record of row and col in \n    # find_empty_location Function    \n    l =[0, 0]\n     \n    # If there is no unassigned \n    # location, we are done    \n    if(not find_empty_location(arr, l)):\n        return True\n     \n    # Assigning list values to row and col \n    # that we got from the above Function \n    row = l[0]\n    col = l[1]\n     \n    # consider digits 1 to 9\n    for num in range(1, 10):\n         \n        # if looks promising\n        if(check_location_is_safe(arr, \n                          row, col, num)):\n             \n            # make tentative assignment\n            arr[row][col]= num\n \n            # return, if success, \n            # ya ! \n            if(solve_sudoku(arr)):\n                return True\n \n            # failure, unmake & try again\n            arr[row][col] = 0\n             \n    # this triggers backtracking        \n    return False\n \n# Driver main function to test above functions\nif __name__=='__main__':\n     \n    # creating a 2D array for the grid\n    grid =[[0 for x in range(9)]for y in range(9)]\n     \n    # assigning values to the grid\n    grid =[[3, 0, 6, 5, 0, 8, 4, 0, 0],\n          [5, 2, 0, 0, 0, 0, 0, 0, 0],\n          [0, 8, 7, 0, 0, 0, 0, 3, 1],\n          [0, 0, 3, 0, 1, 0, 0, 8, 0],\n          [9, 0, 0, 8, 6, 3, 0, 0, 5],\n          [0, 5, 0, 0, 9, 0, 6, 0, 0],\n          [1, 3, 0, 0, 0, 0, 2, 5, 0],\n          [0, 0, 0, 0, 0, 0, 0, 7, 4],\n          [0, 0, 5, 2, 0, 6, 3, 0, 0]]\n     \n    # if success print the grid\n    if(solve_sudoku(grid)):\n        print_grid(grid)\n    else:\n        print ('No solution exists')\n \n# The above code has been contributed by Harshit Sidhwa.\n", "# N is the size of the 2D matrix N*N\nN = 9\n \n# A utility function to print grid\n \n \ndef printing(arr):\n    for i in range(N):\n        for j in range(N):\n            print(arr[i][j], end=' ')\n        print()\n \n# Checks whether it will be\n# legal to assign num to the\n# given row, col\n \n \ndef isSafe(grid, row, col, num):\n \n    # Check if we find the same num\n    # in the similar row , we\n    # return false\n    for x in range(9):\n        if grid[row][x] == num:\n            return False\n \n    # Check if we find the same num in\n    # the similar column , we\n    # return false\n    for x in range(9):\n        if grid[x][col] == num:\n            return False\n \n    # Check if we find the same num in\n    # the particular 3*3 matrix,\n    # we return false\n    startRow = row - row % 3\n    startCol = col - col % 3\n    for i in range(3):\n        for j in range(3):\n            if grid[i + startRow][j + startCol] == num:\n                return False\n    return True\n \n# Takes a partially filled-in grid and attempts\n# to assign values to all unassigned locations in\n# such a way to meet the requirements for\n# Sudoku solution (non-duplication across rows,\n# columns, and boxes) */\n \n \ndef solveSudoku(grid, row, col):\n \n    # Check if we have reached the 8th\n    # row and 9th column (0\n    # indexed matrix) , we are\n    # returning true to avoid\n    # further backtracking\n    if (row == N - 1 and col == N):\n        return True\n \n    # Check if column value becomes 9 ,\n    # we move to next row and\n    # column start from 0\n    if col == N:\n        row += 1\n        col = 0\n \n    # Check if the current position of\n    # the grid already contains\n    # value >0, we iterate for next column\n    if grid[row][col] > 0:\n        return solveSudoku(grid, row, col + 1)\n    for num in range(1, N + 1, 1):\n \n        # Check if it is safe to place\n        # the num (1-9) in the\n        # given row ,col ->we\n        # move to next column\n        if isSafe(grid, row, col, num):\n \n            # Assigning the num in\n            # the current (row,col)\n            # position of the grid\n            # and assuming our assigned\n            # num in the position\n            # is correct\n            grid[row][col] = num\n \n            # Checking for next possibility with next\n            # column\n            if solveSudoku(grid, row, col + 1):\n                return True\n \n        # Removing the assigned num ,\n        # since our assumption\n        # was wrong , and we go for\n        # next assumption with\n        # diff num value\n        grid[row][col] = 0\n    return False\n \n# Driver Code\n \n \n# 0 means unassigned cells\ngrid = [[3, 0, 6, 5, 0, 8, 4, 0, 0],\n        [5, 2, 0, 0, 0, 0, 0, 0, 0],\n        [0, 8, 7, 0, 0, 0, 0, 3, 1],\n        [0, 0, 3, 0, 1, 0, 0, 8, 0],\n        [9, 0, 0, 8, 6, 3, 0, 0, 5],\n        [0, 5, 0, 0, 9, 0, 6, 0, 0],\n        [1, 3, 0, 0, 0, 0, 2, 5, 0],\n        [0, 0, 0, 0, 0, 0, 0, 7, 4],\n        [0, 0, 5, 2, 0, 6, 3, 0, 0]]\n \nif (solveSudoku(grid, 0, 0)):\n    printing(grid)\nelse:\n    print('no solution exists ')\n \n# This code is contributed by sanjoy_62.\n", "# This program works by identifying the remaining elements and backtrack only on those.\n# The elements are inserted in the increasing order of the elements left to be inserted. And hence runs much faster.\n# Comparing with other back tracking algorithms, it runs 5X faster.\n \n# Input matrix\narr = [\n    [3, 0, 6, 5, 0, 8, 4, 0, 0],\n    [5, 2, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 7, 0, 0, 0, 0, 3, 1],\n    [0, 0, 3, 0, 1, 0, 0, 8, 0],\n    [9, 0, 0, 8, 6, 3, 0, 0, 5],\n    [0, 5, 0, 0, 9, 0, 6, 0, 0],\n    [1, 3, 0, 0, 0, 0, 2, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 4],\n    [0, 0, 5, 2, 0, 6, 3, 0, 0]\n]\n \n# Position of the input elements in the arr\n# pos = {\n#     element: [[position 1], [position 2]]\n# }\npos = {}\n \n# Count of the remaining number of the elements\n# rem = {\n#     element: pending count\n# }\nrem = {}\n \n# Graph defining tentative positions of the elements to be filled\n# graph = {\n#     key: {\n#         row1: [columns],\n#         row2: [columns]\n#     }\n# }\ngraph = {}\n \n \n# Print the matrix array\ndef printMatrix():\n    for i in range(0, 9):\n        for j in range(0, 9):\n            print(str(arr[i][j]), end=' ')\n        print()\n \n \n# Method to check if the inserted element is safe\ndef is_safe(x, y):\n    key = arr[x][y]\n    for i in range(0, 9):\n        if i != y and arr[x][i] == key:\n            return False\n        if i != x and arr[i][y] == key:\n            return False\n \n    r_start = int(x / 3) * 3\n    r_end = r_start + 3\n \n    c_start = int(y / 3) * 3\n    c_end = c_start + 3\n \n    for i in range(r_start, r_end):\n        for j in range(c_start, c_end):\n            if i != x and j != y and arr[i][j] == key:\n                return False\n    return True\n \n \n# method to fill the matrix\n# input keys: list of elements to be filled in the matrix\n#        k   : index number of the element to be picked up from keys\n#        rows: list of row index where element is to be inserted\n#        r   : index number of the row to be inserted\n#\ndef fill_matrix(k, keys, r, rows):\n    for c in graph[keys[k]][rows[r]]:\n        if arr[rows[r]] > 0:\n            continue\n        arr[rows[r]] = keys[k]\n        if is_safe(rows[r], c):\n            if r < len(rows) - 1:\n                if fill_matrix(k, keys, r + 1, rows):\n                    return True\n                else:\n                    arr[rows[r]] = 0\n                    continue\n            else:\n                if k < len(keys) - 1:\n                    if fill_matrix(k + 1, keys, 0, list(graph[keys[k + 1]].keys())):\n                        return True\n                    else:\n                        arr[rows[r]] = 0\n                        continue\n                return True\n        arr[rows[r]] = 0\n    return False\n \n \n# Fill the pos and rem dictionary. It will be used to build graph\ndef build_pos_and_rem():\n    for i in range(0, 9):\n        for j in range(0, 9):\n            if arr[i][j] > 0:\n                if arr[i][j] not in pos:\n                    pos[arr[i][j]] = []\n                pos[arr[i][j]].append([i, j])\n                if arr[i][j] not in rem:\n                    rem[arr[i][j]] = 9\n                rem[arr[i][j]] -= 1\n \n    # Fill the elements not present in input matrix. Example: 1 is missing in input matrix\n    for i in range(1, 10):\n        if i not in pos:\n            pos[i] = []\n        if i not in rem:\n            rem[i] = 9\n \n# Build the graph\n \n \ndef build_graph():\n    for k, v in pos.items():\n        if k not in graph:\n            graph[k] = {}\n \n        row = list(range(0, 9))\n        col = list(range(0, 9))\n \n        for cord in v:\n            row.remove(cord[0])\n            col.remove(cord[1])\n \n        if len(row) == 0 or len(col) == 0:\n            continue\n \n        for r in row:\n            for c in col:\n                if arr[r] == 0:\n                    if r not in graph[k]:\n                        graph[k][r] = []\n                    graph[k][r].append(c)\n \n \nbuild_pos_and_rem()\n \n# Sort the rem map in order to start with smaller number of elements to be filled first. Optimization for pruning\nrem = {k: v for k, v in sorted(rem.items(), key=lambda item: item[1])}\n \nbuild_graph()\n \nkey_s = list(rem.keys())\n# Util called to fill the matrix\nfill_matrix(0, key_s, 0, list(graph[key_s[0]].keys()))\n \nprintMatrix()\n \n# This code is contributed by Arun Kumar\n"], "M-Coloring Problem -  ": ["# Python3 program for solution of M Coloring\n# problem using backtracking\n \n \nclass Graph():\n \n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)]\n                      for row in range(vertices)]\n \n    # A utility function to check\n    # if the current color assignment\n    # is safe for vertex v\n    def isSafe(self, v, colour, c):\n        for i in range(self.V):\n            if self.graph[v][i] == 1 and colour[i] == c:\n                return False\n        return True\n \n    # A recursive utility function to solve m\n    # coloring  problem\n    def graphColourUtil(self, m, colour, v):\n        if v == self.V:\n            return True\n \n        for c in range(1, m + 1):\n            if self.isSafe(v, colour, c) == True:\n                colour[v] = c\n                if self.graphColourUtil(m, colour, v + 1) == True:\n                    return True\n                colour[v] = 0\n \n    def graphColouring(self, m):\n        colour = [0] * self.V\n        if self.graphColourUtil(m, colour, 0) == None:\n            return False\n \n        # Print the solution\n        print('Solution exist and Following are the assigned colours:')\n        for c in colour:\n            print(c, end=' ')\n        return True\n \n \n# Driver Code\nif __name__ == '__main__':\n    g = Graph(4)\n    g.graph = [[0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0]]\n    m = 3\n \n    # Function call\n    g.graphColouring(m)\n \n# This code is contributed by Divyanshu Mehta\n"], "Subset Sum Problem using Backtracking -  ": [], "N Queen Problem -  ": ["# Python3 program to solve N Queen\n# Problem using backtracking\n \nglobal N\nN = 4\n \n \ndef printSolution(board):\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 1:\n                print('Q',end=' ')\n            else:\n                print('.',end=' ')\n        print()\n \n \n# A utility function to check if a queen can\n# be placed on board[row][col]. Note that this\n# function is called when 'col' queens are\n# already placed in columns from 0 to col -1.\n# So we need to check only left side for\n# attacking queens\ndef isSafe(board, row, col):\n \n    # Check this row on left side\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n \n    # Check upper diagonal on left side\n    for i, j in zip(range(row, -1, -1),\n                    range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n \n    # Check lower diagonal on left side\n    for i, j in zip(range(row, N, 1),\n                    range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n \n    return True\n \n \ndef solveNQUtil(board, col):\n \n    # Base case: If all queens are placed\n    # then return true\n    if col >= N:\n        return True\n \n    # Consider this column and try placing\n    # this queen in all rows one by one\n    for i in range(N):\n \n        if isSafe(board, i, col):\n \n            # Place this queen in board[i][col]\n            board[i][col] = 1\n \n            # Recur to place rest of the queens\n            if solveNQUtil(board, col + 1) == True:\n                return True\n \n            # If placing queen in board[i][col\n            # doesn't lead to a solution, then\n            # queen from board[i][col]\n            board[i][col] = 0\n \n    # If the queen can not be placed in any row in\n    # this column col then return false\n    return False\n \n \n# This function solves the N Queen problem using\n# Backtracking. It mainly uses solveNQUtil() to\n# solve the problem. It returns false if queens\n# cannot be placed, otherwise return true and\n# placement of queens in the form of 1s.\n# note that there may be more than one\n# solutions, this function prints one of the\n# feasible solutions.\ndef solveNQ():\n    board = [[0, 0, 0, 0],\n             [0, 0, 0, 0],\n             [0, 0, 0, 0],\n             [0, 0, 0, 0]]\n \n    if solveNQUtil(board, 0) == False:\n        print('Solution does not exist')\n        return False\n \n    printSolution(board)\n    return True\n \n \n# Driver Code\nif __name__ == '__main__':\n    solveNQ()\n \n# This code is contributed by Divyanshu Mehta\n", "# Python3 program to solve N Queen Problem using\n# backtracking\nN = 4\n \n# ld is an array where its indices indicate row-col+N-1\n# (N-1) is for shifting the difference to store negative\n# indices\nld = [0] * 30\n \n# rd is an array where its indices indicate row+col\n# and used to check whether a queen can be placed on\n# right diagonal or not\nrd = [0] * 30\n \n# Column array where its indices indicates column and\n# used to check whether a queen can be placed in that\n# row or not\ncl = [0] * 30\n \n \n# A utility function to print solution\ndef printSolution(board):\n    for i in range(N):\n        for j in range(N):\n            print(board[i][j], end=' ')\n        print()\n \n \n# A recursive utility function to solve N\n# Queen problem\ndef solveNQUtil(board, col):\n \n    # Base case: If all queens are placed\n    # then return True\n    if (col >= N):\n        return True\n \n    # Consider this column and try placing\n    # this queen in all rows one by one\n    for i in range(N):\n \n        # Check if the queen can be placed on board[i][col]\n \n        # To check if a queen can be placed on \n        # board[row][col] We just need to check \n        # ld[row-col+n-1] and rd[row+coln]\n        # where ld and rd are for left and \n        # right diagonal respectively\n        if ((ld[i - col + N - 1] != 1 and\n             rd[i + col] != 1) and cl[i] != 1):\n \n            # Place this queen in board[i][col]\n            board[i][col] = 1\n            ld[i - col + N - 1] = rd[i + col] = cl[i] = 1\n \n            # Recur to place rest of the queens\n            if (solveNQUtil(board, col + 1)):\n                return True\n \n            # If placing queen in board[i][col]\n            # doesn't lead to a solution,\n            # then remove queen from board[i][col]\n            board[i][col] = 0  # BACKTRACK\n            ld[i - col + N - 1] = rd[i + col] = cl[i] = 0\n \n            # If the queen cannot be placed in\n            # any row in this column col then return False\n    return False\n \n \n# This function solves the N Queen problem using\n# Backtracking. It mainly uses solveNQUtil() to\n# solve the problem. It returns False if queens\n# cannot be placed, otherwise, return True and\n# prints placement of queens in the form of 1s.\n# Please note that there may be more than one\n# solutions, this function prints one of the\n# feasible solutions.\ndef solveNQ():\n    board = [[0, 0, 0, 0],\n             [0, 0, 0, 0],\n             [0, 0, 0, 0],\n             [0, 0, 0, 0]]\n    if (solveNQUtil(board, 0) == False):\n        printf('Solution does not exist')\n        return False\n    printSolution(board)\n    return True\n \n \n# Driver Code\nif __name__ == '__main__':\n    solveNQ()\n \n# This code is contributed by SHUBHAMSINGH10\n"], "Rat in a Maze -  ": ["# Python3 program to solve Rat in a Maze\n# problem using backtracking\n \n# Maze size\nn = 4\n \n# A utility function to check if x, y is valid\n# index for N * N Maze\n \n \ndef isValid(n, maze, x, y, res):\n    if x >= 0 and y >= 0 and x < n and y < n and maze[x][y] == 1 and res[x][y] == 0:\n        return True\n    return False\n \n# A recursive utility function to solve Maze problem\n \n \ndef RatMaze(n, maze, move_x, move_y, x, y, res):\n    # if (x, y is goal) return True\n    if x == n-1 and y == n-1:\n        return True\n    for i in range(4):\n        # Generate new value of x\n        x_new = x + move_x[i]\n \n        # Generate new value of y\n        y_new = y + move_y[i]\n \n        # Check if maze[x][y] is valid\n        if isValid(n, maze, x_new, y_new, res):\n \n            # mark x, y as part of solution path\n            res[x_new][y_new] = 1\n            if RatMaze(n, maze, move_x, move_y, x_new, y_new, res):\n                return True\n            res[x_new][y_new] = 0\n    return False\n \n \ndef solveMaze(maze):\n    # Creating a 4 * 4 2-D list\n    res = [[0 for i in range(n)] for i in range(n)]\n    res[0][0] = 1\n \n    # x matrix for each direction\n    move_x = [-1, 1, 0, 0]\n \n    # y matrix for each direction\n    move_y = [0, 0, -1, 1]\n \n    if RatMaze(n, maze, move_x, move_y, 0, 0, res):\n        for i in range(n):\n            for j in range(n):\n                print(res[i][j], end=' ')\n            print()\n    else:\n        print('Solution does  not exist')\n \n \n# Driver program to test above function\nif __name__ == '__main__':\n    # Initialising the maze\n    maze = [[1, 0, 0, 0],\n             [1, 1, 0, 1],\n             [0, 1, 0, 0],\n             [1, 1, 1, 1]]\n \n    solveMaze(maze)\n \n# This code is contributed by Anvesh Govind Saxena\n", "class Solution:\n    def solve(self, i, j, arr, n, ans, move, direction, dir1, djr, visited):\n      #if we reach the last cell of the matrix. just add the current move to the list of answers (ans) and return from the function, effectively stopping any further exploration.\n        if i == n - 1 and j == n - 1:\n            ans.append(move)\n            return\n         \n        for ind in range(4):\n          #calculate the next row index based on the current i (row) and the di array, which holds values for direction changes.\n            nexti = i + dir1[ind]\n            #calculate the next column index based on the current j (column) and the dj array, which holds values for direction changes.\n            nextj = j + djr[ind]\n            # to check whether is is valid to move to the next cell\n      # make sure to check if the next cell has been visited before.\n             \n            if 0 <= nexti < n and 0 <= nextj < n and visited[nexti][nextj] == 0 and arr[nexti][nextj] == 1:\n              #Also Mark the current cell as visited to prevent revisiting it during the same path exploration. \n              visited[i][j] = 1\n              #Recursively call the solve function with the updated position , the updated path move(adding the current direction), and the current direction), and the updated state information.\n              self.solve(nexti, nextj, arr, n, ans, move + direction[ind], direction, dir1, djr, visited)\n               # Reset the current cell's visited status to 0 to allow backtracking(an essential step)\n              visited[i][j] = 0\n \n    def findPath(self, m, n):\n       #we intialise with array to get all the required values.\n        ans = []\n         #initialise a string direction which represents all the directions.\n        direction = 'DLRU'\n        dir1 = [1, 0, 0, -1]\n        djr = [0, -1, 1, 0]\n        #for visited cell\n        visited = [[0 for _ in range(n)] for _ in range(n)]\n         \n         #if top-left corner of the grid is equal to 1 to verify if there is a valid starting point in the grid.\n        if m[0][0] == 1:\n            self.solve(0, 0, m, n, ans, '', direction, dir1, djr, visited)\n \n        return ans\n \nif __name__ == '__main__':\n    n = 4\n    m = [\n        [1, 0, 0, 0],\n        [1, 1, 0, 1],\n        [1, 1, 0, 0],\n        [0, 1, 1, 1]\n    ]\n \n    obj = Solution()\n    result = obj.findPath(m, n)\n    if len(result) == 0:\n        print(-1)\n    else:\n        for path in result:\n            print(path, end=' ')\n        print()\n"], "The Knight's tour problem -  ": ["# Python3 program to solve Knight Tour problem using Backtracking \n  \n# Chessboard Size \nn = 8\n  \n  \ndef isSafe(x, y, board): \n    ''' \n        A utility function to check if i,j are valid indexes  \n        for N*N chessboard \n    '''\n    if(x >= 0 and y >= 0 and x < n and y < n and board[x][y] == -1): \n        return True\n    return False\n  \n  \ndef printSolution(n, board): \n    ''' \n        A utility function to print Chessboard matrix \n    '''\n    for i in range(n): \n        for j in range(n): \n            print(board[i][j], end=' ') \n        print() \n  \n  \ndef solveKT(n): \n    ''' \n        This function solves the Knight Tour problem using  \n        Backtracking. This function mainly uses solveKTUtil()  \n        to solve the problem. It returns false if no complete  \n        tour is possible, otherwise return true and prints the  \n        tour.  \n        Please note that there may be more than one solutions,  \n        this function prints one of the feasible solutions. \n    '''\n  \n    # Initialization of Board matrix \n    board = [[-1 for i in range(n)]for i in range(n)] \n  \n    # move_x and move_y define next move of Knight. \n    # move_x is for next value of x coordinate \n    # move_y is for next value of y coordinate \n    move_x = [2, 1, -1, -2, -2, -1, 1, 2] \n    move_y = [1, 2, 2, 1, -1, -2, -2, -1] \n  \n    # Since the Knight is initially at the first block \n    board[0][0] = 0\n  \n    # Step counter for knight's position \n    pos = 1\n  \n    # Checking if solution exists or not \n    if(not solveKTUtil(n, board, 0, 0, move_x, move_y, pos)): \n        print('Solution does not exist') \n    else: \n        printSolution(n, board) \n  \n  \ndef solveKTUtil(n, board, curr_x, curr_y, move_x, move_y, pos): \n    ''' \n        A recursive utility function to solve Knight Tour  \n        problem \n    '''\n  \n    if(pos == n**2): \n        return True\n  \n    # Try all next moves from the current coordinate x, y \n    for i in range(8): \n        new_x = curr_x + move_x[i] \n        new_y = curr_y + move_y[i] \n        if(isSafe(new_x, new_y, board)): \n            board[new_x][new_y] = pos \n            if(solveKTUtil(n, board, new_x, new_y, move_x, move_y, pos+1)): \n                return True\n  \n            # Backtracking \n            board[new_x][new_y] = -1\n    return False\n  \n  \n# Driver Code \nif __name__ == '__main__': \n      \n    # Function Call \n    solveKT(n) \n  \n# This code is contributed by AAKASH PAL \n"], "Program for Tower of Hanoi Algorithm -  ": ["# Recursive Python function to solve tower of hanoi \n  \n  \ndef TowerOfHanoi(n, from_rod, to_rod, aux_rod): \n    if n == 0: \n        return\n    TowerOfHanoi(n-1, from_rod, aux_rod, to_rod) \n    print('Move disk', n, 'from rod', from_rod, 'to rod', to_rod) \n    TowerOfHanoi(n-1, aux_rod, to_rod, from_rod) \n  \n  \n# Driver code \nN = 3\n  \n# A, C, B are the name of rods \nTowerOfHanoi(N, 'A', 'C', 'B') \n  \n# Contributed By Harshit Agrawal \n"], "What is Tail Recursion -  ": ["# An example of tail recursive function\n \n \ndef prints(n):\n \n    if (n < 0):\n        return\n    print(str(n), end=' ')\n \n    # The last executed statement is recursive call\n    prints(n-1)\n \n    # This code is contributed by Pratham76\n    # improved by ashish2021\n", "# A NON-tail-recursive function.\n# The function is not tail\n# recursive because the value\n# returned by fact(n-1) is used\n# in fact(n) and call to fact(n-1)\n# is not the last thing done by\n# fact(n)\n \n \ndef fact(n):\n    if (n == 0):\n        return 1\n    return n * fact(n-1)\n \n \n# Driver program to test\n# above function\nif __name__ == '__main__':\n    print(fact(5))\n \n# This code is contributed by Smitha.\n", "# A tail recursive function\n# to calculate factorial\n \n \ndef fact(n, a=1):\n \n    if (n <= 1):\n        return a\n \n    return fact(n - 1, n * a)\n \n \n# Driver program to test\n# above function\nprint(fact(5))\n \n# This code is contributed\n# by Smitha\n# improved by Ujwal, ashish2021\n"], "Recursive Functions -  ": ["# Recursive Function to calculate Factorial of a number\ndef factorial(n):\n    # Base case\n    if n == 0:\n        return 1\n \n    # Recursive case\n    return n * factorial(n - 1)\n \n# Driver Code\nif __name__ == '__main__':\n    n = 4\n \n    print('Factorial of', n, 'is:', factorial(n))\n"], "Tree Traversal Techniques - Data Structure and Algorithm Tutorials -  ": ["# Python3 program to for tree traversals\n \n \n# A class that represents an individual node in a\n# Binary Tree\nclass Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n \n \n# A function to do inorder tree traversal\ndef printInorder(root):\n \n    if root:\n \n        # First recur on left child\n        printInorder(root.left)\n \n        # Then print the data of node\n        print(root.val, end=' '),\n \n        # Now recur on right child\n        printInorder(root.right)\n \n \n# Driver code\nif __name__ == '__main__':\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n \n    # Function call\n    print('Inorder traversal of binary tree is')\n    printInorder(root)\n", "# Python3 program to for tree traversals\n \n \n# A class that represents an individual node\n# in a Binary Tree\nclass Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n \n \n# A function to do preorder tree traversal\ndef printPreorder(root):\n \n    if root:\n \n        # First print the data of node\n        print(root.val, end=' '),\n \n        # Then recur on left child\n        printPreorder(root.left)\n \n        # Finally recur on right child\n        printPreorder(root.right)\n \n \n# Driver code\nif __name__ == '__main__':\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n \n    # Function call\n    print('Preorder traversal of binary tree is')\n    printPreorder(root)\n", "# Python3 program to for tree traversals\n \n \n# A class that represents an individual node\n# in a Binary Tree\nclass Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n \n \n# A function to do postorder tree traversal\ndef printPostorder(root):\n \n    if root:\n \n        # First recur on left child\n        printPostorder(root.left)\n \n        # The recur on right child\n        printPostorder(root.right)\n \n        # Now print the data of node\n        print(root.val, end=' '),\n \n \n# Driver code\nif __name__ == '__main__':\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n \n    # Function call\n    print('Postorder traversal of binary tree is')\n    printPostorder(root)\n"], "Fractional Knapsack Problem -  ": ["# Structure for an item which stores weight and\n# corresponding value of Item\nclass Item:\n    def __init__(self, profit, weight):\n        self.profit = profit\n        self.weight = weight\n \n# Main greedy function to solve problem\ndef fractionalKnapsack(W, arr):\n \n    # Sorting Item on basis of ratio\n    arr.sort(key=lambda x: (x.profit/x.weight), reverse=True)    \n \n    # Result(value in Knapsack)\n    finalvalue = 0.0\n \n    # Looping through all Items\n    for item in arr:\n \n        # If adding Item won't overflow, \n        # add it completely\n        if item.weight <= W:\n            W -= item.weight\n            finalvalue += item.profit\n \n        # If we can't add current Item, \n        # add fractional part of it\n        else:\n            finalvalue += item.profit * W / item.weight\n            break\n     \n    # Returning final value\n    return finalvalue\n \n \n# Driver Code\nif __name__ == '__main__':\n    W = 50\n    arr = [Item(60, 10), Item(100, 20), Item(120, 30)]\n \n    # Function call\n    max_val = fractionalKnapsack(W, arr)\n    print(max_val)\n"], "Exponential Search -  ": ["# Python program to find an element x\n# in a sorted array using Exponential Search\n \n# A recursive binary search function returns \n# location  of x in given array arr[l..r] is \n# present, otherwise -1\ndef binarySearch( arr, l, r, x):\n    if r >= l:\n        mid = l + ( r-l ) // 2\n         \n        # If the element is present at \n        # the middle itself\n        if arr[mid] == x:\n            return mid\n         \n        # If the element is smaller than mid, \n        # then it can only be present in the \n        # left subarray\n        if arr[mid] > x:\n            return binarySearch(arr, l, \n                                mid - 1, x)\n         \n        # Else he element can only be\n        # present in the right\n        return binarySearch(arr, mid + 1, r, x)\n         \n    # We reach here if the element is not present\n    return -1\n \n# Returns the position of first\n# occurrence of x in array\ndef exponentialSearch(arr, n, x):\n    # IF x is present at first \n    # location itself\n    if arr[0] == x:\n        return 0\n         \n    # Find range for binary search \n    # j by repeated doubling\n    i = 1\n    while i < n and arr[i] <= x:\n        i = i * 2\n     \n    # Call binary search for the found range\n    return binarySearch( arr, i // 2, \n                         min(i, n-1), x)\n     \n \n# Driver Code\narr = [2, 3, 4, 10, 40]\nn = len(arr)\nx = 10\nresult = exponentialSearch(arr, n, x)\nif result == -1:\n    print ('Element not found in the array')\nelse:\n    print ('Element is present at index %d' %(result))\n \n# This code is contributed by Harshit Agrawal\n"], "Interpolation Search -  ": ["# Python3 program to implement\n# interpolation search\n# with recursion\n \n# If x is present in arr[0..n-1], then\n# returns index of it, else returns -1.\n \n \ndef interpolationSearch(arr, lo, hi, x):\n \n    # Since array is sorted, an element present\n    # in array must be in range defined by corner\n    if (lo <= hi and x >= arr[lo] and x <= arr[hi]):\n \n        # Probing the position with keeping\n        # uniform distribution in mind.\n        pos = lo + ((hi - lo) // (arr[hi] - arr[lo]) *\n                    (x - arr[lo]))\n \n        # Condition of target found\n        if arr[pos] == x:\n            return pos\n \n        # If x is larger, x is in right subarray\n        if arr[pos] < x:\n            return interpolationSearch(arr, pos + 1,\n                                       hi, x)\n \n        # If x is smaller, x is in left subarray\n        if arr[pos] > x:\n            return interpolationSearch(arr, lo,\n                                       pos - 1, x)\n    return -1\n \n# Driver code\n \n \n# Array of items in which\n# search will be conducted\narr = [10, 12, 13, 16, 18, 19, 20,\n       21, 22, 23, 24, 33, 35, 42, 47]\nn = len(arr)\n \n# Element to be searched\nx = 18\nindex = interpolationSearch(arr, 0, n - 1, x)\n \nif index != -1:\n    print('Element found at index', index)\nelse:\n    print('Element not found')\n \n# This code is contributed by Hardik Jain\n", "# Python equivalent of above C++ code \n# Python program to implement interpolation search by using iteration approach\ndef interpolationSearch(arr, n, x): \n   \n    # Find indexes of two corners \n    low = 0\n    high = (n - 1) \n   \n    # Since array is sorted, an element present \n    # in array must be in range defined by corner \n    while low <= high and x >= arr[low] and x <= arr[high]: \n        if low == high: \n            if arr[low] == x: \n                return low; \n            return -1; \n   \n        # Probing the position with keeping \n        # uniform distribution in mind. \n        pos = int(low + (((float(high - low)/( arr[high] - arr[low])) * (x - arr[low])))) \n   \n        # Condition of target found \n        if arr[pos] == x: \n            return pos \n   \n        # If x is larger, x is in upper part \n        if arr[pos] < x: \n            low = pos + 1; \n   \n        # If x is smaller, x is in lower part \n        else: \n            high = pos - 1; \n       \n    return -1\n   \n# Main function\nif __name__ == '__main__':\n    # Array of items on whighch search will \n    # be conducted.\n    arr = [10, 12, 13, 16, 18, 19, 20, 21,\n           22, 23, 24, 33, 35, 42, 47]\n    n = len(arr) \n   \n    x = 18 # Element to be searched\n    index = interpolationSearch(arr, n, x) \n   \n    # If element was found\n    if index != -1: \n        print ('Element found at index',index)\n    else: \n        print ('Element not found')\n"], "Jump Search -  ": ["# Python3 code to implement Jump Search\nimport math\n \ndef jumpSearch( arr , x , n ):\n     \n    # Finding block size to be jumped\n    step = math.sqrt(n)\n     \n    # Finding the block where element is\n    # present (if it is present)\n    prev = 0\n    while arr[int(min(step, n)-1)] < x:\n        prev = step\n        step += math.sqrt(n)\n        if prev >= n:\n            return -1\n     \n    # Doing a linear search for x in \n    # block beginning with prev.\n    while arr[int(prev)] < x:\n        prev += 1\n         \n        # If we reached next block or end \n        # of array, element is not present.\n        if prev == min(step, n):\n            return -1\n     \n    # If element is found\n    if arr[int(prev)] == x:\n        return prev\n     \n    return -1\n \n# Driver code to test function\narr = [ 0, 1, 1, 2, 3, 5, 8, 13, 21,\n    34, 55, 89, 144, 233, 377, 610 ]\nx = 55\nn = len(arr)\n \n# Find the index of 'x' using Jump Search\nindex = jumpSearch(arr, x, n)\n \n# Print the index where 'x' is located\nprint('Number' , x, 'is at index' ,'%.0f'%index)\n \n# This code is contributed by 'Sharad_Bhardwaj'.\n"], "Ternary Search -  ": ["# Python3 program to illustrate\n# recursive approach to ternary search\nimport math as mt\n \n# Function to perform Ternary Search\ndef ternarySearch(l, r, key, ar):\n \n    if (r >= l):\n \n        # Find the mid1 and mid2\n        mid1 = l + (r - l) //3\n        mid2 = r - (r - l) //3\n \n        # Check if key is present at any mid\n        if (ar[mid1] == key): \n            return mid1\n         \n        if (ar[mid2] == key): \n            return mid2\n         \n        # Since key is not present at mid,\n        # check in which region it is present\n        # then repeat the Search operation\n        # in that region\n        if (key < ar[mid1]): \n \n            # The key lies in between l and mid1\n            return ternarySearch(l, mid1 - 1, key, ar)\n         \n        elif (key > ar[mid2]): \n \n            # The key lies in between mid2 and r\n            return ternarySearch(mid2 + 1, r, key, ar)\n         \n        else: \n \n            # The key lies in between mid1 and mid2\n            return ternarySearch(mid1 + 1, \n                                 mid2 - 1, key, ar)\n         \n    # Key not found\n    return -1\n \n# Driver code\nl, r, p = 0, 9, 5\n \n# Get the array\n# Sort the array if not sorted\nar = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\n \n# Starting index\nl = 0\n \n# end element index\nr = 9\n \n# Checking for 5\n \n# Key to be searched in the array\nkey = 5\n \n# Search the key using ternarySearch\np = ternarySearch(l, r, key, ar)\n \n# Print the result\nprint('Index of', key, 'is', p)\n \n# Checking for 50\n \n# Key to be searched in the array\nkey = 50\n \n# Search the key using ternarySearch\np = ternarySearch(l, r, key, ar)\n \n# Print the result\nprint('Index of', key, 'is', p)\n \n# This code is contributed by \n# Mohit kumar 29\n", "# Python 3 program to illustrate iterative\n# approach to ternary search\n \n# Function to perform Ternary Search\ndef ternarySearch(l, r, key, ar):\n    while r >= l:\n         \n        # Find mid1 and mid2\n        mid1 = l + (r-l) // 3\n        mid2 = r - (r-l) // 3\n \n        # Check if key is at any mid\n        if key == ar[mid1]:\n            return mid1\n        if key == ar[mid2]:\n            return mid2\n \n        # Since key is not present at mid, \n        # Check in which region it is present\n        # Then repeat the search operation in that region\n        if key < ar[mid1]:\n            # key lies between l and mid1\n            r = mid1 - 1\n        elif key > ar[mid2]:\n            # key lies between mid2 and r\n            l = mid2 + 1\n        else:\n            # key lies between mid1 and mid2\n            l = mid1 + 1\n            r = mid2 - 1\n \n    # key not found\n    return -1\n \n# Driver code\n \n# Get the list\n# Sort the list if not sorted\nar = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n \n# Starting index\nl = 0\n \n# end element index\nr = 9\n \n# Checking for 5\n# Key to be searched in the list\nkey = 5\n \n# Search the key using ternary search\np = ternarySearch(l, r, key, ar)\n \n# Print the result\nprint('Index of', key, 'is', p)\n \n# Checking for 50\n# Key to be searched in the list\nkey = 50\n \n# Search the key using ternary search\np = ternarySearch(l, r, key, ar)\n \n# Print the result\nprint('Index of', key, 'is', p)\n \n# This code has been contributed by Sujal Motagi\n"], "What is Priority Queue | Introduction to Priority Queue -  ": ["import sys\n \n# Structure for the elements in the\n# priority queue\nclass item :\n    value = 0\n    priority = 0\nclass GFG :\n   \n    # Store the element of a priority queue\n    pr = [None] * (100000)\n     \n    # Pointer to the last index\n    size = -1\n     \n    # Function to insert a new element\n    # into priority queue\n    @staticmethod\n    def enqueue( value,  priority) :\n       \n        # Increase the size\n        GFG.size += 1\n         \n        # Insert the element\n        GFG.pr[GFG.size] = item()\n        GFG.pr[GFG.size].value = value\n        GFG.pr[GFG.size].priority = priority\n         \n    # Function to check the top element\n    @staticmethod\n    def  peek() :\n        highestPriority = -sys.maxsize\n        ind = -1\n         \n        # Check for the element with\n        # highest priority\n        i = 0\n        while (i <= GFG.size) :\n           \n            # If priority is same choose\n            # the element with the\n            # highest value\n            if (highestPriority == GFG.pr[i].priority and ind > -1 and GFG.pr[ind].value < GFG.pr[i].value) :\n                highestPriority = GFG.pr[i].priority\n                ind = i\n            elif(highestPriority < GFG.pr[i].priority) :\n                highestPriority = GFG.pr[i].priority\n                ind = i\n            i += 1\n             \n        # Return position of the element\n        return ind\n       \n    # Function to remove the element with\n    # the highest priority\n    @staticmethod\n    def dequeue() :\n       \n        # Find the position of the element\n        # with highest priority\n        ind = GFG.peek()\n         \n        # Shift the element one index before\n        # from the position of the element\n        # with highest priority is found\n        i = ind\n        while (i < GFG.size) :\n            GFG.pr[i] = GFG.pr[i + 1]\n            i += 1\n             \n        # Decrease the size of the\n        # priority queue by one\n        GFG.size -= 1\n    @staticmethod\n    def main( args) :\n       \n        # Function Call to insert elements\n        # as per the priority\n        GFG.enqueue(10, 2)\n        GFG.enqueue(14, 4)\n        GFG.enqueue(16, 4)\n        GFG.enqueue(12, 3)\n         \n        # Stores the top element\n        # at the moment\n        ind = GFG.peek()\n        print(GFG.pr[ind].value)\n         \n        # Dequeue the top element\n        GFG.dequeue()\n         \n        # Check the top element\n        ind = GFG.peek()\n        print(GFG.pr[ind].value)\n         \n        # Dequeue the top element\n        GFG.dequeue()\n         \n        # Check the top element\n        ind = GFG.peek()\n        print(GFG.pr[ind].value)\n     \nif __name__=='__main__':\n    GFG.main([])\n     \n    # This code is contributed by aadityaburujwale.\n"], "Introduction to Circular Queue -  ": ["class CircularQueue():\n \n    # constructor\n    def __init__(self, size): # initializing the class\n        self.size = size\n         \n        # initializing queue with none\n        self.queue = [None for i in range(size)] \n        self.front = self.rear = -1\n \n    def enqueue(self, data):\n         \n        # condition if queue is full\n        if ((self.rear + 1) % self.size == self.front): \n            print(' Queue is Full\\n')\n             \n        # condition for empty queue\n        elif (self.front == -1): \n            self.front = 0\n            self.rear = 0\n            self.queue[self.rear] = data\n        else:\n             \n            # next position of rear\n            self.rear = (self.rear + 1) % self.size \n            self.queue[self.rear] = data\n             \n    def dequeue(self):\n        if (self.front == -1): # condition for empty queue\n            print ('Queue is Empty\\n')\n             \n        # condition for only one element\n        elif (self.front == self.rear): \n            temp=self.queue[self.front]\n            self.front = -1\n            self.rear = -1\n            return temp\n        else:\n            temp = self.queue[self.front]\n            self.front = (self.front + 1) % self.size\n            return temp\n \n    def display(self):\n     \n        # condition for empty queue\n        if(self.front == -1): \n            print ('Queue is Empty')\n \n        elif (self.rear >= self.front):\n            print('Elements in the circular queue are:', \n                                              end = ' ')\n            for i in range(self.front, self.rear + 1):\n                print(self.queue[i], end = ' ')\n            print ()\n \n        else:\n            print ('Elements in Circular Queue are:', \n                                           end = ' ')\n            for i in range(self.front, self.size):\n                print(self.queue[i], end = ' ')\n            for i in range(0, self.rear + 1):\n                print(self.queue[i], end = ' ')\n            print ()\n \n        if ((self.rear + 1) % self.size == self.front):\n            print('Queue is Full')\n \n# Driver Code\nob = CircularQueue(5)\nob.enqueue(14)\nob.enqueue(22)\nob.enqueue(13)\nob.enqueue(-6)\nob.display()\nprint ('Deleted value = ', ob.dequeue())\nprint ('Deleted value = ', ob.dequeue())\nob.display()\nob.enqueue(9)\nob.enqueue(20)\nob.enqueue(5)\nob.display()\n \n# This code is contributed by AshwinGoel \n"], "FIFO (First-In-First-Out) approach in Programming -  ": ["# Python program to demonstrate\n# working of FIFO\n# using Queue interface in Python\n \nq = []\n \n# Adds elements {0, 1, 2, 3, 4} to queue\nfor i in range(5):\n    q.append(i)\n \n# Display contents of the queue.\nprint('Elements of queue-' , q)\n \n# To remove the head of queue.\n# In this the oldest element '0' will be removed\nremovedele = q.pop(0)\nprint('removed element-' , removedele)\n \nprint(q)\n \n# To view the head of queue\nhead = q[0]\nprint('head of queue-' , head)\n \n# Rest all methods of collection interface,\n# Like size and contains can be used with this\n# implementation.\nsize = len(q)\nprint('Size of queue-' , size)\n \n# This code is contributed by patel2127.\n"], "LIFO (Last-In-First-Out) approach in Programming -  ": ["# Python3 program to demonstrate working of LIFO\n \n# Pushing element on the top of the stack\ndef stack_push(stack):\n    for i in range(5):\n        stack.append(i)\n    return stack\n  \n# Popping element from the top of the stack\ndef stack_pop(stack):\n    print('Pop :')\n  \n    for i in range(5):\n        y = stack[-1]\n        stack.pop()\n        print(y)\n    return stack\n  \n# Displaying element on the top of the stack\ndef stack_peek(stack):\n    element = stack[-1]\n    print('Element on stack top :', element)\n  \n# Searching element in the stack\ndef stack_search(stack, element):\n    pos = -1\n    co = 0\n    while(len(stack) > 0):\n        co+=1\n        if(stack[-1] == element):\n            pos = co\n            break\n        stack.pop()\n  \n    if (pos == -1):\n        print( 'Element not found')\n    else:\n        print('Element is found at position', pos)\n \nstack = []\nstack_push(stack)\nstack_pop(stack)\nstack_push(stack)\nstack_peek(stack)\nstack_search(stack, 2)\nstack_search(stack, 6)\n \n# This code is contributed by rameshtravel07.\n"], "Introduction to Strings - Data Structure and Algorithm Tutorials -  ": [], "What is Binary String? -  ": ["# Python code for above approach\n \n# function to calculate the Hamming distance between two binary strings\ndef hammingDistance(s1, s2):\n    hamming_dist = 0\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            hamming_dist += 1\n    return hamming_dist\n \n# create binary strings\nbinary_str1 = '10101010'\nbinary_str2 = '01010101'\n \n# Length of binary string\nprint('Length of binary string 1:', len(binary_str1))\n \n# Concatenation of binary strings\nconcatenated_str = binary_str1 + binary_str2\nprint('Concatenation of binary strings:', concatenated_str)\n \n# Substring of binary string\nsubstring = binary_str1[2:6]  # starting index and ending index (exclusive)\nprint('Substring of binary string 1:', substring)\n \n# Prefix of binary string\nprefix = binary_str1[:3]  # starting index and ending index (exclusive)\nprint('Prefix of binary string 1:', prefix)\n \n# Suffix of binary string\nsuffix = binary_str2[4:]  # starting index\nprint('Suffix of binary string 2:', suffix)\n \n# Hamming distance between two binary strings\nhamming_dist = hammingDistance(binary_str1, binary_str2)\nprint('Hamming distance between binary strings 1 and 2:', hamming_dist)\n \n# Regular Language of binary strings (ends with '0')\nhas_regular_language = binary_str1[-1] == '0'\nprint('Does binary string 1 have a regular language?', 'Yes' if has_regular_language else 'No')\n \n# Binary Arithmetic (addition)\nbinary_num1 = int(binary_str1, 2)\nbinary_num2 = int(binary_str2, 2)\nSum = bin(binary_num1 + binary_num2)[2:].zfill(8)\nprint('Binary addition of', binary_str1, 'and', binary_str2 + ':', Sum)\n \n# This code is contributed by Utkarsh Kumar\n"], "Introduction to Arrays - Data Structure and Algorithm Tutorials -  ": ["# list of integers\nmy_list = [1, 2, 3, 4]\n \n# Empty list\nmy_list = []\n \n# list of mixed data types\nmy_list = ['Hello', 1, 5.5]\n"], "Sort an array of 0s, 1s and 2s | Dutch National Flag problem -  ": ["# Python program to sort an array with\n# 0, 1 and 2 in a single pass\n \n# Function to sort array\n \n \ndef sort012(a, arr_size):\n    lo = 0\n    hi = arr_size - 1\n    mid = 0\n    # Iterate till all the elements\n    # are sorted\n    while mid <= hi:\n        # If the element is 0\n        if a[mid] == 0:\n            a[lo], a[mid] = a[mid], a[lo]\n            lo = lo + 1\n            mid = mid + 1\n        # If the element is 1\n        elif a[mid] == 1:\n            mid = mid + 1\n        # If the element is 2\n        else:\n            a[mid], a[hi] = a[hi], a[mid]\n            hi = hi - 1\n    return a\n \n# Function to print array\n \n \ndef printArray(a):\n    for k in a:\n        print(k, end=' ')\n \n \n# Driver Program\narr = [0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1]\narr_size = len(arr)\narr = sort012(arr, arr_size)\nprintArray(arr)\n \n# Contributed by Harshit Agrawal\n", "def sort012(arr, n):\n    # Initialisation\n    l = 0\n    r = n - 1\n \n    i = 0\n    while i < n and i <= r:\n        # current element is 0\n        if arr[i] == 0:\n            arr[l], arr[i] = arr[i], arr[l]\n            l += 1\n            i += 1\n        # current element is 2\n        elif arr[i] == 2:\n            arr[i], arr[r] = arr[r], arr[i]\n            r -= 1\n        # current element is 1\n        else:\n            i += 1\n \n \ndef printArray(arr, arr_size):\n    # Iterate and print every element\n    for i in range(arr_size):\n        print(arr[i], end=' ')\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1]\n    n = len(arr)\n \n    sort012(arr, n)\n \n    printArray(arr, n)\n", "# Python implementation of the approach\n \n# Utility function to print contents of an array\n \n \ndef printArr(arr, n):\n    for i in range(n):\n        print(arr[i], end=' ')\n \n \n# Function to sort the array of 0s, 1s and 2s\ndef sortArr(arr, n):\n    cnt0 = 0\n    cnt1 = 0\n    cnt2 = 0\n \n    # Count the number of 0s, 1s and 2s in the array\n    for i in range(n):\n        if arr[i] == 0:\n            cnt0 += 1\n \n        elif arr[i] == 1:\n            cnt1 += 1\n \n        elif arr[i] == 2:\n            cnt2 += 1\n \n    # Update the array\n    i = 0\n \n    # Store all the 0s in the beginning\n    while (cnt0 > 0):\n        arr[i] = 0\n        i += 1\n        cnt0 -= 1\n \n    # Then all the 1s\n    while (cnt1 > 0):\n        arr[i] = 1\n        i += 1\n        cnt1 -= 1\n \n    # Finally all the 2s\n    while (cnt2 > 0):\n        arr[i] = 2\n        i += 1\n        cnt2 -= 1\n \n    # Print the sorted array\n    printArr(arr, n)\n \n \n# Driver code\n \narr = [0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1]\nn = len(arr)\n \nsortArr(arr, n)\n \n# This code is contributed by shubhamsingh10\n"], "Largest Sum Contiguous Subarray (Kadane's Algorithm) -  ": ["# Python program to print largest contiguous array sum\n \nfrom sys import maxsize\n \n# Function to find the maximum contiguous subarray\n# and print its starting and end index\n \n \ndef maxSubArraySum(a, size):\n \n    max_so_far = -maxsize - 1\n    max_ending_here = 0\n    start = 0\n    end = 0\n    s = 0\n \n    for i in range(0, size):\n \n        max_ending_here += a[i]\n \n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n            start = s\n            end = i\n \n        if max_ending_here < 0:\n            max_ending_here = 0\n            s = i+1\n \n    print('Maximum contiguous sum is %d' % (max_so_far))\n    print('Starting Index %d' % (start))\n    print('Ending Index %d' % (end))\n \n \n# Driver program to test maxSubArraySum\na = [-2, -3, 4, -1, -2, 1, 5, -3]\nmaxSubArraySum(a, len(a))\n"], "Program to cyclically rotate an array by one -  ": ["# Python3 code for program to\n# cyclically rotate an array by one\n \n# Method for rotation\n \n \ndef rotate(arr, n):\n    last_el = arr[n - 1]\n \n    for i in range(n - 1, 0, -1):\n        arr[i] = arr[i - 1]\n \n    arr[0] = last_el\n \n \n# Driver function\narr = [1, 2, 3, 4, 5]\nn = len(arr)\nprint('Given array is')\nfor i in range(0, n):\n    print(arr[i], end=' ')\n \nrotate(arr, n)\n \nprint('\\nRotated array is')\nfor i in range(0, n):\n    print(arr[i], end=' ')\n \n# This article is contributed\n# by saloni1297\n", "def rotate(arr, n):\n    i = 0\n    j = n - 1\n    while i != j:\n      arr[i], arr[j] = arr[j], arr[i]\n      i = i + 1\n    pass\n \n \n# Driver function\narr= [1, 2, 3, 4, 5]\nn = len(arr)\nprint ('Given array is')\nfor i in range(0, n):\n    print (arr[i], end = ' ')\n \nrotate(arr, n)\n \nprint ('\\nRotated array is')\nfor i in range(0, n):\n    print (arr[i], end = ' ')\n", "arr = [1, 2, 3, 4, 5]\nn = len(arr)\nk = 1  # No. of rotations\ni, j = 0, 0\n \nprint('Given array is')\nfor i in range(n):\n    print(arr[i], end=' ')\n \n# Reverse the first n-1 terms\nfor i, j in zip(range(0, (n-k)//2), range(n-k-1, (n-k)//2-1, -1)):\n    temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n \n# Reverse the entire array\nfor i, j in zip(range(0, n//2), range(n-1, n//2-1, -1)):\n    temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n \nprint('\\nRotated array is')\nfor i in range(n):\n    print(arr[i], end=' ')\n"], "Write a program to reverse an array or string -  ": [], "Analysis of Algorithms | Big-O analysis -  ": ["# Python program to findtime complexity for single for loop\na = 0\nb = 0\n# declare size\nN = 5\nM = 5\n# This loop runs for N time\nfor i in range(N):\n    a = a + 5\n# This loop runs for M time\nfor i in range(M):\n    b = b + 10\n# print value of a and b\nprint(a, end=' ')\nprint(b)\n \n# Code submitted by Susobhan Akhuli\n"], "Understanding Time Complexity with Simple Examples -  ": ["print('Hello World')\n \n# This code is contributed by akashish__\n", "# Python code\nn = 8\nfor i in range(1, n + 1):\n    print('Hello World !!!')\n \n# This code is contributed by lokesh\n", "n = 8\n# for (i = 1; i <= n; i=i*2) {\nfor i in range(1,9,+2):\n    print('Hello World !!!')\n \n# This code is contributed by akashish__\n", "n = 8\ni = 2\nfor j in range(2,n+1):\n    if(i >= n):\n        break\n    print('Hello World !!!')   \n    i *= i\n# This code is contributed by akashish__\n", "# Pseudocode : Sum(a, b) { return a + b }\na = 5\nb = 6\n \ndef sum(a,b):\n  return a+b\n \n # function call\nprint(sum(a,b))\n", "# A function to calculate the sum of the elements in an array\ndef list_sum(A, n):\n    sum = 0\n    for i in range(n):\n        sum += A[i]\n    return sum\n \n \n# A sample array\nA = [5, 6, 1, 2]\n \n# Finding the number of elements in the array\nn = len(A)\n \n# Call the function and print the result\nprint(list_sum(A, n))\n", "n = 3\nm = 3\narr = [[3, 2, 7], [2, 6, 8], [5, 1, 9]]\nsum = 0\n \n# Iterating over all 1-D arrays in 2-D array\nfor i in range(n):\n    # Printing all elements in ith 1-D array\n    for j in range(m):\n        # Printing jth element of ith row\n        sum += arr[i][j]\n \nprint(sum)\n \n# This code id contributed by shivhack999\n"], "Sort a linked list in O(n log n) time using constant space complexity. Example : Input : 1 -> 5 -> 4 -> 3 Returned list : 1 -> 3 -> 4 -> 5": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x, next):\n        self.val = x\n        self.next = next\n        \n        \ndef merge(left, right):\n    head = current = ListNode(None, None)\n    \n    curr_left, curr_right = left, right\n    while curr_left and curr_right:\n        if curr_left.val < curr_right.val:\n            current.next = curr_left\n            curr_left = curr_left.next\n        else:\n            current.next = curr_right\n            curr_right = curr_right.next\n        current = current.next\n            \n    if not curr_left:\n        current.next = curr_right\n    else:\n        current.next = curr_left\n    \n    return head.next\n\n    \nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    def sortList(self, A):\n        slow = fast = A\n        \n        # Base case\n        if not A or not A.next:\n            return A\n            \n        if not A.next.next:\n            left, right = A, A.next\n            A.next = None\n            return merge(left, right)\n            \n        # Find mid\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow\n        \n        # Divide into two and sort each segment\n        right = self.sortList(mid.next)\n        mid.next = None\n        left = self.sortList(A)\n        \n        return merge(left, right)\n        \n            \n        \n\n\n", "Chocolate Distribution Problem -  ": ["# Python3 program to solve\n# chocolate distribution\n# problem\n \n \n# arr[0..n-1] represents sizes of packets\n# m is number of students.\n# Returns minimum difference between maximum\n# and minimum values of distribution.\ndef findMinDiff(arr, n, m):\n \n    # if there are no chocolates or number\n    # of students is 0\n    if (m == 0 or n == 0):\n        return 0\n \n    # Sort the given packets\n    arr.sort()\n \n    # Number of students cannot be more than\n    # number of packets\n    if (n < m):\n        return -1\n \n    # Largest number of chocolates\n    min_diff = arr[n-1] - arr[0]\n \n    # Find the subarray of size m such that\n    # difference between last (maximum in case\n    # of sorted) and first (minimum in case of\n    # sorted) elements of subarray is minimum.\n    for i in range(len(arr) - m + 1):\n        min_diff = min(min_diff,  arr[i + m - 1] - arr[i])\n \n    return min_diff\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [12, 4, 7, 9, 2, 23, 25, 41,\n           30, 40, 28, 42, 30, 44, 48,\n           43, 50]\n    m = 7  # Number of students\n    n = len(arr)\n    print('Minimum difference is', findMinDiff(arr, n, m))\n \n# This code is contributed by Smitha\n"], "Count smaller elements on Right side -  ": ["def constructLowerArray(arr, countSmaller, n):\n \n    # initialize all the counts in countSmaller array as 0\n    for i in range(n):\n        countSmaller[i] = 0\n \n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[j] < arr[i]):\n                countSmaller[i] += 1\n \n# Utility function that prints out an array on a line\n \n \ndef printArray(arr, size):\n    for i in range(size):\n        print(arr[i], end=' ')\n    print()\n \n \n# Driver code\narr = [12, 1, 2, 3, 0, 11, 4]\nn = len(arr)\nlow = [0]*n\nconstructLowerArray(arr, low, n)\nprintArray(low, n)\n \n# This code is contributed by ApurvaRaj\n", "def merge(v, ans, l, mid, h):\n    t = []  # temporary array for merging both halves\n    i = l\n    j = mid+1\n    while (i < mid+1 and j <= h):\n       \n        # v[i][0] is greater than all\n        # the elements from j till h.\n        if v[i][0] > v[j][0]:\n            ans[v[i][1]] += (h-j+1)\n            t.append(v[i])\n            i += 1\n        else:\n            t.append(v[j])\n            j += 1\n             \n    # if any elements left in left array\n    while (i <= mid):\n        t.append(v[i])\n        i += 1\n         \n    # if any elements left in right array\n    while j <= h:\n        t.append(v[j])\n        j += 1\n         \n    # putting elements back in main array in\n    # descending order\n    k = 0\n    i = l\n    while (i <= h):\n        v[i] = t[k]\n        i += 1\n        k += 1\n \ndef mergesort(v, ans, i, j):\n    if i < j:\n        mid = (i+j)//2\n         \n        # calling mergesort for left half\n        mergesort(v, ans, i, mid)\n         \n        # calling mergesort for right half\n        mergesort(v, ans, mid + 1, j)\n         \n        # merging both halves and generating answer\n        merge(v, ans, i, mid, j)\n \n \ndef constructLowerArray(arr, n):\n    v = []\n     \n    # inserting elements and corresponding index as pair\n    for i in range(n):\n        v.append([arr[i], i])\n         \n    # answer array for keeping count initialized by 0\n    ans = [0]*n\n     \n    # calling mergesort\n    mergesort(v, ans, 0, n-1)\n    return ans\n \n# Driver Code\narr = [12, 1, 2, 3, 0, 11, 4]\nn = len(arr)\nans = constructLowerArray(arr, n)\nfor x in ans:\n    print(x, end=' ')\n     \n'''This code is contributed by RAJATKUMARGLA19'''\n", "import math\n \n \nclass GFG:\n    # An AVL tree node\n    class node:\n        key = 0\n        left = None\n        right = None\n        height = 0\n        # size of the tree rooted\n        # with this node\n        size = 0\n    countSmaller = None\n    count = 0\n    # A utility function to get\n    # height of the tree rooted with N\n \n    @staticmethod\n    def height(N):\n        if (N == None):\n            return 0\n        return N.height\n    # A utility function to size\n    # of the tree of rooted with N\n \n    @staticmethod\n    def size(N):\n        if (N == None):\n            return 0\n        return N.size\n    # A utility function to\n    # get maximum of two integers\n \n    @staticmethod\n    def max(a,  b):\n        return a if (a > b) else b\n    # Helper function that allocates a\n    # new node with the given key and\n    # null left and right pointers.\n \n    @staticmethod\n    def newNode(key):\n        node = GFG.node()\n        node.key = key\n        node.left = None\n        node.right = None\n        # New node is initially added at leaf\n        node.height = 1\n        node.size = 1\n        return (node)\n    # A utility function to right rotate\n    # subtree rooted with y\n \n    @staticmethod\n    def rightRotate(y):\n        x = y.left\n        T2 = x.right\n        # Perform rotation\n        x.right = y\n        y.left = T2\n        # Update heights\n        y.height = max(GFG.height(y.left), GFG.height(y.right)) + 1\n        x.height = max(GFG.height(x.left), GFG.height(x.right)) + 1\n        # Update sizes\n        y.size = GFG.size(y.left) + GFG.size(y.right) + 1\n        x.size = GFG.size(x.left) + GFG.size(x.right) + 1\n        # Return new root\n        return x\n    # A utility function to left rotate\n    # subtree rooted with x\n \n    @staticmethod\n    def leftRotate(x):\n        y = x.right\n        T2 = y.left\n        # Perform rotation\n        y.left = x\n        x.right = T2\n        #  Update heights\n        x.height = max(GFG.height(x.left), GFG.height(x.right)) + 1\n        y.height = max(GFG.height(y.left), GFG.height(y.right)) + 1\n        # Update sizes\n        x.size = GFG.size(x.left) + GFG.size(x.right) + 1\n        y.size = GFG.size(y.left) + GFG.size(y.right) + 1\n        # Return new root\n        return y\n    # Get Balance factor of node N\n \n    @staticmethod\n    def getBalance(N):\n        if (N == None):\n            return 0\n        return GFG.height(N.left) - GFG.height(N.right)\n    # Inserts a new key to the tree rotted with\n    # node. Also, updates *count to contain count\n    # of smaller elements for the new key\n \n    @staticmethod\n    def insert(node,  key,  count):\n        # 1. Perform the normal BST rotation\n        if (node == None):\n            return (GFG.newNode(key))\n        if (key < node.key):\n            node.left = GFG.insert(node.left, key, count)\n        else:\n            node.right = GFG.insert(node.right, key, count)\n            # UPDATE COUNT OF SMALLER ELEMENTS FOR KEY\n            GFG.countSmaller[count] = GFG.countSmaller[count] + \\\n                GFG.size(node.left) + 1\n        # 2.Update height and size of this ancestor node\n        node.height = max(GFG.height(node.left), GFG.height(node.right)) + 1\n        node.size = GFG.size(node.left) + GFG.size(node.right) + 1\n        # 3. Get the balance factor of this\n        # ancestor node to check whether this\n        # node became unbalanced\n        balance = GFG.getBalance(node)\n        # If this node becomes unbalanced,\n        # then there are 4 cases\n        # Left Left Case\n        if (balance > 1 and key < node.left.key):\n            return GFG.rightRotate(node)\n        # Right Right Case\n        if (balance < -1 and key > node.right.key):\n            return GFG.leftRotate(node)\n        # Left Right Case\n        if (balance > 1 and key > node.left.key):\n            node.left = GFG.leftRotate(node.left)\n            return GFG.rightRotate(node)\n        # Right Left Case\n        if (balance < -1 and key < node.right.key):\n            node.right = GFG.rightRotate(node.right)\n            return GFG.leftRotate(node)\n        # Return the (unchanged) node pointer\n        return node\n    # The following function updates the\n    # countSmaller array to contain count of\n    # smaller elements on right side.\n \n    @staticmethod\n    def constructLowerArray(arr,  n):\n        i = 0\n        j = 0\n        root = None\n        # Initialize all the counts in\n        # countSmaller array as 0\n        i = 0\n        while (i < n):\n            GFG.countSmaller[i] = 0\n            i += 1\n        # Starting from rightmost element,\n        # insert all elements one by one in\n        # an AVL tree and get the count of\n        # smaller elements\n        i = n - 1\n        while (i >= 0):\n            root = GFG.insert(root, arr[i], i)\n            i -= 1\n    # Utility function that prints out an\n    # array on a line\n \n    @staticmethod\n    def printArray(arr,  size):\n        i = 0\n        print('\\n', end='')\n        i = 0\n        while (i < size):\n            print(str(arr[i]) + ' ', end='')\n            i += 1\n    # Driver code\n \n    @staticmethod\n    def main(args):\n        arr = [12, 1, 2, 3, 0, 11, 4]\n        n = len(arr)\n        GFG.countSmaller = [0] * (n)\n        GFG.constructLowerArray(arr, n)\n        GFG.printArray(GFG.countSmaller, n)\n \n \nif __name__ == '__main__':\n    GFG.main([])\n", "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n \n        # denotes number of times (frequency)\n        # an element has occurred.\n        self.elecount = 1\n \n        # denotes the number of nodes on left\n        # side of the node encountered so far.\n        self.lcount = 0\n \n \nclass Tree:\n    def __init__(self, root):\n        self.root = root\n \n    def insert(self, node):\n        '''This function helps to place an element at \n            its correct position in the BST and returns \n            the count of elements which are smaller than \n            the elements which are already inserted into the BST. \n        '''\n        curr = self.root\n        cnt = 0\n        while curr != None:\n            prev = curr\n            if node.val > curr.val:\n \n                # This step computes the number of elements\n                # which are less than the current Node.\n                cnt += (curr.elecount+curr.lcount)\n                curr = curr.right\n            elif node.val < curr.val:\n                curr.lcount += 1\n                curr = curr.left\n            else:\n                prev = curr\n                prev.elecount += 1\n                break\n        if prev.val > node.val:\n            prev.left = node\n        elif prev.val < node.val:\n            prev.right = node\n        else:\n            return cnt+prev.lcount\n        return cnt\n \n \ndef constructArray(arr, n):\n    t = Tree(Node(arr[-1]))\n    ans = [0]\n    for i in range(n-2, -1, -1):\n        ans.append(t.insert(Node(arr[i])))\n    return reversed(ans)\n \n# Driver function for above code\n \n \ndef main():\n    n = 7\n    arr = [12, 1, 2, 3, 0, 11, 4]\n    print(' '.join(list(map(str, constructArray(arr, n)))))\n \n \nif __name__ == '__main__':\n    main()\n \n# Code Contributed by Tarun Gudipati\n", "import bisect\n \nclass Solution:\n    def constructLowerArray(self, arr, n):\n        ans = []\n        temp = []\n         \n        for i in range(n - 1, -1, -1):\n            c = bisect.bisect_left(temp, arr[i])\n            ans.append(c)\n            temp = [arr[i]]\n         \n        return ans[::-1]\n \narr = [12, 1, 2, 3, 0, 11, 4]\nn = len(arr)\n \ns = Solution()\nans = s.constructLowerArray(arr, n)\n \nprint(*ans)\n"], "Find the point where maximum intervals overlap -  ": ["# Program to find maximum guest\n# at any time in a party\ndef findMaxGuests(arrl, exit, n):\n \n    # Sort arrival and exit arrays\n    arrl.sort();\n    exit.sort();\n \n    # guests_in indicates number of \n    # guests at a time\n    guests_in = 1;\n    max_guests = 1;\n    time = arrl[0];\n    i = 1;\n    j = 0;\n \n    # Similar to merge in merge sort to \n    # process all events in sorted order\n    while (i < n and j < n):\n         \n        # If next event in sorted order is \n        # arrival, increment count of guests\n        if (arrl[i] <= exit[j]):\n     \n            guests_in = guests_in + 1;\n \n        # Update max_guests if needed\n            if(guests_in > max_guests):\n         \n                max_guests = guests_in;\n                time = arrl[i];\n                 \n            # increment index of arrival array\n            i = i + 1; \n     \n        else:\n            guests_in = guests_in - 1;\n            j = j + 1;\n     \n    print('Maximum Number of Guests =',\n           max_guests, 'at time', time)\n \n# Driver Code\narrl = [1, 2, 10, 5, 5];\nexit = [4, 5, 12, 9, 12];\nn = len(arrl);\nfindMaxGuests(arrl, exit, n);\n \n# This code is contributed \n# by Shivi_Aggarwal \n", "import sys\n  \ndef maxOverlap(start,end):\n  \n    n= len(start)\n    maxa = max(start)# Finding maximum starting time\n    maxb = max(end)  # Finding maximum ending time\n    maxc=max(maxa,maxb)\n    x =(maxc+2)*[0]\n    cur=0; idx=0\n  \n    for i in range(0,n) :# CREATING AN AUXILIARY ARRAY\n        x[start[i]]+=1 # Lazy addition\n        x[end[i]+1]-=1\n       \n    maxy=-1\n    #Lazily Calculating value at index i\n    for i in range(0,maxc+1): \n        cur+=x[i]\n        if maxy<cur :\n            maxy=cur\n            idx=i     \n    print('Maximum value is: {0:d}'.format(maxy),\n                     ' at position: {0:d}'.format(idx))\nif __name__ == '__main__':\n      \n    start=[13,28,29,14,40,17,3]\n    end=[107,95,111,105,70,127,74]\n                    \n    maxOverlap(start,end)\n"], "Find all elements in array which have at-least two greater elements -  ": ["# Sorting based Python 3 program\n# to find all elements in array \n# which have atleast two greater \n# elements itself.\n \ndef findElements(arr, n):\n \n    arr.sort()\n \n    for i in range(0, n-2):\n        print(arr[i], end =' ')\n \n# Driven source\narr = [2, -6, 3, 5, 1]\nn = len(arr)\nfindElements(arr, n)\n \n# This code is contributed \n# by Smitha Dinesh Semwal\n", "# Python3 program to find all elements\n# in array which have atleast two \n# greater elements itself.\nimport sys\n \ndef findElements(arr, n):\n \n    first = -sys.maxsize\n    second = -sys.maxsize\n \n    for i in range(0, n):\n     \n        # If current element is smaller\n        # than first then update both\n        # first and second \n        if (arr[i] > first):\n         \n            second = first\n            first = arr[i]\n         \n        # If arr[i] is in between first\n        # and second then update second \n        elif (arr[i] > second):\n            second = arr[i]\n     \n    for i in range(0, n):\n        if (arr[i] < second):\n            print(arr[i], end =' ')\n \n \n# Driver code\narr = [2, -6, 3, 5, 1]\nn = len(arr)\nfindElements(arr, n)\n \n# This code is contributed\n# by Smitha Dinesh Semwal\n"], "Count the number of possible triangles -  ": ["# Python3 code to count the number of\n# possible triangles using brute\n# force approach\n \n# Function to count all possible\n# triangles with arr[] elements\n \n \ndef findNumberOfTriangles(arr, n):\n \n    # Count of triangles\n    count = 0\n \n    # The three loops select three\n    # different values from array\n    for i in range(n):\n        for j in range(i + 1, n):\n \n            # The innermost loop checks for\n            # the triangle property\n            for k in range(j + 1, n):\n \n                # Sum of two sides is greater\n                # than the third\n                if (arr[i] + arr[j] > arr[k] and\n                    arr[i] + arr[k] > arr[j] and\n                        arr[k] + arr[j] > arr[i]):\n                    count += 1\n    return count\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [10, 21, 22, 100, 101, 200, 300]\n    size = len(arr)\n \n    # Function call\n    print('Total number of triangles possible is',\n          findNumberOfTriangles(arr, size))\n \n# This code is contributed by shubhamsingh10\n", "# Python3 function to count all possible triangles with arr[]\n# elements\n \n \ndef findnumberofTriangles(arr):\n \n    # Sort array and initialize count as 0\n    n = len(arr)\n    arr.sort()\n    count = 0\n \n    # Fix the first element. We need to run till n-3 as\n    # the other two elements are selected from arr[i + 1...n-1]\n    for i in range(0, n-2):\n \n        # Initialize index of the rightmost third element\n        k = i + 2\n \n        # Fix the second element\n        for j in range(i + 1, n):\n \n            # Find the rightmost element which is smaller\n            # than the sum of two fixed elements\n            # The important thing to note here is, we use\n            # the previous value of k. If value of arr[i] +\n            # arr[j-1] was greater than arr[k], then arr[i] +\n            # arr[j] must be greater than k, because the array\n            # is sorted.\n            while (k < n and arr[i] + arr[j] > arr[k]):\n                k += 1\n \n            # Total number of possible triangles that can be\n            # formed with the two fixed elements is k - j - 1.\n            # The two fixed elements are arr[i] and arr[j]. All\n            # elements between arr[j + 1] to arr[k-1] can form a\n            # triangle with arr[i] and arr[j]. One is subtracted\n            # from k because k is incremented one extra in above\n            # while loop. k will always be greater than j. If j\n            # becomes equal to k, then above loop will increment k,\n            # because arr[k] + arr[i] is always greater than arr[k]\n            if(k > j):\n                count += k - j - 1\n \n    return count\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [10, 21, 22, 100, 101, 200, 300]\n \n    # Function call\n    print('Total number of Triangles:', findnumberofTriangles(arr))\n \n# This code is contributed by Devesh Agrawal\n", "# Python implementation of the above approach\ndef CountTriangles(A):\n \n    n = len(A)\n \n    A.sort()\n \n    count = 0\n \n    for i in range(n - 1, 0, -1):\n        l = 0\n        r = i - 1\n        while(l < r):\n            if(A[l] + A[r] > A[i]):\n \n                # If it is possible with a[l], a[r]\n                # and a[i] then it is also possible\n                # with a[l + 1]..a[r-1], a[r] and a[i]\n                count += r - l\n \n                # checking for more possible solutions\n                r -= 1\n \n            else:\n \n                # if not possible check for\n                # higher values of arr[l]\n                l += 1\n    print('No of possible solutions: ', count)\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    A = [10, 21, 22, 100, 101, 200, 300]\n \n    # Function call\n    CountTriangles(A)\n \n# This code is contributed by PrinciRaj1992\n"], "Minimum Number of Platforms Required for a Railway/Bus Station -  ": ["# Program to find minimum number of platforms\n# required on a railway station\n \n \ndef findPlatform(arr, dep, n):\n    '''\n    Accepts two arrays with arrival and departure time\n    and the size of the array\n    Returns minimum number of platforms required\n    '''\n \n    # plat_needed indicates number of platforms\n    # needed at a time\n    plat_needed = 1\n    result = 1\n \n    # run a nested loop to find overlap\n    for i in range(n):\n        # minimum platform needed\n        plat_needed = 1\n \n        for j in range(n):\n            # check for overlap\n            if i != j:\n                if (arr[i] >= arr[j] and dep[j] >= arr[i]):\n                    plat_needed += 1\n \n        # update result\n        result = max(result, plat_needed)\n \n    return result\n \n# Driver code\n \n \ndef main():\n    arr = [100, 300, 500]\n    dep = [900, 400, 600]\n \n    n = len(arr)\n \n    print('{}'.format(\n        findPlatform(arr, dep, n)))\n \n \nif __name__ == '__main__':\n    main()\n", "import heapq\n# Function to find the minimum number\n# of platforms required\n \n \ndef findPlatform(arr, dep, n):\n    arr2 = []\n    # Store the arrival and departure time\n    for i in range(n):\n        arr2.append([arr[i], dep[i]])\n    arr2.sort()  # Sort trains based on arrival time\n    p = []\n    count = 1\n    heapq.heappush(p, arr2[0][1])\n    for i in range(1, n):\n        # Check if arrival time of current train\n        # is less than or equals to departure time\n        # of previous train\n        if p[0] >= arr2[i][0]:\n            count += 1\n        else:\n            heapq.heappop(p)\n        heapq.heappush(p, arr2[i][1])\n    # return the count of number of platforms required\n    return count\n \n \nif __name__ == '__main__':\n    arr = [900, 940, 950, 1100, 1500, 1800]\n    dep = [910, 1200, 1120, 1130, 1900, 2000]\n    n = len(arr)\n    print(findPlatform(arr, dep, n))\n", "# Program to find minimum\n# number of platforms\n# required on a railway\n# station\n \n# Returns minimum number\n# of platforms required\n \n \ndef findPlatform(arr, dep, n):\n \n    # Sort arrival and\n    # departure arrays\n    arr.sort()\n    dep.sort()\n \n    # plat_needed indicates\n    # number of platforms\n    # needed at a time\n    plat_needed = 1\n    result = 1\n    i = 1\n    j = 0\n \n    # Similar to merge in\n    # merge sort to process\n    # all events in sorted order\n    while (i < n and j < n):\n \n        # If next event in sorted\n        # order is arrival,\n        # increment count of\n        # platforms needed\n        if (arr[i] <= dep[j]):\n \n            plat_needed += 1\n            i += 1\n \n        # Else decrement count\n        # of platforms needed\n        elif (arr[i] > dep[j]):\n \n            plat_needed -= 1\n            j += 1\n \n        # Update result if needed\n        if (plat_needed > result):\n            result = plat_needed\n \n    return result\n \n# Driver code\n \n \narr = [900, 940, 950, 1100, 1500, 1800]\ndep = [910, 1200, 1120, 1130, 1900, 2000]\nn = len(arr)\n \nprint('Minimum Number of Platforms Required = ',\n      findPlatform(arr, dep, n))\n \n# This code is contributed\n# by Anant Agarwal.\n", "from typing import List\n \n# Function to find the minimum number of platforms required.\ndef find_platform_optimized(arr: List[int], dep: List[int], n: int) -> int:\n \n    count = 0\n    max_platforms = 0\n \n    # Find the maximum departure time\n    max_departure_time = max(dep)\n \n    # Create a list to store the count of trains at each time\n    v = [0] * (max_departure_time + 2)\n \n    # Increment the count at the arrival time and decrement at the departure time\n    for i in range(n):\n        v[arr[i]] += 1\n        v[dep[i] + 1] -= 1\n \n    # Iterate over the list and keep track of the maximum sum seen so far\n    for i in range(max_departure_time + 2):\n        count += v[i]\n        max_platforms = max(max_platforms, count)\n \n    return max_platforms\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [100, 300, 600]\n    dep = [900, 400, 500]\n    n = len(arr)\n    print(find_platform_optimized(arr, dep, n))\n"], "Inversion count in Array using Merge Sort -  ": ["# Python3 program to count\n# inversions in an array\n \n \ndef getInvCount(arr, n):\n \n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n \n    return inv_count\n \n \n# Driver Code\narr = [1, 20, 6, 4, 5]\nn = len(arr)\nprint('Number of inversions are',\n      getInvCount(arr, n))\n \n# This code is contributed by Smitha Dinesh Semwal\n", "from heapq import heappush, heappop\nfrom bisect import bisect, insort\n \n \ndef getNumOfInversions(A):\n    N = len(A)\n    if N <= 1:\n        return 0\n \n    sortList = []\n    result = 0\n \n    # Heapsort, O(N*log(N))\n    for i, v in enumerate(A):\n        heappush(sortList, (v, i))\n \n    # Create a sorted list of indexes\n    x = []\n    while sortList:\n       \n        # O(log(N))\n        v, i = heappop(sortList)\n         \n        # Find the current minimum's index\n        # the index y can represent how many minimums on the left\n        y = bisect(x, i)\n         \n        # i can represent how many elements on the left\n        # i - y can find how many bigger nums on the left\n        result += i - y\n \n        insort(x, i)\n \n    return result\n \n# Driver Code\nif __name__ == '__main__':\n    A = [1, 20, 6, 4, 5]\n    result = getNumOfInversions(A)\n    print(f'Number of inversions are {result}')\n"], "Find all triplets with zero sum -  ": ["# A simple Python 3 program\n# to find three elements whose\n# sum is equal to zero\n \n# Prints all triplets in\n# arr[] with 0 sum\n \n \ndef findTriplets(arr, n):\n \n    found = False\n    for i in range(0, n-2):\n \n        for j in range(i+1, n-1):\n \n            for k in range(j+1, n):\n \n                if (arr[i] + arr[j] + arr[k] == 0):\n                    print(arr[i], arr[j], arr[k])\n                    found = True\n \n    # If no triplet with 0 sum\n    # found in array\n    if (found == False):\n        print(' not exist ')\n \n \n# Driver code\narr = [0, -1, 2, -3, 1]\nn = len(arr)\nfindTriplets(arr, n)\n \n# This code is contributed by Smitha Dinesh Semwal\n", "# Python3 program to find triplets\n# in a given array whose sum is zero\n \n# function to print triplets with 0 sum\n \n \ndef findTriplets(arr, n):\n    found = False\n    for i in range(n - 1):\n \n        # Find all pairs with sum\n        # equals to '-arr[i]'\n        s = set()\n        for j in range(i + 1, n):\n            x = -(arr[i] + arr[j])\n            if x in s:\n                print(x, arr[i], arr[j])\n                found = True\n            else:\n                s.add(arr[j])\n    if found == False:\n        print('No Triplet Found')\n \n \n# Driver Code\narr = [0, -1, 2, -3, 1]\nn = len(arr)\nfindTriplets(arr, n)\n \n# This code is contributed by Shrikant13\n", "# python program to find triplets in a given\n# array whose sum is zero\n \n# function to print triplets with 0 sum\n \n \ndef findTriplets(arr, n):\n \n    found = False\n \n    # sort array elements\n    arr.sort()\n \n    for i in range(0, n-1):\n \n        # initialize left and right\n        l = i + 1\n        r = n - 1\n        x = arr[i]\n        while (l < r):\n \n            if (x + arr[l] + arr[r] == 0):\n                # print elements if it's sum is zero\n                print(x, arr[l], arr[r])\n                l += 1\n                r -= 1\n                found = True\n \n            # If sum of three elements is less\n            # than zero then increment in left\n            elif (x + arr[l] + arr[r] < 0):\n                l += 1\n \n            # if sum is greater than zero then\n            # decrement in right side\n            else:\n                r -= 1\n \n    if (found == False):\n        print(' No Triplet Found')\n \n \n# Driven source\narr = [0, -1, 2, -3, 1]\nn = len(arr)\nfindTriplets(arr, n)\n \n# This code is contributed by Smitha Dinesh Semwal\n"], "Floor in a Sorted Array -  ": ["# Python3 program to find floor of a\n# given number in a sorted array\n \n# Function to get index of floor\n# of x in arr[low..high]\n \n \ndef floorSearch(arr, n, x):\n    # If last element is smaller than x\n    if (x >= arr[n - 1]):\n        return n - 1\n \n    # If first element is greater than x\n    if (x < arr[0]):\n        return -1\n \n    # Linearly search for the first element\n    # greater than x\n    for i in range(1, n):\n        if (arr[i] > x):\n            return (i - 1)\n \n    return -1\n \n \n# Driver Code\narr = [1, 2, 4, 6, 10, 12, 14]\nn = len(arr)\nx = 7\nindex = floorSearch(arr, n-1, x)\n \nif (index == -1):\n    print('Floor of', x, 'doesn't exist \\\n                    in array ', end='')\nelse:\n    print('Floor of', x, 'is', arr[index])\n \n# This code is contributed by Smitha Dinesh Semwal.\n", "# Python3 program to find floor of a\n# given number in a sorted array\n \n# Function to get index of floor\n# of x in arr[low..high]\n \n \ndef floorSearch(arr, low, high, x):\n \n    # If low and high cross each other\n    if (low > high):\n        return -1\n \n    # If last element is smaller than x\n    if (x >= arr[high]):\n        return high\n \n    # Find the middle point\n    mid = int((low + high) / 2)\n \n    # If middle point is floor.\n    if (arr[mid] == x):\n        return mid\n \n    # If x lies between mid-1 and mid\n    if (mid > 0 and arr[mid-1] <= x\n            and x < arr[mid]):\n        return mid - 1\n \n    # If x is smaller than mid,\n    # floor must be in left half.\n    if (x < arr[mid]):\n        return floorSearch(arr, low, mid-1, x)\n \n    # If mid-1 is not floor and x is greater than\n    # arr[mid],\n    return floorSearch(arr, mid + 1, high, x)\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [1, 2, 4, 6, 10, 12, 14]\n    n = len(arr)\n    x = 7\n \n    # Function call\n    index = floorSearch(arr, 0, n-1, x)\n \n    if (index == -1):\n        print('Floor of', x, 'doesn't exist\\\n                      in array ', end='')\n    else:\n        print('Floor of', x, 'is', arr[index])\n \n# This code is contributed by Smitha Dinesh Semwal.\n"], "Check if an array contains all elements of a given range -  ": ["# Python code for the following approach\nimport collections\n \n# function that check all elements between A and B\n# including them are present in set or not\ndef checkElements(arr, n, A, B):\n    st = set()\n \n    # put all the elements of array into set\n    for i in range(n):\n        st.add(arr[i])\n \n    # now check every between between A to B including\n    # them also, that they are present in set or not\n    for i in range(A, B+1):\n        # element not present in set so return false\n        # and no need to traverse further\n        if i not in st:\n            return False\n \n    # all elements between A and B including them are\n    # present in set so return true\n    return True\n \n# Driver code\nif __name__ == '__main__':\n   \n    # Defining Array and size\n    arr = [1, 4, 5, 2, 7, 8, 3]\n    n = len(arr)\n     \n    # A is lower limit and B is the upper limit\n    # of range\n    A = 2\n    B = 5\n     \n    # True denotes all elements were present\n    if checkElements(arr, n, A, B):\n        print('Yes')\n         \n    # False denotes any element was not present\n    else:\n        print('No')\n", "# Function to check the array for \n# elements in given range \ndef check_elements(arr, n, A, B) :\n     \n    # Range is the no. of elements \n    # that are to be checked \n    rangeV = B - A \n     \n    # Traversing the array \n    for i in range(0, n): \n     \n        # If an element is in range \n        if (abs(arr[i]) >= A and\n            abs(arr[i]) <= B) : \n     \n            # Negating at index \u2018element \u2013 A\u2019 \n            z = abs(arr[i]) - A \n            if (arr[z] > 0) : \n                arr[z] = arr[z] * -1\n             \n    # Checking whether elements in \n    # range 0-range are negative \n    count = 0\n    for i in range(0, rangeV + 1): \n        if i >= n:\n            break\n             \n        # Element from range is\n        # missing from array\n        if (arr[i] > 0): \n            return False\n        else:\n            count = count + 1\n     \n    if(count != (rangeV + 1)): \n        return False\n         \n    # All range elements are present \n    return True\n \n# Driver code \n \n# Defining Array and size \narr = [ 1, 4, 5, 2, 7, 8, 3 ] \nn = len(arr) \n     \n# A is lower limit and B is \n# the upper limit of range \nA = 2\nB = 5\n     \n# True denotes all elements \n# were present \nif (check_elements(arr, n, A, B)) :\n    print('Yes') \n     \n# False denotes any element \n# was not present \nelse:\n    print('No') \n \n# This code is contributed \n# by Yatin Gupta\n"], "Find the row with maximum number of 1s -  ": ["# Python implementation of the approach\nR,C = 4,4\n \n# Function to find the index of first index \n# of 1 in a boolean array arr \ndef first(arr , low , high): \n \n    if(high >= low): \n \n        # Get the middle index \n        mid = low + (high - low)//2\n     \n        # Check if the element at middle index is first 1 \n        if ( ( mid == 0 or arr[mid-1] == 0) and arr[mid] == 1): \n            return mid \n     \n        # If the element is 0, recur for right side \n        elif (arr[mid] == 0): \n            return first(arr, (mid + 1), high); \n         \n        # If element is not first 1, recur for left side \n        else:\n            return first(arr, low, (mid -1)); \n \n    return -1\n \n# Function that returns index of row \n# with maximum number of 1s. \ndef rowWithMax1s(mat): \n \n    # Initialize max values \n    max_row_index,Max = 0,-1\n \n    # Traverse for each row and count number of 1s \n    # by finding the index of first 1 \n    for i in range(R):\n \n        index = first (mat[i], 0, C-1)\n        if (index != -1 and C-index > Max):\n            Max = C - index; \n            max_row_index = i\n \n    return max_row_index \n \n# Driver Code\nmat = [[0, 0, 0, 1], \n       [0, 1, 1, 1], \n       [1, 1, 1, 1], \n       [0, 0, 0, 0]]\nprint('Index of row with maximum 1s is ' + str(rowWithMax1s(mat)))\n \n# This code is contributed by shinjanpatra\n", "# Python3 program to find the row\n# with maximum number of 1s\n \n# Function to find the index\n# of first index of 1 in a\n# boolean array arr[]\n \n \ndef first(arr, low, high):\n    if high >= low:\n \n        # Get the middle index\n        mid = low + (high - low)//2\n \n        # Check if the element at\n        # middle index is first 1\n        if (mid == 0 or arr[mid - 1] == 0) and arr[mid] == 1:\n            return mid\n \n        # If the element is 0,\n        # recur for right side\n        elif arr[mid] == 0:\n            return first(arr, (mid + 1), high)\n \n        # If element is not first 1,\n        # recur for left side\n        else:\n            return first(arr, low, (mid - 1))\n    return -1\n \n# Function that returns\n# index of row with maximum\n# number of 1s.\n \n \ndef rowWithMax1s(mat):\n \n    # Initialize max values\n    R = len(mat)\n    C = len(mat[0])\n    max_row_index = 0\n    max = -1\n \n    # Traverse for each row and\n    # count number of 1s by finding\n    #  the index of first 1\n    for i in range(0, R):\n        index = first(mat[i], 0, C - 1)\n        if index != -1 and C - index > max:\n            max = C - index\n            max_row_index = i\n \n    return max_row_index\n \n \n# Driver Code\nmat = [[0, 0, 0, 1],\n       [0, 1, 1, 1],\n       [1, 1, 1, 1],\n       [0, 0, 0, 0]]\nprint('Index of row with maximum 1s is',\n      rowWithMax1s(mat))\n \n# This code is contributed\n# by shreyanshi_arun\n", "# The main function that returns index\n# of row with maximum number of 1s.\n \n \ndef rowWithMax1s(mat):\n \n    # Initialize max using values from first row.\n    max_row_index = 0\n    max = first(mat[0], 0, C - 1)\n \n    # Traverse for each row and count number of 1s\n    # by finding the index of first 1\n    for i in range(1, R):\n \n        # Count 1s in this row only if this row\n        # has more 1s than max so far\n \n        # Count 1s in this row only if this row\n        # has more 1s than max so far\n        if (max != -1 and mat[i][C - max - 1] == 1):\n \n            # Note the optimization here also\n            index = first(mat[i], 0, C - max)\n \n            if (index != -1 and C - index > max):\n                max = C - index\n                max_row_index = i\n        else:\n            max = first(mat[i], 0, C - 1)\n \n    return max_row_index\n \n# This code is contributed by Dharanendra L V\n", "# Python3 program to find the row\n# with maximum number of 1s\n \n# Function that returns\n# index of row with maximum\n# number of 1s.\n \n \ndef rowWithMax1s(mat):\n \n    # Initialize max values\n    R = len(mat)\n    C = len(mat[0])\n    max_row_index = 0\n    index = C-1\n    # Traverse for each row and\n    # count number of 1s by finding\n    # the index of first 1\n    for i in range(0, R):\n        flag = False  # to check whether a row has more 1's than previous\n        while(index >= 0 and mat[i][index] == 1):\n            flag = True  # present row has more 1's than previous\n            index -= 1\n            if(flag):  # if the present row has more 1's than previous\n                max_row_index = i\n        if max_row_index == 0 and mat[0][C-1] == 0:\n            return 0\n    return max_row_index\n \n \n# Driver Code\nmat = [[0, 0, 0, 1],\n       [0, 1, 1, 1],\n       [1, 1, 1, 1],\n       [0, 0, 0, 0]]\nprint('Index of row with maximum 1s is',\n      rowWithMax1s(mat))\n \n# This code is contributed\n# by Rishabh Chauhan\n"], "Median of two Sorted Arrays of Different Sizes -  ": ["# Python3 program for the above approach\ndef Solution(arr):\n \n    n = len(arr)\n \n    # If length of array is even\n    if n % 2 == 0:\n        z = n // 2\n        e = arr[z]\n        q = arr[z - 1]\n        ans = (e + q) / 2\n        return ans\n \n    # If length of array is odd\n    else:\n        z = n // 2\n        ans = arr[z]\n        return ans\n \n \n# Driver code\nif __name__ == '__main__':\n \n    arr1 = [-5, 3, 6, 12, 15]\n    arr2 = [-12, -10, -6, -3, 4, 10]\n \n    # Concatenating the two arrays\n    arr3 = arr1 + arr2\n \n    # Sorting the resultant array\n    arr3.sort()\n \n    print('Median = ', Solution(arr3))\n \n# This code is contributed by kush11\n", "# A Simple Merge based O(n) solution to find\n# median of two sorted arrays\n \n''' This function returns median of ar1[] and ar2[]. \nAssumption in this function: \nBoth ar1[] and ar2[] are sorted arrays '''\n \n \ndef getMedian(ar1, ar2, n, m):\n \n    i = 0  # Current index of input array ar1[]\n    j = 0  # Current index of input array ar2[]\n    m1, m2 = -1, -1\n    for count in range(((n + m) // 2) + 1):\n        if(i != n and j != m):\n            if ar1[i] > ar2[j]:\n                m1 = ar2[j]\n                j += 1\n            else:\n                m1 = ar1[i]\n                i += 1\n        elif(i < n):\n            m1 = ar1[i]\n            i += 1\n            # for case when j<m,\n        else:\n            m1 = ar2[j]\n            j += 1\n           # return m1 if it's length odd else return (m1+m2)//2\n    return m1 if (n + m) % 2 == 1 else (m1 + m2) // 2\n \n \n# Driver code\nar1 = [900]\nar2 = [5, 8, 10, 20]\n \nn1 = len(ar1)\nn2 = len(ar2)\nprint(getMedian(ar1, ar2, n1, n2))\n \n# This code is contributed by divyesh072019\n", "class Solution:\n \n    # Method to find median\n    def Median(self, A, B):\n \n          # Assumption both A and B cannot be empty\n        n = len(A)\n        m = len(B)\n        if (n > m):\n            return self.Median(B, A)  # Swapping to make A smaller\n \n        start = 0\n        end = n\n        realmidinmergedarray = (n + m + 1) // 2\n \n        while (start <= end):\n            mid = (start + end) // 2\n            leftAsize = mid\n            leftBsize = realmidinmergedarray - mid\n \n            # checking overflow of indices\n            leftA = A[leftAsize - 1] if (leftAsize > 0) else float('-inf')\n            leftB = B[leftBsize - 1] if (leftBsize > 0) else float('-inf')\n            rightA = A[leftAsize] if (leftAsize < n) else float('inf')\n            rightB = B[leftBsize] if (leftBsize < m) else float('inf')\n \n            # if correct partition is done\n            if leftA <= rightB and leftB <= rightA:\n                if ((m + n) % 2 == 0):\n                    return (max(leftA, leftB) + min(rightA, rightB)) / 2.0\n                return max(leftA, leftB)\n \n            elif (leftA > rightB):\n                end = mid - 1\n            else:\n                start = mid + 1\n \n \n# Driver code\nans = Solution()\narr1 = [-5, 3, 6, 12, 15]\narr2 = [-12, -10, -6, -3, 4, 10]\nprint('Median of the two arrays is')\nprint(ans.Median(arr1, arr2))\n \n# This code is contributed by Arpan\n", "# Python code for the above approach\n \nimport heapq\n \n \ndef Median(A, B):\n    n, m = len(A), len(B)\n    # initializing Priority Queue (Min Heap)\n    pq = []\n    # pushing array A values to priority Queue\n    for i in range(n):\n        heapq.heappush(pq, A[i])\n    # pushing array B values to priority Queue\n    for i in range(m):\n        heapq.heappush(pq, B[i])\n    check = n + m\n    count = -1\n    mid1, mid2 = -1, -1\n    while pq:\n        count += 1\n        # returning mid value if combined length(n+m) is odd\n        if check % 2 != 0 and count == check // 2:\n            return pq[0]\n        # maintaining mid1 value if combined length(n+m) is even\n        # where we need to maintain both mid values in case of\n        # even combined length\n        if check % 2 == 0 and count == (check // 2) - 1:\n            mid1 = pq[0]\n        # now returning the mid2 value with previous maintained\n        # mid1 value by 2\n        if check % 2 == 0 and count == check // 2:\n            mid2 = heapq.heappop(pq)\n            return (mid1 + mid2) / 2\n        heapq.heappop(pq)\n    return 0.00000\n \n \n# Driver code\narr1 = [-2, 3, 4, 5]\narr2 = [-4, -1, 7, 8, 9]\n \nprint('Median of the two arrays are')\nprint(Median(arr1, arr2))\n \n# This code is contributed by karthik\n"], "Find next greater number with same set of digits -  ": ["# Python program to find the smallest number which  \n# is greater than a given no. has same set of  \n# digits as given number \n  \n# Given number as int array, this function finds the  \n# greatest number and returns the number as integer \ndef findNext(number,n): \n       \n     # Start from the right most digit and find the first \n     # digit that is smaller than the digit next to it \n     for i in range(n-1,0,-1): \n         if number[i] > number[i-1]: \n             break\n               \n     # If no such digit found,then all numbers are in  \n     # descending order, no greater number is possible \n     if i == 1 and number[i] <= number[i-1]: \n         print ('Next number not possible') \n         return\n           \n     # Find the smallest digit on the right side of  \n     # (i-1)'th digit that is greater than number[i-1] \n     x = number[i-1] \n     smallest = i \n     for j in range(i+1,n): \n         if number[j] > x and number[j] < number[smallest]: \n             smallest = j \n           \n     # Swapping the above found smallest digit with (i-1)'th \n     number[smallest],number[i-1] = number[i-1], number[smallest] \n       \n     # X is the final number, in integer datatype  \n     x = 0\n     # Converting list upto i-1 into number \n     for j in range(i): \n         x = x * 10 + number[j] \n       \n     # Sort the digits after i-1 in ascending order \n     number = sorted(number[i:]) \n     # converting the remaining sorted digits into number \n     for j in range(n-i): \n         x = x * 10 + number[j] \n       \n     print ('Next number with set of digits is',x) \n  \n  \n# Driver Program to test above function \ndigits = '534976'         \n  \n# converting into integer array, \n# number becomes [5,3,4,9,7,6] \nnumber = list(map(int ,digits)) \nfindNext(number, len(digits)) \n  \n# This code is contributed by Harshit Agrawal \n", "# A python program to find the next greatest number \ndef nextPermutation(arr): \n    \n      # find the length of the array \n    n = len(arr) \n      \n    # start from the right most digit and find the first \n    # digit that is smaller than the digit next to it. \n    k = n - 2\n    while k >= 0: \n        if arr[k] < arr[k + 1]: \n            break\n        k -= 1\n          \n    # reverse the list if the digit that is smaller than the \n    # digit next to it is not found. \n    if k < 0: \n        arr = arr[::-1] \n    else: \n        \n          # find the first greatest element than arr[k] from the  \n        # end of the list \n        for l in range(n - 1, k, -1): \n            if arr[l] > arr[k]: \n                break\n  \n        # swap the elements at arr[k] and arr[l       \n        arr[l], arr[k] = arr[k], arr[l] \n          \n        # reverse the list from k + 1 to the end to find the  \n        # most nearest greater number to the given input number \n        arr[k + 1:] = reversed(arr[k + 1:]) \n  \n    return arr \n  \n# Driver code \narr = [5, 3, 4, 9, 7, 6] \nprint(*nextPermutation(arr)) \n  \n# This code is contributed by Manish Thapa \n"], "Koko Eating Bananas -  ": ["# Python implementation for the above approach\ndef check(bananas, mid_val, H):\n  time = 0;\n  for i in range(len(bananas)):\n     \n    # to get the ceil value\n    if (bananas[i] % mid_val != 0):\n       \n      # in case of odd number\n      time += bananas[i] // mid_val + 1;\n    else:\n       \n      # in case of even number\n      time += bananas[i] // mid_val\n \n  # check if time is less than\n  # or equals to given hour\n  if (time <= H):\n    return True;\n  else:\n    return False;\n   \ndef minEatingSpeed(piles, H):\n  # as minimum speed of eating must be 1\n  start = 1;\n \n  # Maximum speed of eating\n  # is the maximum bananas in given piles\n  end = sorted(piles.copy(), reverse=True)[0]\n \n  while (start < end):\n    mid = start + (end - start) // 2;\n \n    # Check if the mid(hours) is valid\n    if (check(piles, mid, H) == True):\n       \n      # If valid continue to search\n      # lower speed\n      end = mid;\n    else:\n       \n      # If cant finish bananas in given\n      # hours, then increase the speed\n      start = mid + 1;\n  return end;\n \n# Driver code\npiles = [30, 11, 23, 4, 20];\nH = 6;\nprint(minEatingSpeed(piles, H));\n \n# This code is contributed by gfgking.\n"], "Minimum number of times A has to be repeated such that B is a substring of it -  ": ["# Python3 program to find minimum number\n# of times 'A' has to be repeated\n# such that 'B' is a substring of it\n \n# Method to find Minimum number \n# of times 'A' has to be repeated \n# such that 'B' is a substring of it\ndef min_repetitions(a, b):\n    len_a = len(a)\n    len_b = len(b)\n     \n    for i in range(0, len_a):\n         \n        if a[i] == b[0]:\n            k = i\n            count = 1\n            for j in range(0, len_b):\n                 \n                # we are reiterating over A again and \n                # again for each value of B \n                # Resetting A pointer back to 0 as B \n                # is not empty yet\n                if k >= len_a:\n                    k = 0\n                    count = count + 1\n                     \n                # Resetting A means count \n                # needs to be increased\n                if a[k] != b[j]:\n                    break\n                k = k + 1\n                 \n            # k is iterating over A\n            else:\n                return count\n    return -1\n \n# Driver Code\nA = 'abcd'\nB = 'cdabcdab'\nprint(min_repetitions(A, B))\n \n# This code is contributed by satycool\n"], "The Painter's Partition Problem -  ": ["# Python program for The painter's\n# partition problem function to\n# calculate sum between two indices\n# in array\n \n \ndef sum(arr, frm, to):\n    total = 0\n    for i in range(frm, to + 1):\n        total += arr[i]\n    return total\n \n# for n boards and k partitions\n \n \ndef partition(arr, n, k):\n \n    # base cases\n    if k == 1:  # one partition\n        return sum(arr, 0, n - 1)\n    if n == 1:  # one board\n        return arr[0]\n    best = 100000000\n \n    # find minimum of all possible\n    # maximum k-1 partitions to\n    # the left of arr[i], with i\n    # elements, put k-1 th divider\n    # between arr[i-1] & arr[i] to\n    # get k-th partition\n    for i in range(1, n + 1):\n        best = min(best,\n                   max(partition(arr, i, k - 1),\n                       sum(arr, i, n - 1)))\n    return best\n \n \n# Driver Code\narr = [10, 20, 60, 50, 30, 40]\nn = len(arr)\nk = 3\nprint(partition(arr, n, k))\n \n# This code is contributed\n# by sahilshelangia\n", "# A DP based Python3 program for\n# painter's partition problem\n \n# function to calculate sum between\n# two indices in list\n \n \ndef sum(arr, start, to):\n    total = 0\n    for i in range(start, to + 1):\n        total += arr[i]\n    return total\n \n# bottom up tabular dp\n \n \ndef findMax(arr, n, k):\n \n    # initialize table\n    dp = [[0 for i in range(n + 1)]\n          for j in range(k + 1)]\n \n    # base cases\n    # k=1\n    for i in range(1, n + 1):\n        dp[1][i] = sum(arr, 0, i - 1)\n \n    # n=1\n    for i in range(1, k + 1):\n        dp[i][1] = arr[0]\n \n    # 2 to k partitions\n    for i in range(2, k + 1):  # 2 to n boards\n        for j in range(2, n + 1):\n \n            # track minimum\n            best = 100000000\n \n            # i-1 th separator before position arr[p=1..j]\n            for p in range(1, j + 1):\n                best = min(best, max(dp[i - 1][p],\n                                     sum(arr, p, j - 1)))\n \n            dp[i][j] = best\n \n    # required\n    return dp[k][n]\n \n \n# Driver Code\narr = [10, 20, 60, 50, 30, 40]\nn = len(arr)\nk = 3\nprint(findMax(arr, n, k))\n \n# This code is contributed by ashutosh450\n", "sum = [0] * (n + 1)\n \n# sum from 1 to i elements of arr\nfor i in range(1, n + 1):\n    sum[i] = sum[i-1] + arr[i-1]\n \nfor i in range(1, n + 1):\n    dp[1][i] = sum[i]\n \n# and using it to calculate the result as:\nbest = min(best, max(dp[i-1][p], sum[j] - sum[p]))\n \n# This code is contributed by kraanzu.\n", "for i range(k-1, n+1):\n    best = min(best, max(partition(arr, i, k-1), sum(arr, i, n-1)))\n \n# This code is contributed by Aman Kumar.\n"], "Search an element in a sorted and rotated Array -  ": ["# Python Program to search an element\n# in a sorted and pivoted array\n \n# Searches an element key in a pivoted\n# sorted array arrp[] of size n\ndef pivotedBinarySearch(arr, n, key):\n \n    pivot = findPivot(arr, 0, n-1)\n \n    # If we didn't find a pivot,\n    # then array is not rotated at all\n    if pivot == -1:\n        return binarySearch(arr, 0, n-1, key)\n \n    # If we found a pivot, then first\n    # compare with pivot and then\n    # search in two subarrays around pivot\n    if arr[pivot] == key:\n        return pivot\n    if arr[0] <= key:\n        return binarySearch(arr, 0, pivot-1, key)\n    return binarySearch(arr, pivot + 1, n-1, key)\n \n \n# Function to get pivot. For array\n# 3, 4, 5, 6, 1, 2 it returns 3\n# (index of 6)\ndef findPivot(arr, low, high):\n \n    # base cases\n    if high < low:\n        return -1\n    if high == low:\n        return low\n \n    # low + (high - low)/2;\n    mid = int((low + high)/2)\n \n    if mid < high and arr[mid] > arr[mid + 1]:\n        return mid\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return (mid-1)\n    if arr[low] >= arr[mid]:\n        return findPivot(arr, low, mid-1)\n    return findPivot(arr, mid + 1, high)\n \n# Standard Binary Search function\ndef binarySearch(arr, low, high, key):\n \n    if high < low:\n        return -1\n \n    # low + (high - low)/2;\n    mid = int((low + high)/2)\n \n    if key == arr[mid]:\n        return mid\n    if key > arr[mid]:\n        return binarySearch(arr, (mid + 1), high,\n                            key)\n    return binarySearch(arr, low, (mid - 1), key)\n \n \n# Driver program to check above functions\n# Let us search 3 in below array\nif __name__ == '__main__':\n    arr1 = [5, 6, 7, 8, 9, 10, 1, 2, 3]\n    n = len(arr1)\n    key = 3\n    print('Index of the element is : ', \\\n          pivotedBinarySearch(arr1, n, key))\n \n# This is contributed by Smitha Dinesh Semwal\n", "# Search an element in sorted and rotated array using\n# single pass of Binary Search\n \n# Returns index of key in arr[l..h] if key is present,\n# otherwise returns -1\ndef search(arr, l, h, key):\n    if l > h:\n        return -1\n \n    mid = (l + h) // 2\n    if arr[mid] == key:\n        return mid\n \n    # If arr[l...mid] is sorted\n    if arr[l] <= arr[mid]:\n \n        # As this subarray is sorted, we can quickly\n        # check if key lies in half or other half\n        if key >= arr[l] and key <= arr[mid]:\n            return search(arr, l, mid-1, key)\n        return search(arr, mid + 1, h, key)\n \n    # If arr[l..mid] is not sorted, then arr[mid... r]\n    # must be sorted\n    if key >= arr[mid] and key <= arr[h]:\n        return search(arr, mid + 1, h, key)\n    return search(arr, l, mid-1, key)\n \n \n# Driver program\nif __name__ == '__main__':\n    arr = [4, 5, 6, 7, 8, 9, 1, 2, 3]\n    key = 3\n    i = search(arr, 0, len(arr)-1, key)\n    if i != -1:\n        print('Index: % d' % i)\n    else:\n        print('Key not found')\n \n# This code is contributed by Shreyanshi Arun\n", "def search_rotated_array(arr, key):\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == key:\n            return i\n    return -1\n \narr = [5, 6, 7, 8, 9, 10, 1, 2, 3]\nkey = 3\nindex = search_rotated_array(arr, key)\nif index != -1:\n    print(f'Found at index {index}')\nelse:\n    print('Not found')\n"], "K\u2019th Smallest/Largest Element in Unsorted Array -  ": ["# Python3 program to find K'th smallest\n# element\n \n# Function to return K'th smallest\n# element in a given array\n \n \ndef kthSmallest(arr, N, K):\n \n    # Sort the given array\n    arr.sort()\n \n    # Return k'th element in the\n    # sorted array\n    return arr[K-1]\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [12, 3, 5, 7, 19]\n    N = len(arr)\n    K = 2\n \n    # Function call\n    print('K'th smallest element is',\n          kthSmallest(arr, N, K))\n \n# This code is contributed by\n# Shrikant13\n", "# Python3 code for kth smallest element in an array\n \nimport sys\n \n# function to calculate number of elements\n# less than equal to mid\n \n \ndef count(nums, mid):\n    cnt = 0\n    for i in range(len(nums)):\n        if nums[i] <= mid:\n            cnt += 1\n    return cnt\n \n \ndef kthSmallest(nums, k):\n    low = sys.maxsize\n    high = -sys.maxsize - 1\n \n    # calculate minimum and maximum the array.\n    for i in range(len(nums)):\n        low = min(low, nums[i])\n        high = max(high, nums[i])\n \n        # Our answer range lies between minimum and maximum element\n        # of the array on which Binary Search is Applied\n    while low < high:\n        mid = low + (high - low) // 2\n        # if the count of number of elements in the array less than equal\n        # to mid is less than k then increase the number. Otherwise decrement\n        # the number and try to find a better answer.\n        if count(nums, mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n \n \n# Driver's code\nif __name__ == '__main__':\n    nums = [1, 4, 5, 3, 19, 3]\n    k = 3\n \n    # Function call\n    print('K'th smallest element is', kthSmallest(nums, k))\n \n# This code is contributed by Tapesh(tapeshdua420)\n", "import heapq\n \n# Function to find the kth smallest array element\ndef kthSmallest(arr, K):\n    # Create a max heap (priority queue)\n    max_heap = []\n \n    # Iterate through the array elements\n    for num in arr:\n        # Push the negative of the current element onto the max heap\n        heapq.heappush(max_heap, -num)\n \n        # If the size of the max heap exceeds K, remove the largest element\n        if len(max_heap) > K:\n            heapq.heappop(max_heap)\n \n    # Return the Kth smallest element (top of the max heap, negated)\n    return -max_heap[0]\n \n# Driver's code:\nif __name__ == '__main__':\n    arr = [10, 5, 4, 3, 48, 6, 2, 33, 53, 10]\n    K = 4\n \n    # Function call\n    print('Kth Smallest Element is:', kthSmallest(arr, K))\n", "# Python3 code for the above approach\n \n# This function returns k'th smallest element\n# in arr[l..r] using QuickSort based method.\n# ASSUMPTION: ALL ELEMENTS IN ARR[] ARE DISTINCT\nimport sys\n \n \ndef kthSmallest(arr, l, r, K):\n \n    # If k is smaller than number of\n    # elements in array\n    if (K > 0 and K <= r - l + 1):\n \n        # Partition the array around last\n        # element and get position of pivot\n        # element in sorted array\n        pos = partition(arr, l, r)\n \n        # If position is same as k\n        if (pos - l == K - 1):\n            return arr[pos]\n        if (pos - l > K - 1):  # If position is more,\n                              # recur for left subarray\n            return kthSmallest(arr, l, pos - 1, K)\n \n        # Else recur for right subarray\n        return kthSmallest(arr, pos + 1, r,\n                           K - pos + l - 1)\n \n    # If k is more than number of\n    # elements in array\n    return sys.maxsize\n \n# Standard partition process of QuickSort().\n# It considers the last element as pivot and\n# moves all smaller element to left of it\n# and greater elements to right\n \n \ndef partition(arr, l, r):\n \n    x = arr[r]\n    i = l\n    for j in range(l, r):\n        if (arr[j] <= x):\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    arr[i], arr[r] = arr[r], arr[i]\n    return i\n \n \n# Driver's Code\nif __name__ == '__main__':\n \n    arr = [12, 3, 5, 7, 4, 19, 26]\n    N = len(arr)\n    K = 3\n    print('K'th smallest element is',\n          kthSmallest(arr, 0, N - 1, K))\n \n# This code is contributed by ita_c\n", "# Python3 code for kth smallest element in an array\n \n# function returns the kth smallest element in an array\ndef kth_smallest(arr, k):\n    # First, find the maximum element in the array\n    max_element = max(arr)\n \n    # Create a dictionary to store the frequency of each \n    # element in the input array\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n \n    # Keep track of the cumulative frequency of elements \n    # in the input array\n    count = 0\n    for i in range(max_element + 1):\n        if i in freq:\n            count += freq[i]\n            if count >= k:\n                # If we have seen k or more elements, \n                # return the current element\n                return i\n \n    return -1\n \n# Driver Code\narr = [12, 3, 5, 7, 19]\nk = 2\nprint('The', k,'th smallest element is', kth_smallest(arr, k))\n"], "Sliding Window Maximum (Maximum of all subarrays of size K) -  ": ["# Python3 program for the above approach\n \n# Method to find the maximum for each\n# and every contiguous subarray\n# of size K\n \ndef printMax(arr, N, K):\n    max = 0\n \n    for i in range(N - K + 1):\n        max = arr[i]\n        for j in range(1, K):\n            if arr[i + j] > max:\n                max = arr[i + j]\n        print(str(max) + ' ', end='')\n \n \n# Driver's code\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    N = len(arr)\n    K = 3\n     \n    # Function call\n    printMax(arr, N, K)\n \n# This code is contributed by Shiv Shankar\n", "import heapq\n \n \ndef max_sliding_window(arr, k):\n    ans = []\n    heap = []\n \n    # Initialize the heap with the first k elements\n    for i in range(k):\n        heapq.heappush(heap, (-arr[i], i))\n \n    # The maximum element in the first window\n    ans.append(-heap[0][0])\n \n    # Process the remaining elements\n    for i in range(k, len(arr)):\n        heapq.heappush(heap, (-arr[i], i))\n \n        # Remove elements that are outside the current window\n        while heap[0][1] <= i - k:\n            heapq.heappop(heap)\n \n        # The maximum element in the current window\n        ans.append(-heap[0][0])\n \n    return ans\n \n \narr = [2, 3, 7, 9, 5, 1, 6, 4, 3]\nk = 3\n \n# Find the maximum element in each sliding window of size k\nresult = max_sliding_window(arr, k)\n \n# Print the results\nfor num in result:\n    print(num, end=' ')\n", "# Python3 program to find the maximum for\n# each and every contiguous subarray of\n# size K\n \nfrom collections import deque\n \n# A Deque (Double ended queue) based\n# method for printing maximum element\n# of all subarrays of size K\n \n \ndef printMax(arr, N, K):\n    ''' Create a Double Ended Queue, Qi that \n    will store indexes of array elements. \n    The queue will store indexes of useful \n    elements in every window and it will\n    maintain decreasing order of values from\n    front to rear in Qi, i.e., arr[Qi.front[]]\n    to arr[Qi.rear()] are sorted in decreasing\n    order'''\n    Qi = deque()\n \n    # Process first k (or first window)\n    # elements of array\n    for i in range(K):\n \n        # For every element, the previous\n        # smaller elements are useless\n        # so remove them from Qi\n        while Qi and arr[i] >= arr[Qi[-1]]:\n            Qi.pop()\n \n        # Add new element at rear of queue\n        Qi.append(i)\n \n    # Process rest of the elements, i.e.\n    # from arr[k] to arr[n-1]\n    for i in range(K, N):\n \n        # The element at the front of the\n        # queue is the largest element of\n        # previous window, so print it\n        print(str(arr[Qi[0]]) + ' ', end='')\n \n        # Remove the elements which are\n        # out of this window\n        while Qi and Qi[0] <= i-K:\n \n            # remove from front of deque\n            Qi.popleft()\n \n        # Remove all elements smaller than\n        # the currently being added element\n        # (Remove useless elements)\n        while Qi and arr[i] >= arr[Qi[-1]]:\n            Qi.pop()\n \n        # Add current element at the rear of Qi\n        Qi.append(i)\n \n    # Print the maximum element of last window\n    print(str(arr[Qi[0]]))\n \n \n# Driver's code\nif __name__ == '__main__':\n    arr = [12, 1, 78, 90, 57, 89, 56]\n    K = 3\n     \n    # Function call\n    printMax(arr, len(arr), K)\n \n# This code is contributed by Shiv Shankar\n"], "Minimum time required to rotten all oranges -  ": ["# Python3 program to rot all\n# oranges when you can move\n# in all the four direction\n# from a rotten orange\nR = 3\nC = 5\n \n# Check if i, j is under the\n# array limits of row and\n# column\n \n \ndef issafe(i, j):\n \n    if (i >= 0 and i < R and\n            j >= 0 and j < C):\n        return True\n    return False\n \n \ndef rotOranges(v):\n \n    changed = False\n    no = 2\n    while (True):\n        for i in range(R):\n            for j in range(C):\n \n                # Rot all other oranges\n                # present at (i+1, j),\n                # (i, j-1), (i, j+1),\n                # (i-1, j)\n                if (v[i][j] == no):\n                    if (issafe(i + 1, j) and\n                            v[i + 1][j] == 1):\n                        v[i + 1][j] = v[i][j] + 1\n                        changed = True\n \n                    if (issafe(i, j + 1) and\n                            v[i][j + 1] == 1):\n                        v[i][j + 1] = v[i][j] + 1\n                        changed = True\n \n                    if (issafe(i - 1, j) and\n                            v[i - 1][j] == 1):\n                        v[i - 1][j] = v[i][j] + 1\n                        changed = True\n \n                    if (issafe(i, j - 1) and\n                            v[i][j - 1] == 1):\n                        v[i][j - 1] = v[i][j] + 1\n                        changed = True\n \n        # if no rotten orange found\n        # it means all oranges rottened\n        # now\n        if (not changed):\n            break\n        changed = False\n        no += 1\n \n    for i in range(R):\n        for j in range(C):\n \n            # if any orange is found\n            # to be not rotten then\n            # ans is not possible\n            if (v[i][j] == 1):\n                return -1\n \n    # Because initial value\n    # for a rotten orange was 2\n    return no - 2\n \n \n# Driver function\nif __name__ == '__main__':\n \n    v = [[2, 1, 0, 2, 1],\n         [1, 0, 1, 2, 1],\n         [1, 0, 0, 2, 1]]\n \n    print('Max time incurred: ',\n          rotOranges(v))\n \n# This code is contributed by Chitranayal\n", "# Python3 program to find minimum time required to make all\n# oranges rotten\nfrom collections import deque\n \n# function to check whether a cell is valid / invalid\n \n \ndef isvalid(i, j):\n    return (i >= 0 and j >= 0 and i < 3 and j < 5)\n \n# Function to check whether the cell is delimiter\n# which is (-1, -1)\n \n \ndef isdelim(temp):\n    return (temp[0] == -1 and temp[1] == -1)\n \n# Function to check whether there is still a fresh\n# orange remaining\n \n \ndef checkall(arr):\n    for i in range(3):\n        for j in range(5):\n            if (arr[i][j] == 1):\n                return True\n    return False\n \n# This function finds if it is\n# possible to rot all oranges or not.\n# If possible, then it returns\n# minimum time required to rot all,\n# otherwise returns -1\n \n \ndef rotOranges(arr):\n \n    # Create a queue of cells\n    Q = deque()\n    temp = [0, 0]\n    ans = 1\n \n    # Store all the cells having\n    # rotten orange in first time frame\n    for i in range(3):\n        for j in range(5):\n            if (arr[i][j] == 2):\n                temp[0] = i\n                temp[1] = j\n                Q.append([i, j])\n \n    # Separate these rotten oranges\n    # from the oranges which will rotten\n    # due the oranges in first time\n    # frame using delimiter which is (-1, -1)\n    temp[0] = -1\n    temp[1] = -1\n    Q.append([-1, -1])\n    # print(Q)\n \n    # Process the grid while there are\n    # rotten oranges in the Queue\n    while False:\n \n        # This flag is used to determine\n        # whether even a single fresh\n        # orange gets rotten due to rotten\n        # oranges in current time\n        # frame so we can increase\n        # the count of the required time.\n        flag = False\n        print(len(Q))\n \n        # Process all the rotten\n        # oranges in current time frame.\n        while not isdelim(Q[0]):\n            temp = Q[0]\n            print(len(Q))\n \n            # Check right adjacent cell that if it can be rotten\n            if (isvalid(temp[0] + 1, temp[1]) and arr[temp[0] + 1][temp[1]] == 1):\n \n                # if this is the first orange to get rotten, increase\n                # count and set the flag.\n                if (not flag):\n                    ans, flag = ans + 1, True\n \n                # Make the orange rotten\n                arr[temp[0] + 1][temp[1]] = 2\n \n                # append the adjacent orange to Queue\n                temp[0] += 1\n                Q.append(temp)\n \n                temp[0] -= 1  # Move back to current cell\n \n            # Check left adjacent cell that if it can be rotten\n            if (isvalid(temp[0] - 1, temp[1]) and arr[temp[0] - 1][temp[1]] == 1):\n                if (not flag):\n                    ans, flag = ans + 1, True\n                arr[temp[0] - 1][temp[1]] = 2\n                temp[0] -= 1\n                Q.append(temp)  # append this cell to Queue\n                temp[0] += 1\n \n            # Check top adjacent cell that if it can be rotten\n            if (isvalid(temp[0], temp[1] + 1) and arr[temp[0]][temp[1] + 1] == 1):\n                if (not flag):\n                    ans, flag = ans + 1, True\n                arr[temp[0]][temp[1] + 1] = 2\n                temp[1] += 1\n                Q.append(temp)  # Push this cell to Queue\n                temp[1] -= 1\n \n            # Check bottom adjacent cell if it can be rotten\n            if (isvalid(temp[0], temp[1] - 1) and arr[temp[0]][temp[1] - 1] == 1):\n                if (not flag):\n                    ans, flag = ans + 1, True\n                arr[temp[0]][temp[1] - 1] = 2\n                temp[1] -= 1\n                Q.append(temp)  # append this cell to Queue\n            Q.popleft()\n \n        # Pop the delimiter\n        Q.popleft()\n \n        # If oranges were rotten in\n        # current frame than separate the\n        # rotten oranges using delimiter\n        # for the next frame for processing.\n        if (len(Q) == 0):\n            temp[0] = -1\n            temp[1] = -1\n            Q.append(temp)\n \n        # If Queue was empty than no rotten oranges left to process so exit\n \n    # Return -1 if all arranges could not rot, otherwise return ans.\n    return ans + 1 if(checkall(arr)) else -1\n \n \n# Driver program\nif __name__ == '__main__':\n    arr = [[2, 1, 0, 2, 1],\n           [1, 0, 1, 2, 1],\n           [1, 0, 0, 2, 1]]\n    ans = rotOranges(arr)\n    if (ans == -1):\n        print('All oranges cannot rotn')\n    else:\n        print('Time required for all oranges to rot => ', ans)\n \n        # This code is contributed by mohit kumar 29\n"], "Complete Tutorial on LRU Cache with Implementations -  ": ["# We can use stl container list as a double\n# ended queue to store the cache keys, with\n# the descending time of reference from front\n# to back and a set container to check presence\n# of a key. But to fetch the address of the key\n# in the list using find(), it takes O(N) time.\n# This can be optimized by storing a reference\n# (iterator) to each key in a hash map.\nclass LRUCache:\n    # store keys of cache\n    def __init__(self, n):\n        self.csize = n\n        self.dq = []\n        self.ma = {}\n \n \n    # Refers key x with in the LRU cache\n    def refer(self, x):\n         \n        #  not present in cache\n        if x not in self.ma.keys():\n            # cache is full\n            if len(self.dq) == self.csize:\n                # delete least recently used element\n                last = self.dq[-1]\n \n                # Pops the last element\n                ele = self.dq.pop();\n \n                # Erase the last\n                del self.ma[last]\n \n        # present in cache\n        else:\n            del self.dq[self.ma[x]]\n \n        # update reference\n        self.dq.insert(0, x)\n        self.ma[x] = 0;\n \n    # Function to display contents of cache\n    def display(self):\n \n        # Iterate in the deque and print\n        # all the elements in it\n        print(self.dq)\n \n# Driver Code\nca = LRUCache(4)\n \nca.refer(1)\nca.refer(2)\nca.refer(3)\nca.refer(1)\nca.refer(4)\nca.refer(5)\nca.display()\n# This code is contributed by Satish Srinivas\n"], "Find the first circular tour that visits all petrol pumps -  ": ["# Python program to find circular tour for a truck\n \n# A petrol pump has petrol and distance to next petrol pump\nclass petrolPump:\n    def __init__(self, petrol, distance):\n        self.petrol = petrol\n        self.distance = distance\n \n# The function returns starting point if there is a\n# possible solution, otherwise returns -1\ndef printTour(arr, n):\n    start = 0\n \n    for i in range(n):\n       \n        # Identify the first petrol pump from where we\n        # might get a full circular tour\n        if arr[i].petrol >= arr[i].distance:\n            start = i\n            break\n             \n    # To store the excess petrol\n    curr_petrol = 0\n    for i in range(start, n):\n        curr_petrol += (arr[i].petrol - arr[i].distance)\n \n        # If at any point remaining petrol is less than 0,\n        # it means that we cannot start our journey from\n        # current start\n        if(curr_petrol < 0):\n \n            # We move to the next petrol pump\n            i += 1\n \n            # We try to identify the next petrol pump from\n            # where we might get a full circular tour\n            while(i < n):\n                if(arr[i].petrol >= arr[i].distance):\n                    start = i\n \n                    # Reset rem_petrol\n                    curr_petrol = 0\n                    break\n                i += 1\n \n        else:\n            # Move to the next petrolpump if curr_petrol is\n            # >= 0\n            i += 1\n \n    ''' If remaining petrol is less than 0 while we reach the\n     first petrol pump, it means no circular tour is\n     possible '''\n    if(curr_petrol < 0):\n        return -1\n \n    for i in range(start):\n        curr_petrol += (arr[i].petrol - arr[i].distance)\n \n        ''' If remaining petrol is less than 0 at any point\n         before we reach initial start, it means no\n         circular tour is possible '''\n        if(curr_petrol < 0):\n            return -1\n \n    ''' If we have successfully reached intial_start, it\n     means can get a circular tour from final_start, hence\n     return it '''\n    return start\n \n# Driver code\narr = [petrolPump(6, 4), petrolPump(3, 6), petrolPump(7, 3)]\nstart = printTour(arr, len(arr))\nif start == -1:\n    print('No solution')\nelse:\n    print('Start = {}'.format(start))\n \n# This code is contributed by jainlovely450\n", "# Python program to find circular tour for a truck\n \n# A petrol pump has petrol and distance to next petrol pump\nclass petrolPump:\n    def __init__(self,a, b):\n        self.petrol = a;\n        self.distance = b;\n     \n# The function returns starting point if there is a\n# possible solution, otherwise returns -1\ndef printTour( p, n):\n \n    # deficit is used to store the value of the capacity as\n    # soon as the value of capacity becomes negative so as\n    # not to traverse the array twice in order to get the\n    # solution\n    start = 0;\n    deficit = 0;\n    capacity = 0;\n    for i in range(n):\n        capacity += p[i].petrol - p[i].distance;\n        if (capacity < 0):\n            # If this particular step is not done then the\n            # between steps would be redundant\n            start = i + 1;\n            deficit += capacity;\n            capacity = 0;\n         \n    if(capacity + deficit >= 0):\n        return start;\n    else:\n        return -1;\n \n# Driver code\nif __name__ == '__main__':\n    arr = [petrolPump(6, 4),petrolPump(3, 6),petrolPump(7, 3)] ;\n \n    n = len(arr);\n    start = printTour(arr, n);\n \n    if (start == -1):\n        print('No solution');\n    else:\n        print('Start = ' , start);\n \n \n# This code is contributed by Rajput-Ji \n", "# Python program to find circular tour for a truck\n \n# A petrol pump has petrol and distance to next petrol pump\nclass petrolPump:\n    def __init__(self,a, b):\n        self.petrol = a;\n        self.distance = b;\n \n \n# The function returns starting point if there is a\n# possible solution, otherwise returns -1\ndef printTour( p, n):\n    # storing the difference between petrol and distance\n    v=[];\n    for i in range(0,n):\n       v.append(p[i].petrol-p[i].distance);\n     \n     \n    # pref array will store the difference of petrol and distance \n    # till the i'th position\n     \n    pref=[0]*(n);\n    pref[0]=v[0];\n    for i in range(0,n):\n       pref[i]=pref[i-1]+v[i];\n     \n    # suff array will store the difference of petrol and distance \n    # till the i'th position from the end\n     \n    suff=[0]*n;\n    suff[n-1]=v[n-1];\n    for i in range(n-2,-1):\n       suff[i]=suff[i+1]+v[i];\n     \n    flag=0;\n    ans=-1;\n     \n    for i in range(0,n):\n       # when the pref array will become 0 first time then we will\n       # store the next index of it\n       # if the pref of i'th pos minus pref of last index where pref \n       # array became negative is less than 0\n       # then we will update the ans\n        \n       if((ans==-1 and pref[i]<0) or (ans!=-1 and pref[i]-pref[ans-1]<0)):\n            ans=i+1;\n     \n    # no index in pref array is less than 0\n    if(ans==-1):\n       return 0;\n     \n    # if at i'th position pref array become 0\n    elif(ans<n):\n        if(pref[ans-1]+suff[ans]>=0):\n            return ans;\n        \n    # if at n'th position pref array become 0\n    elif(ans==n):\n       if(suff[ans-1]+pref[ans-2]>=0):\n           return n-1;\n        \n    # if no index is picked as starting point\n    return -1;\n \nif __name__ == '__main__':\n    arr = [petrolPump(6, 4),petrolPump(3, 6),petrolPump(7, 3)] ;\n  \n    n = len(arr);\n    start = printTour(arr, n);\n  \n    if (start == -1):\n        print('No solution');\n    else:\n        print('Start = ' , start);\n \n        # This code is contributed by ratiagrawal.\n"], "Length of the longest valid substring -  ": ["# Python program to find length of the longest valid\n# substring\n \n \ndef findMaxLen(string):\n    n = len(string)\n \n    # Create a stack and push -1\n    # as initial index to it.\n    stk = []\n    stk.append(-1)\n \n    # Initialize result\n    result = 0\n \n    # Traverse all characters of given string\n    for i in range(n):\n \n        # If opening bracket, push index of it\n        if string[i] == '(':\n            stk.append(i)\n         \n        # If closing bracket, i.e., str[i] = ')'\n        else:\n \n            # Pop the previous opening bracket's index\n            if len(stk) != 0:\n                stk.pop()\n \n            # Check if this length formed with base of\n            # current valid substring is more than max\n            # so far\n            if len(stk) != 0:\n                result = max(result,\n                            i - stk[len(stk)-1])\n \n            # If stack is empty. push current index as\n            # base for next valid substring (if any)\n            else:\n                stk.append(i)\n \n    return result\n \n \n# Driver code\nstring = '((()()'\n \n# Function call\nprint (findMaxLen(string))\n \nstring = '()(()))))'\n \n# Function call\nprint (findMaxLen(string))\n \n# This code is contributed by Bhavya Jain\n \n# This code is modified by Susobhan Akhuli\n", "# Python3 program to find length of\n# the longest valid substring\n \n \ndef findMaxLen(s):\n    if (len(s) <= 1):\n        return 0\n \n    # Initialize curMax to zero\n    curMax = 0\n \n    longest = [0] * (len(s))\n \n    # Iterate over the string starting\n    # from second index\n    for i in range(1, len(s)):\n        if ((s[i] == ')'\n             and i - longest[i - 1] - 1 >= 0\n             and s[i - longest[i - 1] - 1] == '(')):\n             \n            longest[i] = longest[i - 1] + 2\n            if (i - longest[i - 1] - 2 >= 0):\n                longest[i] += (longest[i -\n                                       longest[i - 1] - 2])\n            else:\n                longest[i] += 0\n            curMax = max(longest[i], curMax)\n    return curMax\n \n \n# Driver Code\nif __name__ == '__main__':\n    Str = '((()()'\n     \n    # Function call\n    print(findMaxLen(Str))\n \n    Str = '()(()))))'\n     \n    # Function call\n    print(findMaxLen(Str))\n \n# This code is contributed by PranchalK\n", "# Python3 program to implement the above approach\n \n# Function to return the length of\n# the longest valid substring\n \n \ndef solve(s, n):\n \n    # Variables for left and right counter.\n    # maxlength to store the maximum length found so far\n    left = 0\n    right = 0\n    maxlength = 0\n \n    # Iterating the string from left to right\n    for i in range(n):\n \n        # If '(' is encountered,\n        # then left counter is incremented\n        # else right counter is incremented\n        if (s[i] == '('):\n            left += 1\n        else:\n            right += 1\n \n        # Whenever left is equal to right, it signifies\n        # that the subsequence is valid and\n        if (left == right):\n            maxlength = max(maxlength, 2 * right)\n \n        # Resetting the counters when the subsequence\n        # becomes invalid\n        elif (right > left):\n            left = right = 0\n \n    left = right = 0\n \n    # Iterating the string from right to left\n    for i in range(n - 1, -1, -1):\n \n        # If '(' is encountered,\n        # then left counter is incremented\n        # else right counter is incremented\n        if (s[i] == '('):\n            left += 1\n        else:\n            right += 1\n \n        # Whenever left is equal to right, it signifies\n        # that the subsequence is valid and\n        if (left == right):\n            maxlength = max(maxlength, 2 * left)\n \n        # Resetting the counters when the subsequence\n        # becomes invalid\n        elif (left > right):\n            left = right = 0\n    return maxlength\n \n \n# Driver code\n# Function call\nprint(solve('((()()()()(((())', 16))\n \n# This code is contributed by shubhamsingh10\n"], "Maximum size rectangle binary sub-matrix with all 1s -  ": ["# Python3 program to find largest rectangle\n# with all 1s in a binary matrix\n \n# Finds the maximum area under the\n# histogram represented\n# by histogram. See below article for details.\n \n \nclass Solution():\n    def maxHist(self, row):\n        # Create an empty stack. The stack holds\n        # indexes of hist array / The bars stored\n        # in stack are always in increasing order\n        # of their heights.\n        result = []\n \n        # Top of stack\n        top_val = 0\n \n        # Initialize max area in current\n        max_area = 0\n        # row (or histogram)\n \n        area = 0  # Initialize area with current top\n \n        # Run through all bars of given\n        # histogram (or row)\n        i = 0\n        while (i < len(row)):\n \n            # If this bar is higher than the\n            # bar on top stack, push it to stack\n            if (len(result) == 0) or (row[result[-1]] <= row[i]):\n                result.append(i)\n                i += 1\n            else:\n \n                # If this bar is lower than top of stack,\n                # then calculate area of rectangle with\n                # stack top as the smallest (or minimum\n                # height) bar. 'i' is 'right index' for\n                # the top and element before top in stack\n                # is 'left index'\n                top_val = row[result.pop()]\n                area = top_val * i\n \n                if (len(result)):\n                    area = top_val * (i - result[-1] - 1)\n                max_area = max(area, max_area)\n \n        # Now pop the remaining bars from stack\n        # and calculate area with every popped\n        # bar as the smallest bar\n        while (len(result)):\n            top_val = row[result.pop()]\n            area = top_val * i\n            if (len(result)):\n                area = top_val * (i - result[-1] - 1)\n \n            max_area = max(area, max_area)\n \n        return max_area\n \n    # Returns area of the largest rectangle\n    # with all 1s in A\n    def maxRectangle(self, A):\n \n        # Calculate area for first row and\n        # initialize it as result\n        result = self.maxHist(A[0])\n \n        # iterate over row to find maximum rectangular\n        # area considering each row as histogram\n        for i in range(1, len(A)):\n \n            for j in range(len(A[i])):\n \n                # if A[i][j] is 1 then add A[i -1][j]\n                if (A[i][j]):\n                    A[i][j] += A[i - 1][j]\n \n            # Update result if area with current\n            # row (as last row) of rectangle) is more\n            result = max(result, self.maxHist(A[i]))\n \n        return result\n \n \n# Driver Code\nif __name__ == '__main__':\n    A = [[0, 1, 1, 0],\n         [1, 1, 1, 1],\n         [1, 1, 1, 1],\n         [1, 1, 0, 0]]\n    ans = Solution()\n \n    print('Area of maximum rectangle is',\n          ans.maxRectangle(A))\n \n# This code is contributed\n# by Aaryaman Sharma\n"], "Largest Rectangular Area in a Histogram using Stack -  ": ["# Python3 program to find maximum \n# rectangular area in linear time \n  \n  \ndef max_area_histogram(histogram): \n  \n    # This function calculates maximum \n    # rectangular area under given \n    # histogram with n bars \n  \n    # Create an empty stack. The stack \n    # holds indexes of histogram[] list. \n    # The bars stored in the stack are \n    # always in increasing order of \n    # their heights. \n    stack = list() \n  \n    max_area = 0  # Initialize max area \n  \n    # Run through all bars of \n    # given histogram \n    index = 0\n    while index < len(histogram): \n  \n        # If this bar is higher \n        # than the bar on top \n        # stack, push it to stack \n  \n        if (not stack) or (histogram[stack[-1]] <= histogram[index]): \n            stack.append(index) \n            index += 1\n  \n        # If this bar is lower than top of stack, \n        # then calculate area of rectangle with \n        # stack top as the smallest (or minimum \n        # height) bar.'i' is 'right index' for \n        # the top and element before top in stack \n        # is 'left index' \n        else: \n            # pop the top \n            top_of_stack = stack.pop() \n  \n            # Calculate the area with \n            # histogram[top_of_stack] stack \n            # as smallest bar \n            area = (histogram[top_of_stack] *\n                    ((index - stack[-1] - 1) \n                     if stack else index)) \n  \n            # update max area, if needed \n            max_area = max(max_area, area) \n  \n    # Now pop the remaining bars from \n    # stack and calculate area with \n    # every popped bar as the smallest bar \n    while stack: \n  \n        # pop the top \n        top_of_stack = stack.pop() \n  \n        # Calculate the area with \n        # histogram[top_of_stack] \n        # stack as smallest bar \n        area = (histogram[top_of_stack] *\n                ((index - stack[-1] - 1) \n                 if stack else index)) \n  \n        # update max area, if needed \n        max_area = max(max_area, area) \n  \n    # Return maximum area under \n    # the given histogram \n    return max_area \n  \n  \n# Driver Code \nif __name__ == '__main__': \n    hist = [6, 2, 5, 4, 5, 1, 6] \n  \n    # Function call \n    print('Maximum area is', \n          max_area_histogram(hist)) \n  \n# This code is contributed \n# by Jinay Shah \n", "# Python3 code for the above approach \n  \n  \ndef getMaxArea(arr): \n    s = [-1] \n    n = len(arr) \n    area = 0\n    i = 0\n    left_smaller = [-1]*n \n    right_smaller = [n]*n \n    while i < n: \n        while s and (s[-1] != -1) and (arr[s[-1]] > arr[i]): \n            right_smaller[s[-1]] = i \n            s.pop() \n        if((i > 0) and (arr[i] == arr[i-1])): \n            left_smaller[i] = left_smaller[i-1] \n        else: \n            left_smaller[i] = s[-1] \n        s.append(i) \n        i += 1\n    for j in range(0, n): \n        area = max(area, arr[j]*(right_smaller[j]-left_smaller[j]-1)) \n    return area \n  \n  \n# Driver code \nif __name__ == '__main__': \n    hist = [6, 2, 5, 4, 5, 1, 6] \n  \n    # Function call \n    print('maxArea = ', getMaxArea(hist)) \n  \n# This code is contributed by Arunit Kumar \n"], "The Celebrity Problem -  ": ["def celebrity(M, n):\n   \n    # Create an adjacency list for each person\n    adj = [[] for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if M[i][j] == 1:\n                adj[i].append(j)\n                 \n    # Check if there is a person \n    # who doesn't know anyone but \n    # everyone knows him/her\n    for i in range(n):\n        if not adj[i]:\n            flag = True\n            for j in range(n):\n                if i == j:\n                    continue\n                if i not in adj[j]:\n                    flag = False\n                    break\n            if flag:\n                return i\n    return -1\n \n# Sample input\nM = [[0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0], [0, 0, 1, 0]]\nn = len(M)\nCelebrity = celebrity(M, n)\nif Celebrity != -1:\n    print('Celebrity is : ', Celebrity)\nelse:\n    print('No celebrity')\n", "# Python3 program to find celebrity\n \n# Max # of persons in the party\nN = 8\n \n# Person with 2 is celebrity\nMATRIX = [[0, 0, 1, 0],\n          [0, 0, 1, 0],\n          [0, 0, 0, 0],\n          [0, 0, 1, 0]]\n \n \ndef knows(a, b):\n \n    return MATRIX[a][b]\n \n \ndef findCelebrity(n):\n \n    # The graph needs not be constructed\n    # as the edges can be found by\n    # using knows function\n \n    # degree array;\n    indegree = [0 for x in range(n)]\n    outdegree = [0 for x in range(n)]\n \n    # Query for all edges\n    for i in range(n):\n        for j in range(n):\n            x = knows(i, j)\n \n            # Set the degrees\n            outdegree[i] += x\n            indegree[j] += x\n \n    # Find a person with indegree n-1\n    # and out degree 0\n    for i in range(n):\n        if (indegree[i] == n - 1 and\n                outdegree[i] == 0):\n            return i\n \n    return -1\n \n \n# Driver code\nif __name__ == '__main__':\n \n    n = 4\n    id_ = findCelebrity(n)\n \n    if id_ == -1:\n        print('No celebrity')\n    else:\n        print('Celebrity ID', id_)\n \n# This code is contributed by UnworthyProgrammer\n", "# Python3 program to find celebrity\n \n# Max # of persons in the party\nN = 8\n \n# Person with 2 is celebrity\nMATRIX = [[0, 0, 1, 0],\n          [0, 0, 1, 0],\n          [0, 0, 0, 0],\n          [0, 0, 1, 0]]\n \n \ndef knows(a, b):\n \n    return MATRIX[a][b]\n \n# Returns -1 if a potential celebrity\n# is not present. If present,\n# returns id (value from 0 to n-1).\n \n \ndef findPotentialCelebrity(n):\n \n    # Base case\n    if (n == 0):\n        return 0\n \n    # Find the celebrity with n-1\n    # persons\n    id_ = findPotentialCelebrity(n - 1)\n \n    # If there are no celebrities\n    if (id_ == -1):\n        return n - 1\n    # if the id knows the nth person\n    # then the id cannot be a celebrity, but nth person\n    # could be on\n    elif knows(id_, n - 1):\n        return n - 1\n    # if the id knows the nth person\n    # then the id cannot be a celebrity, but nth person\n    # could be one\n    elif knows(n - 1, id_):\n        return id_\n    # If there is no celebrity\n    return - 1\n \n# Returns -1 if celebrity\n# is not present. If present,\n# returns id (value from 0 to n-1).\n# a wrapper over findCelebrity\n \n \ndef Celebrity(n):\n \n    # Find the celebrity\n    id_ = findPotentialCelebrity(n)\n \n    # Check if the celebrity found\n    # is really the celebrity\n    if (id_ == -1):\n        return id_\n    else:\n        c1 = 0\n        c2 = 0\n \n        # Check the id is really the\n        # celebrity\n        for i in range(n):\n            if (i != id_):\n                c1 += knows(id_, i)\n                c2 += knows(i, id_)\n \n        # If the person is known to\n        # everyone.\n        if (c1 == 0 and c2 == n - 1):\n            return id_\n \n        return -1\n \n \n# Driver code\nif __name__ == '__main__':\n \n    n = 4\n    id_ = Celebrity(n)\n \n    if id_ == -1:\n        print('No celebrity')\n    else:\n        print('Celebrity ID', id_)\n \n# This code is contributed by UnworthyProgrammer\n", "# Python3 program to find celebrity\n# using stack data structure\n \n# Max # of persons in the party\nN = 8\n \n# Person with 2 is celebrity\nMATRIX = [[0, 0, 1, 0],\n          [0, 0, 1, 0],\n          [0, 0, 0, 0],\n          [0, 0, 1, 0]]\n \n \ndef knows(a, b):\n \n    return MATRIX[a][b]\n \n# Returns -1 if celebrity\n# is not present. If present,\n# returns id (value from 0 to n-1).\n \n \ndef findCelebrity(n):\n \n    # Handle trivial\n    # case of size = 2\n    s = []\n \n    # Push everybody to stack\n    for i in range(n):\n        s.append(i)\n \n    # Find a potential celebrity\n    while (len(s) > 1):\n \n          # Pop out the first two elements from stack\n        A = s.pop()\n        B = s.pop()\n \n        # if A knows B, we find that B might be the celebrity and vice versa\n        if (knows(A, B)):\n            s.append(B)\n        else:\n            s.append(A)\n \n    # If there are only two people\n    # and there is no\n    # potential candidate\n    if(len(s) == 0):\n        return -1\n \n    # Potential candidate?\n    C = s.pop()\n \n    # Last candidate was not\n    # examined, it leads one\n    # excess comparison (optimize)\n    if (knows(C, B)):\n        C = B\n \n    if (knows(C, A)):\n        C = A\n \n    # Check if C is actually\n    # a celebrity or not\n    for i in range(n):\n \n        # If any person doesn't\n        # know 'a' or 'a' doesn't\n        # know any person, return -1\n        if ((i != C) and\n            (knows(C, i) or\n                not(knows(i, C)))):\n            return -1\n \n    return C\n \n \n# Driver code\nif __name__ == '__main__':\n \n    n = 4\n    id_ = findCelebrity(n)\n \n    if id_ == -1:\n        print('No celebrity')\n    else:\n        print('Celebrity ID ', id_)\n \n# This code is contributed by UnworthyProgrammer\n", "# Python code for the above approach\n \n \n# Function to find if there is a celebrity in the party\n# or not.\ndef celebrity(M, n):\n    # r=row number\n    r = 0\n    for i in range(1, n):\n        # checking if r th person knows i th person\n        if(M[r][i] == 1):\n            M[r][r] = 1\n            r = i\n        else:\n            M[i][i] = 1\n \n    for i in range(n):\n        # checking if i th person can be a celebrity or\n        # not\n        if(M[i][i] == 0):\n            flag = 0\n            # iterating in the i th column to check\n            # whether everyone knows i th person or not\n            for j in range(n):\n                # checking if M[j][i] is not a diagonal\n                # element and if j th person knows i th\n                      # person\n                if(j != i and M[j][i] == 0):\n                    flag = 1\n                    break\n            if(flag == 0):\n                return i\n \n    return -1\n \n \nM = [[0, 0, 1, 0],\n     [0, 0, 1, 0],\n     [0, 0, 0, 0],\n     [0, 0, 1, 0]]\na = celebrity(M, 4)\nif(a is -1):\n    print('No Celebrity')\nelse:\n    print('Celebrity ID', a)\n \n# This code is contributed by lokeshmvs21.\n", "# Python3 code\nclass Solution:\n \n    # Function to find if there is a celebrity in the party or not.\n    # return index if celebrity else return -1\n    def celebrity(self, M, n):\n        # code here\n        i = 0\n        j = n-1\n        candidate = -1\n        while(i < j):\n            if M[j][i] == 1:\n                j -= 1\n            else:\n                i += 1\n \n        candidate = i\n        for k in range(n):\n            if candidate != k:\n                if M[candidate][k] == 1 or M[k][candidate] == 0:\n                    return -1\n \n        return candidate\n \n \nn = 4\nm = [[0, 0, 1, 0],\n     [0, 0, 1, 0],\n     [0, 0, 0, 0],\n     [0, 0, 1, 0]]\nob = Solution()\na = ob.celebrity(m, n)\nif a == -1:\n    print('No Celebrity')\nelse:\n    print('Celebrity ID', a)\n"], "Reverse a sublist of linked list -  ": ["# Python3 program to reverse a linked list \n# from position m to position n \n   \n# Linked list node \nclass Node: \n      \n    def __init__(self, data): \n          \n        self.data = data \n        self.next = None\n  \n# The standard reverse function used \n# to reverse a linked list \ndef reverse(head): \n  \n    prev = None   \n    curr = head \n   \n    while (curr): \n        next = curr.next\n        curr.next = prev \n        prev = curr \n        curr = next\n      \n    return prev \n   \n# Function used to reverse a linked list \n# from position m to n which uses reverse \n# function \ndef reverseBetween(head, m, n): \n  \n    if (m == n): \n        return head \n          \n    # revs and revend is start and end respectively \n    # of the portion of the linked list which \n    # need to be reversed. revs_prev is previous \n    # of starting position and revend_next is next \n    # of end of list to be reversed. \n    revs = None\n    revs_prev = None\n    revend = None\n    revend_next = None\n   \n    # Find values of above pointers. \n    i = 1\n    curr = head \n      \n    while (curr and i <= n): \n        if (i < m): \n            revs_prev = curr \n   \n        if (i == m): \n            revs = curr \n   \n        if (i == n): \n            revend = curr \n            revend_next = curr.next\n   \n        curr = curr.next\n        i += 1\n  \n    revend.next = None\n   \n    # Reverse linked list starting with \n    # revs. \n    revend = reverse(revs) \n   \n    # If starting position was not head \n    if (revs_prev): \n        revs_prev.next = revend \n   \n    # If starting position was head \n    else: \n        head = revend \n   \n    revs.next = revend_next \n    return head \n  \ndef prints(head): \n  \n    while (head != None): \n        print(head.data, end = ' ') \n        head = head.next\n          \n    print() \n  \n# Function to add a new node at the \n# beginning of the list \ndef push(head_ref, new_data): \n  \n    new_node = Node(new_data) \n    new_node.data = new_data \n    new_node.next = (head_ref) \n    (head_ref) = new_node \n    return head_ref \n  \n# Driver code \nif __name__=='__main__': \n      \n    head = None\n    head = push(head, 70) \n    head = push(head, 60) \n    head = push(head, 50) \n    head = push(head, 40) \n    head = push(head, 30) \n    head = push(head, 20) \n    head = push(head, 10) \n      \n    reverseBetween(head, 3, 6) \n      \n    prints(head) \n      \n# This code is contributed by rutvik_56\n", "# Python3 program to reverse a linked list \n# from position m to position n \n  \n# Linked list node \nclass Node: \n      \n    def __init__(self, data): \n          \n        self.data = data \n        self.next = None\n  \ndef reverse(head): \n  \n    prev = None\n    curr = head \n  \n    while (curr): \n        next = curr.next\n        curr.next = prev \n        prev = curr \n        curr = next\n      \n    return prev \n  \n# Function used to reverse a linked list \n# from position m to n  \ndef reverseBetween(head, m, n): \n  \n          # First move the current pointer to the node from \n        # where we have to reverse the linked list \n        curr = head \n        prev = None\n        # prev points to the node before mth node \n        i = 1\n        while i<m:  \n            prev = curr \n            curr = curr.next\n            i+=1\n          \n        # This pointer stores the pointer to the head of \n        # the reversed linkedlist \n        rtail = curr \n        # This pointer stores the pointer to the tail of \n        # the reversed linkedlist \n        rhead = None\n        # Now reverse the linked list from m to n nodes \n        while (i <= n): \n            temp = curr.next\n            curr.next = rhead \n            rhead = curr \n            curr = temp \n            i+=1\n          \n        # if prev is not null it means that some of the \n        # nodes exits before m ( or if m!=1) \n        if prev: \n            prev.next = rhead \n        else: \n            head = rhead \n        # at this point curr will point to the next of nth \n        # node where we will connect the tail of the \n        # reversed linked list \n        rtail.next = curr \n        # at the end return the new head. \n        return head \n  \ndef prints(head): \n  \n    while (head != None): \n        print(head.data, end = ' ') \n        head = head.next\n          \n    print() \n  \n# Function to add a new node at the \n# beginning of the list \ndef push(head_ref, new_data): \n  \n    new_node = Node(new_data) \n    new_node.data = new_data \n    new_node.next = (head_ref) \n    (head_ref) = new_node \n    return head_ref \n  \n# Driver code \nif __name__=='__main__': \n      \n    head = None\n    head = push(head, 70) \n    head = push(head, 60) \n    head = push(head, 50) \n    head = push(head, 40) \n    head = push(head, 30) \n    head = push(head, 20) \n    head = push(head, 10) \n      \n    reverseBetween(head, 3, 6) \n      \n    prints(head) \n      \n# This code is contributed by Abhijeet Kumar(abhijeet19403) \n"], "Sort a linked list of 0s, 1s and 2s -  ": ["# Python program to sort a linked list of 0, 1 and 2\nclass LinkedList(object):\n    def __init__(self):\n \n         # head of list\n         self.head = None\n \n    # Linked list Node\n    class Node(object):\n        def __init__(self, d):\n            self.data = d\n            self.next = None\n \n    def sortList(self):\n \n        # initialise count of 0 1 and 2 as 0\n        count = [0, 0, 0]\n \n        ptr = self.head\n \n        # count total number of '0', '1' and '2'\n        # * count[0] will store total number of '0's\n        # * count[1] will store total number of '1's\n        # * count[2] will store total number of '2's  \n        while ptr != None:\n            count[ptr.data]+=1\n            ptr = ptr.next\n \n        i = 0\n        ptr = self.head\n \n        # Let say count[0] = n1, count[1] = n2 and count[2] = n3\n        # * now start traversing list from head node,\n        # * 1) fill the list with 0, till n1 > 0\n        # * 2) fill the list with 1, till n2 > 0\n        # * 3) fill the list with 2, till n3 > 0  \n        while ptr != None:\n            if count[i] == 0:\n                i+=1\n            else:\n                ptr.data = i\n                count[i]-=1\n                ptr = ptr.next\n \n \n    # Utility functions\n    # Inserts a new Node at front of the list.\n    def push(self, new_data):\n \n        # 1 & 2: Allocate the Node &\n        # Put in the data\n        new_node = self.Node(new_data)\n \n        # 3. Make next of new Node as head\n        new_node.next = self.head\n \n        # 4. Move the head to point to new Node\n        self.head = new_node\n \n    # Function to print linked list\n    def printList(self):\n        temp = self.head\n        while temp != None:\n            print (str(temp.data),end=' ') \n            temp = temp.next\n        print()\n \n# Driver program to test above functions\nllist = LinkedList()\nllist.push(0)\nllist.push(1)\nllist.push(0)\nllist.push(2)\nllist.push(1)\nllist.push(1)\nllist.push(2)\nllist.push(1)\nllist.push(2)\n \nprint ('Linked List before sorting')\nllist.printList()\n \nllist.sortList()\n \nprint ('Linked List after sorting')\nllist.printList()\n \n# This code is contributed by BHAVYA JAIN\n", "# Define a class for a node in a linked list\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# Function to insert a new node at the end of the linked list\n \n \ndef push(head, data):\n    new_node = Node(data)\n \n    if head is None:\n        head = new_node\n        return head\n \n    last = head\n    while last.next is not None:\n        last = last.next\n \n    last.next = new_node\n    return head\n \n# Function to print the linked list\n \n \ndef printList(head):\n    current = head\n    while current is not None:\n        print(current.data, end=' ')\n        current = current.next\n    print()\n \n# Function to sort the linked list containing 0's, 1's, and 2's\n \n \ndef sortList(head):\n    count = [0, 0, 0]\n \n    # Count the number of 0's, 1's, and 2's in the linked list\n    current = head\n    while current is not None:\n        count[current.data] += 1\n        current = current.next\n \n    # Overwrite the linked list with the sorted elements\n    current = head\n    i = 0\n    while current is not None:\n        if count[i] == 0:\n            i += 1\n        else:\n            current.data = i\n            count[i] -= 1\n            current = current.next\n \n \n# Main function to test the implementation\nif __name__ == '__main__':\n    head = None\n \n    # Insert some elements into the linked list\n    head = push(head, 0)\n    head = push(head, 1)\n    head = push(head, 0)\n    head = push(head, 2)\n    head = push(head, 1)\n    head = push(head, 1)\n    head = push(head, 2)\n    head = push(head, 1)\n    head = push(head, 2)\n \n    print('Linked List before Sorting:')\n    printList(head)\n \n    sortList(head)\n \n    print('Linked List after Sorting:')\n    printList(head)\n"], "Pairwise Swap Nodes of a given Linked List -  ": ["# Recursive function to pairwise swap elements of a linked list\ndef pairWiseSwap(head):\n \n    # There must be at-least two nodes in the list\n    if (head != None and head.next != None):\n \n        # Swap the node's data with data of next node\n        swap(head.data, head.next.data)\n \n        # Call pairWiseSwap() for rest of the list\n        pairWiseSwap(head.next.next)\n \n# This code is contributed by _saurabh_jaiswal\n"], "Given a linked list which is sorted, how will you insert in sorted way -  ": ["# Node class\nclass Node:\n   \n  # Constructor to initialize the node object\n  def __init__(self, data):\n    self.data = data\n    self.next = None\n   \nclass LinkedList:\n   \n  # Function to initialize head\n  def __init__(self):\n    self.head = None\n \n  # Function to insert a new node in a sorted way\n  def sortedInsert(self, new_node):\n    if self.head is None:\n      self.head = new_node\n      return\n     \n    prev = None\n    current = self.head\n    while current and current.data < new_node.data:\n      prev = current\n      current = current.next\n     \n    if prev is None:\n      new_node.next = self.head\n      self.head = new_node\n    else:\n      new_node.next = current\n      prev.next = new_node\n \n  # Utility function to print the LinkedList\n  def printList(self):\n    temp = self.head\n    while temp:\n      print(temp.data, end=' ')\n      temp = temp.next\n \n# Driver program\nllist = LinkedList()\nnew_node = Node(5)\nllist.sortedInsert(new_node)\nnew_node = Node(10)\nllist.sortedInsert(new_node)\nnew_node = Node(7)\nllist.sortedInsert(new_node)\nnew_node = Node(3)\nllist.sortedInsert(new_node)\nnew_node = Node(1)\nllist.sortedInsert(new_node)\nnew_node = Node(9)\nllist.sortedInsert(new_node)\nprint('Create Linked List')\nllist.printList()\n"], "Find length of loop/cycle in given Linked List -  ": ["# Python 3 program to find the number\n# of nodes in loop in a linked list\n# if loop is present\n \n# Python Code to detect a loop and\n# find the length of the loop\n# Node defining class\n \n \nclass Node:\n \n    # Function to make a node\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n \n# Linked List defining and loop\n# length finding class\n \n \nclass LinkedList:\n \n    # Function to initialize the\n    # head of the linked list\n    def __init__(self):\n        self.head = None\n \n    # Function to insert a new\n    # node at the end\n    def AddNode(self, val):\n        if self.head is None:\n            self.head = Node(val)\n        else:\n            curr = self.head\n            while(curr.next):\n                curr = curr.next\n            curr.next = Node(val)\n \n    # Function to create a loop in the\n    # Linked List. This function creates\n    # a loop by connecting the last node\n    # to n^th node of the linked list,\n    # (counting first node as 1)\n    def CreateLoop(self, n):\n \n        # LoopNode is the connecting node to\n        # the last node of linked list\n        LoopNode = self.head\n        for _ in range(1, n):\n            LoopNode = LoopNode.next\n \n        # end is the last node of the Linked List\n        end = self.head\n        while(end.next):\n            end = end.next\n \n        # Creating the loop\n        end.next = LoopNode\n \n    # Function to detect the loop and return\n    # the length of the loop if the returned\n    # value is zero, that means that either\n    # the linked list is empty or the linked\n    # list doesn't have any loop\n    def detectLoop(self):\n \n        # if linked list is empty then there\n        # is no loop, so return 0\n        if self.head is None:\n            return 0\n \n        # Using Floyd\u2019s Cycle-Finding\n        # Algorithm/ Slow-Fast Pointer Method\n        slow = self.head\n        fast = self.head\n        flag = 0  # to show that both slow and fast\n        # are at start of the Linked List\n        while(slow and slow.next and fast and\n              fast.next and fast.next.next):\n            if slow == fast and flag != 0:\n \n                # Means loop is confirmed in the\n                # Linked List. Now slow and fast\n                # are both at the same node which\n                # is part of the loop\n                count = 1\n                slow = slow.next\n                while(slow != fast):\n                    slow = slow.next\n                    count += 1\n                return count\n \n            slow = slow.next\n            fast = fast.next.next\n            flag = 1\n        return 0  # No loop\n \n \n# Setting up the code\n# Making a Linked List and adding the nodes\nmyLL = LinkedList()\nmyLL.AddNode(1)\nmyLL.AddNode(2)\nmyLL.AddNode(3)\nmyLL.AddNode(4)\nmyLL.AddNode(5)\n \n# Creating a loop in the linked List\n# Loop is created by connecting the\n# last node of linked list to n^th node\n# 1<= n <= len(LinkedList)\nmyLL.CreateLoop(2)\n \n# Checking for Loop in the Linked List\n# and printing the length of the loop\nloopLength = myLL.detectLoop()\nif myLL.head is None:\n    print('Linked list is empty')\nelse:\n    print(str(loopLength))\n \n# This code is contributed by _Ashutosh\n", "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n \ndef countNodesInLoop(head):\n    visited = set()\n    current = head\n    count = 0\n \n    while current is not None:\n        # If the node is already visited, it means there is a loop\n        if current in visited:\n            start_of_loop = current\n            while True:\n                count += 1\n                current = current.next\n                if current == start_of_loop:\n                    break\n            return count\n \n        # Mark the current node as visited\n        visited.add(current)\n \n        # Move to the next node\n        current = current.next\n \n    # Return 0 to indicate that there is no loop\n    return 0\n \n# Driver Code\nif __name__ == '__main__':\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    head.next.next.next = ListNode(4)\n    head.next.next.next.next = ListNode(5)\n \n    # Create a loop for testing\n    head.next.next.next.next.next = head.next\n \n    print(countNodesInLoop(head))\n     \n# This code is contributed by akshitaguprzj3\n"], "Delete a Node from linked list without head pointer -  ": ["class Node: \n    def __init__(self, val): \n        self.data = val \n        self.next = None\n  \nclass LinkedList: \n    def __init__(self): \n        self.head = None\n  \n    # Function to delete the node without head \n    def delete_node_without_head(self, pos): \n        if pos is None:  # If linked list is empty \n            return\n        elif pos.next is None: \n            print('This is last node, require head, can't be freed\\n') \n            return\n  \n        # copy data of the next node to current node \n        pos.data = pos.next.data \n  \n        # perform conventional deletion \n        pos.next = pos.next.next\n  \n    def push(self, new_data): \n        # allocate node and put in the data \n        new_node = Node(new_data) \n  \n        # link the old list of the new node \n        new_node.next = self.head \n  \n        # move the head to point to the new node \n        self.head = new_node \n  \n    def print_list(self): \n        temp = self.head \n        while temp is not None: \n            print(temp.data, end='->') \n            temp = temp.next\n        print('NULL\\n') \n  \nif __name__ == '__main__': \n    llist = LinkedList() \n  \n    # create linked list 35->15->4->20 \n    llist.push(20) \n    llist.push(4) \n    llist.push(15) \n    llist.push(35) \n  \n    print('Initial Linked List : ') \n    llist.print_list() \n  \n    # Delete 15 without sending head \n    del_node = llist.head.next\n  \n    # Function call \n    llist.delete_node_without_head(del_node) \n  \n    # Print the final Linked List \n    print('Final Linked List after deletion of 15 : ') \n    llist.print_list() \n  \n# This code has been contributed by Mayank Bohra\n"], "Detect loop or cycle in a linked list -  ": ["# Python3 program to detect loop\n# in the linked list\n \n# Node class\nclass Node:\n \n    # Constructor to initialize\n    # the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # Function to insert a new\n    # node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Utility function to print it\n    # the linked LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(temp.data, end=' ')\n            temp = temp.next\n \n    def detectLoop(self):\n        s = set()\n        temp = self.head\n        while (temp):\n \n            # If we already have\n            # this node in hashmap it\n            # means there is a cycle\n            # (Because we are encountering\n            # the node second time).\n            if (temp in s):\n                return True\n \n            # If we are seeing the node for\n            # the first time, insert it in hash\n            s.add(temp)\n \n            temp = temp.next\n \n        return False\n \n \n# Driver program for testing\nllist = LinkedList()\nllist.push(20)\nllist.push(4)\nllist.push(15)\nllist.push(10)\n \n# Create a loop for testing\nllist.head.next.next.next.next = llist.head\n \nif(llist.detectLoop()):\n    print('Loop Found')\nelse:\n    print('No Loop ')\n \n# This code is contributed by Gitanjali.\n", "# Python3 program to detect loop in a linked list\n \n''' Link list node '''\n \n \nclass Node:\n \n    def __init__(self):\n        self.data = 0\n        self.next = None\n        self.flag = 0\n \n \ndef push(head_ref, new_data):\n    ''' allocate node '''\n    new_node = Node()\n \n    ''' put in the data '''\n    new_node.data = new_data\n \n    new_node.flag = 0\n \n    ''' link the old list of the new node '''\n    new_node.next = (head_ref)\n \n    ''' move the head to point to the new node '''\n    (head_ref) = new_node\n    return head_ref\n \n# Returns true if there is a loop in linked list\n# else returns false.\n \n \ndef detectLoop(h):\n \n    while (h != None):\n        # If this node is already traverse\n        # it means there is a cycle\n        # (Because you we encountering the\n        # node for the second time).\n        if (h.flag == 1):\n            return True\n \n        # If we are seeing the node for\n        # the first time, mark its flag as 1\n        h.flag = 1\n        h = h.next\n    return False\n \n \n''' Driver program to test above function'''\nif __name__ == '__main__':\n \n    ''' Start with the empty list '''\n    head = None\n \n    head = push(head, 20)\n    head = push(head, 4)\n    head = push(head, 15)\n    head = push(head, 10)\n \n    ''' Create a loop for testing '''\n    head.next.next.next.next = head\n \n    if (detectLoop(head)):\n        print('Loop Found')\n    else:\n        print('No Loop')\n \n# This code is contributed by rutvik_56\n", "# Python3 program to return first node of loop\n \n# A binary tree node has data, pointer to\n# left child and a pointer to right child\n# Helper function that allocates a new node\n# with the given data and None left and\n# right pointers\n \n \nclass newNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# A utility function to print a linked list\n \n \ndef printList(head):\n    while (head != None):\n        print(head.key, end=' ')\n        head = head.next\n \n    print()\n \n# Function to detect first node of loop\n# in a linked list that may contain loop\n \n \ndef detectLoop(head):\n \n    # Create a temporary node\n    temp = ''\n    while (head != None):\n \n        # This condition is for the case\n        # when there is no loop\n        if (head.next == None):\n            return False\n \n        # Check if next is already\n        # pointing to temp\n        if (head.next == temp):\n            return True\n \n        # Store the pointer to the next node\n        # in order to get to it in the next step\n        next = head.next\n \n        # Make next point to temp\n        head.next = temp\n \n        # Get to the next node in the list\n        head = next\n \n    return False\n \n \n# Driver Code\nhead = newNode(1)\nhead.next = newNode(2)\nhead.next.next = newNode(3)\nhead.next.next.next = newNode(4)\nhead.next.next.next.next = newNode(5)\n \n# Create a loop for testing(5 is pointing to 3)\nhead.next.next.next.next.next = head.next.next\n \nfound = detectLoop(head)\nif (found):\n    print('Loop Found')\nelse:\n    print('No Loop')\n \n# This code is contributed by SHUBHAMSINGH10\n", "# Python program to return first node of loop\nclass newNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n         \n \n# A utility function to print a linked list\ndef printList(head):\n \n    while (head != None) :\n        print(head.key, end=' ')\n        head = head.next;\n     \n    print()\n \n \n# returns distance between first and last node every time\n# last node moves forwards\ndef distance(first, last):\n \n    # counts no of nodes between first and last\n    counter = 0\n \n    curr = first\n \n    while (curr != last):\n        counter = counter + 1\n        curr = curr.next\n     \n \n    return counter + 1\n \n   \n# Function to detect first node of loop\n# in a linked list that may contain loop\ndef detectLoop(head):\n \n    # Create a temporary node\n    temp = ''\n \n    # first always points to head\n    first = head;\n    # last pointer initially points to head\n    last = head;\n \n    # current_length stores no of nodes between current\n    # position of first and last\n    current_length = 0\n \n    #current_length stores no of nodes between previous\n    # position of first and last*/\n    prev_length = -1\n \n    while (current_length > prev_length and last != None) :\n        # set prev_length to current length then update the\n        # current length\n        prev_length = current_length\n        # distance is calculated\n        current_length = distance(first, last)\n        # last node points the next node\n        last = last.next;\n     \n     \n    if (last == None) :\n        return False\n     \n    else : \n        return True\n  \n \n# Driver program to test above function\n \nhead = newNode(1);\nhead.next = newNode(2);\nhead.next.next = newNode(3);\nhead.next.next.next = newNode(4);\nhead.next.next.next.next = newNode(5);\n \n# Create a loop for testing(5 is pointing to 3) \nhead.next.next.next.next.next = head.next.next;\n \nfound = detectLoop(head)\nif (found) :\n    print('Loop Found')\nelse :\n    print('No Loop Found')\n \n# This code is contributed by ihritik\n"], "Reverse a Linked List -  ": ["# Python program to reverse a linked list\n# Time Complexity : O(n)\n# Space Complexity : O(1)\n \n# Node class\nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # Function to reverse the linked list\n    def reverse(self):\n        prev = None\n        current = self.head\n        while(current is not None):\n            next = current.next\n            current.next = prev\n            prev = current\n            current = next\n        self.head = prev\n \n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Utility function to print the LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(temp.data, end=' ')\n            temp = temp.next\n \n \n# Driver code\nllist = LinkedList()\nllist.push(20)\nllist.push(4)\nllist.push(15)\nllist.push(85)\n \nprint ('Given linked list')\nllist.printList()\nllist.reverse()\nprint ('\\nReversed linked list')\nllist.printList()\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "'''Python3 program to reverse linked list\nusing recursive method'''\n \n# Linked List Node\n \n \nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# Create and Handle list operations\n \n \nclass LinkedList:\n    def __init__(self):\n        self.head = None  # Head of list\n \n    # Method to reverse the list\n    def reverse(self, head):\n \n        # If head is empty or has reached the list end\n        if head is None or head.next is None:\n            return head\n \n        # Reverse the rest list\n        rest = self.reverse(head.next)\n \n        # Put first element at the end\n        head.next.next = head\n        head.next = None\n \n        # Fix the header pointer\n        return rest\n \n    # Returns the linked list in display format\n    def __str__(self):\n        linkedListStr = ''\n        temp = self.head\n        while temp:\n            linkedListStr = (linkedListStr +\n                             str(temp.data) + ' ')\n            temp = temp.next\n        return linkedListStr\n \n    # Pushes new data to the head of the list\n    def push(self, data):\n        temp = Node(data)\n        temp.next = self.head\n        self.head = temp\n \n \n# Driver code\nlinkedList = LinkedList()\nlinkedList.push(20)\nlinkedList.push(4)\nlinkedList.push(15)\nlinkedList.push(85)\n \nprint('Given linked list')\nprint(linkedList)\n \nlinkedList.head = linkedList.reverse(linkedList.head)\n \nprint('Reversed linked list')\nprint(linkedList)\n \n# This code is contributed by Debidutta Rath\n", "# Simple and tail recursive Python program to\n# reverse a linked list\n \n# Node class\n \n \nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    def reverseUtil(self, curr, prev):\n \n        # If last node mark it head\n        if curr.next is None:\n            self.head = curr\n \n            # Update next to prev node\n            curr.next = prev\n            return\n \n        # Save curr.next node for recursive call\n        next = curr.next\n \n        # And update next\n        curr.next = prev\n \n        self.reverseUtil(next, curr)\n \n    # This function mainly calls reverseUtil()\n    # with previous as None\n \n    def reverse(self):\n        if self.head is None:\n            return\n        self.reverseUtil(self.head, None)\n \n    # Function to insert a new node at the beginning\n \n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Utility function to print the linked LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print (temp.data, end=' ')\n            temp = temp.next\n \n \n# Driver code\nllist = LinkedList()\nllist.push(8)\nllist.push(7)\nllist.push(6)\nllist.push(5)\nllist.push(4)\nllist.push(3)\nllist.push(2)\nllist.push(1)\n \nprint ('Given linked list')\nllist.printList()\n \nllist.reverse()\n \nprint ('\\nReversed linked list')\nllist.printList()\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "# Python code for the above approach\n \n# Definition for singly-linked list.\n \n \nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n \n \nclass Solution:\n \n    # Program to reverse the linked list\n    # using stack\n    def reverseLLUsingStack(self, head):\n \n        # Initialise the variables\n        stack, temp = [], head\n \n        while temp:\n            stack.append(temp)\n            temp = temp.next\n \n        head = temp = stack.pop()\n \n        # Until stack is not\n        # empty\n        while len(stack) > 0:\n            temp.next = stack.pop()\n            temp = temp.next\n \n        temp.next = None\n        return head\n \n \n# Driver Code\nif __name__ == '__main__':\n    head = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))\n    print('Given linked list')\n    temp = head\n    while temp:\n        print(temp.val, end=' ')\n        temp = temp.next\n    obj = Solution()\n    print('\\nReversed linked list')\n    head = obj.reverseLLUsingStack(head)\n    while head:\n        print(head.val, end=' ')\n        head = head.next\n"], "Program for Nth node from the end of a Linked List -  ": ["def printNthFromLast(head, N):\n     \n    i = 0\n    if (head == None)\n        return\n    printNthFromLast(head.next, N);\n    i += 1\n    if (i == N):\n        print(head.data)\n     \n     \n# This code is contributed by sunils0ni.\n", "# Python3 program to find N'th node from end\n \n# Node class\n \n \nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    def printNthFromLast(self, N):\n        main_ptr = self.head\n        ref_ptr = self.head\n \n        count = 0\n        if(self.head is not None):\n            while(count < N):\n                if(ref_ptr is None):\n                    print('% d is greater than the no. pf nodes in list' % (N))\n                    return\n \n                ref_ptr = ref_ptr.next\n                count += 1\n \n        if(ref_ptr is None):\n            self.head = self.head.next\n            if(self.head is not None):\n                print('Node no. % d from last is % d '\n                      % (N, main_ptr.data))\n            #For a single Node\n            if(self.head is None):\n                print('Node no. % d from last is % d '\n                      % (N, main_ptr.data))\n        else:\n           \n            while(ref_ptr is not None):\n                main_ptr = main_ptr.next\n                ref_ptr = ref_ptr.next\n \n            print('Node no. % d from last is % d '\n                  % (N, main_ptr.data))\n \n \n# Driver's code\nif __name__ == '__main__':\n    llist = LinkedList()\n    llist.push(20)\n    llist.push(4)\n    llist.push(15)\n    llist.push(35)\n \n    # Function call\n    llist.printNthFromLast(4)\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"], "Longest prefix which is also suffix -  ": ["# Function to find the length of the longest prefix which is also a suffix\ndef largest_prefix_suffix(s):\n    n = len(s)\n \n    # If the length of the string is less than 2, there can't be a non-overlapping\n    # prefix and suffix, so return 0.\n    if n < 2:\n        return 0\n    lenn = 0  # Initialize the length of the longest prefix which is also a suffix.\n    i = 0\n \n    # Iterate through the first half of the string.\n    while i < n // 2:\n        j1 = 0\n        j2 = (n - 1) - i\n        is_prefix_suffix = True\n \n        # Check if characters at corresponding positions in the first half (j1)\n        # and the second half (j2) of the string are equal.\n        while j1 <= i:\n            if s[j1] != s[j2]:\n                is_prefix_suffix = False  # If any pair of characters doesn't match, it's not a prefix-suffix.\n            j1 += 1\n            j2 += 1\n        if is_prefix_suffix:\n            lenn = i + 1  # If it's a prefix-suffix, update the length.\n        i += 1\n \n    # Return the length of the longest prefix which is also a suffix.\n    return lenn\n \n# Driver code\ns = 'blablabla'\n# Function Call to find the length of the longest prefix which is also a suffix\nprint(largest_prefix_suffix(s))\n", "# Efficient Python 3 program\n# to find length of \n# the longest prefix \n# which is also suffix\n \n# Returns length of the longest prefix\n# which is also suffix and the two do\n# not overlap. This function mainly is\n# copy computeLPSArray() of in below post\n# https://www. .org/searching-for-patterns-set-2-kmp-algorithm/\ndef longestPrefixSuffix(s) :\n    n = len(s)\n    lps = [0] * n   # lps[0] is always 0\n  \n    # length of the previous\n    # longest prefix suffix\n    l = 0\n     \n    # the loop calculates lps[i]\n    # for i = 1 to n-1\n    i = (n+1)//2;\n    while (i < n) :\n        if (s[i] == s[l]) :\n            l = l + 1\n            lps[i] = l\n            i = i + 1\n         \n        else :\n \n            # (pat[i] != pat[len])\n            # This is tricky. Consider\n            # the example. AAACAAAA\n            # and i = 7. The idea is\n            # similar to search step.\n            if (l != 0) :\n                l = lps[l-1]\n  \n                # Also, note that we do\n                # not increment i here\n             \n            else :\n \n                # if (len == 0)\n                lps[i] = 0\n                i = i + 1\n  \n    res = lps[n-1]\n  \n    # Since we are looking for\n    # non overlapping parts.\n    return res;\n         \n  \n# Driver program to test above function\ns = 'bbabbabb'\nprint(longestPrefixSuffix(s))\n \n \n# This code is contributed\n# by Nikita Tiwari.\n#Corrected by Nilanshu Yadav\n"], "Rabin-Karp Algorithm for Pattern Searching -  ": ["# Following program is the python implementation of\n# Rabin Karp Algorithm given in CLRS book\n \n# d is the number of characters in the input alphabet\nd = 256\n \n# pat  -> pattern\n# txt  -> text\n# q    -> A prime number\n \n \ndef search(pat, txt, q):\n    M = len(pat)\n    N = len(txt)\n    i = 0\n    j = 0\n    p = 0    # hash value for pattern\n    t = 0    # hash value for txt\n    h = 1\n \n    # The value of h would be 'pow(d, M-1)%q'\n    for i in range(M-1):\n        h = (h*d) % q\n \n    # Calculate the hash value of pattern and first window\n    # of text\n    for i in range(M):\n        p = (d*p + ord(pat[i])) % q\n        t = (d*t + ord(txt[i])) % q\n \n    # Slide the pattern over text one by one\n    for i in range(N-M+1):\n        # Check the hash values of current window of text and\n        # pattern if the hash values match then only check\n        # for characters one by one\n        if p == t:\n            # Check for characters one by one\n            for j in range(M):\n                if txt[i+j] != pat[j]:\n                    break\n                else:\n                    j += 1\n \n            # if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]\n            if j == M:\n                print('Pattern found at index ' + str(i))\n \n        # Calculate hash value for next window of text: Remove\n        # leading digit, add trailing digit\n        if i < N-M:\n            t = (d*(t-ord(txt[i])*h) + ord(txt[i+M])) % q\n \n            # We might get negative values of t, converting it to\n            # positive\n            if t < 0:\n                t = t+q\n \n \n# Driver Code\nif __name__ == '__main__':\n    txt = 'GEEKS FOR GEEKS'\n    pat = 'GEEK'\n \n    # A prime number\n    q = 101\n \n    # Function Call\n    search(pat, txt, q)\n \n# This code is contributed by Bhavya Jain\n"], "Longest Palindromic Substring -  ": ["# A Python3 solution for longest palindrome\n \n \n# Function to print a subString str[low..high]\ndef printSubStr(str, low, high):\n    for i in range(low, high + 1):\n        print(str[i], end='')\n \n \n# This function prints the\n# longest palindrome subString\n# It also returns the length\n# of the longest palindrome\ndef longestPalSubstr(str):\n \n    # Get length of input String\n    n = len(str)\n \n    # All subStrings of length 1\n    # are palindromes\n    maxLength = 1\n    start = 0\n \n    # Nested loop to mark start\n    # and end index\n    for i in range(n):\n        for j in range(i, n):\n            flag = 1\n \n            # Check palindrome\n            for k in range(0, ((j - i) // 2) + 1):\n                if (str[i + k] != str[j - k]):\n                    flag = 0\n \n            # Palindrome\n            if (flag != 0 and (j - i + 1) > maxLength):\n                start = i\n                maxLength = j - i + 1\n \n    print('Longest palindrome substring is: ', end='')\n    printSubStr(str, start, start + maxLength - 1)\n \n    # Return length of LPS\n    return maxLength\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    str = 'forgeeksskeegfor'\n    print('\\nLength is:', longestPalSubstr(str))\n \n# This code is contributed by 29AjayKumar\n", "# Python program\n \nimport sys\n \n \n# A utility function to print a\n# substring str[low..high]\ndef printSubStr(st, low, high):\n    print ((st[low: high + 1]))\n \n \n# This function prints the longest palindrome\n# substring of st[]. It also returns the length\n# of the longest palindrome\ndef longestPalSubstr(st):\n \n    # Get length of input string\n    n = len(st)\n \n    # table[i][j] will be false if substring\n    # str[i..j] is not palindrome. Else\n    # table[i][j] will be true\n    table = [[0 for x in range(n)] for y\n             in range(n)]\n \n    # All substrings of length 1 are\n    # palindromes\n    maxLength = 1\n    i = 0\n    while (i < n):\n        table[i][i] = True\n        i = i + 1\n \n    # Check for sub-string of length 2.\n    start = 0\n    i = 0\n    while i < n - 1:\n        if (st[i] == st[i + 1]):\n            table[i][i + 1] = True\n            start = i\n            maxLength = 2\n        i = i + 1\n \n    # Check for lengths greater than 2.\n    # k is length of substring\n    k = 3\n    while k <= n:\n \n        # Fix the starting index\n        i = 0\n        while i < (n - k + 1):\n \n            # Get the ending index of\n            # substring from starting\n            # index i and length k\n            j = i + k - 1\n \n            # Checking for sub-string from\n            # ith index to jth index if\n            # st[i + 1] to st[(j-1)] is a\n            # palindrome\n            if (table[i + 1][j - 1] and\n                    st[i] == st[j]):\n                table[i][j] = True\n \n                if (k > maxLength):\n                    start = i\n                    maxLength = k\n            i = i + 1\n        k = k + 1\n    print('Longest palindrome substring is: ',end='')\n    printSubStr(st, start, start + maxLength - 1)\n \n    # Return length of LPS\n    return maxLength\n \n \n# Driver code\nif __name__ == '__main__':\n    st = 'forgeeksskeegfor'\n    l = longestPalSubstr(st)\n    print('Length is:', l)\n \n# This code is contributed by Nikita Tiwari.\n", "def printSubStr(s, low, high):\n    for i in range(low, high + 1):\n        print(s[i], end='')\n    print()\n \ndef longestPalSubstr(s):\n    n = len(s)\n    start = 0\n    end = 1\n \n    for i in range(n):\n        # Find the longest palindromic substring of even length\n        low = i - 1\n        hi = i\n \n        while low >= 0 and hi < n and s[low] == s[hi]:\n            if hi - low + 1 > end:\n                start = low\n                end = hi - low + 1\n            low -= 1\n            hi += 1\n \n        # Find the longest palindromic substring of odd length\n        low = i - 1\n        hi = i + 1\n \n        while low >= 0 and hi < n and s[low] == s[hi]:\n            if hi - low + 1 > end:\n                start = low\n                end = hi - low + 1\n            low -= 1\n            hi += 1\n \n    # Print the longest palindromic substring\n    print('Longest palindrome substring is: ', end='')\n    printSubStr(s, start, start + end - 1)\n \n    # Return the length of the longest palindromic substring\n    return end\n \n# Driver Code:\nif __name__=='__main__':\n    s='forgeeksskeegfor'\n    length = longestPalSubstr(s)\n    print('Length:', length)\n     \n# Code Contributed by atharvajadhav11\n"], "Check if any anagram of a string is palindrome or not -  ": ["from collections import Counter \ndef isPossible(S):\n        a=Counter(S)\n        #create the dictionary of characters which has the count of characters in String\n        a=dict(a)\n        #print(a)\n        c=0\n        #Iterate through the values\n        for v in a.values():\n          # To chech odd or not\n            if v%2==1:\n                c+=1\n        if c>1:\n            return False\n        return True\n# contributed by Raghavendra SN\nq=isPossible('geeksogeeks')\nprint(q)\nz=isPossible(' ')\nprint(z)\n"], "Alien Dictionary -  ": ["# Function to add a directed edge between characters u and v\ndef addEdge(adj, u, v):\n    adj[ord(u) - ord('a')].append(ord(v) - ord('a'))\n \n# Depth-First Search (DFS) function to check for cycles in the graph\ndef dfs(adj, col, curr, isCyclic):\n    # Mark the current node as visited and in the current path\n    col[curr] = 1\n \n    for x in adj[curr]:\n        if col[x] == 1:\n            # If the node is already in the current path, a cycle is detected\n            isCyclic[0] = True\n            return\n        elif col[x] == 0:\n            # Recursively visit adjacent nodes\n            dfs(adj, col, x, isCyclic)\n \n    # Mark the current node as visited and not in the current path\n    col[curr] = 2\n \n# Function to check if a cycle exists in the graph using DFS\ndef checkCycle(adj, col, k):\n    isCyclic = [False]\n    for i in range(k):\n        if col[i] == 0:\n            dfs(adj, col, i, isCyclic)\n    return isCyclic[0]\n \n# DFS-based topological sorting utility function\ndef topologicalSortUtil(adj, u, visited, st):\n    visited[u] = True\n    for v in adj[u]:\n        if not visited[v]:\n            topologicalSortUtil(adj, v, visited, st)\n    st.append(u)\n \n# Function to perform topological sorting\ndef topologicalSort(adj, V):\n    visited = [False] * V\n    st = []\n \n    for i in range(V):\n        if not visited[i]:\n            topologicalSortUtil(adj, i, visited, st)\n \n    # Print the characters in topological order\n    while st:\n        print(chr(st.pop() + ord('a')), end=' ')\n \n# Function to process the words and find the character order\ndef printOrder(words):\n    # To track the frequency of characters\n    frq = [0] * 26\n \n    # Count of unique characters\n    k = 0\n \n    # Count unique characters and their frequencies\n    for word in words:\n        for char in word:\n            frq[ord(char) - ord('a')] += 1\n            if frq[ord(char) - ord('a')] == 1:\n                k += 1\n \n    # Create adjacency list for the graph\n    adj = [[] for _ in range(k)]\n \n    # Build the graph by iterating through adjacent words\n    for i in range(len(words) - 1):\n        word1, word2 = words[i], words[i + 1]\n        j = 0\n        while j < len(word1) and j < len(word2):\n            if word1[j] != word2[j]:\n                # Add edges based on character order\n                addEdge(adj, word1[j], word2[j])\n                break\n            j += 1\n \n    # Color array for cycle detection\n    col = [0] * k\n    isCyclic = [False]\n    if checkCycle(adj, col, k):\n        # Detect and handle cycles\n        print('Valid Order is not possible')\n        return\n \n    # Perform topological sorting and print character order\n    topologicalSort(adj, k)\n \n# Driver Code\nif __name__ == '__main__':\n    words = ['baa', 'abcd', 'abca', 'cab', 'cad']\n    printOrder(words)\n# This code is contributed by Dwaipayan Bandyopadhyay\n"], "Longest Repeating Subsequence -  ": ["# Python 3 program to find the longest repeating \n# subsequence \n \n \n# This function mainly returns LCS(str, str) \n# with a condition that same characters at \n# same index are not considered. \ndef findLongestRepeatingSubSeq( str): \n \n    n = len(str) \n \n    # Create and initialize DP table \n    dp=[[0 for i in range(n+1)] for j in range(n+1)]\n \n    # Fill dp table (similar to LCS loops) \n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            # If characters match and indexes are \n            # not same \n            if (str[i-1] == str[j-1] and i != j): \n                dp[i][j] = 1 + dp[i-1][j-1]         \n                         \n            # If characters do not match \n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j]) \n         \n     \n    return dp[n][n] \n \n \n# Driver Program \nif __name__=='__main__':\n    str = 'aabb'\n    print('The length of the largest subsequence that repeats itself is : '\n          ,findLongestRepeatingSubSeq(str))\n \n# this code is contributed by ash264\n", "# Python 3 program to find the longest repeating\n# subsequence using recursion\n \ndp = [[0 for i in range(1000)] for j in range(1000)]\n \n# This function mainly returns LCS(str, str) \n# with a condition that same characters at \n# same index are not considered. \n \ndef findLongestRepeatingSubSeq( X, m, n):\n     \n    if(dp[m][n]!=-1):\n        return dp[m][n]\n     \n    # return if we have reached the end of either string\n    if (m == 0 or n == 0):\n        dp[m][n] = 0\n        return dp[m][n]\n \n    # if characters at index m and n matches \n    # and index is different\n    if (X[m - 1] == X[n - 1] and m != n):\n        dp[m][n] = findLongestRepeatingSubSeq(X, \n                            m - 1, n - 1) + 1\n         \n        return dp[m][n]\n \n    # else if characters at index m and n don't match\n    dp[m][n] = max (findLongestRepeatingSubSeq(X, m, n - 1), \n                        findLongestRepeatingSubSeq(X, m - 1, n))\n    return dp[m][n]\n \n# Longest Repeated Subsequence Problem\nif __name__ == '__main__':\n    str = 'aabb'\n    m = len(str)\n \ndp =[[-1 for i in range(1000)] for j in range(1000)]\nprint( 'The length of the largest subsequence that'\n            ' repeats itself is : '\n        , findLongestRepeatingSubSeq(str,m,m))\n         \n# this code is contributed by\n# ChitraNayal\n", "# Python 3 program to find the longest repeating\n# subsequence Length\n \n# This function mainly returns LRS(str, str,i,j,dp)\n# with a condition that same characters at\n# same index are not considered.\ndef lrs(s1, i, j, dp):\n   \n    # return if we have reached the \n    #end of either string\n    if i >= len(s1) or j >= len(s1):\n        return 0\n   \n    if dp[i][j] != -1:\n        return dp[i][j]\n       \n    # while dp[i][j] is not computed earlier\n    if dp[i][j] == -1: \n       \n        # if characters at index m and n matches\n        # and index is different\n        # Index should not match\n        if s1[i] == s1[j] and i != j: \n            dp[i][j] = 1+lrs(s1, i+1, j+1, dp)\n         \n        # else if characters at index m and n don't match\n        else:  \n            dp[i][j] = max(lrs(s1, i, j+1, dp), \n                                lrs(s1, i+1, j, dp))\n     \n    # return answer\n    return dp[i][j]\n \n# Driver Code\nif __name__ == '__main__':\n    s1 = 'aabb'\n     \n    # Reversing the same string\n    s2 = s1[::-1]  \n    dp =[[-1 for i in range(1000)] for j in range(1000)]\n    print('LENGTH OF LONGEST REPEATING SUBSEQUENCE IS :', \n                                    lrs(s1, 0, 0, dp))\n     \n# this code is contributed by saikumar kudikala\n", "# Python 3 program to find the longest repeating\n# subsequence\n \n \n# This function mainly returns LCS(str, str)\n# with a condition that same characters at\n# same index are not considered.\ndef findLongestRepeatingSubSeq(str):\n    n = len(str)\n \n    # Create and initialize DP table\n    dp = [0 for i in range(n + 1)]\n \n    # Fill dp table (similar to LCS loops)\n    for i in range(1, n + 1):\n        new_a = [0]\n        for j in range(1, n + 1):\n            # If characters match and indexes are\n            # not same\n            if str[i - 1] == str[j - 1] and i != j:\n                new_a.append(1 + dp[j - 1])\n \n                # If characters do not match\n            else:\n                new_a.append(max(dp[j], new_a[-1]))\n        dp = new_a[:]\n    return dp[-1]\n \n \n# Driver Program\nif __name__ == '__main__':\n    str = 'aabb'\n    print('The length of the largest subsequence that repeats itself is : ', findLongestRepeatingSubSeq(str))\n \n# this code is contributed by ash264\n"], "Minimum insertions to form a palindrome | DP-28 -  ": ["# A Naive recursive program to find minimum  \n# number insertions needed to make a string \n# palindrome \nimport sys \n  \n# Recursive function to find minimum  \n# number of insertions \ndef findMinInsertions(str, l, h): \n  \n    # Base Cases \n    if (l > h): \n        return sys.maxsize \n    if (l == h): \n        return 0\n    if (l == h - 1): \n        return 0 if(str[l] == str[h]) else 1\n  \n    # Check if the first and last characters are \n    # same. On the basis of the comparison result,  \n    # decide which subproblem(s) to call \n      \n    if(str[l] == str[h]): \n        return findMinInsertions(str, l + 1, h - 1) \n    else: \n        return (min(findMinInsertions(str, l, h - 1), \n                    findMinInsertions(str, l + 1, h)) + 1) \n  \n# Driver Code \nif __name__ == '__main__': \n      \n    str = 'geeks'\n    print(findMinInsertions(str, 0, len(str) - 1)) \n  \n# This code is contributed by ita_c \n", "# A Dynamic Programming based program to  \n# find minimum number insertions needed  \n# to make a string palindrome \n  \n# A utility function to find minimum  \n# of two integers \ndef Min(a, b): \n    return min(a, b) \n  \n# A DP function to find minimum number \n# of insertions \ndef findMinInsertionsDP(str1, n): \n  \n    # Create a table of size n*n. table[i][j] \n    # will store minimum number of insertions  \n    # needed to convert str1[i..j] to a palindrome. \n    table = [[0 for i in range(n)]  \n                for i in range(n)] \n    l, h, gap = 0, 0, 0\n  \n    # Fill the table \n    for gap in range(1, n): \n        l = 0\n        for h in range(gap, n): \n            if str1[l] == str1[h]: \n                table[l][h] = table[l + 1][h - 1] \n            else: \n                table[l][h] = (Min(table[l][h - 1],  \n                                   table[l + 1][h]) + 1) \n            l += 1\n  \n    # Return minimum number of insertions  \n    # for str1[0..n-1] \n    return table[0][n - 1]; \n  \n# Driver Code \nstr1 = 'geeks'\nprint(findMinInsertionsDP(str1, len(str1))) \n  \n# This code is contributed by  \n# Mohit kumar 29 \n", "# An LCS based Python3 program to find minimum  \n# number insertions needed to make a string  \n# palindrome  \n  \n''' Returns length of LCS for X[0..m-1],  \nY[0..n-1]. See http://goo.gl/bHQVP for  \ndetails of this function '''\ndef lcs(X, Y, m, n) :  \n  \n    L = [[0 for i in range(n + 1)] for j in range(m + 1)]  \n  \n    ''' Following steps build L[m + 1, n + 1] in  \n    bottom up fashion. Note that L[i, j]  \n    contains length of LCS of X[0..i - 1]  \n    and Y[0..j - 1] '''\n    for i in range(m + 1) :      \n        for j in range(n + 1) :        \n            if (i == 0 or j == 0) :  \n                L[i][j] = 0\n  \n            elif (X[i - 1] == Y[j - 1]) : \n                L[i][j] = L[i - 1][j - 1] + 1 \n            else : \n                L[i][j] = max(L[i - 1][j], L[i][j - 1])  \n  \n    ''' L[m,n] contains length of LCS for  \n    X[0..n-1] and Y[0..m-1] '''\n    return L[m][n] \n      \n# LCS based function to find minimum number  \n# of insertions  \ndef findMinInsertionsLCS(Str, n) :  \n  \n    # Using charArray to reverse a String  \n    charArray = list(Str) \n    charArray.reverse()  \n    revString = ''.join(charArray) \n      \n    # The output is length of string minus  \n    # length of lcs of str and it reverse  \n    return (n - lcs(Str, revString , n, n)) \n  \n# Driver code   \nStr = 'geeks' \nprint(findMinInsertionsLCS(Str,len(Str)))  \n  \n# This code is contributed by divyehrabadiya07\n", "#  An LCS based program to find minimum number \n#  insertions needed to make a string palindrome \n  \n#  Returns length of LCS for X[0..m-1], Y[0..n-1]. \ndef lcs(X, Y, m, n): \n    prev = [0 for i in range(n+1)] \n    curr = [0 for i in range(n+1)] \n    for i in range(m+1): \n        for j in range(n+1): \n            if i == 0 or j == 0: \n                prev[j] = 0\n            elif X[i-1] == Y[j-1]: \n                curr[j] = prev[j-1]+1\n            else: \n                curr[j] = max(prev[j], curr[j-1]) \n        prev = curr \n  \n    #  L[m][n] contains length of LCS for X[0..n-1] \n    #  and Y[0..m-1] \n    return prev[n] \n  \ndef reverseStr(str): \n    return str[::-1] \n  \n#  LCS based function to find minimum number of \n#  insertions \ndef findMinInsertionsLCS(str, n): \n  \n    #  Create another string to store reverse of 'str' \n    rev = reverseStr(str) \n  \n    #  The output is length of string minus length of lcs of \n    #  str and it reverse \n    return (n - lcs(str, rev, n, n)) \n  \n#  Driver code \nif __name__ == '__main__': \n    str = 'geeks'\n    print(findMinInsertionsLCS(str, len(str))) \n  \n# This Code is Contributed By Vivek Maddeshiya \n"], "License Key Formatting -  ": ["# Python code for the above approach\n \n# Function to compute the answer\ndef ReFormatStrings(s,k):\n \n    # Create a temporary string to store the alphanumeric characters only\n    temp = ''\n    n = len(s)\n    for i in range(0,n):\n        if(s[i] != '-'):\n            temp += s[i].upper()\n    length = len(temp)\n     \n    # String ans is created to store the final string.\n    ans = ''\n    val = k\n \n    # Iterate over the string from right to left and start pushing characters at an interval of K\n    for i in range(length - 1,-1,-1):\n        if(val == 0):\n            val = k\n            ans += '-'\n        ans += temp[i]\n        val -= 1\n \n    # Reverse the final string and return it.\n    ans = ans[::-1]\n    return ans\n \n# Driver code\nif __name__ == '__main__':\n    s = '5F3Z-2e-9-w'\n    k = 4\n     \n    # Function call\n    print(ReFormatStrings(s,k))\n     \n    # This code is contributed by ajaymakvana\n", "# Python3 code for the above approach\n# Function to reverse a string\ndef reverse(string):\n    string = string[::-1]\n    return string\n \n# Function to compute the answer\ndef ReFormatString( S, K):\n    length = len(S)\n    cnt = 0\n    x = 0\n \n    # Move the characters to the\n    # back of the string.\n    for i in range(length-1,-1,-1):\n        if (S[i] == '-'):\n            x+=1\n        else:\n            S = S[:i+x] + S[i].upper() + S[i+x+1:]\n \n    # Calculate total number of\n    # alphanumeric characters so\n    # as to get the number of dashes\n    # in the final string.\n    slen = length - x\n    step = slen / K\n \n    # Remove x characterclss from the\n    # start of the string\n \n    S = reverse(S)\n    val = x\n    while (val>0):\n        S = S[:len(S)-1]\n        val-=1\n \n    # Push the empty spaces in\n    # the string (slen+step) to get\n    # the final string length\n \n    temp = step\n    while (temp>0):\n        S+=' '\n        temp-=1\n    S = reverse(S)\n      \n    length = len(S)\n \n    # Using simple mathematics\n    # to push the elements\n    # in the string at the correct place.\n \n    i = slen\n    j = step\n    f = 0\n    while (j < length):\n \n        # At every step calculate the\n        # number of dashes that would be\n        # present before the character\n        step = int(i / K)\n        if (f == 1):\n            step-=1\n        rem = i % K\n \n        # If the remainder is zero it\n        # implies that the character is a dash.\n        if (rem == 0 and f == 0):\n            step = int(step)\n            j = int(j)\n            S = S[:int(j-step)] + '-' + S[int(j-step)+1:]\n            f = 1\n            continue\n        S = S[:int(j-step)] + S[int(j)] + S[int(j-step)+1:]\n        i -= 1\n        j += 1\n        f = 0\n    # Remove all the dashes that would have\n    # accumulated in the beginning of the string.\n    length = len(S)\n    S = reverse(S)\n    for char in reversed(S):\n        if (char != '-'):\n            break\n        if (char == '-'):\n            S = S[:len(S)-1]\n    S = reverse(S)\n \n    return S\n \n# Driver code\ns = '5F3Z-2e-9-w'\nK = 4\n \n# Function Call\nprint(ReFormatString(s, K))\n \n# This code is contributed by akashish__\n"], "Find uncommon characters of the two strings -  ": ["def findAndPrintUncommonChars(str1, str2):\n    # to store the answer\n    ans = ''\n \n    # to handle the case of duplicates\n    used = [False]*26\n \n    # check first for str1\n    for i in range(len(str1)):\n        # keeping a flag variable\n        found = False\n \n        for j in range(len(str2)):\n            # if found change the flag\n            # and break from loop\n            if str1[i] == str2[j]:\n                found = True\n                break\n \n        # if duplicate character not found\n        # then add it to ans\n        if not found and not used[ord(str1[i]) - ord('a')]:\n            used[ord(str1[i]) - ord('a')] = True\n            ans += str1[i]\n \n    # now check for str2\n    for i in range(len(str2)):\n        # keeping a flag variable\n        found = False\n \n        for j in range(len(str1)):\n            # if found change the flag\n            # and break from loop\n            if str2[i] == str1[j]:\n                found = True\n                break\n \n        # if duplicate character not found\n        # then add it to ans\n        if not found and not used[ord(str2[i]) - ord('a')]:\n            used[ord(str2[i]) - ord('a')] = True\n            ans += str2[i]\n \n    # to match with output\n    ans = ''.join(sorted(ans))\n \n    # if not found any character\n    if len(ans) == 0:\n        print('-1')\n    # else print the answer\n    else:\n        print(ans)\n \n# Driver program to test above\nstr1 = 'characters'\nstr2 = 'alphabets'\nfindAndPrintUncommonChars(str1, str2)\n", "# Python 3 implementation to find the \n# uncommon characters of the two strings \n \n# size of the hash table \nMAX_CHAR = 26\n \n# function to find the uncommon characters \n# of the two strings \ndef findAndPrintUncommonChars(str1, str2):\n     \n    # mark presence of each character as 0 \n    # in the hash table 'present[]'\n    present = [0] * MAX_CHAR\n    for i in range(0, MAX_CHAR):\n        present[i] = 0\n \n    l1 = len(str1)\n    l2 = len(str2)\n     \n    # for each character of str1, mark its \n    # presence as 1 in 'present[]'\n    for i in range(0, l1):\n        present[ord(str1[i]) - ord('a')] = 1\n         \n    # for each character of str2 \n    for i in range(0, l2):\n         \n        # if a character of str2 is also present \n        # in str1, then mark its presence as -1 \n        if(present[ord(str2[i]) - ord('a')] == 1 or\n           present[ord(str2[i]) - ord('a')] == -1):\n            present[ord(str2[i]) - ord('a')] = -1\n \n        # else mark its presence as 2 \n        else:\n            present[ord(str2[i]) - ord('a')] = 2\n \n    # print all the uncommon characters \n    for i in range(0, MAX_CHAR):\n        if(present[i] == 1 or present[i] == 2):\n            print(chr(i + ord('a')), end = ' ')\n \n# Driver Code\nif __name__ == '__main__':\n    str1 = 'characters'\n    str2 = 'alphabets'\n    findAndPrintUncommonChars(str1, str2)\n \n# This code is contributed\n# by Sairahul099\n", "def uncommon_chars(a: str, b: str) -> str:\n    mp1 = [0] * 26\n    mp2 = [0] * 26\n    n = len(a)\n    m = len(b)\n \n    for x in a:\n        mp1[ord(x) - ord('a')] = 1\n \n    for x in b:\n        mp2[ord(x) - ord('a')] = 1\n \n    chars = ''\n \n    for i in range(26):\n        if mp1[i] ^ mp2[i]:\n            chars += chr(i + ord('a'))\n \n    if chars == '':\n        return '-1'\n    else:\n        return chars\n \n \na = ' '\nb = 'geeksquiz'\nresult = uncommon_chars(a, b)\nprint(result)\n", "str1 = 'characters'\nstr2 = 'alphabets'\n \n# Converting both the string\n# into sets\nstr1 = set(str1)\nstr2 = set(str2)\n \n \n# Using symmetric difference operator\nprint(''.join(sorted(str1 ^ str2)))\n \n# using symmetric_difference() method\nprint(''.join(sorted(str1.symmetric_difference(str2))))\n"], "How to replace a substring of a string -  ": ["# Python program for the above approach\n \n# Function to replace all the occurrences\n# of the substring S1 to S2 in string S\ndef modifyString(s, s1, s2):\n    # Stores the resultant string\n    ans = ''\n \n    # Traverse the string s\n    i = 0\n    while i < len(s):\n        k = 0\n \n        # If the first character of string s1 matches with the\n        # current character in string s\n        if s[i] == s1[k] and i + len(s1) <= len(s):\n            j = i\n \n            # If the complete string matches or not\n            while j < i + len(s1) and s[j] == s1[k]:\n                k += 1\n                j += 1\n \n            # If complete string matches then replace it with the string s2\n            if j == i + len(s1):\n                ans += s2\n                i = j - 1\n \n            # Otherwise\n            else:\n                ans += s[i]\n        else:\n            ans += s[i]\n        i += 1\n \n    # Print the resultant string\n    print(ans)\n \n# Driver Code\nS = ' '\nS1 = 'eek'\nS2 = 'ok'\nmodifyString(S, S1, S2)\n \n# This code is contributed by rutikbhosale\n", "# Python program for the above approach\n \n# Function to calculate the LPS array\n# for the given string S1\ndef computeLPS(s1):\n    # Stores the longest proper prefix\n    # and suffix for each character\n    # in the string s1\n    lps = [0] * len(s1)\n    length = 0\n \n    # Set lps value 0 for the first\n    # character of the string s1\n    lps[0] = 0\n    i = 1\n \n    # Iterate to fill the lps vector\n    while i < len(s1):\n        if s1[i] == s1[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            # If there is no longest\n            # proper prefix which is\n            # suffix, then set lps[i] = 0\n            if length == 0:\n                lps[i] = 0\n                i += 1\n            # Otherwise\n            else:\n                length = lps[length - 1]\n    return lps\n \n \n# Function to replace all the occurrences\n# of the substring S1 to S2 in string S\ndef modifyString(s, s1, s2):\n    lps = computeLPS(s1)\n    i = j = 0\n    # Stores all the starting index\n    # from character S1 occurs in S\n    found = []\n \n    # Iterate to find all starting\n    # indexes and store all indices\n    # in a list found\n    while i < len(s):\n        if s[i] == s1[j]:\n            i += 1\n            j += 1\n        # The string s1 occurrence is\n        # found and store it in found[]\n        if j == len(s1):\n            found.append(i - j)\n            j = lps[j - 1]\n        elif i < len(s) and s1[j] != s[i]:\n            if j == 0:\n                i += 1\n            else:\n                j = lps[j - 1]\n \n    # Stores the resultant string\n    ans = ''\n    prev = 0\n \n    # Traverse the list found[]\n    for k in range(len(found)):\n        if found[k] < prev:\n            continue\n        ans += s[prev:found[k]]\n        ans += s2\n        prev = found[k] + len(s1)\n \n    ans += s[prev:]\n    # Print the resultant string\n    print(ans)\n \n \n# Driver Code\nS = ' '\nS1 = 'eek'\nS2 = 'ok'\nmodifyString(S, S1, S2)\n \n# This code is contributed by rutikbhosale\n"], "Find Maximum number possible by doing at-most K swaps -  ": ["# Python3 program to find maximum \n# integer possible by doing at-most\n# K swap operations on its digits.\n \n# utility function to swap two\n# characters of a string\ndef swap(string, i, j):\n \n    return (string[:i] + string[j] +\n            string[i + 1:j] +\n            string[i] + string[j + 1:])\n \n# function to find maximum integer \n# possible by doing at-most K swap \n# operations on its digits\ndef findMaximumNum(string, k, maxm):\n     \n    # return if no swaps left\n    if k == 0:\n        return\n \n    n = len(string)\n \n    # consider every digit\n    for i in range(n - 1):\n \n        # and compare it with all digits after it\n        for j in range(i + 1, n):\n \n            # if digit at position i is less than \n            # digit at position j, swap it and \n            # check for maximum number so far and\n            # recurse for remaining swaps\n            if string[i] < string[j]:\n \n                # swap string[i] with string[j]\n                string = swap(string, i, j)\n \n                # If current num is more than\n                # maximum so far\n                if string > maxm[0]:\n                    maxm[0] = string\n \n                # recurse of the other k - 1 swaps\n                findMaximumNum(string, k - 1, maxm)\n \n                # backtrack\n                string = swap(string, i, j)\n \n# Driver Code\nif __name__ == '__main__':\n    string = '129814999'\n    k = 4\n    maxm = [string]\n    findMaximumNum(string, k, maxm)\n    print(maxm[0])\n \n# This code is contributed \n# by vibhu4agarwal\n", "# Python3 program to find maximum\n# integer possible by doing at-most\n# K swap operations on its digits.\n \n# function to find maximum integer\n# possible by doing at-most K swap\n# operations on its digits\ndef findMaximumNum(string, k, maxm, ctr):\n      \n    # return if no swaps left\n    if k == 0:\n        return\n  \n    n = len(string)\n    # Consider every digit after\n    # the cur position\n    mx = string[ctr]\n \n    for i in range(ctr+1,n):\n        # Find maximum digit greater\n        # than at ctr among rest\n        if int(string[i]) > int(mx):\n            mx=string[i]\n             \n    # If maxm is not equal to str[ctr],\n    # decrement k        \n    if(mx!=string[ctr]):\n        k=k-1\n     \n    # search this maximum among the rest from behind\n    # first swap the last maximum digit if it occurs more than 1 time\n    # example str= 1293498 and k=1 then max string is 9293418 instead of 9213498\n    for i in range(ctr,n):\n        # If digit equals maxm swap\n        # the digit with current\n        # digit and recurse for the rest\n        if(string[i]==mx):\n            # swap str[ctr] with str[j]\n            string[ctr], string[i] = string[i], string[ctr]\n            new_str = ''.join(string)\n            # If current num is more than\n            # maximum so far\n            if int(new_str) > int(maxm[0]):\n                  maxm[0] = new_str\n  \n            # recurse of the other k - 1 swaps\n            findMaximumNum(string, k , maxm, ctr+1)\n \n            # backtrack\n            string[ctr], string[i] = string[i], string[ctr]\n  \n# Driver Code\nif __name__ == '__main__':\n    string = '129814999'\n    k = 4\n    maxm = [string]\n    string = [char for char in string]\n    findMaximumNum(string, k, maxm, 0)\n    print(maxm[0])\n  \n# This code is contributed Aarti_Rathi\n"], "Find the character in first string that is present at minimum index in second string -  ": ["# Python3 implementation to find the character in\n# first that is present at minimum index\n# in second String\n \n# function to find the minimum index character\ndef printMinIndexChar(Str, patt):\n \n    # to store the index of character having\n    # minimum index\n    minIndex = 10**9\n \n    # lengths of the two Strings\n    m =len(Str)\n    n =len(patt)\n \n    # traverse 'patt'\n    for i in range(n):\n \n        # for each character of 'patt' traverse 'Str'\n        for j in range(m):\n \n            # if patt[i] is found in 'Str', check if\n            # it has the minimum index or not. If yes,\n            # then update 'minIndex' and break\n            if (patt[i] == Str[j] and j < minIndex):\n                minIndex = j\n                break\n \n \n \n \n    # print the minimum index character\n    if (minIndex != 10**9):\n        print('Minimum Index Character = ',Str[minIndex])\n \n    # if no character of 'patt' is present in 'Str'\n    else:\n        print('No character present')\n \n \n# Driver code\n \nStr = ' '\npatt = 'set'\nprintMinIndexChar(Str, patt)\n \n# This code is contributed by mohit kumar 29\n", "# Python3 implementation to \n# find the character in first \n# string that is present at\n# minimum index in second string\nimport sys\n \n# Function to find the \n# minimum index character\ndef printMinIndexChar(st, patt):\n \n    # unordered_map 'um' \n    # implemented as hash table\n    um = {}\n \n    # to store the index of \n    # character having minimum index\n    minIndex = sys.maxsize\n \n    # Lengths of the two strings\n    m = len(st)\n    n = len(patt)\n \n    # Store the first index of \n    # each character of 'str'\n    for i in range (m):\n        if (st[i] not in um):\n            um[st[i]] = i\n \n    # traverse the string 'patt'\n    for i in range(n):\n \n        # If patt[i] is found in 'um', \n        # check if  it has the minimum \n        # index or not accordingly \n        # update 'minIndex'\n        if (patt[i] in um and\n            um[patt[i]] < minIndex):\n            minIndex = um[patt[i]]\n \n    # Print the minimum index character\n    if (minIndex != sys.maxsize):\n        print ('Minimum Index Character = ', \n                st[minIndex])\n \n    # If no character of 'patt'\n    # is present in 'str'\n    else:\n        print ('No character present')\n \n# Driver program to test above\nif __name__ == '__main__':\n \n  st = ' '\n  patt = 'set'\n  printMinIndexChar(st, patt)\n \n# This code is contributed by Chitranayal\n"], "Multiply Large Numbers represented as Strings -  ": ["# Python3 program to multiply two numbers \n# represented as strings.\n \n# Multiplies str1 and str2, and prints result.\ndef multiply(num1, num2):\n    len1 = len(num1)\n    len2 = len(num2)\n    if len1 == 0 or len2 == 0:\n        return '0'\n \n    # will keep the result number in vector\n    # in reverse order\n    result = [0] * (len1 + len2)\n     \n    # Below two indexes are used to \n    # find positions in result.\n    i_n1 = 0\n    i_n2 = 0\n \n    # Go from right to left in num1\n    for i in range(len1 - 1, -1, -1):\n        carry = 0\n        n1 = ord(num1[i]) - 48\n \n        # To shift position to left after every\n        # multiplication of a digit in num2\n        i_n2 = 0\n \n        # Go from right to left in num2\n        for j in range(len2 - 1, -1, -1):\n             \n            # Take current digit of second number\n            n2 = ord(num2[j]) - 48\n         \n            # Multiply with current digit of first number\n            # and add result to previously stored result\n            # at current position.\n            summ = n1 * n2 + result[i_n1 + i_n2] + carry\n \n            # Carry for next iteration\n            carry = summ // 10\n \n            # Store result\n            result[i_n1 + i_n2] = summ % 10\n \n            i_n2 += 1\n \n            # store carry in next cell\n        if (carry > 0):\n            result[i_n1 + i_n2] += carry\n \n            # To shift position to left after every\n            # multiplication of a digit in num1.\n        i_n1 += 1\n         \n        # print(result)\n \n    # ignore '0's from the right\n    i = len(result) - 1\n    while (i >= 0 and result[i] == 0):\n        i -= 1\n \n    # If all were '0's - means either both or\n    # one of num1 or num2 were '0'\n    if (i == -1):\n        return '0'\n \n    # generate the result string\n    s = ''\n    while (i >= 0):\n        s += chr(result[i] + 48)\n        i -= 1\n \n    return s\n \n# Driver code\nstr1 = '1235421415454545454545454544'\nstr2 = '1714546546546545454544548544544545'\n \nif((str1[0] == '-' or str2[0] == '-') and\n   (str1[0] != '-' or str2[0] != '-')):\n    print('-', end = '')\n \n \nif(str1[0] == '-' and str2[0] != '-'):\n    str1 = str1[1:]\nelif(str1[0] != '-' and str2[0] == '-'):\n    str2 = str2[1:]\nelif(str1[0] == '-' and str2[0] == '-'):\n    str1 = str1[1:]\n    str2 = str2[1:]\nprint(multiply(str1, str2))\n \n# This code is contributed by ankush_953\n", "def multiply_strings(a, b):\n    if a == '0' or b == '0':\n        return '0'\n     \n    m, n = len(a) - 1, len(b) - 1\n    carry = 0\n    product = ''\n    for i in range(0, m+n+1):\n        for j in range(max(0, i-n), min(i, m)+1):\n            carry += (ord(a[m-j]) - 48) * (ord(b[n-i+j]) - 48)\n        product += str(carry % 10)\n        carry //= 10\n    return product[::-1]\n \nif __name__ == '__main__':\n    a = '1235421415454545454545454544'\n    b = '1714546546546545454544548544544545'\n    product = multiply_strings(a, b)\n    print('The Product is: ' + product)\n", "# Python3 program to implement the above approach\n \n# function to reverse the string\ndef reverse(s):\n    str = ''\n    for i in s:\n        str = i + str\n    return str\n \nnum1 = '1235421415454545454545454544'\ntempnum1 = num1\nnum2 = '1714546546546545454544548544544545'\ntempnum2 = num2\n \n# Check condition if one string is negative\nif (num1[0] == '-' and num2[0] != '-'):\n    num1 = num1[1:]\nelif (num1[0] != '-' and num2[0] == '-'):\n    num2 = num2[1:]\nelif (num1[0] == '-' and num2[0] == '-'):\n    num1 = num1[1:]\n    num2 = num2[1:]\n  \ns1 = num1\ns2 = num2\ns1 = reverse(s1)\ns2 = reverse(s2)\nm = [0]*(len(s1)+len(s2))\n \n# Go from right to left in num1\nfor i in range(len(s1)):\n   \n    # Go from right to left in num2\n    for j in range(len(s2)):\n        m[i + j] = m[i + j] + (ord(s1[i]) - 48) * (ord(s2[j]) - 48)\n       \n     \nproduct = ''\n# Multiply with current digit of first number\n# and add result to previously stored product\n# at current position.\nfor i in range(len(m)):\n    digit = m[i] % 10\n    carry = m[i] // 10\n    if (i + 1 < len(m)):\n        m[i + 1] = m[i + 1] + carry\n    product = str(digit) + product\n   \n# ignore '0's from the right\nwhile (len(product) > 1 and product[0] == '0'): \n    product = product[1:]\n    \n#check condition if one string is negative\nif (tempnum1[0] == '-' and tempnum2[0] != '-'):\n    product = '-' + product\n     \nelif (tempnum1[0] != '-' and tempnum2[0] == '-'):\n    product = '-' + product\n     \n \nprint('Product of the two numbers is :')\nprint(product)\n \n \n# This code is contributed by Abhijeet Kumar(abhijeet19403)\n", "def multiply(num1, num2):\n    # Convert the input numbers from strings to lists of integers\n    num1 = [int(digit) for digit in num1][::-1]\n    num2 = [int(digit) for digit in num2][::-1]\n \n    # Initialize the result list with zeros\n    result = [0] * (len(num1) + len(num2))\n \n    # Multiply each digit in num2 with num1 and add the result to the appropriate position in the result list\n    for i, digit2 in enumerate(num2):\n        carry = 0\n        for j, digit1 in enumerate(num1):\n            product = digit1 * digit2 + carry + result[i + j]\n            carry = product // 10\n            result[i + j] = product % 10\n        result[i + len(num1)] = carry\n \n    # Remove leading zeros from the result list and convert it back to a string\n    result = result[::-1]\n    while len(result) > 1 and result[-1] == 0:\n        result.pop()\n    return ''.join(str(digit) for digit in result)\n# Example 1\nnum1 = '4154'\nnum2 = '51454'\nprint(multiply(num1, num2))\n# Output: '213739916'\n \n# Example 2\nnum1 = '654154154151454545415415454'\nnum2 = '63516561563156316545145146514654'\nprint(multiply(num1, num2))\n# Output: '41549622603955309777243716069997997007620439937711509062916'\n"], "Check for Balanced Brackets in an expression (well-formedness) -  ": ["# Python3 program to check for\n# balanced brackets.\n \n# function to check if\n# brackets are balanced\n \n \ndef areBracketsBalanced(expr):\n    stack = []\n \n    # Traversing the Expression\n    for char in expr:\n        if char in ['(', '{', '[']:\n \n            # Push the element in the stack\n            stack.append(char)\n        else:\n \n            # IF current character is not opening\n            # bracket, then it must be closing.\n            # So stack cannot be empty at this point.\n            if not stack:\n                return False\n            current_char = stack.pop()\n            if current_char == '(':\n                if char != ')':\n                    return False\n            if current_char == '{':\n                if char != '}':\n                    return False\n            if current_char == '[':\n                if char != ']':\n                    return False\n \n    # Check Empty Stack\n    if stack:\n        return False\n    return True\n \n \n# Driver Code\nif __name__ == '__main__':\n    expr = '{()}[]'\n \n    # Function call\n    if areBracketsBalanced(expr):\n        print('Balanced')\n    else:\n        print('Not Balanced')\n \n# This code is contributed by AnkitRai01 and improved\n# by Raju Pitta\n", "def are_brackets_balanced(s):\n    stack = []\n    for ch in s:\n        if ch in ('(', '{', '['):\n            stack.append(ch)\n        else:\n            if stack and ((stack[-1] == '(' and ch == ')') or\n                          (stack[-1] == '{' and ch == '}') or\n                          (stack[-1] == '[' and ch == ']')):\n                stack.pop()\n            else:\n                return False\n    return not stack\n \nexpr = '{()}[]'\n \n# Function call\nif are_brackets_balanced(expr):\n    print('Balanced')\nelse:\n    print('Not Balanced')\n"], "Capacity To Ship Packages Within D Days -  ": ["# function for checking the that sum is minimum weight capacity of a boat\n# to ship all weight in d days or not.\ndef check(v, index, sum, remain, n):\n    # curr_sum checker fo sub_array.\n    xsum = 0\n \n    # to_check the number of days.\n    cnt = 0\n \n    # here we go for all part that are possible.\n    for i in range(index, n):\n        xsum += v[i]\n        if xsum >= sum:\n            if xsum == sum:\n                xsum = 0\n            else:\n                xsum = v[i]\n            cnt += 1\n        if n-i == remain-cnt:\n            return 1\n    if xsum != 0:\n        cnt += 1\n    return cnt == remain\n \n \nv = [1, 2, 1]\nd = 2\n \nm = max(v)\n \nif d == 1:\n    sum = 0\n    for it in v:\n        sum += it\n    print(sum)\nelse:\n    n = len(v)\n    i = 0\n \n    while True:\n        if check(v, i, m, d, n):\n            print('Minimum Capacity Of Boat To Ship Weights In ' + str(d) + ' Days Should Be: ' + str(m))\n            break\n        m += 1\n", "# Python3 program for the above approach\n \n# Function to check if the weights\n# can be delivered in D days or not\ndef isValid(weight, n, D, mx):\n     \n    # Stores the count of days required\n    # to ship all the weights if the\n    # maximum capacity is mx\n    st = 1\n    sum = 0\n \n    # Traverse all the weights\n    for i in range(n):\n        sum += weight[i]\n \n        # If total weight is more than\n        # the maximum capacity\n        if (sum > mx):\n            st += 1\n            sum = weight[i]\n \n        # If days are more than D,\n        # then return false\n        if (st > D):\n            return False\n \n    # Return true for the days < D\n    return True\n \n# Function to find the least weight\n# capacity of a boat to ship all the\n# weights within D days\ndef shipWithinDays(weight, D, n):\n     \n    # Stores the total weights to\n    # be shipped\n    sum = 0\n \n    # Find the sum of weights\n    for i in range(n):\n        sum += weight[i]\n \n    # Stores the maximum weight in the\n    # array that has to be shipped\n    s = weight[0]\n    for i in range(1, n):\n        s = max(s, weight[i])\n \n    # Store the ending value for\n    # the search space\n    e = sum\n \n    # Store the required result\n    res = -1\n \n    # Perform binary search\n    while (s <= e):\n         \n        # Store the middle value\n        mid = s + (e - s) // 2\n \n        # If mid can be shipped, then\n        # update the result and end\n        # value of the search space\n        if (isValid(weight, n, D, mid)):\n            res = mid\n            e = mid - 1\n \n        # Search for minimum value\n        # in the right part\n        else:\n            s = mid + 1\n \n    # Print the result\n    print(res)\n \n# Driver Code\nif __name__ == '__main__':\n     \n    weight = [ 9, 8, 10 ]\n    D = 3\n    N = len(weight)\n     \n    shipWithinDays(weight, D, N)\n \n# This code is contributed by ipg2016107\n"], "Print all array elements appearing more than N / K times -  ": ["# Python3 program to implement\n# the above approach\n \n# Function to print all array elements\n# whose frequency is greater than N / K\ndef NDivKWithFreq(arr, N, K):\n     \n    # Sort the array, arr[]\n    arr = sorted(arr)\n \n    # Traverse the array\n    i = 0\n     \n    while i < N:\n         \n        # Stores frequency of arr[i]\n        cnt = 1\n \n        # Traverse array elements which\n        # is equal to arr[i]\n        while ((i + 1) < N and\n               arr[i] == arr[i + 1]):\n \n            # Update cnt\n            cnt += 1\n \n            # Update i\n            i += 1\n \n        # If frequency of arr[i] is\n        # greater than (N / K)\n        if (cnt > (N // K)):\n            print(arr[i], end = ' ')\n             \n        i += 1\n \n# Driver Code\nif __name__ == '__main__':\n     \n    arr = [ 1, 2, 2, 6, 6, 6, 6, 7, 10 ]\n    N = len(arr)\n    K = 4\n \n    NDivKWithFreq(arr, N, K)\n \n# This code is contributed by mohit kumar 29\n", "# Python program to implement\n# the above approach\n \n# Function to+ find the upper_bound of\n# an array element\ndef upperBound(arr, N, K):\n \n  # Stores minimum index\n    # in which K lies\n    l = 0;\n \n    # Stores maximum index\n    # in which K lies\n    r = N;\n \n    # Calculate the upper\n    # bound of K\n    while (l < r):\n \n        # Stores mid element\n        # of l and r\n        mid = (l + r) // 2;\n \n        # If arr[mid] is less\n        # than or equal to K\n        if (arr[mid] <= K):\n \n            # Right subarray\n            l = mid + 1;\n        else:\n \n            # Left subarray\n            r = mid;\n    return l;\n \n# Function to print all array elements\n# whose frequency is greater than N / K\ndef NDivKWithFreq(arr, N, K):\n   \n  # Sort the array arr\n    arr.sort();\n \n    # Stores index of\n    # an array element\n    i = 0;\n \n    # Traverse the array\n    while (i < N):\n \n        # Stores upper bound of arr[i]\n        X = upperBound(arr, N, arr[i]);\n \n        # If frequency of arr[i] is\n        # greater than N / 4\n        if ((X - i) > N // 4):\n            print(arr[i], end='');\n \n        # Update i\n        i = X;\n \n# Driver Code\nif __name__ == '__main__':\n   \n    # Given array arr\n    arr = [1, 2, 2, 6, 6, 6, 6, 7, 10];\n \n    # Size of array\n    N = len(arr);\n    K = 4;\n \n    # Function Call\n    NDivKWithFreq(arr, N, K);\n \n    # This code is contributed by 29AjayKumar\n", "# Python3 implementation\nfrom collections import Counter\n \n# Function to find the number of array\n# elements with frequency more than n/k times\ndef printElements(arr, n, k):\n \n    # Calculating n/k\n    x = n//k\n \n    # Counting frequency of every \n    # element using Counter\n    mp = Counter(arr)\n     \n    # Traverse the map and print all\n    # the elements with occurrence atleast n/k times\n    for it in mp:\n        if mp[it] > x:\n            print(it)\n \n \n# Driver code\narr = [1, 2, 2, 6, 6, 6, 6, 7, 10]\n \n# Size of array\nn = len(arr)\nk = 4\n \nprintElements(arr, n, k)\n \n# This code is contributed by vikkycirus\n", "def find_elements(arr, K):\n    N = len(arr)\n    freq_map = {}\n    for i in range(N):\n        if arr[i] not in freq_map:\n            freq_map[arr[i]] = 1\n        else:\n            freq_map[arr[i]] += 1\n    req_elements = []\n    for key, value in freq_map.items():\n        if value > (N // K):\n            req_elements.append(key)\n    return req_elements\n \narr = [1, 2, 6, 6, 6, 6, 6, 10]\nK = 4\nprint(find_elements(arr, K))  # Output: [6]\n \n# This code is contributed by Uppala Sridevi\n"], "Sum of bit differences among all pairs -  ": ["# Python3 program for the above approach\ndef sumBitDiff(arr):\n    diff = 0    #hold the ans\n       \n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n               \n        # XOR toggles the bits and will form a number that will have\n        # set bits at the places where the numbers bits differ\n        # eg: 010 ^ 111 = 101...diff of bits = count of 1's = 2           \n            xor = arr[i]^arr[j]\n            count = countSetBits(xor)        #Integer.bitCount() can also be used\n                   \n            # when i == j (same numbers) the xor would be 0, \n            # thus our ans will remain unaffected as (2*0 = 0)\n            diff += (2*count)\n       \n    return diff\n     \n# Kernighan algo\ndef countSetBits(n):\n    count = 0            # `count` stores the total bits set in `n`\n  \n    while (n != 0) :\n        n = n & (n - 1)    # clear the least significant bit set\n        count += 1\n         \n    return count\n     \n# Driver code\nif __name__ == '__main__':\n     \n    arr = [5,10]\n    ans  = sumBitDiff(arr)\n    print(ans)\n \n    # This code is contributed by sanjoy_62.\n", "# Python program to compute sum of pairwise bit differences\n \ndef sumBitDifferences(arr, n):\n \n    ans = 0  # Initialize result\n \n    # traverse over all bits\n    for i in range(0, 32):\n     \n        # count number of elements with i'th bit set\n        count = 0\n        for j in range(0, n):\n            if ( (arr[j] & (1 << i)) ):\n                count+= 1\n \n        # Add 'count * (n - count) * 2' to the answer\n        ans += (count * (n - count) * 2);\n     \n    return ans\n \n# Driver program\narr = [1, 3, 5]\nn = len(arr )\nprint(sumBitDifferences(arr, n))\n \n# This code is contributed by\n# Smitha Dinesh Semwal    \n"], "k-th smallest absolute difference of two elements in an array -  ": ["# Python3 program to find \n# k-th absolute difference \n# between two elements \nfrom bisect import bisect as upper_bound \n \n# returns number of pairs with \n# absolute difference less than \n# or equal to mid. \ndef countPairs(a, n, mid): \n    res = 0\n    for i in range(n): \n \n        # Upper bound returns pointer to position \n        # of next higher number than a[i]+mid in \n        # a[i..n-1]. We subtract (a + i + 1) from \n        # this position to count \n        res += upper_bound(a, a[i] + mid) \n    return res \n \n# Returns k-th absolute difference \ndef kthDiff(a, n, k): \n     \n    # Sort array \n    a = sorted(a) \n \n    # Minimum absolute difference \n    low = a[1] - a[0] \n    for i in range(1, n - 1): \n        low = min(low, a[i + 1] - a[i]) \n \n    # Maximum absolute difference \n    high = a[n - 1] - a[0] \n \n    # Do binary search for k-th absolute difference \n    while (low < high): \n        mid = (low + high) >> 1\n        if (countPairs(a, n, mid) < k): \n            low = mid + 1\n        else: \n            high = mid \n \n    return low \n \n# Driver code \nk = 3\na = [1, 2, 3, 4] \nn = len(a) \nprint(kthDiff(a, n, k)) \n \n# This code is contributed by Mohit Kumar \n"], "Find Surpasser Count of each element in array -  ": ["# Naive Python3 program to find \n# surpasser count of each element in array\n \n# Function to find surpasser count of \n# each element in array\ndef findSurpasser(arr, n):\n \n    for i in range(0, n):\n     \n        # stores surpasser count for element\n        # arr[i]\n        count = 0;\n \n        for j in range (i + 1, n):\n            if (arr[j] > arr[i]):\n                count += 1\n \n        print(count, end = ' ')\n \n \n# Function to print an array \ndef printArray(arr, n):\n \n    for i in range(0, n):\n        print(arr[i], end = ' ')\n     \n# Driver program to test above functions \narr = [2, 7, 5, 3, 0, 8, 1 ]\nn = len(arr)\n \nprint('Given array is')\nprintArray(arr , n)\n \nprint('\\nSurpasser Count of array is');\nfindSurpasser(arr , n)\n \n# This code is contributed by Smitha Dinesh Semwal\n", "# Python program to find surpasser count of each element\n# in array\n \n#  Function to merge the two haves arr[l..m] and\n# arr[m+1..r] of array arr[] \ndef merge(arr, l, m, r, hm):\n \n    n1 = m - l + 1\n    n2 = r - m\n \n    # create temp arrays\n    L= [0 for i in range(n1)]\n    R = [0 for i in range(n2)]\n \n    # Copy data to temp arrays L[] and R[]\n    for i in range(n1):\n        L[i] = arr[l + i]\n \n    for j in range(n2):\n        R[j] = arr[m + 1 + j]\n \n    #  Merge the temp arrays back into arr[l..r]\n    i,j,k,c = 0,0,l,0\n    while (i < n1 and j < n2):\n        if (L[i] <= R[j]):\n            # increment inversion count of L[i]\n            if(L[i] in hm):\n                hm[L[i]] += c\n            else :\n                hm[L[i]] = c\n            arr[k] = L[i]\n            k += 1\n            i += 1\n        else:\n            arr[k] = R[j]\n \n            # inversion found\n            c += 1\n            k += 1\n            j += 1\n \n    # Copy the remaining elements of L[], if\n    # there are any\n    while (i < n1):\n        if(L[i] in hm):\n            hm[L[i]] += c\n        else :\n            hm[L[i]] = c\n        arr[k] = L[i]\n        k += 1\n        i += 1\n \n    # Copy the remaining elements of R[], if\n    # there are any \n    while (j < n2):\n        arr[k] = R[j]\n        k += 1\n        j += 1\n \n# l is for left index and r is right index of\n# the sub-array of arr to be sorted\ndef mergeSort(arr,l,r,hm):\n    if (l < r):\n        m = l + (r - l) // 2\n        mergeSort(arr, l, m, hm)\n        mergeSort(arr, m + 1, r, hm)\n        merge(arr, l, m, r, hm)\n \n#  Function to print an array \ndef printArray(arr,n):\n \n    for i in range(n):\n        print(arr[i],end = ' ')\n    print('')\n \ndef findSurpasser(arr, n):\n    # To store inversion count for elements\n    hm = {}\n \n    # To store copy of array\n    dup = arr[:]\n \n    # Sort the copy and store inversion count\n    # for each element.\n    mergeSort(dup, 0, n - 1, hm)\n \n    print('Surpasser Count of array is ')\n    for i in range(n):\n        print((n - 1) - i - (hm[arr[i]] if arr[i] in hm else 0),end = ' ')\n \n# Driver program to test above functions \n \narr = [ 2, 7, 5, 3, 0, 8, 1 ]\nn = len(arr)\n \nprint('Given array is ')\nprintArray(arr, n)\n \nfindSurpasser(arr, n)\n \n# This code is contributed by shinjanpatra\n"], "Max sum of M non-overlapping subarrays of size K -  ": ["# Python3 program to find Max sum of M non-overlapping\n# subarray of size K in an Array\n \n# calculating presum of array. presum[i]\n# is going to store prefix sum of subarray\n# of size k beginning with arr[i]\ndef calculatePresumArray(presum,arr, n, k):\n \n    for i in range(k):\n        presum[0] += arr[i]\n \n    # store sum of array index i to i+k \n    # in presum array at index i of it.\n    for i in range(1,n - k + 1): \n        presum[i] += presum[i - 1] + arr[i + k - 1] - arr[i - 1]\n \n# calculating maximum sum of m non overlapping array\ndef maxSumMnonOverlappingSubarray(presum, m, size, k, start):\n     \n    # if m is zero then no need any array\n    # of any size so return 0.\n    if (m == 0):\n        return 0\n \n    # if start is greater then the size\n    # of presum array return 0.\n    if (start > size - 1):\n        return 0\n \n    mx = 0\n \n    # if including subarray of size k\n    includeMax = presum[start] + maxSumMnonOverlappingSubarray(presum,m - 1, size, k, start + k)\n \n    # if excluding element and searching \n    # in all next possible subarrays\n    excludeMax = maxSumMnonOverlappingSubarray(presum,m, size, k, start + 1)\n \n    # return max\n    return max(includeMax, excludeMax)\n \n# Driver code\narr = [2, 10, 7, 18, 5, 33, 0]\nn = len(arr)\n \nm, k = 3, 1\n \npresum = [0 for i in range(n + 1 - k)]\ncalculatePresumArray(presum, arr, n, k)\n \n# resulting presum array will have a size = n+1-k\nprint(maxSumMnonOverlappingSubarray(presum, m, n + 1 - k, k, 0))\n \n# This code is contributed by mohit kumar\n"], "Search a Word in a 2D Grid of characters (Word Search) -  ": ["# Python3 program to search a word in a 2D grid\nclass GFG:\n     \n    def __init__(self):\n        self.R = None\n        self.C = None\n        self.dir = [[-1, 0], [1, 0], [1, 1], \n                    [1, -1], [-1, -1], [-1, 1],\n                    [0, 1], [0, -1]]\n                     \n    # This function searches in all 8-direction \n    # from point(row, col) in grid[][]\n    def search2D(self, grid, row, col, word):\n         \n        # If first character of word doesn't match \n        # with the given starting point in grid.\n        if grid[row][col] != word[0]:\n            return False\n             \n        # Search word in all 8 directions \n        # starting from (row, col)\n        for x, y in self.dir:\n             \n            # Initialize starting point \n            # for current direction\n            rd, cd = row + x, col + y\n            flag = True\n             \n            # First character is already checked, \n            # match remaining characters\n            for k in range(1, len(word)):\n                 \n                # If out of bound or not matched, break\n                if (0 <= rd <self.R and\n                    0 <= cd < self.C and\n                    word[k] == grid[rd][cd]):\n                     \n                    # Moving in particular direction\n                    rd += x\n                    cd += y\n                else:\n                    flag = False\n                    break\n             \n            # If all character matched, then \n            # value of flag must be false        \n            if flag:\n                return True\n        return False\n         \n    # Searches given word in a given matrix\n    # in all 8 directions    \n    def patternSearch(self, grid, word):\n         \n        # Rows and columns in given grid\n        self.R = len(grid)\n        self.C = len(grid[0])\n         \n        # Consider every point as starting point \n        # and search given word\n        for row in range(self.R):\n            for col in range(self.C):\n                if self.search2D(grid, row, col, word):\n                    print('pattern found at ' +\n                           str(row) + ', ' + str(col))\n                     \n# Driver Code\nif __name__=='__main__':\n    grid = [' ',\n            'GEEKSQUIZGEEK',\n            'IDEQAPRACTICE']\n    gfg = GFG()\n    gfg.patternSearch(grid, 'GEEKS')\n    print('')\n    gfg.patternSearch(grid, 'EEE')\n     \n# This code is contributed by Yezheng Li\n", "from typing import List\n \n \nclass Solution:\n    def __init__(self):\n        # making the possible moves in movers array\n        self.mover = [\n            [1, 0], [0, 1], [-1, 0], [0, -1],\n            [1, 1], [-1, -1], [1, -1], [-1, 1]\n        ]\n \n    # making a function findwords to find words along with\n    # their location which inputs the board and list of\n    # words\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        result = []\n        rows = len(board)\n        cols = len(board[0])\n \n        # making board a global variable\n        self.board = board\n \n        for word in words:\n            for i in range(rows):\n                for j in range(cols):\n                    if self.board[i][j] == word[0]:\n \n                        # making a function findwords to\n                        # find words along with their\n                        # location which inputs the board\n                        # and list of words\n                        if self.dfs(i, j, word[1:], [[False] * cols for _ in range(rows)]):\n                            result.append(f'{word}->{{{i},{j}}}')\n \n        return result\n \n    # depth first search for the string, with the\n    # coordinates and a visited array to take care that we\n    # do not overlap the places visited already\n    def dfs(self, x: int, y: int, s: str, vis: List[List[bool]]) -> bool:\n \n        # if string length becomes 0 means string is found\n        if not s:\n            return True\n \n        vis[x][y] = True\n \n        # making a solution boolean to see if we can\n        # perform depth search to find answer\n        sol = False\n \n        # making possible moves\n        for move in self.mover:\n            currX = move[0] + x\n            currY = move[1] + y\n \n            # checking for out of bound areas\n            if 0 <= currX < len(self.board) and 0 <= currY < len(self.board[0]):\n \n                # checking for similarity in the first\n                # letter and the visited array\n                if self.board[currX][currY] == s[0] and not vis[currX][currY]:\n                    if self.dfs(currX, currY, s[1:], vis):\n \n                        # removing the first letter\n                        # from the string\n                        sol = True\n \n        return sol\n \n \n# testing the code\nsolver = Solution()\nboard = [['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'],\n         ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v']]\nwords = ['oath', 'pea', 'eat', 'rain']\nans = solver.findWords(board, words)\nfor part in ans:\n    print(part)\n", "class Solution:\n    def __init__(self):\n        # Possible moves\n        self.mover = [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n \n    def dfs(self, x, y, word, visited):\n        # If word length becomes 0, the string is found\n        if len(word) == 0:\n            return True\n         \n        visited[x][y] = True\n        sol = False\n         \n        # Making possible moves\n        for move in self.mover:\n            curr_x = move[0] + x\n            curr_y = move[1] + y\n             \n            # Checking for out of bound areas\n            if 0 <= curr_x < len(self.board) and 0 <= curr_y < len(self.board[0]):\n                # Checking for similarity in the first letter and the visited array\n                if self.board[curr_x][curr_y] == word[0] and not visited[curr_x][curr_y]:\n                    s = word[1:]\n                    sol |= self.dfs(curr_x, curr_y, s, visited)\n                     \n        visited[x][y] = False\n        return sol\n \n    def findWords(self, board, words):\n        self.board = board\n        ans = []\n        visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n         \n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == word[0]:\n                        s = word[1:]\n                        if self.dfs(i, j, s, visited):\n                            ans.append(f'{word} -> {{{i},{j}}}')\n                             \n        return ans\n \n# Test\nboard = [['o', 'a', 'a', 'n'],\n         ['e', 't', 'a', 'e'],\n         ['i', 'h', 'k', 'r'],\n         ['i', 'f', 'l', 'v']]\nwords = ['oath', 'pea', 'eat', 'rain']\nsolver = Solution()\nprint(solver.findWords(board, words))\n"], "Find the Minimum element in a Sorted and Rotated Array -  ": ["# python3 code  to implement the approach\n \ndef findMin(arr, N):\n     \n    min_ele = arr[0];\n \n    # Traversing over array to\n    # find minimum element\n    for i in range(N) :\n        if arr[i] < min_ele :\n            min_ele = arr[i]\n \n    return min_ele;\n \n# Driver program\narr = [5, 6, 1, 2, 3, 4]\nN = len(arr)\n \nprint(findMin(arr,N))\n \n# This code is contributed by aditya942003patil\n", "def findMin(arr, low, high):\n    # If the array is not rotated\n    if arr[low] <= arr[high]:\n        return arr[low]\n \n    # Binary search\n    while low <= high:\n        mid = (low + high) // 2\n \n        # Check if mid is the minimum element\n        if arr[mid] < arr[mid-1]:\n            return arr[mid]\n        # If the left half is sorted, the minimum element must be in the right half\n        if arr[mid] > arr[high]:\n            low = mid + 1\n \n        # If the right half is sorted, the minimum element must be in the left half\n        else:\n            high = mid - 1\n \n    # If no minimum element is found, return None\n    return None\n# Driver program to test above functions\nif __name__ == '__main__':\n    arr = [5, 6, 1, 2, 3, 4]\n    N = len(arr)\n    print('The minimum element is ' + \\\n          str(findMin(arr, 0, N-1)))\n"], "Find the element that appears once -  ": ["# Python3 code to find the element that \n# appears once\n \ndef getSingle(arr, n):\n    ones = 0\n    twos = 0\n     \n    for i in range(n):\n        # one & arr[i]' gives the bits that\n        # are there in both 'ones' and new\n        # element from arr[]. We add these\n        # bits to 'twos' using bitwise XOR\n        twos = twos ^ (ones & arr[i])\n         \n        # one & arr[i]' gives the bits that\n        # are there in both 'ones' and new\n        # element from arr[]. We add these\n        # bits to 'twos' using bitwise XOR\n        ones = ones ^ arr[i]\n         \n        # The common bits are those bits \n        # which appear third time. So these\n        # bits should not be there in both \n        # 'ones' and 'twos'. common_bit_mask\n        # contains all these bits as 0, so\n        # that the bits can be removed from\n        # 'ones' and 'twos'\n        common_bit_mask = ~(ones & twos)\n         \n        # Remove common bits (the bits that \n        # appear third time) from 'ones'\n        ones &= common_bit_mask\n         \n        # Remove common bits (the bits that\n        # appear third time) from 'twos'\n        twos &= common_bit_mask\n    return ones\n     \n# driver code\narr = [3, 3, 2, 3]\nn = len(arr)\nprint('The element with single occurrence is ',\n        getSingle(arr, n))\n \n# This code is contributed by 'Abhishek Sharma 44'\n", "# Python3 code to find the element \n# that occur only once\nINT_SIZE = 32\n \ndef getSingle(arr, n) :\n     \n    # Initialize result\n    result = 0\n     \n    # Iterate through every bit\n    for i in range(0, INT_SIZE) :\n         \n        # Find sum of set bits \n        # at ith position in all \n        # array elements\n        sm = 0\n        x = (1 << i)\n        for j in range(0, n) :\n            if (arr[j] & x) :\n                sm = sm + 1\n                 \n        # The bits with sum not \n        # multiple of 3, are the\n        # bits of element with \n        # single occurrence.\n        if ((sm % 3)!= 0) :\n            result = result | x\n     \n    return result\n     \n# Driver program\narr = [12, 1, 12, 3, 12, 1, 1, 2, 3, 2, 2, 3, 7]\nn = len(arr)\nprint('The element with single occurrence is ', getSingle(arr, n))\n \n \n# This code is contributed \n# by Nikita Tiwari.\n", "# Python3 program to find the element \n# that occur only once\n \n# function which find number\ndef singleNumber(nums):\n     \n    # applying the formula.\n    return (3 * sum(set(nums)) - sum(nums)) / 2\n \n# driver function.\na = [12, 1, 12, 3, 12, 1, 1, 2, 3, 2, 2, 3, 7]\nprint ('The element with single occurrence is ', \n                          int(singleNumber(a)))\n", "from collections import Counter\n# Python3 program to find the element\n# that occur only once\n \n# function which find number\ndef singleNumber(nums):\n   \n    # storing the frequencies using Counter\n    freq = Counter(nums)\n     \n    # traversing the Counter dictionary\n    for i in freq:\n       \n        # check if any value is 1\n        if(freq[i] == 1):\n            return i\n \n \n# driver function.\na = [12, 1, 12, 3, 12, 1, 1, 2, 3, 2, 2, 3, 7]\nprint('The element with single occurrence is ',\n      int(singleNumber(a)))\n# This code is contributed by vikkycirus\n", "# Python3 code to find the element that\n# appears once\n \narr = [3, 3, 2, 3]\nfor i in arr:\n    if(arr.count(i)==1):\n        x=i\n        break\nprint('The element with single occurrence is ',x)\n"], "Number of subarrays having sum exactly equal to k -  ": ["# Python3 program for\n# the above approach\n# Calculate all subarrays\n \n \ndef count_all_subarrys(arr,  n):\n    # count all subarrays\n    res = 0\n    for i in range(n):\n        summ = 0\n        for j in range(i, n):\n \n            # Calculate required sum\n            summ += arr[j]\n \n            # Check if sum is equal to\n            # required sum\n            if summ == k:\n                res += 1\n    return res\n \n \n# main function\nif __name__ == '__main__':\n    arr = [10, 2, -2, -20, 10]\n    n = len(arr)\n    k = -10\n    print(count_all_subarrys(arr, n))\n \n# This code is contributed by shushant kumar\n", "# Python3 program to find the number of \n# subarrays with sum exactly equal to k. \nfrom collections import defaultdict\n \n# Function to find number of subarrays  \n# with sum exactly equal to k. \ndef findSubarraySum(arr, n, Sum): \n  \n    # Dictionary to store number of subarrays \n    # starting from index zero having  \n    # particular value of sum. \n    prevSum = defaultdict(lambda : 0)\n   \n    res = 0\n   \n    # Sum of elements so far. \n    currsum = 0\n   \n    for i in range(0, n):  \n   \n        # Add current element to sum so far. \n        currsum += arr[i] \n   \n        # If currsum is equal to desired sum, \n        # then a new subarray is found. So \n        # increase count of subarrays. \n        if currsum == Sum:  \n            res += 1        \n   \n        # currsum exceeds given sum by currsum  - sum.\n        # Find number of subarrays having  \n        # this sum and exclude those subarrays \n        # from currsum by increasing count by  \n        # same amount. \n        if (currsum - Sum) in prevSum:\n            res += prevSum[currsum - Sum] \n           \n   \n        # Add currsum value to count of  \n        # different values of sum. \n        prevSum[currsum] += 1\n      \n    return res \n  \nif __name__ == '__main__':\n \n    arr =  [10, 2, -2, -20, 10]  \n    Sum = -10\n    n = len(arr) \n    print(findSubarraySum(arr, n, Sum)) \n     \n# This code is contributed by Rituraj Jain\n"], "Find a triplet in an array whose sum is closest to a given number -  ": ["# Python3 implementation of the above approach\nimport sys\n \n# Function to return the sum of a\n# triplet which is closest to x\ndef solution(arr, x):\n \n    # To store the closest sum\n    closestSum = sys.maxsize\n \n    # Run three nested loops each loop \n    # for each element of triplet\n    for i in range (len(arr)) :\n        for j in range(i + 1, len(arr)):\n            for k in range(j + 1, len( arr)):\n             \n                # Update the closestSum\n                if(abs(x - closestSum) > \n                abs(x - (arr[i] +\n                arr[j] + arr[k]))):\n                    closestSum = (arr[i] +\n                                    arr[j] + arr[k])\n             \n    # Return the closest sum found\n    return closestSum\n \n# Driver code\nif __name__ == '__main__':\n     \n    arr = [ -1, 2, 1, -4 ]\n    x = 1\n     \n    print(solution(arr, x))\n \n# This code is contributed by chitranayal\n", "# Python3 implementation of the approach \n \nimport sys\n \n# Function to return the sum of a \n# triplet which is closest to x \ndef solution(arr, x) : \n \n    # Sort the array \n    arr.sort();\n     \n    # To store the closest sum\n    closestSum = sys.maxsize; \n \n    # Fix the smallest number among \n    # the three integers \n    for i in range(len(arr)-2) : \n \n        # Two pointers initially pointing at \n        # the last and the element \n        # next to the fixed element \n        ptr1 = i + 1; ptr2 = len(arr) - 1; \n \n        # While there could be more pairs to check \n        while (ptr1 < ptr2) :\n \n            # Calculate the sum of the current triplet \n            sum = arr[i] + arr[ptr1] + arr[ptr2]; \n \n            # If the sum is more closer than \n            # the current closest sum \n            if (abs(x - sum) < abs(x - closestSum)) :\n                closestSum = sum; \n \n            # If sum is greater than x then decrement \n            # the second pointer to get a smaller sum \n            if (sum > x) :\n                ptr2 -= 1; \n \n            # Else increment the first pointer \n            # to get a larger sum \n            else :\n                ptr1 += 1; \n \n    # Return the closest sum found \n    return closestSum; \n \n \n# Driver code \nif __name__ == '__main__' : \n \n    arr = [ -1, 2, 1, -4 ]; \n    x = 1; \n    print(solution(arr, x)); \n \n# This code is contributed by AnkitRai01\n"], "Find a peak element which is not smaller than its neighbours -  ": ["# A Python3 program to find a peak element \n  \n# Find the peak element in the array \ndef findPeak(arr, n) : \n  \n    # first or last element is peak element \n    if (n == 1) : \n      return 0\n    if (arr[0] >= arr[1]) : \n        return 0\n    if (arr[n - 1] >= arr[n - 2]) : \n        return n - 1\n   \n    # check for every other element \n    for i in range(1, n - 1) : \n   \n        # check if the neighbors are smaller \n        if (arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]) : \n            return i \n              \n# Driver code. \narr = [ 1, 3, 20, 4, 1, 0 ] \nn = len(arr) \nprint('Index of a peak point is', findPeak(arr, n)) \n  \n# This code is contributed by divyeshrabadiya07\n", "# A python3 program to find a peak \n#  element using divide and conquer \n  \n# A binary search based function \n# that returns index of a peak element \n  \n  \ndef findPeakUtil(arr, low, high, n): \n  \n    # Find index of middle element \n    # low + (high - low) / 2 \n    mid = low + (high - low)/2\n    mid = int(mid) \n  \n    # Compare middle element with its \n    # neighbours (if neighbours exist) \n    if ((mid == 0 or arr[mid - 1] <= arr[mid]) and \n        (mid == n - 1 or arr[mid + 1] <= arr[mid])): \n        return mid \n  \n  \n    # If middle element is not peak and  \n    # its left neighbour is greater  \n    # than it, then left half must  \n    # have a peak element \n    elif (mid > 0 and arr[mid - 1] > arr[mid]): \n        return findPeakUtil(arr, low, (mid - 1), n) \n  \n    # If middle element is not peak and \n    # its right neighbour is greater \n    # than it, then right half must  \n    # have a peak element \n    else: \n        return findPeakUtil(arr, (mid + 1), high, n) \n  \n  \n# A wrapper over recursive  \n# function findPeakUtil() \ndef findPeak(arr, n): \n  \n    return findPeakUtil(arr, 0, n - 1, n) \n  \n  \n# Driver code \narr = [1, 3, 20, 4, 1, 0] \nn = len(arr) \nprint('Index of a peak point is', findPeak(arr, n)) \n      \n# This code is contributed by  \n# Smitha Dinesh Semwal \n", "# A Python program to find a peak element \n# using divide and conquer \n  \n# A binary search based function \n# that returns index of a peak element \ndef findPeak(arr, n): \n    \n    l = 0\n    r = n-1\n      \n    while(l <= r): \n  \n        # finding mid by binary right shifting. \n        mid = (l + r) >> 1\n  \n        # first case if mid is the answer \n        if((mid == 0 or arr[mid - 1] <= arr[mid]) and (mid == n - 1 or arr[mid + 1] <= arr[mid])): \n            break\n  \n        # move the right pointer \n        if(mid > 0 and arr[mid - 1] > arr[mid]): \n            r = mid - 1\n  \n        # move the left pointer \n        else: \n            l = mid + 1\n  \n    return mid \n  \n  \n# Driver Code \narr = [1, 3, 20, 4, 1, 0] \nn = len(arr) \nprint(f'Index of a peak point is {findPeak(arr, n)}') \n  \n# This code is contributed by Rajdeep Mallick (rajdeep999) \n"], "Majority Element -  ": ["# Python3 program to find Majority\n# element in an array\n \n# Function to find Majority\n# element in an array\n \n \ndef findMajority(arr, n):\n \n    maxCount = 0\n    index = -1  # sentinels\n    for i in range(n):\n \n        count = 1\n        # here we compare the element in \n        # ith position with i+1th position\n        for j in range(i+1, n):\n \n            if(arr[i] == arr[j]):\n                count += 1\n \n        # update maxCount if count of\n        # current element is greater\n        if(count > maxCount):\n \n            maxCount = count\n            index = i\n \n    # if maxCount is greater than n/2\n    # return the corresponding element\n    if (maxCount > n//2):\n        print(arr[index])\n \n    else:\n        print('No Majority Element')\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [1, 1, 2, 1, 3, 5, 1]\n    n = len(arr)\n \n    # Function calling\n    findMajority(arr, n)\n \n# This code is contributed\n# by ChitraNayal\n", "# Python3 program to demonstrate insert operation in binary\n# search tree.\n# class for creating node\nclass Node():\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n        self.count = 1  # count of number of times data is inserted in tree\n \n# class for binary search tree\n# it initialises tree with None root\n# insert function inserts node as per BST rule\n# and also checks for majority element\n# if no majority element is found yet, it returns None\n \n \nclass BST():\n    def __init__(self):\n        self.root = None\n \n    def insert(self, data, n):\n        out = None\n        if (self.root == None):\n            self.root = Node(data)\n        else:\n            out = self.insertNode(self.root, data, n)\n        return out\n \n    def insertNode(self, currentNode, data, n):\n        if (currentNode.data == data):\n            currentNode.count += 1\n            if (currentNode.count > n//2):\n                return currentNode.data\n            else:\n                return None\n        elif (currentNode.data < data):\n            if (currentNode.right):\n                self.insertNode(currentNode.right, data, n)\n            else:\n                currentNode.right = Node(data)\n        elif (currentNode.data > data):\n            if (currentNode.left):\n                self.insertNode(currentNode.left, data, n)\n            else:\n                currentNode.left = Node(data)\n \n \n# Driver code\n# declaring an array\narr = [3, 2, 3]\nn = len(arr)\n \n# declaring None tree\ntree = BST()\nflag = 0\nfor i in range(n):\n    out = tree.insert(arr[i], n)\n    if (out != None):\n        print(arr[i])\n        flag = 1\n        break\nif (flag == 0):\n    print('No Majority Element')\n", "# Program for finding out majority element in an array\n \n# Function to find the candidate for Majority\n \n \ndef findCandidate(A):\n    maj_index = 0\n    count = 1\n    for i in range(len(A)):\n        if A[maj_index] == A[i]:\n            count += 1\n        else:\n            count -= 1\n        if count == 0:\n            maj_index = i\n            count = 1\n    return A[maj_index]\n \n# Function to check if the candidate occurs more than n/2 times\n \n \ndef isMajority(A, cand):\n    count = 0\n    for i in range(len(A)):\n        if A[i] == cand:\n            count += 1\n    if count > len(A)/2:\n        return True\n    else:\n        return False\n \n# Function to print Majority Element\n \n \ndef printMajority(A):\n    # Find the candidate for Majority\n    cand = findCandidate(A)\n \n    # Print the candidate if it is Majority\n    if isMajority(A, cand) == True:\n        print(cand)\n    else:\n        print('No Majority Element')\n \n \n# Driver code\nA = [1, 3, 3, 1, 2]\n \n# Function call\nprintMajority(A)\n", "# Python3 program for finding out majority \n# element in an array \n \ndef findMajority(arr, size):\n    m = {}\n    for i in range(size):\n        if arr[i] in m:\n            m[arr[i]] += 1\n        else:\n            m[arr[i]] = 1\n    is_majority_present = False\n    for key in m:\n        if m[key] > size / 2:\n            is_majority_present = True\n            print('Majority found :-',key)\n            break\n    if not is_majority_present:\n        print('No Majority element')\n \n# Driver code \narr = [2, 2, 2, 2, 5, 5, 2, 3, 3] \nn = len(arr)\n \n# Function calling \nfindMajority(arr, n)\n \n# This code is contributed by ankush_953\n", "# Python3 program to find Majority \n# element in an array\n \n# Function to find Majority element\n# in an array\n# it returns -1 if there is no majority element\ndef majorityElement(arr, n) :\n     \n    # sort the array in O(nlogn)\n    arr.sort()   \n    count, max_ele, temp, f = 1, -1, arr[0], 0\n    for i in range(1, n) :\n         \n        # increases the count if the same element occurs\n        # otherwise starts counting new element\n        if(temp == arr[i]) :\n            count += 1\n        else :\n            count = 1\n            temp = arr[i]\n             \n        # sets maximum count\n        # and stores maximum occurred element so far\n        # if maximum count becomes greater than n/2\n        # it breaks out setting the flag\n        if(max_ele < count) :\n            max_ele = count\n            ele = arr[i]\n             \n            if(max_ele > (n//2)) :\n                f = 1\n                break\n             \n    # returns maximum occurred element\n    # if there is no such element, returns -1\n    if f == 1 :\n        return ele\n    else :\n        return -1\n \n# Driver code\narr = [1, 1, 2, 1, 3, 5, 1]\nn = len(arr)\n \n# Function calling \nprint(majorityElement(arr, n))\n \n# This code is contributed by divyeshrabadiya07\n", "# Function to count the occurrences\ndef count_occurrences(arr, num):\n    count = 0\n    for i in arr:\n        if i == num:\n            count += 1\n    return count\n \n# Function to find the majority element using recursion\ndef find_majority_util(arr, low, high):\n    # Base case: single element array\n    if low == high:\n        return arr[low]\n \n    # Divide the array into left and right halves\n    mid = (low + high) // 2\n    left_majority = find_majority_util(arr, low, mid)\n    right_majority = find_majority_util(arr, mid+1, high)\n \n    # If left and right halves have the same majority element\n    if left_majority == right_majority:\n        return left_majority\n \n    # Count the occurrences of the majority element in the entire array\n    left_count = count_occurrences(arr[low:high+1], left_majority)\n    right_count = count_occurrences(arr[low:high+1], right_majority)\n \n    # Return the element that occurs more than n/2 times\n    if left_count > (high-low+1) // 2:\n        return left_majority\n    if right_count > (high-low+1) // 2:\n        return right_majority\n \n    # No majority element\n    return -1\n \n# Function to find the majority element\ndef find_majority(arr):\n    n = len(arr)\n    majority = find_majority_util(arr, 0, n-1)\n    if majority != -1:\n        print(majority)\n    else:\n        print('No Majority Element')\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [1, 3, 3, 3, 2]\n    n = len(arr)\n \n    find_majority(arr)\n     \n# This code is contributed by rambabuguphka\n"], "Find Subarray with given sum | Set 1 (Non-negative Numbers) -  ": ["# A simple program to print subarray with sum as given sum\n \n# Returns true if the there is a subarray of arr[] with sum equal to 'sum' otherwise returns false. Also, prints the result\ndef subArraySum(arr, n, sum):\n \n    # Pick a starting point\n    for i in range(0,n):\n        currentSum = arr[i]\n        if(currentSum == sum):\n            print('Sum found at indexes',i)\n            return\n        else:\n            # Try all subarrays starting with 'i'\n            for j in range(i+1,n):\n                currentSum += arr[j]\n                if(currentSum == sum):\n                    print('Sum found between indexes',i,'and',j)\n                    return\n    print('No Subarray Found')\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [15,2,4,8,9,5,10,23]\n    n = len(arr)\n    sum = 23\n    subArraySum(arr, n, sum)\n     \n    # This code is contributed by ajaymakvana\n", "# An efficient program\n# to print subarray\n# with sum as given sum\n \n# Returns true if the\n# there is a subarray\n# of arr[] with sum\n# equal to 'sum'\n# otherwise returns\n# false. Also, prints\n# the result.\n \n \ndef subArraySum(arr, n, sum_):\n \n    # Initialize currentSum as\n    # value of first element\n    # and starting point as 0\n    currentSum = arr[0]\n    start = 0\n \n    # Add elements one by\n    # one to currentSum and\n    # if the currentSum exceeds\n    # the sum, then remove\n    # starting element\n    i = 1\n    while i <= n:\n \n        # If currentSum exceeds\n        # the sum, then remove\n        # the starting elements\n        while currentSum > sum_ and start < i-1:\n \n            currentSum = currentSum - arr[start]\n            start += 1\n \n        # If currentSum becomes\n        # equal to sum, then\n        # return true\n        if currentSum == sum_:\n            print('Sum found between indexes % d and % d' % (start, i-1))\n \n            return 1\n \n        # Add this element\n        # to currentSum\n        if i < n:\n            currentSum = currentSum + arr[i]\n        i += 1\n \n    # If we reach here,\n    # then no subarray\n    print('No subarray found')\n    return 0\n \n \n# Driver program\nif __name__ == '__main__':\n    arr = [15, 2, 4, 8, 9, 5, 10, 23]\n    n = len(arr)\n    sum_ = 23\n \nsubArraySum(arr, n, sum_)\n \n# This code is Contributed by shreyanshi_arun.\n", "def find_subarray_with_given_sum(arr, sum):\n    n = len(arr)\n    curr_sum = arr[0]\n    start = 0\n    i = 1\n    while i <= n:\n        while curr_sum > sum and start < i-1:\n            curr_sum = curr_sum - arr[start]\n            start += 1\n        if curr_sum == sum:\n            return (start, i-1)\n        if i < n:\n            curr_sum = curr_sum + arr[i]\n        i += 1\n    return (-1, -1)\n \n \narr = [15, 2, 4, 8, 9, 5, 10, 23]\nsum = 23\nresult = find_subarray_with_given_sum(arr, sum)\nif result != (-1, -1):\n    print('Subarray: [', end=' ')\n    for i in range(result[0], result[1]+1):\n        print(arr[i], end=' ')\n    print(']')\nelse:\n    print('No subarray with given sum found')\n \n# This code is contributed by Susobhan Akhuli\n"], "Sort an array in wave form -  ": ["# Python function to sort the array arr[0..n-1] in wave form,\n# i.e., arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= arr[5]\ndef sortInWave(arr, n):\n     \n    #sort the array\n    arr.sort()\n    \n    # Swap adjacent elements\n    for i in range(0,n-1,2):\n        arr[i], arr[i+1] = arr[i+1], arr[i]\n \n# Driver program\narr = [10, 90, 49, 2, 1, 5, 23]\nsortInWave(arr, len(arr))\nfor i in range(0,len(arr)):\n    print (arr[i],end=' ')\n     \n# This code is contributed by __Devesh Agrawal__\n", "# Python function to sort the array arr[0..n-1] in wave form,\n# i.e., arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= arr[5]\n \n \ndef sortInWave(arr, n):\n \n    # Traverse all even elements\n    for i in range(0, n - 1, 2):\n \n        # If current even element is smaller than previous\n        if (i > 0 and arr[i] < arr[i-1]):\n            arr[i], arr[i-1] = arr[i-1], arr[i]\n \n        # If current even element is smaller than next\n        if (i < n-1 and arr[i] < arr[i+1]):\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n \n \n# Driver program\narr = [10, 90, 49, 2, 1, 5, 23]\nsortInWave(arr, len(arr))\nfor i in range(0, len(arr)):\n    print(arr[i], end=' ')\n \n# This code is contributed by __Devesh Agrawal__\n"], "Object Oriented Programming in C++ -  ": [], "Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example, Given 1->2->3->3->4->4->5, return 1->2->5. Given 1->1->1->2->3, return 2->3.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    def deleteDuplicates(self, A):\n        self.head = A\n        dummy_node = ListNode(0)\n        dummy_node.next = self.head\n        prev = dummy_node\n        curr = self.head\n        while curr is not None:\n            if curr.next is not None and curr.val == curr.next.val:\n                while curr.next is not None and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = prev.next\n            curr = curr.next\n        return dummy_node.next\n\n\n", "How to quickly swap two arrays of same size in C++? -  ": [], "Minimum number whose binary form is not a subsequence of given binary string -  ": ["# python 3 program for the above approach\n \n# Function to check if string str1 is a\n# subsequence of string str2\ndef isSubsequence(str1, str2, m, n):\n    # Store index of str1\n    j = 0\n \n    # Traverse str2 and str1, and compare\n    # current character of str2 with first\n    # unmatched char of str1\n    i = 0\n    while(i < n and j < m):\n        # If matched, move ahead in str1\n        if (str1[j] == str2[i]):\n            j += 1\n        i += 1\n \n    # If all characters of str1 were\n    # found in str2\n    return (j == m)\n \n# Function to find the minimum number which \n# is not a subsequence of the given binary \n# string in its binary form\ndef findMinimumNumber(s):\n    # Store the decimal number of string, S\n    r = int(s,2)\n \n    # Initialize the required result\n    ans = r + 1\n \n    # Iterate in the range [0, R]\n    for i in range(r+1):\n        # Convert integer i to binary string\n        p = ''\n        j = i\n        while (j > 0):\n            p += str(j % 2)\n            j = j // 2\n \n        m = len(p)\n        n = len(s)\n        p = p[::-1]\n \n        # Check if the string is not a subsequence\n        if (isSubsequence(p, s, m, n) == False):\n            # Update ans and break\n            ans = i\n            break\n \n    # Print the required result\n    print(ans)\n \n# Driver Code\nif __name__ == '__main__':\n   \n    # Function Call\n    s = '10101'\n     \n    # Function Call\n    findMinimumNumber(s)\n     \n    # This code is contributed by SURENDRA_GANGWAR.\n"], "Burst Balloon to maximize coins -  ": ["# Python3 program burst balloon problem. \n \ndef getMax(A):\n    N = len(A)\n    A = [1] + A + [1]# Add Bordering Balloons\n    dp = [[0 for x in range(N + 2)] for y in range(N + 2)]# Declare DP Array\n     \n    for length in range(1, N + 1):\n        for left in range(1, N-length + 2):\n            right = left + length -1\n \n            # For a sub-array from indices left, right\n            # This innermost loop finds the last balloon burst\n            for last in range(left, right + 1):\n                dp[left][right] = max(dp[left][right], \\\n                                      dp[left][last-1] + \\\n                                      A[left-1]*A[last]*A[right + 1] + \\\n                                      dp[last + 1][right])\n    return(dp[1][N])\n \n# Driver code\nA = [1, 2, 3, 4, 5]\nprint(getMax(A))\n"], "Printing brackets in Matrix Chain Multiplication Problem -  ": ["# Python3 program to print optimal parenthesization\n# in matrix chain multiplication.\nname = 0;\n \n# Function for printing the optimal\n# parenthesization of a matrix chain product\ndef printParenthesis(i , j, n, bracket):\n     \n    global name\n   \n    # If only one matrix left in current segment\n    if (i == j):\n     \n        print(name, end = '');\n        name = chr(ord(name) + 1)\n        return;\n     \n    print('(', end = '');\n \n    # Recursively put brackets around subexpression\n    # from i to bracket[i][j].\n    # Note that '*((bracket+i*n)+j)' is similar to\n    # bracket[i][j]\n    printParenthesis(i, bracket[i][j], n, bracket);\n \n    # Recursively put brackets around subexpression\n    # from bracket[i][j] + 1 to j.\n    printParenthesis(bracket[i][j] + 1, j, n, bracket);\n    print(')', end = '');\n   \n# Matrix Ai has dimension p[i-1] x p[i] for i = 1..n\n# Please refer below article for details of this\n# function\n# https:#goo.gl/k6EYKj\ndef matrixChainOrder( p , n):\n     \n    global name\n   \n    '''\n         * For simplicity of the program, \n         one extra row and one extra column are\n         * allocated in m. 0th row and \n         0th column of m are not used\n         '''\n    m = [ [0 for _ in range(n)] for _ in range(n)]\n \n    # bracket[i][j] stores optimal break point in\n    # subexpression from i to j.\n    bracket = [ [0 for _ in range(n)] for _ in range(n)]\n \n    '''\n         * m[i,j] = Minimum number of scalar \n         multiplications needed to compute the\n         * matrix A[i]A[i+1]...A[j] = A[i..j] where\n         dimension of A[i] is p[i-1] x p[i]\n         '''\n \n    # cost is zero when multiplying one matrix.\n    for  i in range(1, n): \n        m[i][i] = 0;\n \n    # L is chain length.\n    for L in range(2, n):\n         \n        for i in range(1, n - L + 1):\n            j = i + L - 1;\n            m[i][j] = 10 ** 8;\n            for k in range(i, j):\n \n                # q = cost/scalar multiplications\n                q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];\n                if (q < m[i][j]) :\n           \n                    m[i][j] = q;\n \n                # Each entry bracket[i,j]=k shows\n                # where to split the product arr\n                # i,i+1....j for the minimum cost.\n                bracket[i][j] = k;\n           \n    # The first matrix is printed as 'A', next as 'B',\n    # and so on\n    name = 'A';\n    print('Optimal Parenthesization is : ');\n    printParenthesis(1, n - 1, n, bracket);\n    print('\\nOptimal Cost is :', m[1][n - 1]);\n   \n# Driver code\narr = [ 40, 20, 30, 10, 30 ];\nn = len(arr);\nmatrixChainOrder(arr, n);\n \n# This code is contributed by phasing17 \n", "# Python3 code to implement the approach\n \nclass FinalCost:\n    def __init__(self):\n        self.label = ''\n        self.cost = float('inf')\n \ndef optimalCost(matrices, labels, prevCost, finalCost):\n    length = len(matrices)\n    if length < 2:\n        finalCost.cost = 0\n    elif length == 2:\n        cost = prevCost + matrices[0][0] * matrices[0][1] * matrices[1][1]\n        # This is where minimal cost has been caught\n        # for whole program\n        if cost < finalCost.cost:\n            finalCost.cost = cost\n            finalCost.label = '(' + labels[0] + labels[1] + ')'\n    else:\n        # recursive Reduce\n        for i in range(length - 1):\n            newMatrix = [[0] * 2 for i in range(length - 1)]\n            newLabels = [0] * (length - 1)\n            subIndex = 0\n \n            # STEP-1:\n            #   - Merge two matrices's into one - in each\n            #   loop, you move merge position\n            #        - if i = 0 THEN  (AB) C D ...\n            #        - if i = 1 THEN  A (BC) D ...\n            #        - if i = 2 THEN  A B (CD) ...\n            #   - and find the cost of this two matrices\n            #   multiplication\n            cost = matrices[i][0] * matrices[i][1] * matrices[i + 1][1]\n \n            # STEP - 2:\n            #    - Build new matrices after merge\n            #    - Keep track of the merged labels too\n            for j in range(i):\n                newMatrix[subIndex] = matrices[j]\n                newLabels[subIndex] = labels[j]\n                subIndex += 1\n             \n            newMatrix[subIndex][0] = matrices[i][0];\n            newMatrix[subIndex][1] = matrices[i + 1][1];\n            newLabels[subIndex] = '(' + str(labels[i]) + str(labels[i + 1]) + ')';\n            subIndex+= 1\n             \n            for j in range(i + 2, length):\n                newMatrix[subIndex] = matrices[j];\n                newLabels[subIndex] = labels[j];\n                subIndex+= 1\n            optimalCost(newMatrix, newLabels, prevCost + cost, finalCost);\n \n             \ndef findOptionalCost(arr):\n    # STEP -1 : Prepare and convert inout as Matrix\n    matrices = [[0] * 2 for i in range(len(arr) - 1)]\n    labels = [0] * (len(arr) - 1)\n \n    for i in range(len(arr) - 1):\n        matrices[i][0] = arr[i]\n        matrices[i][1] = arr[i + 1]\n        labels[i] = chr(65 + i)\n     \n    print('matrices =', matrices)\n     \n     \n    finalCost = FinalCost()\n    optimalCost(matrices, labels, 0, finalCost)\n \n    return finalCost\n \n# Driver Code\n \n# ======= *** TEST CASES **** ============\n \narr = [40, 20, 30, 10, 30]\n \n \ncost = findOptionalCost(arr)\nprint('Final labels:' + cost.label)\nprint('Final Cost:' + str(cost.cost))\n \n \n \n# This code is contributed by phasing17\n"], "Count of number of given string in 2D character array -  ": ["# Python code for finding count \n# of string in a given 2D \n# character array. \n \n# utility function to search \n# complete string from any \n# given index of 2d array \ndef internalSearch(ii, needle, row, col, hay,\n                    row_max, col_max):\n     \n    found = 0\n    if (row >= 0 and row <= row_max and\n        col >= 0 and col <= col_max and\n        needle[ii] == hay[row][col]):\n        match = needle[ii]\n        ii += 1\n        hay[row][col] = 0\n        if (ii == len(needle)):\n            found = 1\n        else:\n             \n            # through Backtrack searching \n            # in every directions \n            found += internalSearch(ii, needle, row, \n                               col + 1, hay, row_max, col_max)\n            found += internalSearch(ii, needle, row, \n                               col - 1, hay, row_max, col_max) \n            found += internalSearch(ii, needle, row + 1, \n                               col, hay, row_max, col_max) \n            found += internalSearch(ii, needle, row - 1, \n                               col, hay, row_max, col_max) \n        hay[row][col] = match \n    return found \n \n# Function to search the string in 2d array \ndef searchString(needle, row, col,strr,\n                row_count, col_count):\n    found = 0\n    for r in range(row_count):\n        for c in range(col_count):\n            found += internalSearch(0, needle, r, c,\n                        strr, row_count - 1, col_count - 1)\n             \n    return found \n \n# Driver code \n \nneedle = 'MAGIC'\ninputt = ['BBABBM','CBMBBA','IBABBG',\n            'GOZBBI','ABBBBC','MCIGAM']\n \nstrr = [0] * len(inputt)\n \nfor i in range(len(inputt)): \n    strr[i] = list(inputt[i])\n     \nprint('count: ', searchString(needle, 0, 0, strr, \n                        len(strr), len(strr[0])))\n \n# This code is contributed by SHUBHAMSINGH10\n"], "Matrix Chain Multiplication | DP-8 -  ": ["# Python code to implement the\n# matrix chain multiplication using recursion\n \nimport sys\n \n# Matrix A[i] has dimension p[i-1] x p[i]\n# for i = 1..n\ndef MatrixChainOrder(p, i, j):\n    if i == j:\n        return 0\n \n    _min = sys.maxsize\n \n    # Place parenthesis at different places\n    # between first and last matrix, \n    # recursively calculate count of multiplications \n    # for each parenthesis placement \n    # and return the minimum count\n    for k in range(i, j):\n \n        count = (MatrixChainOrder(p, i, k)\n                 + MatrixChainOrder(p, k + 1, j)\n                 + p[i-1] * p[k] * p[j])\n \n        if count < _min:\n            _min = count\n \n    # Return minimum count\n    return _min\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 3]\n    N = len(arr)\n     \n    # Function call\n    print('Minimum number of multiplications is ',\n      MatrixChainOrder(arr, 1, N-1))\n \n# This code is contributed by Aryan Garg\n", "# Python program using memoization \nimport sys\ndp = [[-1 for i in range(100)] for j in range(100)]\n \n# Function for matrix chain multiplication \ndef matrixChainMemoised(p, i, j):\n    if(i == j):\n        return 0\n     \n    if(dp[i][j] != -1):\n        return dp[i][j]\n     \n    dp[i][j] = sys.maxsize\n     \n    for k in range(i,j):\n        dp[i][j] = min(dp[i][j], matrixChainMemoised(p, i, k) + matrixChainMemoised(p, k + 1, j)+ p[i - 1] * p[k] * p[j])\n     \n    return dp[i][j]\n \ndef MatrixChainOrder(p,n):\n    i = 1\n    j = n - 1   \n    return matrixChainMemoised(p, i, j)\n \n# Driver Code\narr = [1, 2, 3, 4]\nn = len(arr)\nprint('Minimum number of multiplications is',MatrixChainOrder(arr, n))\n \n# This code is contributed by rag2127\n", "# Dynamic Programming Python implementation of Matrix\n# Chain Multiplication. See the Cormen book for details\n# of the following algorithm\nimport sys\nmaxint=int(1e9+7)\n# Matrix Ai has dimension p[i-1] x p[i] for i = 1..n\n \n \ndef MatrixChainOrder(p, n):\n    # For simplicity of the program, \n    # one extra row and one\n    # extra column are allocated in m[][].  \n    # 0th row and 0th\n    # column of m[][] are not used\n    m = [[0 for x in range(n)] for x in range(n)]\n \n    # m[i, j] = Minimum number of scalar \n    # multiplications needed\n    # to compute the matrix A[i]A[i + 1]...A[j] = \n    # A[i..j] where\n    # dimension of A[i] is p[i-1] x p[i]\n \n    # cost is zero when multiplying one matrix.\n    for i in range(1, n):\n        m[i][i] = 0\n \n    # L is chain length.\n    for L in range(2, n):\n        for i in range(1, n-L + 1):\n            j = i + L-1\n            m[i][j] = maxint\n            for k in range(i, j):\n \n                # q = cost / scalar multiplications\n                q = m[i][k] + m[k + 1][j] + p[i-1]*p[k]*p[j]\n                if q < m[i][j]:\n                    m[i][j] = q\n \n    return m[1][n-1]\n \n \n# Driver code\narr = [1, 2, 3, 4]\nsize = len(arr)\n \nprint('Minimum number of multiplications is ' +\n      str(MatrixChainOrder(arr, size)))\n# This Code is contributed by Bhavya Jain\n"], "Count Possible Decodings of a given Digit Sequence -  ": ["# Recursive implementation of numDecodings\ndef numDecodings(s: str) -> int:\n    if len(s) == 0 or (len(s) == 1 and s[0] == '0'):\n        return 0\n    return numDecodingsHelper(s, len(s))\n \n \ndef numDecodingsHelper(s: str, n: int) -> int:\n    if n == 0 or n == 1:\n        return 1\n    count = 0\n    if s[n-1] > '0':\n        count = numDecodingsHelper(s, n-1)\n    if (s[n - 2] == '1'\n        or (s[n - 2] == '2'\n            and s[n - 1] < '7')):\n        count += numDecodingsHelper(s, n - 2)\n    return count\n \n \n# Driver Code\nif __name__ == '__main__':\n    digits = '1234'\n    print('Count is ', numDecodings(digits))\n", "# A Dynamic Programming based Python3 \n# implementation to count decodings \n \n# A Dynamic Programming based function\n# to count decodings \ndef countDecodingDP(digits, n): \n \n    count = [0] * (n + 1); # A table to store \n                           # results of subproblems \n    count[0] = 1; \n    count[1] = 1; \n \n    for i in range(2, n + 1): \n \n        count[i] = 0; \n \n        # If the last digit is not 0, then last\n        # digit must add to the number of words \n        if (digits[i - 1] > '0'): \n            count[i] = count[i - 1]; \n \n        # If second last digit is smaller than 2\n        # and last digit is smaller than 7, then\n        # last two digits form a valid character \n        if (digits[i - 2] == '1' or\n           (digits[i - 2] == '2' and\n            digits[i - 1] < '7') ): \n            count[i] += count[i - 2]; \n \n    return count[n]; \n \n# Driver Code\ndigits = '1234'; \nn = len(digits); \nprint('Count is' , \n       countDecodingDP(digits, n)); \n \n# This code is contributed by mits\n", "mod = 1e9 + 7\n \n# function which returns the number of ways to decode the message\ndef decodeMessage(dp, s, str, n):\n   \n    # an empty string can also form 1 valid decoding\n    if(s >= n):\n        return 1\n \n        # if we have already computed the number of\n        # ways to decode the substring return the \n        # answer directly\n \n    if(dp[s] != -1):\n        return dp[s]\n     \n    num = 0\n    tc = 0\n    for i in range(s,n):\n        # generate the number \n        num = num*10 + (ord(str[i]) - ord('0'))\n \n        # validate the number\n        if(num >= 1 and num <= 26):\n             \n                # since the number of ways to decode any string\n                # depends on the result of\n                # how the remaining string is decoded so get the\n                # number of ways how the rest of the string can \n                # be decoded\n            c = decodeMessage(dp, i + 1, str, n)\n \n            # add all the ways that the substring\n            # from the current index can be decoded\n            tc = int((tc%mod + c%mod)%mod)\n \n        # leading 0\u2019s or the number\n        # generated so far is greater than 26 \n        # we can just stop the process\n        # as it can never be a part of our solution\n        else:\n            break\n \n    # store all the possible decodings and return the result\n    dp[s] = tc\n    return dp[s]\n \ndef CountWays(str):\n \n    n = len(str)\n \n    # empty string can form 1 valid decoding\n    if(n == 0):\n        return 1\n \n    # dp vector to store the  number of ways \n    # to decode each and every substring\n    dp = [-1]*(n)\n \n    # return the result\n    return decodeMessage(dp, 0, str, n)\n   \n# driver code\nif __name__ == '__main__' :\n \n   str = '1234'\n   print(CountWays(str))\n \n  # This code is contributed by shinjanpatra.\n"], "Wildcard Pattern Matching -  ": ["# Python program to implement wildcard\n# pattern matching algorithm\n \n# Function that matches input strr with\n# given wildcard pattern\n \n \ndef strrmatch(strr, pattern, n, m):\n \n    # empty pattern can only match with\n    # empty string\n    if (m == 0):\n        return (n == 0)\n \n    # lookup table for storing results of\n    # subproblems\n    lookup = [[False for i in range(m + 1)] for j in range(n + 1)]\n \n    # empty pattern can match with empty string\n    lookup[0][0] = True\n \n    # Only '*' can match with empty string\n    for j in range(1, m + 1):\n        if (pattern[j - 1] == '*'):\n            lookup[0][j] = lookup[0][j - 1]\n \n    # fill the table in bottom-up fashion\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n \n            # Two cases if we see a '*'\n            # a) We ignore \u2018*\u2019 character and move\n            # to next character in the pattern,\n            # i.e., \u2018*\u2019 indicates an empty sequence.\n            # b) '*' character matches with ith\n            # character in input\n            if (pattern[j - 1] == '*'):\n                lookup[i][j] = lookup[i][j - 1] or lookup[i - 1][j]\n \n            # Current characters are considered as\n            # matching in two cases\n            # (a) current character of pattern is '?'\n            # (b) characters actually match\n            else if (pattern[j - 1] == '?' or strr[i - 1] == pattern[j - 1]):\n                lookup[i][j] = lookup[i - 1][j - 1]\n \n            # If characters don't match\n            else:\n                lookup[i][j] = False\n \n    return lookup[n][m]\n \n# Driver code\n \n \nstrr = 'baaabab'\npattern = '*****ba*****ab'\n# char pattern[] = 'ba*****ab'\n# char pattern[] = 'ba*ab'\n# char pattern[] = 'a*ab'\n# char pattern[] = 'a*****ab'\n# char pattern[] = '*a*****ab'\n# char pattern[] = 'ba*ab****'\n# char pattern[] = '****'\n# char pattern[] = '*'\n# char pattern[] = 'aa?ab'\n# char pattern[] = 'b*b'\n# char pattern[] = 'a*a'\n# char pattern[] = 'baaabab'\n# char pattern[] = '?baaabab'\n# char pattern[] = '*baaaba*'\n \nif (strrmatch(strr, pattern, len(strr), len(pattern))):\n    print('Yes')\nelse:\n    print('No')\n \n# This code is contributed by shubhamsingh10\n", "# Python program to implement wildcard\n# pattern matching algorithm\ndef finding(s, p, n, m):\n    # return 1 if n and m are negative\n    if n < 0 and m < 0:\n        return 1\n \n    # return 0 if m is negative\n    if m < 0:\n        return 0\n \n    # return n if n is negative\n    if n < 0:\n        # while m is positive\n        while m >= 0:\n            if p[m] != '*':\n                return 0\n            m -= 1\n        return 1\n \n    # if dp state is not visited\n    if dp[n][m] == -1:\n        if p[m] == '*':\n            dp[n][m] = finding(s, p, n - 1, m) or finding(s, p, n, m - 1)\n            return dp[n][m]\n        else:\n            if p[m] != s[n] and p[m] != '?':\n                dp[n][m] = 0\n                return dp[n][m]\n            else:\n                dp[n][m] = finding(s, p, n - 1, m - 1)\n                return dp[n][m]\n \n    # return dp[n][m] if dp state is previsited\n    return dp[n][m]\n \ndef isMatch(s, p):\n    global dp\n    dp = []\n \n    # resize the dp array\n    for i in range(len(s) + 1):\n        dp.append([-1] * (len(p) + 1))\n    dp[len(s)][len(p)] = finding(s, p, len(s) - 1, len(p) - 1)\n    return dp[len(s)][len(p)]\n \n# Driver code\n \n \ndef main():\n    s = 'baaabab'\n    p = '*****ba*****ab'\n    # p = 'ba*****ab'\n    # p = 'ba*ab'\n    # p = 'a*ab'\n    # p = 'a*****ab'\n    # p = '*a*****ab'\n    # p = 'ba*ab****'\n    # p = '****'\n    # p = '*'\n    # p = 'aa?ab'\n    # p = 'b*b'\n    # p = 'a*a'\n    # p = 'baaabab'\n    # p = '?baaabab'\n    # p = '*baaaba*'\n \n    if isMatch(s, p):\n        print('Yes')\n    else:\n        print('No')\n \n \nif __name__ == '__main__':\n    main()\n \n# This code is contributed by divyansh2212\n", "# Python program to implement wildcard\n# pattern matching algorithm\n \n# Function that matches input str with\n# given wildcard pattern\ndef strmatch(str, pattern, m, n):\n    # lookup table for storing results of\n    # subproblems\n    prev, curr = [False]*(m+1), [False]*(m+1)\n \n    # empty pattern can match with empty string\n    prev[0] = True\n \n    # fill the table in bottom-up fashion\n    for i in range(1, n+1):\n \n        flag = True\n        for ii in range(1, i):\n            if pattern[ii-1] != '*':\n                flag = False\n                break\n        curr[0] = flag # for every row we are assigning\n                        # 0th column value.\n        for j in range(1, m+1):\n            # Two cases if we see a '*'\n            # a) We ignore '*' character and move\n            #    to next  character in the pattern,\n            #     i.e., '*' indicates an empty sequence.\n            # b) '*' character matches with ith\n            #     character in input\n            if pattern[i-1] == '*':\n                curr[j] = curr[j-1] or prev[j]\n \n            # Current characters are considered as\n            # matching in two cases\n            # (a) current character of pattern is '?'\n            # (b) characters actually match\n            elif pattern[i-1] == '?' or str[j-1] == pattern[i-1]:\n                curr[j] = prev[j-1]\n \n            # If characters don't match\n            else:\n                curr[j] = False\n        prev, curr = curr, prev\n \n    return prev[m]\n \nif __name__ == '__main__':\n    str = 'baaabab'\n    pattern = '*****ba*****ab'\n    # pattern = 'ba*****ab'\n    # pattern = 'ba*ab'\n    # pattern = 'a*ab'\n    # pattern = 'a*****ab'\n    # pattern = '*a*****ab'\n    # pattern = 'ba*ab****'\n    # pattern = '****'\n    # pattern = '*'\n    # pattern = 'aa?ab'\n    # pattern = 'b*b'\n    # pattern = 'a*a'\n    # pattern = 'baaabab'\n    # pattern = '?baaabab'\n    # pattern = '*baaaba*'\n \n    if strmatch(str, pattern, len(str), len(pattern)):\n        print('Yes')\n    else:\n        print('No')\n \n \n# This code is contributed by rishabmalhdijo\n", "'''\nThis Python function checks whether a string 'text' matches a pattern 'pattern'\ncontaining wildcard characters '?' and '*'.\n'''\n \ndef isMatch(text, pattern):\n    n = len(text)\n    m = len(pattern)\n    i = 0\n    j = 0\n    startIndex = -1\n    match = 0\n \n    while i < n:\n        if j < m and (pattern[j] == '?' or pattern[j] == text[i]):\n            # Characters match or '?' in pattern matches any character.\n            i += 1\n            j += 1\n        elif j < m and pattern[j] == '*':\n            # Wildcard character '*', mark the current position in the pattern and the text as a proper match.\n            startIndex = j\n            match = i\n            j += 1\n        elif startIndex != -1:\n            # No match, but a previous wildcard was found. Backtrack to the last '*' character position and try for a different match.\n            j = startIndex + 1\n            match += 1\n            i = match\n        else:\n            # If none of the above cases comply, the pattern does not match.\n            return False\n \n    # Consume any remaining '*' characters in the given pattern.\n    while j < m and pattern[j] == '*':\n        j += 1\n \n    # If we have reached the end of both the pattern and the text, the pattern matches the text.\n    return j == m\n \nstr = 'baaabab'\npattern = '*****ba*****ab'\n \nif isMatch(str, pattern):\n    print('Yes')\nelse:\n    print('No')\n"], "Unbounded Knapsack (Repetition of items allowed) -  ": ["# Python3 program to find maximum \n# achievable value with a knapsack \n# of weight W and multiple instances allowed. \n  \n# Returns the maximum value \n# with knapsack of W capacity \n# A Naive recursive implementation of unbounded Knapsack problem  \ndef unboundedKnapsack(W, index, val, wt): \n  \n    #Base case of recursion when only one element is there. \n    if index==0 :return (W//wt[0])*val[0] \n    #If the element with referred by index is doesn't occur even once in the required solution \n    notTake=0+unboundedKnapsack(W,index-1,val,wt) \n    #If the element is occur atleast once in the required solution \n    take=-100000\n    if wt[index]<=W: \n        take=val[index]+unboundedKnapsack(W-wt[index],index,val,wt) \n    return max(take,notTake)     \n  \n  \n# Driver program \nW = 100\nval = [10, 30, 20] \nwt = [5, 10, 15] \nn = len(val) \n  \nprint(unboundedKnapsack(W, n-1, val, wt)) \n", "def unboundedKnapsack(W, wt, val, idx, dp): \n    # Base Case \n    # if we are at idx 0. \n    if idx == 0: \n        return (W // wt[0]) * val[0] \n    # If the value is already calculated then we will \n    # previous calculated value \n    if dp[idx][W] != -1: \n        return dp[idx][W] \n    # There are two cases either take element or not take. \n    # If not take then \n    notTake = 0 + unboundedKnapsack(W, wt, val, idx - 1, dp) \n    # if take then weight = W-wt[idx] and index will remain \n    # same. \n    take = float('-inf') \n    if wt[idx] <= W: \n        take = val[idx] + unboundedKnapsack(W - wt[idx], wt, val, idx, dp) \n    dp[idx][W] = max(take, notTake) \n    return dp[idx][W] \n  \n# Driver code \nW = 100\nval = [10, 30, 20] \nwt = [5, 10, 15] \nn = len(val) \ndp = [[-1 for _ in range(W+1)] for _ in range(n)] \nprint(unboundedKnapsack(W, wt, val, n-1, dp)) \n", "   \n# Python3 program to find maximum \n# achievable value with a knapsack \n# of weight W and multiple instances allowed. \n  \n# Returns the maximum value  \n# with knapsack of W capacity \ndef unboundedKnapsack(W, n, val, wt): \n  \n    # dp[i] is going to store maximum  \n    # value with knapsack capacity i. \n    dp = [0 for i in range(W + 1)] \n  \n    ans = 0\n  \n    # Fill dp[] using above recursive formula \n    for i in range(W + 1): \n        for j in range(n): \n            if (wt[j] <= i): \n                dp[i] = max(dp[i], dp[i - wt[j]] + val[j]) \n  \n    return dp[W] \n  \n# Driver program \nW = 100\nval = [10, 30, 20] \nwt = [5, 10, 15] \nn = len(val) \n  \nprint(unboundedKnapsack(W, n, val, wt)) \n  \n# This code is contributed by Anant Agarwal. \n"], "Minimum number of jumps to reach end (Jump Game) -  ": ["# Python3 program to find Minimum \n# number of jumps to reach end \n  \n# Returns minimum number of jumps \n# to reach arr[h] from arr[l] \n  \n  \ndef minJumps(arr, l, h): \n  \n    # Base case: when source and \n    # destination are same \n    if (h == l): \n        return 0\n  \n    # when nothing is reachable \n    # from the given source \n    if (arr[l] == 0): \n        return float('inf') \n  \n    # Traverse through all the points \n    # reachable from arr[l]. Recursively \n    # get the minimum number of jumps \n    # needed to reach arr[h] from \n    # these reachable points. \n    min = float('inf') \n    for i in range(l + 1, h + 1): \n        if (i < l + arr[l] + 1): \n            jumps = minJumps(arr, i, h) \n            if (jumps != float('inf') and\n                    jumps + 1 < min): \n                min = jumps + 1\n  \n    return min\n  \n  \n# Driver program to test above function \narr = [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9] \nn = len(arr) \nprint('Minimum number of jumps to reach', \n      'end is', minJumps(arr, 0, n-1)) \n  \n# This code is contributed by Soumen Ghosh \n", "# Helper function to find the minimum jumps required to reach the end \ndef jump(nums, idx, end, memo): \n    # We reached the end. No jumps to make further \n    if idx == end: \n        return 0\n  \n    if memo[idx] != -1: \n        return memo[idx] \n  \n    min_jumps = float('inf') \n  \n    # We will try to make all possible jumps from the current index \n    # and select the minimum of those. \n    # It does not matter if we try from 1 to nums[idx] or from nums[idx] to 1. \n    for j in range(nums[idx], 0, -1): \n        # If we make this jump 'j' distance away from idx, \n        # do we overshoot? \n        # If we land within the nums, we will test further. \n        if idx + j <= end: \n            # Make a jump to idx + j index and explore further, \n            # then update min_jumps with the minimum jumps \n            # we made to reach the end while trying all possible \n            # nums[idx] jumps from the current index. \n            min_jumps = min(min_jumps, 1 + jump(nums, idx + j, end, memo)) \n  \n    memo[idx] = min_jumps \n    return memo[idx] \n  \n  \ndef min_jumps(nums): \n    '''Memoization'''\n  \n    memo = [-1 for i in range(len(nums))] \n    jump(nums, 0, len(nums) - 1, memo) \n    return memo[0] \n  \n  \nif __name__ == '__main__': \n    arr = [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9] \n    print(min_jumps(arr)) \n# this code is contributed by Rohit Singh\n", "# Python3 program to find Minimum \n# number of jumps to reach end \n  \n# Returns minimum number of jumps \n# to reach arr[n-1] from arr[0] \n  \n  \ndef minJumps(arr, n): \n    jumps = [0 for i in range(n)] \n  \n    if (n == 0) or (arr[0] == 0): \n        return float('inf') \n  \n    jumps[0] = 0\n  \n    # Find the minimum number of \n    # jumps to reach arr[i] from \n    # arr[0] and assign this \n    # value to jumps[i] \n    for i in range(1, n): \n        jumps[i] = float('inf') \n        for j in range(i): \n            if (i <= j + arr[j]) and (jumps[j] != float('inf')): \n                jumps[i] = min(jumps[i], jumps[j] + 1) \n                break\n    return jumps[n-1] \n  \n  \n# Driver Program to test above function \narr = [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9] \nsize = len(arr) \nprint('Minimum number of jumps to reach', \n      'end is', minJumps(arr, size)) \n  \n# This code is contributed by Soumen Ghosh \n"], "Activity Selection Problem | Greedy Algo-1 -  ": ["# Python3 program for activity selection problem.\n \n# The following implementation assumes that the activities\n# are already sorted according to their finish time\n \n# Prints a maximum set of activities that can be done \n# by a single person, one at a time\ndef printMaxActivities(s, f):\n    n = len(f)\n    print('Following activities are selected')\n \n    # The first activity is always selected\n    i = 0\n    print(i, end=' ')\n \n    # Consider rest of the activities\n    for j in range(1, n):\n \n        # If this activity has start time greater than\n        # or equal to the finish time of previously\n        # selected activity, then select it\n        if s[j] >= f[i]:\n            print(j, end=' ')\n            i = j\n \n \n# Driver code\nif __name__ == '__main__':\n    s = [1, 3, 0, 5, 8, 5]\n    f = [2, 4, 6, 7, 9, 9]\n \n    # Function call\n    printMaxActivities(s, f)\n \n# This code is contributed by Nikhil Kumar Singh\n", "''' Python program for activity selection problem\n when input activities may not be sorted.'''\n \n \ndef MaxActivities(arr, n):\n    selected = []\n \n    # Sort jobs according to finish time\n    Activity.sort(key=lambda x: x[1])\n \n    # The first activity always gets selected\n    i = 0\n    selected.append(arr[i])\n \n    for j in range(1, n):\n \n        '''If this activity has start time greater than or\n           equal to the finish time of previously selected\n           activity, then select it'''\n        if arr[j][0] >= arr[i][1]:\n            selected.append(arr[j])\n            i = j\n    return selected\n \n \n# Driver code\nif __name__ == '__main__':\n    Activity = [[5, 9], [1, 2], [3, 4], [0, 6], [5, 7], [8, 9]]\n    n = len(Activity)\n \n    # Function call\n    selected = MaxActivities(Activity, n)\n    print('Following activities are selected :')\n    print(selected[0], end = '');\n    for i in range (1, len(selected)):\n        print(',', end = ' ')\n        print(selected[i], end = '')\n \n# This code is contributed by kshitijjainm\n", "# Python3 program for activity selection problem\n# when input activities may not be sorted.\nfrom heapq import heappop, heappush\n \n# Function to select activites\n \n \ndef SelectActivities(s, f):\n    ans = []\n    p = []\n \n    # Pushing elements in the list\n    for i, j in zip(s, f):\n        heappush(p, (j, i))\n \n    it = heappop(p)\n    start = it[1]\n    end = it[0]\n    ans.append(it)\n \n    # Sorting process\n    while p:\n        it = heappop(p)\n        if it[1] >= end:\n            start = it[1]\n            end = it[0]\n            ans.append(it)\n \n    print('Following Activities should be selected.\\n')\n    for f, s in ans:\n        print(f'Activity started at {s} and ends at {f}')\n \n \n# Driver code\nif __name__ == '__main__':\n    s = [1, 3, 0, 5, 8, 5]\n    finish = [2, 4, 6, 7, 9, 9]\n \n    # Function call\n    SelectActivities(s, finish)\n \n# This code is contributed by kraanzu.\n"], "Smallest window in a String containing all characters of other String -  ": ["# Function to check if any substring of length mid contains\n# all characters of the pattern\ndef is_valid(s, pattern, mid, start):\n    # Count the frequency of each character in the pattern\n    count = [0] * 256\n \n    # Stores the number of distinct characters in the pattern\n    distinct = 0\n    found = False\n \n    # Count the frequency of each character in the pattern\n    for c in pattern:\n        count[ord(c)] += 1\n        if count[ord(c)] == 1:\n            distinct += 1\n \n    # Stores the number of characters in a substring of size\n    # mid in s whose frequency is the same as the frequency in\n    # the pattern\n    curr_count = 0\n    for i in range(len(s)):\n        count[ord(s[i])] -= 1\n        if count[ord(s[i])] == 0:\n            curr_count += 1\n        if i >= mid:\n            count[ord(s[i - mid])] += 1\n            if count[ord(s[i - mid])] == 1:\n                curr_count -= 1\n        if i >= mid - 1:\n            # Substring of length mid found which contains\n            # all the characters of the pattern\n            if curr_count == distinct:\n                found = True\n                # Stores the starting index of that substring\n                start[0] = i - mid + 1\n                break\n \n    return found\n \n# Function to find the smallest substring containing all\n# characters of the pattern\ndef find_smallest_substring(s, pattern):\n    len_str = len(s)\n    len_pattern = len(pattern)\n    smallest_substring = ''\n \n    min_length = float('inf')\n \n    # Lower bound and Upper Bound for Binary Search\n    low_bound = 1\n    high_bound = len_str\n \n    # Stores the starting index of the min length substring\n    idx = [0]\n \n    # Applying Binary Search on answer\n    while low_bound <= high_bound:\n        mid = (low_bound + high_bound) // 2\n        start = [0]\n \n        # If a substring of length mid is found which\n        # contains all the characters of the pattern then\n        # update min_length and high_bound; otherwise, update\n        # low_bound\n        if is_valid(s, pattern, mid, start):\n            if mid < min_length:\n                min_length = mid\n                idx[0] = start[0]\n            high_bound = mid - 1\n        else:\n            low_bound = mid + 1\n \n    smallest_substring = s[idx[0]:idx[0] + min_length]\n    return smallest_substring\n \nif __name__ == '__main__':\n    str1 = 'this is a test string'\n    pattern1 = 'tist'\n    print('Input: string =', str1, ', pattern =', pattern1)\n    print('Output:', ''' + find_smallest_substring(str1, pattern1) + ''')\n \n    str2 = ' '\n    pattern2 = 'ork'\n    print('Input: string =', str2, ', pattern =', pattern2)\n    print('Output:', ''' + find_smallest_substring(str2, pattern2) + ''')\n", "# Python3 program to find the smallest window\n# containing all characters of a pattern.\nno_of_chars = 256\n \n# Function to find smallest window\n# containing all characters of 'pat'\ndef findSubString(string, pat):\n \n    len1 = len(string)\n    len2 = len(pat)\n \n    # Check if string's length is\n    # less than pattern's\n    # length. If yes then no such\n    # window can exist\n    if len1 < len2:\n \n        print('No such window exists')\n        return ''\n \n    hash_pat = [0] * no_of_chars\n    hash_str = [0] * no_of_chars\n \n    # Store occurrence ofs characters of pattern\n    for i in range(0, len2):\n        hash_pat[ord(pat[i])] += 1\n \n    start, start_index, min_len = 0, -1, float('inf')\n \n    # Start traversing the string\n    count = 0  # count of characters\n    for j in range(0, len1):\n \n        # count occurrence of characters of string\n        hash_str[ord(string[j])] += 1\n \n        # If string's char matches with\n        # pattern's char then increment count\n        if (hash_str[ord(string[j])] <=\n                hash_pat[ord(string[j])]):\n            count += 1\n \n        # if all the characters are matched\n        if count == len2:\n \n            # Try to minimize the window\n            while (hash_str[ord(string[start])] >\n                   hash_pat[ord(string[start])] or\n                   hash_pat[ord(string[start])] == 0):\n \n                if (hash_str[ord(string[start])] >\n                        hash_pat[ord(string[start])]):\n                    hash_str[ord(string[start])] -= 1\n                start += 1\n \n            # update window size\n            len_window = j - start + 1\n            if min_len > len_window:\n \n                min_len = len_window\n                start_index = start\n \n    # If no window found\n    if start_index == -1:\n        print('No such window exists')\n        return ''\n \n    # Return substring starting from\n    # start_index and length min_len\n    return string[start_index: start_index + min_len]\n \n \n# Driver code\nif __name__ == '__main__':\n \n    string = 'this is a test string'\n    pat = 'tist'\n \n    print(findSubString(string, pat))\n \n# This code is contributed by Rituraj Jain\n"], "Find maximum possible stolen value from houses -  ": ["# Python3 program to find the maximum stolen value \n  \n# calculate the maximum stolen value \ndef maxLoot(hval,n): \n  \n    # base case \n    if (n < 0): \n        return 0\n  \n    if (n == 0): \n        return hval[0] \n      \n    # if current element is pick then previous cannot be \n    # picked \n    pick = hval[n] + maxLoot(hval, n - 2) \n    # if current element is not picked then previous \n    # element is picked \n    notPick = maxLoot(hval, n - 1) \n  \n    # return max of picked and not picked \n    return max(pick, notPick) \n  \n# Driver to test above code \nhval = [ 6, 7, 1, 3, 8, 2, 4 ] \nn = len(hval) \nprint('Maximum loot possible : ',maxLoot(hval, n - 1)); \n  \n# This code is contributed by shinjanpatra\n", "def solve(n, v): \n    dp = [-2]*(n) \n    maxmoney = 0\n    if (n == 1 or n == 2): \n        print('Maximum loot possible : ') \n        print(max(v)) \n        return\n          \n    dp[0] = v[0] \n    dp[1] = v[1] \n    for i in range(2,n): \n        money = 0\n        dp[i] = v[i] \n        for j in range(i-2,-1,-1): \n            money = max(money, dp[j]) \n        dp[i] += money \n    m = max(dp) \n    print('Maximum loot possible :', m) \n    return\n  \nn = 7\nv = [6, 7, 1, 3, 8, 2, 4] \nsolve(n, v)\n", "# Python3 program to find the maximum stolen value \n  \n# calculate the maximum stolen value \n  \n  \ndef maxLoot(hval, n, dp): \n  \n    # base case \n    if(n < 0): \n        return 0\n  \n    if(n == 0): \n        return hval[0] \n  \n   # If the subproblem is already solved \n   # then return its value \n    if(dp[n] != -1): \n        return dp[n] \n  \n    # if current element is pick then previous cannot be picked \n    pick = hval[n] + maxLoot(hval, n-2, dp) \n  \n    # if current element is not picked then previous element is picked \n    notPick = maxLoot(hval, n-1, dp) \n  \n    # return max of picked and not picked \n    dp[n] = max(pick, notPick) \n    return dp[n] \n  \n  \n# Driver to test above code \nhval = [6, 7, 1, 3, 8, 2, 4] \nn = len(hval) \n  \n# Initialize a dp vector \ndp = [-1 for i in range(n+1)] \nprint('Maximum loot possible : '+str(maxLoot(hval, n-1, dp))) \n  \n# This code is contributed by shinjanpatra \n", "# Python3 program to find the maximum stolen value \n  \n# calculate the maximum stolen value \ndef maximize_loot(hval, n): \n    if n == 0: \n        return 0\n    if n == 1: \n        return hval[0] \n    if n == 2: \n        return max(hval[0], hval[1]) \n  \n    # dp[i] represent the maximum value stolen so \n    # for after reaching house i. \n    dp = [0]*n \n  \n    # Initialize the dp[0] and dp[1] \n    dp[0] = hval[0] \n    dp[1] = max(hval[0], hval[1]) \n      \n    # Fill remaining positions \n    for i in range(2, n): \n        dp[i] = max(hval[i]+dp[i-2], dp[i-1]) \n  \n    return dp[-1] \n  \n# Driver to test above code  \ndef main(): \n  \n    # Value of houses \n    hval = [6, 7, 1, 3, 8, 2, 4] \n  \n    # number of houses \n    n = len(hval) \n    print('Maximum loot possible : {}'. \n        format(maximize_loot(hval, n))) \n  \nif __name__ == '__main__': \n    main() \n", "# Python3 program to find the maximum stolen value \n  \n# calculate the maximum stolen value \ndef maximize_loot(hval, n): \n    if n == 0: \n        return 0\n  \n    value1 = hval[0] \n    if n == 1: \n        return value1 \n  \n    value2 = max(hval[0], hval[1]) \n    if n == 2: \n        return value2 \n  \n    # contains maximum stolen value at the end \n    max_val = None\n  \n    # Fill remaining positions \n    for i in range(2, n): \n        max_val = max(hval[i]+value1, value2) \n        value1 = value2 \n        value2 = max_val \n  \n    return max_val \n  \n# Driver to test above code  \ndef main(): \n  \n    # Value of houses \n    hval = [6, 7, 1, 3, 8, 2, 4] \n  \n    # number of houses \n    n = len(hval) \n    print('Maximum loot possible : {}'.format(maximize_loot(hval, n))) \n  \nif __name__ == '__main__': \n    main() \n"], "Find if a string is interleaved of two other strings | DP-33 -  ": ["def isInterleaved(A, B, C):\n    # Base Case: If all strings are empty\n    if not A and not B and not C:\n        return True\n \n    # If C is empty and any of the two strings is not empty\n    if not C:\n        return False\n \n    # If the first character of C matches the first character of A,\n    # then recursively check the rest of A and C\n    if A and C[0] == A[0]:\n        return isInterleaved(A[1:], B, C[1:])\n \n    # If the first character of C matches the first character of B,\n    # then recursively check the rest of B and C\n    if B and C[0] == B[0]:\n        return isInterleaved(A, B[1:], C[1:])\n \n    # If none of the above conditions are met, then C cannot be interleaved\n    # from A and B\n    return False\n     \n      \n# A function to run test cases\ndef test(A, B, C):\n  \n    if (isInterleaved(A, B, C)):\n        print(C, 'is interleaved of', A, 'and', B)\n    else:\n        print(C, 'is not interleaved of', A, 'and', B)\n  \n# Driver Code\nif __name__ == '__main__':\n    test('XXY', 'XXZ', 'XXZXXXY')\n    test('XY', 'WZ', 'WZXY')\n    test('XY', 'X', 'XXY')\n    test('YX', 'X', 'XXY')\n    test('XXY', 'XXZ', 'XXXXZY')\n", "# A Dynamic Programming based python3 program \n# to check whether a string C is an interleaving \n# of two other strings A and B. \n \n# The main function that returns true if C is \n# an interleaving of A and B, otherwise false. \ndef isInterleaved(A, B, C): \n \n    # Find lengths of the two strings \n    M = len(A)\n    N = len(B) \n \n    # Let us create a 2D table to store solutions of \n    # subproblems. C[i][j] will be true if C[0..i + j-1] \n    # is an interleaving of A[0..i-1] and B[0..j-1]. \n    # Initialize all values as false. \n    IL = [[False] * (N + 1) for i in range(M + 1)] \n \n    # C can be an interleaving of A and B only of sum \n    # of lengths of A & B is equal to length of C. \n    if ((M + N) != len(C)): \n        return False\n \n    # Process all characters of A and B\n    for i in range(0, M + 1): \n        for j in range(0, N + 1):\n             \n            # two empty strings have an empty string \n            # as interleaving \n            if (i == 0 and j == 0): \n                IL[i][j] = True\n \n            # A is empty \n            elif (i == 0): \n                if (B[j - 1] == C[j - 1]): \n                    IL[i][j] = IL[i][j - 1] \n             \n            # B is empty \n            elif (j == 0): \n                if (A[i - 1] == C[i - 1]): \n                    IL[i][j] = IL[i - 1][j] \n             \n            # Current character of C matches with \n            # current character of A, but doesn't match \n            # with current character of B \n            elif (A[i - 1] == C[i + j - 1] and\n                  B[j - 1] != C[i + j - 1]): \n                IL[i][j] = IL[i - 1][j] \n \n            # Current character of C matches with \n            # current character of B, but doesn't match \n            # with current character of A \n            elif (A[i - 1] != C[i + j - 1] and\n                  B[j - 1] == C[i + j - 1]): \n                IL[i][j] = IL[i][j - 1] \n \n            # Current character of C matches with \n            # that of both A and B \n            elif (A[i - 1] == C[i + j - 1] and\n                  B[j - 1] == C[i + j - 1]): \n                IL[i][j] = (IL[i - 1][j] or IL[i][j - 1]) \n         \n    return IL[M][N] \n \n# A function to run test cases \ndef test(A, B, C): \n \n    if (isInterleaved(A, B, C)): \n        print(C, 'is interleaved of', A, 'and', B) \n    else:\n        print(C, 'is not interleaved of', A, 'and', B)\n \n# Driver Code \nif __name__ == '__main__': \n    test('XXY', 'XXZ', 'XXZXXXY') \n    test('XY', 'WZ', 'WZXY') \n    test('XY', 'X', 'XXY') \n    test('YX', 'X', 'XXY') \n    test('XXY', 'XXZ', 'XXXXZY') \n     \n# This code is contributed by ashutosh450\n", "# A Python Memoization program\n# to check whether a string C is\n# an interleaving of two other\n# strings A and B.\n \n# Declare dp array\ndp = [[0]*101]*101\n \n# This function checks if there exist a valid path from 0,0 to n,m\ndef dfs(i, j, A, B, C):\n \n    # If path has already been calculated from this index\n    # then return calculated value.\n    if(dp[i][j]!=-1):\n        return dp[i][j]\n         \n    # If we reach the destination return 1\n    n,m=len(A),len(B)\n    if(i==n and j==m):\n        return 1\n     \n    # If C[i+j] matches with both A[i] and B[j]\n    # we explore both the paths\n     \n    if (i<n and A[i]==C[i + j] and j<m and B[j]==C[i + j]):\n        # go down and store the calculated value in x\n        # and go right and store the calculated value in y.\n        x = dfs(i + 1, j, A, B, C)\n        y = dfs(i, j + 1, A, B, C)\n         \n        # return the best of both.\n        dp[i][j] = x|y\n        return dp[i][j]\n     \n    # If C[i+j] matches with A[i].\n    if (i < n and A[i] == C[i + j]):\n        # go down\n        x = dfs(i + 1, j, A, B, C)\n         \n        # Return the calculated value.\n        dp[i][j] = x\n        return dp[i][j]\n     \n    # If C[i+j] matches with B[j].\n    if (j < m and B[j] == C[i + j]):\n        y = dfs(i, j + 1, A, B, C)\n         \n        # Return the calculated value.\n        dp[i][j] = y\n        return dp[i][j]\n     \n    # if nothing matches we return 0\n    dp[i][j] = 0\n    return dp[i][j]\n \n# The main function that \n# returns true if C is\n# an interleaving of A \n# and B, otherwise false.\ndef isInterleaved(A, B, C):\n \n    # Storing the length in n,m\n    n = len(A)\n    m = len(B)\n     \n    # C can be an interleaving of\n    # A and B only of the sum\n    # of lengths of A & B is equal\n    # to the length of C.\n     \n    if((n+m)!=len(C)):\n        return 0\n     \n    # initializing dp array with -1\n    for i in range(n+1):\n        for j in range(m+1):\n            dp[i][j]=-1\n     \n    # calling and returning the answer\n    return dfs(0,0,A,B,C)\n     \n \n# A function to run test cases\ndef test(A, B, C):\n \n    if (isInterleaved(A, B, C)):\n        print(C, 'is interleaved of', A, 'and', B)\n    else:\n        print(C, 'is not interleaved of', A, 'and', B)\n \n# Driver Code\nif __name__ == '__main__':\n    test('XXY', 'XXZ', 'XXZXXXY')\n    test('XY', 'WZ', 'WZXY')\n    test('XY', 'X', 'XXY')\n    test('YX', 'X', 'XXY')\n    test('XXY', 'XXZ', 'XXXXZY')\n    test('ACA', 'DAS', 'DAACSA')\n     \n# This code is contributed by Pushpesh Raj.\n"], "Stock Buy Sell to Maximize Profit -  ": ["# Python3 implementation of the approach \n  \n# Function to return the maximum profit \n# that can be made after buying and \n# selling the given stocks \n  \n  \ndef maxProfit(price, start, end): \n  \n    # If the stocks can't be bought \n    if (end <= start): \n        return 0\n  \n    # Initialise the profit \n    profit = 0\n  \n    # The day at which the stock \n    # must be bought \n    for i in range(start, end, 1): \n  \n        # The day at which the \n        # stock must be sold \n        for j in range(i+1, end+1): \n  \n            # If buying the stock at ith day and \n            # selling it at jth day is profitable \n            if (price[j] > price[i]): \n  \n                # Update the current profit \n                curr_profit = price[j] - price[i] +\\ \n                    maxProfit(price, start, i - 1) + \\ \n                    maxProfit(price, j + 1, end) \n  \n                # Update the maximum profit so far \n                profit = max(profit, curr_profit) \n  \n    return profit \n  \n  \n# Driver code \nif __name__ == '__main__': \n    price = [100, 180, 260, 310, 40, 535, 695] \n    n = len(price) \n  \n    print(maxProfit(price, 0, n - 1)) \n  \n# This code is contributed by Rajput-Ji \n", "# Python3 Program to find \n# best buying and selling days \n  \n# This function finds the buy sell \n# schedule for maximum profit \n  \n  \ndef stockBuySell(price, n): \n  \n    # Prices must be given for at least two days \n    if (n == 1): \n        return\n  \n    # Traverse through given price array \n    i = 0\n    while (i < (n - 1)): \n  \n        # Find Local Minima \n        # Note that the limit is (n-2) as we are \n        # comparing present element to the next element \n        while ((i < (n - 1)) and\n                (price[i + 1] <= price[i])): \n            i += 1\n  \n        # If we reached the end, break \n        # as no further solution possible \n        if (i == n - 1): \n            break\n  \n        # Store the index of minima \n        buy = i \n        i += 1\n  \n        # Find Local Maxima \n        # Note that the limit is (n-1) as we are \n        # comparing to previous element \n        while ((i < n) and (price[i] >= price[i - 1])): \n            i += 1\n  \n        # Store the index of maxima \n        sell = i - 1\n  \n        print('Buy on day: ', buy, '\\t', \n              'Sell on day: ', sell) \n  \n# Driver code \n  \n  \n# Stock prices on consecutive days \nprice = [100, 180, 260, 310, 40, 535, 695] \nn = len(price) \n  \n# Function call \nstockBuySell(price, n) \n  \n# This is code contributed by SHUBHAMSINGH10 \n", "# Python3 program for the above approach \ndef max_profit(prices: list, days: int) -> int: \n  \n    profit = 0\n  \n    for i in range(1, days): \n  \n        # checks if elements are adjacent and in increasing order \n        if prices[i] > prices[i-1]: \n  \n            # difference added to 'profit' \n            profit += prices[i] - prices[i-1] \n  \n    return profit \n  \n  \n# Driver Code \nif __name__ == '__main__': \n  \n    # stock prices on consecutive days \n    prices = [100, 180, 260, 310, 40, 535, 695] \n  \n    # function call \n    profit = max_profit(prices, len(prices)) \n    print(profit) \n  \n    # This code is contributed by vishvofficial. \n"], "Maximum Product Subarray -  ": ["# Python3 program to find Maximum Product Subarray\n \n# Returns the product of max product subarray.\n \n \ndef maxSubarrayProduct(arr, n):\n \n    # Initializing result\n    result = arr[0]\n \n    for i in range(n):\n \n        mul = arr[i]\n \n        # traversing in current subarray\n        for j in range(i + 1, n):\n \n            # updating result every time\n            # to keep an eye over the maximum product\n            result = max(result, mul)\n            mul *= arr[j]\n \n        # updating the result for (n-1)th index.\n        result = max(result, mul)\n \n    return result\n \n \n# Driver code\narr = [1, -2, -3, 0, 7, -8, -2]\nn = len(arr)\nprint('Maximum Sub array product is', maxSubarrayProduct(arr, n))\n \n# This code is contributed by divyeshrabadiya07\n", "# Python3 program to find Maximum Product Subarray\n \n#  Returns the product\n# of max product subarray.\n \n \ndef maxSubarrayProduct(arr, n):\n \n    # max positive product\n    # ending at the current position\n    max_ending_here = arr[0]\n \n    # min negative product ending\n    # at the current position\n    min_ending_here = arr[0]\n \n    # Initialize overall max product\n    max_so_far = arr[0]\n \n    # /* Traverse through the array.\n    # the maximum product subarray ending at an index\n    # will be the maximum of the element itself,\n    # the product of element and max product ending previously\n    # and the min product ending previously. */\n    for i in range(1, n):\n        temp = max(max(arr[i], arr[i] * max_ending_here),\n                   arr[i] * min_ending_here)\n        min_ending_here = min(\n            min(arr[i], arr[i] * max_ending_here), arr[i] * min_ending_here)\n        max_ending_here = temp\n        max_so_far = max(max_so_far, max_ending_here)\n \n    return max_so_far\n \n \n# Driver code\narr = [1, -2, -3, 0, 7, -8, -2]\nn = len(arr)\nprint(f'Maximum Sub array product is {maxSubarrayProduct(arr, n)}')\n \n# This code is contributed by shinjanpatra\n", "# Python program to find Maximum Product Subarray\n \nimport sys\n \n# Returns the product of max product subarray.\ndef maxSubarrayProduct(arr, n):\n    ans = -sys.maxsize - 1  # Initialize the answer to the minimum possible value\n    product = 1\n \n    for i in range(n):\n        product *= arr[i]\n        ans = max(ans, product)  # Update the answer with the maximum of the current answer and product\n        if arr[i] == 0:\n            product = 1  # Reset the product to 1 if the current element is 0\n \n    product = 1\n \n    for i in range(n - 1, -1, -1):\n        product *= arr[i]\n        ans = max(ans, product)\n        if arr[i] == 0:\n            product = 1\n \n    return ans\n \n# Driver code\narr = [1, -2, -3, 0, 7, -8, -2]\nn = len(arr)\nprint('Maximum Subarray product is', maxSubarrayProduct(arr, n))\n"], "Trapping Rain Water -  ": ["# Python3 implementation of the approach \n  \n# Function to return the maximum \n# water that can be stored \ndef maxWater(arr, n): \n  \n    # To store the maximum water \n    # that can be stored \n    res = 0\n  \n    # For every element of the array \n    for i in range(1, n - 1): \n  \n        # Find the maximum element on its left \n        left = arr[i] \n        for j in range(i): \n            left = max(left, arr[j]) \n  \n        # Find the maximum element on its right \n        right = arr[i] \n  \n        for j in range(i + 1, n): \n            right = max(right, arr[j]) \n  \n        # Update the maximum water \n        res = res + (min(left, right) - arr[i]) \n  \n    return res \n  \n  \n# Driver code \nif __name__ == '__main__': \n  \n    arr = [0, 1, 0, 2, 1, 0, \n           1, 3, 2, 1, 2, 1] \n    n = len(arr) \n  \n    print(maxWater(arr, n)) \n  \n# This code is contributed by AnkitRai01 \n", "# Python program to find maximum amount of water that can \n# be trapped within given set of bars. \n  \n  \ndef findWater(arr, n): \n  \n    # left[i] contains height of tallest bar to the \n    # left of i'th bar including itself \n    left = [0]*n \n  \n    # Right [i] contains height of tallest bar to \n    # the right of ith bar including itself \n    right = [0]*n \n  \n    # Initialize result \n    water = 0\n  \n    # Fill left array \n    left[0] = arr[0] \n    for i in range(1, n): \n        left[i] = max(left[i-1], arr[i]) \n  \n    # Fill right array \n    right[n-1] = arr[n-1] \n    for i in range(n-2, -1, -1): \n        right[i] = max(right[i + 1], arr[i]) \n  \n    # Calculate the accumulated water element by element \n    # consider the amount of water on i'th bar, the \n    # amount of water accumulated on this particular \n    # bar will be equal to min(left[i], right[i]) - arr[i] . \n    for i in range(0, n): \n        water += min(left[i], right[i]) - arr[i] \n  \n    return water \n  \n  \n# Driver program \nif __name__ == '__main__': \n    arr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] \n    n = len(arr) \n    print(findWater(arr, n)) \n  \n# This code is contributed by \n# Smitha Dinesh Semwal \n", "# Python implementation of the approach \n  \n# Function to return the maximum \n# water that can be stored \n  \n  \ndef maxWater(height): \n  \n    # Stores the indices of the bars \n    stack = [] \n  \n    # size of the array \n    n = len(height) \n  \n    # Stores the final result \n    ans = 0\n  \n    # Loop through the each bar \n    for i in range(n): \n  \n        # Remove bars from the stack \n        # until the condition holds \n        while(len(stack) != 0 and (height[stack[-1]] < height[i])): \n  \n            # store the height of the top \n            # and pop it. \n            pop_height = height[stack[-1]] \n            stack.pop() \n  \n            # If the stack does not have any \n            # bars or the popped bar \n            # has no left boundary \n            if(len(stack) == 0): \n                break\n  \n            # Get the distance between the \n            # left and right boundary of \n            # popped bar \n            distance = i - stack[-1] - 1\n  \n            # Calculate the min. height \n            min_height = min(height[stack[-1]], height[i])-pop_height \n  \n            ans += distance * min_height \n  \n        # If the stack is either empty or \n        # height of the current bar is less than \n        # or equal to the top bar of stack \n        stack.append(i) \n  \n    return ans \n  \n  \n# Driver code \nif __name__ == '__main__': \n    arr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] \n    print(maxWater(arr)) \n  \n# This code is contributed by rag2127 \n", "# Python code to implement the approach \n  \ndef trappedWater(arr): \n    num_blocks = 0\n    n = 0\n    max_height = float('-inf') \n  \n    # Find total blocks, max height and length of array \n    for height in arr: \n        num_blocks += height \n        n += 1\n        max_height = max(max_height, height) \n  \n    # Total water, left pointer and right pointer  \n    # initialized to 0 and n - 1 \n    total = 0\n    left = 0\n    right = n - 1\n  \n    for i in range(1, max_height+1): \n          \n        # Find leftmost point greater than current row (i) \n        while arr[left] < i: \n            left += 1\n          \n        # Find rightmost point greater than current row (i) \n        while arr[right] < i: \n            right -= 1\n          \n        # Water in this row = right - left + 1 \n        total += (right - left + 1) \n      \n    total -= num_blocks \n    return total \n  \n# Driver code \nif __name__ == '__main__': \n    arr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] \n    print(trappedWater(arr)) \n", "# Python3 implementation of the approach \n  \n# Function to return the maximum \n# water that can be stored \n  \n  \ndef maxWater(arr, n): \n      \n    # Indices to traverse the array \n    left = 0\n    right = n-1\n  \n    # To store Left max and right max  \n    # for two pointers left and right \n    l_max = 0\n    r_max = 0\n  \n    # To store the total amount  \n    # of rain water trapped \n    result = 0\n    while (left <= right): \n          \n        # We need check for minimum of left  \n        # and right max for each element \n        if r_max <= l_max: \n              \n            # Add the difference between  \n            #current value and right max at index r \n            result += max(0, r_max-arr[right]) \n              \n            # Update right max \n            r_max = max(r_max, arr[right]) \n              \n            # Update right pointer \n            right -= 1\n        else: \n              \n            # Add the difference between  \n            # current value and left max at index l \n            result += max(0, l_max-arr[left]) \n              \n            # Update left max \n            l_max = max(l_max, arr[left]) \n              \n            # Update left pointer \n            left += 1\n    return result \n  \n  \n# Driver code \nif __name__ == '__main__': \n    arr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] \n    N = len(arr) \n    print(maxWater(arr, N)) \n  \n# This code is contributed by Nikhil Chatragadda \n", "# Python3 implementation of the approach \n  \n# Function to return the maximum \n# water that can be stored \n  \n  \ndef maxWater(arr, n): \n    size = n - 1\n  \n    # Let the first element be stored as \n    # previous, we shall loop from index 1 \n    prev = arr[0] \n  \n    # To store previous wall's index \n    prev_index = 0\n    water = 0\n  \n    # To store the water until a larger wall \n    # is found, if there are no larger walls \n    # then delete temp value from water \n    temp = 0\n    for i in range(1, size + 1): \n  \n        # If the current wall is taller than \n        # the previous wall then make current \n        # wall as the previous wall and its \n        # index as previous wall's index \n        # for the subsequent loops \n        if (arr[i] >= prev): \n            prev = arr[i] \n            prev_index = i \n  \n            # Because larger or same height wall is found \n            temp = 0\n        else: \n  \n            # Since current wall is shorter than \n            # the previous, we subtract previous \n            # wall's height from the current wall's \n            # height and add it to the water \n            water += prev - arr[i] \n  \n            # Store the same value in temp as well \n            # If we dont find any larger wall then \n            # we will subtract temp from water \n            temp += prev - arr[i] \n  \n    # If the last wall was larger than or equal \n    # to the previous wall then prev_index would \n    # be equal to size of the array (last element) \n    # If we didn't find a wall greater than or equal \n    # to the previous wall from the left then \n    # prev_index must be less than the index \n    # of the last element \n    if (prev_index < size): \n  \n        # Temp would've stored the water collected \n        # from previous largest wall till the end \n        # of array if no larger wall was found then \n        # it has excess water and remove that \n        # from 'water' var \n        water -= temp \n  \n        # We start from the end of the array, so previous \n        # should be assigned to the last element \n        prev = arr[size] \n  \n        # Loop from the end of array up to the 'previous index' \n        # which would contain the 'largest wall from the left' \n        for i in range(size, prev_index - 1, -1): \n  \n            # Right end wall will be definitely smaller \n            # than the 'previous index' wall \n            if (arr[i] >= prev): \n                prev = arr[i] \n            else: \n                water += prev - arr[i] \n  \n    # Return the maximum water \n    return water \n  \n  \n# Driver code \nif __name__ == '__main__': \n    arr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] \n    N = len(arr) \n    print(maxWater(arr, N)) \n  \n# This code is contributed by Mohit Kumar \n"], "Clone an Undirected Graph -  ": ["from collections import deque\n \nclass GraphNode:\n    def __init__(self, val=0, neighbors=[]):\n        self.val = val\n        self.neighbors = neighbors\n \ndef cloneGraph(src: GraphNode) -> GraphNode:\n    # A Map to keep track of all the\n    # nodes which have already been created\n    m = {}\n    q = deque()\n \n    # Enqueue src node\n    q.append(src)\n    node = None\n \n    # Make a clone Node\n    node = GraphNode()\n    node.val = src.val\n \n    # Put the clone node into the Map\n    m[src] = node\n    while q:\n        # Get the front node from the queue\n        # and then visit all its neighbors\n        u = q.popleft()\n        v = u.neighbors\n        for neighbor in v:\n            # Check if this node has already been created\n            if neighbor not in m:\n                # If not then create a new Node and\n                # put into the HashMap\n                node = GraphNode()\n                node.val = neighbor.val\n                m[neighbor] = node\n                q.append(neighbor)\n \n            # Add these neighbors to the cloned graph node\n            m[u].neighbors.append(m[neighbor])\n \n    # Return the address of cloned src Node\n    return m[src]\n \n# Build the desired graph\ndef buildGraph() -> GraphNode:\n    '''\n    Given Graph:\n    1--2\n    | |\n    4--3\n    '''\n    node1 = GraphNode(1)\n    node2 = GraphNode(2)\n    node3 = GraphNode(3)\n    node4 = GraphNode(4)\n    node1.neighbors = [node2, node4]\n    node2.neighbors = [node1, node3]\n    node3.neighbors = [node2, node4]\n    node4.neighbors = [node3, node1]\n    return node1\n \n# A simple bfs traversal of a graph to\n# check for proper cloning of the graph\ndef bfs(src: GraphNode):\n    visit = {}\n    q = deque()\n    q.append(src)\n    visit[src] = True\n    while q:\n        u = q.popleft()\n        print(f'Value of Node {u.val}')\n        print(f'Address of Node {u}')\n        v = u.neighbors\n        for neighbor in v:\n            if neighbor not in visit:\n                visit[neighbor] = True\n                q.append(neighbor)\n \nif __name__ == '__main__':\n    src = buildGraph()\n    print('BFS Traversal before cloning')\n    bfs(src)\n    clone = cloneGraph(src)\n    print('\\nBFS Traversal after cloning')\n    bfs(clone)\n \n    # This code is contributed by vikramshirsath177\n"], "Minimum steps to reach target by a Knight | Set 1 -  ": ["# Python3 code to find minimum steps to reach\n# to specific cell in minimum moves by Knight\n \n \nclass cell:\n \n    def __init__(self, x=0, y=0, dist=0):\n        self.x = x\n        self.y = y\n        self.dist = dist\n \n# checks whether given position is\n# inside the board\n \n \ndef isInside(x, y, N):\n    if (x >= 1 and x <= N and\n            y >= 1 and y <= N):\n        return True\n    return False\n \n# Method returns minimum step to reach\n# target position\n \n \ndef minStepToReachTarget(knightpos,\n                         targetpos, N):\n \n    # all possible movements for the knight\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n \n    queue = []\n \n    # push starting position of knight\n    # with 0 distance\n    queue.append(cell(knightpos[0], knightpos[1], 0))\n \n    # make all cell unvisited\n    visited = [[False for i in range(N + 1)]\n               for j in range(N + 1)]\n \n    # visit starting state\n    visited[knightpos[0]][knightpos[1]] = True\n \n    # loop until we have one element in queue\n    while(len(queue) > 0):\n \n        t = queue[0]\n        queue.pop(0)\n \n        # if current cell is equal to target\n        # cell, return its distance\n        if(t.x == targetpos[0] and\n           t.y == targetpos[1]):\n            return t.dist\n \n        # iterate for all reachable states\n        for i in range(8):\n \n            x = t.x + dx[i]\n            y = t.y + dy[i]\n \n            if(isInside(x, y, N) and not visited[x][y]):\n                visited[x][y] = True\n                queue.append(cell(x, y, t.dist + 1))\n \n \n# Driver Code\nif __name__ == '__main__':\n    N = 30\n    knightpos = [1, 1]\n    targetpos = [30, 30]\n \n    # Function call\n    print(minStepToReachTarget(knightpos,\n                               targetpos, N))\n \n# This code is contributed by\n# Kaustav kumar Chanda\n"], "Word Ladder (Length of shortest chain to reach a target word) -  ": ["# Python3 program to find length of the\n# shortest chain transformation from source\n# to target\nfrom collections import deque\n \n# Returns length of shortest chain\n# to reach 'target' from 'start'\n# using minimum number of adjacent\n# moves. D is dictionary\ndef shortestChainLen(start, target, D):\n     \n    if start == target:\n      return 0\n    # If the target is not\n    # present in the dictionary\n    if target not in D:\n        return 0\n \n    # To store the current chain length\n    # and the length of the words\n    level, wordlength = 0, len(start)\n \n    # Push the starting word into the queue\n    Q =  deque()\n    Q.append(start)\n \n    # While the queue is non-empty\n    while (len(Q) > 0):\n         \n        # Increment the chain length\n        level += 1\n \n        # Current size of the queue\n        sizeofQ = len(Q)\n \n        # Since the queue is being updated while\n        # it is being traversed so only the\n        # elements which were already present\n        # in the queue before the start of this\n        # loop will be traversed for now\n        for i in range(sizeofQ):\n \n            # Remove the first word from the queue\n            word = [j for j in Q.popleft()]\n            #Q.pop()\n \n            # For every character of the word\n            for pos in range(wordlength):\n                 \n                # Retain the original character\n                # at the current position\n                orig_char = word[pos]\n \n                # Replace the current character with\n                # every possible lowercase alphabet\n                for c in range(ord('a'), ord('z')+1):\n                    word[pos] = chr(c)\n \n                    # If the new word is equal\n                    # to the target word\n                    if (''.join(word) == target):\n                        return level + 1\n \n                    # Remove the word from the set\n                    # if it is found in it\n                    if (''.join(word) not in D):\n                        continue\n                         \n                    del D[''.join(word)]\n \n                    # And push the newly generated word\n                    # which will be a part of the chain\n                    Q.append(''.join(word))\n \n                # Restore the original character\n                # at the current position\n                word[pos] = orig_char\n \n    return 0\n \n# Driver code\nif __name__ == '__main__':\n     \n    # Make dictionary\n    D = {}\n    D['poon'] = 1\n    D['plee'] = 1\n    D['same'] = 1\n    D['poie'] = 1\n    D['plie'] = 1\n    D['poin'] = 1\n    D['plea'] = 1\n    start = 'toon'\n    target = 'plea'\n     \n    print('Length of shortest chain is: ',\n    shortestChainLen(start, target, D))\n \n# This code is contributed by mohit kumar 29\n", "from typing import List, Tuple, Set, Dict, Any, Union\n \ndef shortest_chain_len(start: str, target: str, D: Set[str]) -> int:\n    if start == target:\n        return 0\n \n    # Dictionary of intermediate words and\n    # the list of original words\n    umap: Dict[str, List[str]] = {}\n \n    # Initialize umap with empty lists\n    for i in range(len(start)):\n        intermediate_word = start[:i] + '*' + start[i+1:]\n        umap[intermediate_word] = []\n \n    # Find all the intermediate words for\n    # the words in the given Set\n    for word in D:\n        for i in range(len(word)):\n            intermediate_word = word[:i] + '*' + word[i+1:]\n            if intermediate_word not in umap:\n                umap[intermediate_word] = []\n            umap[intermediate_word].append(word)\n \n    # Perform BFS and push (word, distance)\n    q = [(start, 1)]\n    visited = {start: 1}\n \n    # Traverse until queue is empty\n    while q:\n        word, dist = q.pop(0)\n \n        # If target word is found\n        if word == target:\n            return dist\n \n        # Finding intermediate words for\n        # the word in front of queue\n        for i in range(len(word)):\n            intermediate_word = word[:i] + '*' + word[i+1:]\n            vect = umap[intermediate_word]\n            for k in range(len(vect)):\n               \n                # If the word is not visited\n                if vect[k] not in visited:\n                    visited[vect[k]] = 1\n                    q.append((vect[k], dist + 1))\n \n    return 0\n \n# Test\n \n# Make dictionary\nD = {'poon', 'plee', 'same', 'poie', 'plie', 'poin', 'plea'}\nstart = 'toon'\ntarget = 'plea'\nprint(f'Length of shortest chain is: {shortest_chain_len(start, target, D)}')\n \n# This code is contributed by vikramshirsath177\n"], "Connected Components in an Undirected Graph -  ": ["# Python program to print connected\n# components in an undirected graph\n \n \nclass Graph:\n \n    # init function to declare class variables\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for i in range(V)]\n \n    def DFSUtil(self, temp, v, visited):\n \n        # Mark the current vertex as visited\n        visited[v] = True\n \n        # Store the vertex to list\n        temp.append(v)\n \n        # Repeat for all vertices adjacent\n        # to this vertex v\n        for i in self.adj[v]:\n            if visited[i] == False:\n \n                # Update the list\n                temp = self.DFSUtil(temp, i, visited)\n        return temp\n \n    # method to add an undirected edge\n    def addEdge(self, v, w):\n        self.adj[v].append(w)\n        self.adj[w].append(v)\n \n    # Method to retrieve connected components\n    # in an undirected graph\n    def connectedComponents(self):\n        visited = []\n        cc = []\n        for i in range(self.V):\n            visited.append(False)\n        for v in range(self.V):\n            if visited[v] == False:\n                temp = []\n                cc.append(self.DFSUtil(temp, v, visited))\n        return cc\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # Create a graph given in the above diagram\n    # 5 vertices numbered from 0 to 4\n    g = Graph(5)\n    g.addEdge(1, 0)\n    g.addEdge(2, 1)\n    g.addEdge(3, 4)\n    cc = g.connectedComponents()\n    print('Following are connected components')\n    print(cc)\n \n# This code is contributed by Abhishek Valsan\n", "# Python equivalent of above Java code\n \n# importing utilities\nimport collections\n \n# class to find connected components\nclass ConnectedComponents:\n  # function to merge two components\n  def merge(self, parent, x):\n    if parent[x] == x:\n      return x\n    return self.merge(parent, parent[x])\n \n  # function to find connected components\n  def connectedComponents(self, n, edges):\n    # list to store parents of each node\n    parent = [i for i in range(n)]\n \n    # loop to set parent of each node\n    for x in edges:\n      parent[self.merge(parent, x[0])] = self.merge(parent, x[1])\n       \n    # count to store number of connected components\n    ans = 0\n    # loop to count number of connected components\n    for i in range(n):\n      if parent[i] == i:\n        ans += 1\n     \n    # loop to merge all components\n    for i in range(n):\n      parent[i] = self.merge(parent, parent[i])\n \n    # map to store parent and its connected components\n    m = collections.defaultdict(list)\n    for i in range(n):\n      m[parent[i]].append(i)\n     \n    # loop to print connected components\n    for it in m.items():\n      l = it[1]\n      print(' '.join([str(x) for x in l]))\n     \n    return ans\n \n \n# driver code\nif __name__ == '__main__':\n  n = 5\n  edges = [[0, 1], [2, 1], [3, 4]]\n \n  # print connected components\n  print('Following are connected components:')\n  ans = ConnectedComponents().connectedComponents(n, edges)\n"], "Flood Fill Algorithm -  ": ["# Python3 implementation of the approach\n \n# Function that returns true if \n# the given pixel is valid\ndef isValid(screen, m, n, x, y, prevC, newC):\n    if x<0 or x>= m\\\n       or y<0 or y>= n or\\\n       screen[x][y]!= prevC\\\n       or screen[x][y]== newC:\n        return False\n    return True\n \n \n# FloodFill function\ndef floodFill(screen,  \n            m, n, x,  \n            y, prevC, newC):\n    queue = []\n     \n    # Append the position of starting \n    # pixel of the component\n    queue.append([x, y])\n \n    # Color the pixel with the new color\n    screen[x][y] = newC\n \n    # While the queue is not empty i.e. the \n    # whole component having prevC color \n    # is not colored with newC color\n    while queue:\n         \n        # Dequeue the front node\n        currPixel = queue.pop()\n         \n        posX = currPixel[0]\n        posY = currPixel[1]\n         \n        # Check if the adjacent\n        # pixels are valid\n        if isValid(screen, m, n,  \n                posX + 1, posY,  \n                        prevC, newC):\n             \n            # Color with newC\n            # if valid and enqueue\n            screen[posX + 1][posY] = newC\n            queue.append([posX + 1, posY])\n         \n        if isValid(screen, m, n,  \n                    posX-1, posY,  \n                        prevC, newC):\n            screen[posX-1][posY]= newC\n            queue.append([posX-1, posY])\n         \n        if isValid(screen, m, n,  \n                posX, posY + 1,  \n                        prevC, newC):\n            screen[posX][posY + 1]= newC\n            queue.append([posX, posY + 1])\n         \n        if isValid(screen, m, n,  \n                    posX, posY-1,  \n                        prevC, newC):\n            screen[posX][posY-1]= newC\n            queue.append([posX, posY-1])\n \n \n \n# Driver code\nscreen =[\n[1, 1, 1, 1, 1, 1, 1, 1], \n[1, 1, 1, 1, 1, 1, 0, 0], \n[1, 0, 0, 1, 1, 0, 1, 1], \n[1, 2, 2, 2, 2, 0, 1, 0], \n[1, 1, 1, 2, 2, 0, 1, 0], \n[1, 1, 1, 2, 2, 2, 2, 0], \n[1, 1, 1, 1, 1, 2, 1, 1], \n[1, 1, 1, 1, 1, 2, 2, 1], \n    ]\n     \n# Row of the display\nm = len(screen)\n \n# Column of the display\nn = len(screen[0])\n \n# Co-ordinate provided by the user\nx = 4\ny = 4\n \n# Current color at that co-ordinate\nprevC = screen[x][y]\n \n# New color that has to be filled\nnewC = 3\n \nfloodFill(screen, m, n, x, y, prevC, newC)\n \n \n# Printing the updated screen\nfor i in range(m):\n    for j in range(n):\n        print(screen[i][j], end =' ')\n    print()\n", "from typing import List, Tuple\n \n \ndef flood_fill(screen: List[List[int]], sr: int, sc: int, row: int, col: int, source: int, color: int) -> None:\n    # Condition for checking out of bounds\n    if sr < 0 or sr >= row or sc < 0 or sc >= col:\n        return\n \n    if screen[sr][sc] != source:\n        return\n \n    screen[sr][sc] = color\n    flood_fill(screen, sr - 1, sc, row, col, source, color)  # left\n    flood_fill(screen, sr + 1, sc, row, col, source, color)  # right\n    flood_fill(screen, sr, sc + 1, row, col, source, color)  # top\n    flood_fill(screen, sr, sc - 1, row, col, source, color)  # bottom\n \n \nif __name__ == '__main__':\n    screen = [\n        [1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 1, 1, 0, 0],\n        [1, 0, 0, 1, 1, 0, 1, 1],\n        [1, 2, 2, 2, 2, 0, 1, 0],\n        [1, 1, 1, 2, 2, 0, 1, 0],\n        [1, 1, 1, 2, 2, 2, 2, 0],\n        [1, 1, 1, 1, 1, 2, 1, 1],\n        [1, 1, 1, 1, 1, 2, 2, 1]\n    ]\n \n    # Row of the display\n    m = 8\n \n    # Column of the display\n    n = 8\n \n    # Coordinate provided by the user\n    x = 4\n    y = 4\n \n    # Current color at that coordinate\n    prevC = screen[x][y]\n \n    # New color that has to be filled\n    newC = 3\n \n    flood_fill(screen, x, y, m, n, prevC, newC)\n \n    # Printing the updated screen\n    for i in range(m):\n        for j in range(n):\n            print(screen[i][j], end=' ')\n        print()\n"], "Check if it is possible to finish all task from given dependencies (Course Schedule I) -  ": ["# Python3 program to check whether we can finish all\n# tasks or not from given dependencies.\n \n# class to store dependencies as a pair\nclass pair:\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n \n# Returns adjacency list representation from a list\n# of pairs.\ndef make_graph(numTasks, prerequisites):\n    graph = []\n    for i in range(numTasks):\n        graph.append([])\n \n    for pre in prerequisites:\n        graph[pre.second].append(pre.first)\n \n    return graph\n \n# A DFS based function to check if there is a cycle\n# in the directed graph.\ndef dfs_cycle(graph, node, onpath, visited):\n    if visited[node]:\n        return false\n    onpath[node] = visited[node] = True\n    for neigh in graph[node]:\n        if (onpath[neigh] or dfs_cycle(graph, neigh, onpath, visited)):\n            return true\n    return False\n \n# Main function to check whether possible to finish all\n# tasks or not\ndef canFinish(numTasks, prerequisites):\n    graph = make_graph(numTasks, prerequisites)\n    onpath = [False]*numTasks\n    visited = [False]*numTasks\n    for i in range(numTasks):\n        if (not visited[i] and dfs_cycle(graph, i, onpath, visited)):\n            return False\n    return True\n \n \n# Driver code to test above functions\nnumTasks = 4\nprerequisites = []\n \nprerequisites.append(pair(1, 0))\nprerequisites.append(pair(2, 1))\nprerequisites.append(pair(3, 2))\n \nif canFinish(numTasks, prerequisites):\n    print('Possible to finish all tasks')\nelse:\n    print('Impossible to finish all tasks')\n \n# This code is contributed by Abhijeet Kumar(abhijeet19403)\n", "# A BFS based solution to check if we can finish\n# all tasks or not. This solution is mainly based\n# on Kahn's algorithm.\n \n# class to store dependencies as a pair\n \n \nclass pair:\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n \n# Returns adjacency list representation from a list\n# of pairs.\n \n \ndef make_graph(numTasks, prerequisites):\n    graph = []\n    for i in range(numTasks):\n        graph.append([])\n \n    for pre in prerequisites:\n        graph[pre.second].append(pre.first)\n \n    return graph\n \n \n# Finds in-degree of every vertex\ndef compute_indegree(graph):\n    degrees = [0]*len(graph)\n \n    for neighbors in graph:\n        for neigh in neighbors:\n            degrees[neigh] += 1\n \n    return degrees\n \n \n# Main function to check whether possible to finish all tasks or not\ndef canFinish(numTasks, prerequisites):\n    graph = make_graph(numTasks, prerequisites)\n    degrees = compute_indegree(graph)\n \n    for i in range(numTasks):\n        j = 0\n        while(j < numTasks):\n            if (degrees[j] == 0):\n                break\n            j += 1\n \n        if (j == numTasks):\n            return False\n \n        degrees[j] = -1\n        for neigh in graph[j]:\n            degrees[neigh] -= 1\n \n    return True\n \nnumTasks = 4\nprerequisites = []\n \nprerequisites.append(pair(1, 0))\nprerequisites.append(pair(2, 1))\nprerequisites.append(pair(3, 2))\n \nif (canFinish(numTasks, prerequisites)):\n    print('Possible to finish all tasks')\nelse:\n    print('Impossible to finish all tasks')\n \n# This code is contributed by Lovely Jain\n"], "Boggle (Find all possible words in a board of characters) | Set 1 -  ": ["# Python3 program for Boggle game\n# Let the given dictionary be following\n \ndictionary = ['GEEKS', 'FOR', 'QUIZ', 'GO']\nn = len(dictionary)\nM = 3\nN = 3\n \n# A given function to check if a given string\n# is present in dictionary. The implementation is\n# naive for simplicity. As per the question\n# dictionary is given to us.\ndef isWord(Str):\n   \n    # Linearly search all words\n    for i in range(n):\n        if (Str == dictionary[i]):\n            return True\n    return False\n \n# A recursive function to print all words present on boggle\ndef findWordsUtil(boggle, visited, i, j, Str):\n    # Mark current cell as visited and\n    # append current character to str\n    visited[i][j] = True\n    Str = Str + boggle[i][j]\n     \n    # If str is present in dictionary,\n    # then print it\n    if (isWord(Str)):\n        print(Str)\n     \n    # Traverse 8 adjacent cells of boggle[i,j]\n    row = i - 1\n    while row <= i + 1 and row < M:\n        col = j - 1\n        while col <= j + 1 and col < N:\n            if (row >= 0 and col >= 0 and not visited[row][col]):\n                findWordsUtil(boggle, visited, row, col, Str)\n            col+=1\n        row+=1\n     \n    # Erase current character from string and\n    # mark visited of current cell as false\n    Str = '' + Str[-1]\n    visited[i][j] = False\n \n# Prints all words present in dictionary.\ndef findWords(boggle):\n   \n    # Mark all characters as not visited\n    visited = [[False for i in range(N)] for j in range(M)]\n     \n    # Initialize current string\n    Str = ''\n     \n    # Consider every character and look for all words\n    # starting with this character\n    for i in range(M):\n      for j in range(N):\n        findWordsUtil(boggle, visited, i, j, Str)\n \n# Driver Code\nboggle = [['G', 'I', 'Z'], ['U', 'E', 'K'], ['Q', 'S', 'E']]\n \nprint('Following words of', 'dictionary are present')\nfindWords(boggle)\n \n#  This code is contributed by divyesh072019.\n", "def dfs(board, s, i, j, n, m, idx):\n    if i < 0 or i >= n or j < 0 or j >= m:\n        return False\n    if s[idx] != board[i][j]:\n        return False\n    if idx == len(s) - 1:\n        return True\n    temp = board[i][j]\n    board[i][j] = '*'\n    a = dfs(board, s, i, j+1, n, m, idx+1)\n    b = dfs(board, s, i, j-1, n, m, idx+1)\n    c = dfs(board, s, i+1, j, n, m, idx+1)\n    d = dfs(board, s, i-1, j, n, m, idx+1)\n    e = dfs(board, s, i+1, j+1, n, m, idx+1)\n    f = dfs(board, s, i-1, j+1, n, m, idx+1)\n    g = dfs(board, s, i+1, j-1, n, m, idx+1)\n    h = dfs(board, s, i-1, j-1, n, m, idx+1)\n    board[i][j] = temp\n    return a or b or c or e or f or g or h or d\n \ndef wordBoggle(board, dictionary):\n    n = len(board)\n    m = len(board[0])\n    store = set()\n     \n    #     Let the given dictionary be following\n    for word in dictionary:\n        for i in range(n):\n            for j in range(m):\n                if dfs(board, word, i, j, n, m, 0):\n                    store.add(word)\n    for word in store:\n        print(word)\n \nboggle = [['G', 'I', 'Z'],\n          ['U', 'E', 'K'],\n          ['Q', 'S', 'E']]\ndictionary = ['GEEKS', 'FOR', 'QUIZ', 'GO']\nprint('Following words of dictionary are present:')\nwordBoggle(boggle, dictionary)\n \n# This code is contributed by vikramshirsath177\n"], "Find size of the largest region in Boolean Matrix -  ": ["# Python3 program to find the length of the\n# largest region in boolean 2D-matrix\n \n# A function to check if a given cell\n# (row, col) can be included in DFS\n \n \ndef isSafe(M, row, col, visited):\n    global ROW, COL\n \n    # row number is in range, column number is in\n    # range and value is 1 and not yet visited\n    return ((row >= 0) and (row < ROW) and\n            (col >= 0) and (col < COL) and\n            (M[row][col] and not visited[row][col]))\n \n# A utility function to do DFS for a 2D\n# boolean matrix. It only considers\n# the 8 neighbours as adjacent vertices\n \n \ndef DFS(M, row, col, visited, count):\n \n    # These arrays are used to get row and column\n    # numbers of 8 neighbours of a given cell\n    rowNbr = [-1, -1, -1, 0, 0, 1, 1, 1]\n    colNbr = [-1, 0, 1, -1, 1, -1, 0, 1]\n \n    # Mark this cell as visited\n    visited[row][col] = True\n \n    # Recur for all connected neighbours\n    for k in range(8):\n        if (isSafe(M, row + rowNbr[k],\n                   col + colNbr[k], visited)):\n \n            # increment region length by one\n            count[0] += 1\n            DFS(M, row + rowNbr[k],\n                col + colNbr[k], visited, count)\n \n# The main function that returns largest\n# length region of a given boolean 2D matrix\n \n \ndef largestRegion(M):\n    global ROW, COL\n \n    # Make a bool array to mark visited cells.\n    # Initially all cells are unvisited\n    visited = [[0] * COL for i in range(ROW)]\n \n    # Initialize result as 0 and traverse\n    # through the all cells of given matrix\n    result = -999999999999\n    for i in range(ROW):\n        for j in range(COL):\n \n            # If a cell with value 1 is not\n            if (M[i][j] and not visited[i][j]):\n \n                # visited yet, then new region found\n                count = [1]\n                DFS(M, i, j, visited, count)\n \n                # maximum region\n                result = max(result, count[0])\n    return result\n \n \n# Driver Code\nif __name__ == '__main__':\n  ROW = 4\n  COL = 5\n \n  M = [[0, 0, 1, 1, 0],\n       [1, 0, 1, 1, 0],\n       [0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 1]]\n \n  # Function call\n  print(largestRegion(M))\n \n# This code is contributed by PranchalK\n", "from typing import List, Tuple\nfrom collections import deque\n \ndef largestRegion(grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n \n    # creating a queue that will help in bfs traversal\n    q = deque()\n    area = 0\n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            # if the value at any particular cell is 1 then\n            # from here we need to do the BFS traversal\n            if grid[i][j] == 1:\n                ans = 0\n                # pushing the pair(i,j) in the queue\n                q.append((i, j))\n                # marking the value 1 to -1 so that we\n                # don't again push this cell in the queue\n                grid[i][j] = -1\n                while len(q) > 0:\n                    t = q.popleft()\n                    ans += 1\n                    x, y = t[0], t[1]\n                    # now we will check in all 8 directions\n                    if x + 1 < m:\n                        if grid[x + 1][y] == 1:\n                            q.append((x + 1, y))\n                            grid[x + 1][y] = -1\n                    if x - 1 >= 0:\n                        if grid[x - 1][y] == 1:\n                            q.append((x - 1, y))\n                            grid[x - 1][y] = -1\n                    if y + 1 < n:\n                        if grid[x][y + 1] == 1:\n                            q.append((x, y + 1))\n                            grid[x][y + 1] = -1\n                    if y - 1 >= 0:\n                        if grid[x][y - 1] == 1:\n                            q.append((x, y - 1))\n                            grid[x][y - 1] = -1\n                    if x + 1 < m and y + 1 < n:\n                        if grid[x + 1][y + 1] == 1:\n                            q.append((x + 1, y + 1))\n                            grid[x + 1][y + 1] = -1\n                    if x - 1 >= 0 and y + 1 < n:\n                        if grid[x - 1][y + 1] == 1:\n                            q.append((x - 1, y + 1))\n                            grid[x - 1][y + 1] = -1\n                    if x - 1 >= 0 and y - 1 >= 0:\n                        if grid[x - 1][y - 1] == 1:\n                            q.append((x - 1, y - 1))\n                            grid[x - 1][y - 1] = -1\n                    if x + 1 < m and y - 1 >= 0:\n                        if grid[x + 1][y - 1] == 1:\n                            q.append((x + 1, y - 1))\n                            grid[x + 1][y - 1] = -1\n                area = max(area, ans)\n    return area\n \ndef main():\n    grid = [\n        [0, 0, 1, 1, 0],\n        [1, 0, 1, 1, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 0, 1]\n    ]\n    result = largestRegion(grid)\n    print(f'Largest region of 1s has an area of {result}')\n \nmain()\n"], "Find the number of islands using DFS -  ": ["# Program to count islands in boolean 2D matrix\nclass Graph:\n \n    def __init__(self, row, col, g):\n        self.ROW = row\n        self.COL = col\n        self.graph = g\n \n    # A function to check if a given cell\n    # (row, col) can be included in DFS\n    def isSafe(self, i, j, visited):\n        # row number is in range, column number\n        # is in range and value is 1\n        # and not yet visited\n        return (i >= 0 and i < self.ROW and\n                j >= 0 and j < self.COL and\n                not visited[i][j] and self.graph[i][j])\n \n    # A utility function to do DFS for a 2D\n    # boolean matrix. It only considers\n    # the 8 neighbours as adjacent vertices\n \n    def DFS(self, i, j, visited):\n \n        # These arrays are used to get row and\n        # column numbers of 8 neighbours\n        # of a given cell\n        rowNbr = [-1, -1, -1,  0, 0,  1, 1, 1]\n        colNbr = [-1,  0,  1, -1, 1, -1, 0, 1]\n \n        # Mark this cell as visited\n        visited[i][j] = True\n \n        # Recur for all connected neighbours\n        for k in range(8):\n            if self.isSafe(i + rowNbr[k], j + colNbr[k], visited):\n                self.DFS(i + rowNbr[k], j + colNbr[k], visited)\n \n    # The main function that returns\n    # count of islands in a given boolean\n    # 2D matrix\n \n    def countIslands(self):\n        # Make a bool array to mark visited cells.\n        # Initially all cells are unvisited\n        visited = [[False for j in range(self.COL)]for i in range(self.ROW)]\n \n        # Initialize count as 0 and traverse\n        # through the all cells of\n        # given matrix\n        count = 0\n        for i in range(self.ROW):\n            for j in range(self.COL):\n                # If a cell with value 1 is not visited yet,\n                # then new island found\n                if visited[i][j] == False and self.graph[i][j] == 1:\n                    # Visit all cells in this island\n                    # and increment island count\n                    self.DFS(i, j, visited)\n                    count += 1\n \n        return count\n \n \ngraph = [[1, 1, 0, 0, 0],\n         [0, 1, 0, 0, 1],\n         [1, 0, 0, 1, 1],\n         [0, 0, 0, 0, 0],\n         [1, 0, 1, 0, 1]]\n \n \nrow = len(graph)\ncol = len(graph[0])\n \ng = Graph(row, col, graph)\n \nprint('Number of islands is:')\nprint(g.countIslands())\n \n# This code is contributed by Neelam Yadav\n", "# Program to count islands in boolean 2D matrix\nclass Graph:\n \n    def __init__(self, row, col, graph):\n        self.ROW = row\n        self.COL = col\n        self.graph = graph\n \n    # A utility function to do DFS for a 2D\n    # boolean matrix. It only considers\n    # the 8 neighbours as adjacent vertices\n    def DFS(self, i, j):\n        if i < 0 or i >= len(self.graph) or j < 0 or j >= len(self.graph[0]) or self.graph[i][j] != 1:\n            return\n \n        # mark it as visited\n        self.graph[i][j] = -1\n \n        # Recur for 8 neighbours\n        self.DFS(i - 1, j - 1)\n        self.DFS(i - 1, j)\n        self.DFS(i - 1, j + 1)\n        self.DFS(i, j - 1)\n        self.DFS(i, j + 1)\n        self.DFS(i + 1, j - 1)\n        self.DFS(i + 1, j)\n        self.DFS(i + 1, j + 1)\n \n    # The main function that returns\n    # count of islands in a given boolean\n    # 2D matrix\n    def countIslands(self):\n        # Initialize count as 0 and traverse\n        # through the all cells of\n        # given matrix\n        count = 0\n        for i in range(self.ROW):\n            for j in range(self.COL):\n                # If a cell with value 1 is not visited yet,\n                # then new island found\n                if self.graph[i][j] == 1:\n                    # Visit all cells in this island\n                    # and increment island count\n                    self.DFS(i, j)\n                    count += 1\n \n        return count\n \n \ngraph = [\n    [1, 1, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [1, 0, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n    [1, 0, 1, 0, 1]\n]\n \n \nrow = len(graph)\ncol = len(graph[0])\n \ng = Graph(row, col, graph)\n \nprint('Number of islands is:', g.countIslands())\n \n# This code is contributed by Shivam Shrey\n", "def check(i, j, n, m):\n    return i >= 0 and j >= 0 and i < n and j < m\n \ndef mark_component(v, vis, i, j, n, m):\n    if not check(i, j, n, m):\n        return\n    vis[i][j] = True\n    if v[i][j] == 1:\n        v[i][j] = 0\n#marking(connecting all possible part of single island.\n        mark_component(v, vis, i + 1, j, n, m)\n        mark_component(v, vis, i - 1, j, n, m)\n        mark_component(v, vis, i, j + 1, n, m)\n        mark_component(v, vis, i, j - 1, n, m)\n        mark_component(v, vis, i + 1, j + 1, n, m)\n        mark_component(v, vis, i - 1, j - 1, n, m)\n        mark_component(v, vis, i + 1, j - 1, n, m)\n        mark_component(v, vis, i - 1, j + 1, n, m)\n \nv = [[1, 1, 0, 0, 0],\n     [0, 1, 0, 0, 1],\n     [1, 0, 0, 1, 1],\n     [0, 0, 0, 0, 0],\n     [1, 0, 1, 0, 1]]\nn = len(v)\nm = len(v[0])\ncnt = 0\nvis = [[False for j in range(m)] for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if not vis[i][j] and v[i][j] == 1:\n            cnt += 1\n            mark_component(v, vis, i, j, n, m)\nprint('The number of islands in the matrix are:')\nprint(cnt)\n# This code is contributed by Shivam Tiwari\n"], "Find Shortest Paths from Source to all Vertices using Dijkstra\u2019s Algorithm": ["import heapq\n \n# iPair ==> Integer Pair\niPair = tuple\n \n# This class represents a directed graph using\n# adjacency list representation\nclass Graph:\n    def __init__(self, V: int): # Constructor\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n \n    def addEdge(self, u: int, v: int, w: int):\n        self.adj[u].append((v, w))\n        self.adj[v].append((u, w))\n \n    # Prints shortest paths from src to all other vertices\n    def shortestPath(self, src: int):\n        # Create a priority queue to store vertices that\n        # are being preprocessed\n        pq = []\n        heapq.heappush(pq, (0, src))\n \n        # Create a vector for distances and initialize all\n        # distances as infinite (INF)\n        dist = [float('inf')] * self.V\n        dist[src] = 0\n \n        while pq:\n            # The first vertex in pair is the minimum distance\n            # vertex, extract it from priority queue.\n            # vertex label is stored in second of pair\n            d, u = heapq.heappop(pq)\n \n            # 'i' is used to get all adjacent vertices of a\n            # vertex\n            for v, weight in self.adj[u]:\n                # If there is shorted path to v through u.\n                if dist[v] > dist[u] + weight:\n                    # Updating distance of v\n                    dist[v] = dist[u] + weight\n                    heapq.heappush(pq, (dist[v], v))\n \n        # Print shortest distances stored in dist[]\n        for i in range(self.V):\n            print(f'{i} \\t\\t {dist[i]}')\n \n# Driver's code\nif __name__ == '__main__':\n    # create the graph given in above figure\n    V = 9\n    g = Graph(V)\n \n    # making above shown graph\n    g.addEdge(0, 1, 4)\n    g.addEdge(0, 7, 8)\n    g.addEdge(1, 2, 8)\n    g.addEdge(1, 7, 11)\n    g.addEdge(2, 3, 7)\n    g.addEdge(2, 8, 2)\n    g.addEdge(2, 5, 4)\n    g.addEdge(3, 4, 9)\n    g.addEdge(3, 5, 14)\n    g.addEdge(4, 5, 10)\n    g.addEdge(5, 6, 2)\n    g.addEdge(6, 7, 1)\n    g.addEdge(6, 8, 6)\n    g.addEdge(7, 8, 7)\n \n    g.shortestPath(0)\n"], "Connect nodes at same level -  ": ["# Iterative program to connect all the adjacent nodes at the same level in a binary tree\nclass newnode:\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = self.nextRight = None\n \n#   setting right pointer to next right node\n \n#              10 ----------> NULL\n#             /  \\\n#           8 --->2 --------> NULL\n#          /\n#         3 ----------------> NULL\n \n \ndef connect(root):\n \n    # Base condition\n    if root is None:\n        return\n \n    # Create an empty queue like level order traversal\n    queue = []\n    queue.append(root)\n    while len(queue) != 0:\n \n        # size indicates no. of nodes at current level\n        size = len(queue)\n \n        # for keeping track of previous node\n        prev = newnode(None)\n        for i in range(size):\n            temp = queue.pop(0)\n            if temp.left:\n                queue.append(temp.left)\n            if temp.right:\n                queue.append(temp.right)\n            if prev != None:\n                prev.nextRight = temp\n                prev = temp\n        prev.nextRight = None\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # Constructed binary tree is\n    # 10\n    #     / \\\n    # 8     2\n    # /\n    # 3\n    root = newnode(10)\n    root.left = newnode(8)\n    root.right = newnode(2)\n    root.left.left = newnode(3)\n \n    # Populates nextRight pointer in all nodes\n    connect(root)\n \n    # Let us check the values of nextRight pointers\n    print('Following are populated nextRight',\n          'pointers in the tree (-1 is printed',\n          'if there is no nextRight)')\n    print('nextRight of', root.data, 'is ', end='')\n    if root.nextRight:\n        print(root.nextRight.data)\n    else:\n        print(-1)\n    print('nextRight of', root.left.data, 'is ', end='')\n    if root.left.nextRight:\n        print(root.left.nextRight.data)\n    else:\n        print(-1)\n    print('nextRight of', root.right.data, 'is ', end='')\n    if root.right.nextRight:\n        print(root.right.nextRight.data)\n    else:\n        print(-1)\n    print('nextRight of', root.left.left.data, 'is ', end='')\n    if root.left.left.nextRight:\n        print(root.left.left.nextRight.data)\n    else:\n        print(-1)\n \n# This code is contributed by Vivek Maddeshiya\n", "# Python3 program to connect nodes at same\n# level using extended pre-order traversal\n \n \nclass newnode:\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = self.nextRight = None\n \n# Sets the nextRight of root and calls\n# connectRecur() for other nodes\n \n \ndef connect(p):\n \n    # Set the nextRight for root\n    p.nextRight = None\n \n    # Set the next right for rest of\n    # the nodes (other than root)\n    connectRecur(p)\n \n# Set next right of all descendants of p.\n# Assumption: p is a complete binary tree\n \n \ndef connectRecur(p):\n \n    # Base case\n    if (not p):\n        return\n \n    # Set the nextRight pointer for p's\n    # left child\n    if (p.left):\n        p.left.nextRight = p.right\n \n    # Set the nextRight pointer for p's right\n    # child p.nextRight will be None if p is\n    # the right most child at its level\n    if (p.right):\n        if p.nextRight:\n            p.right.nextRight = p.nextRight.left\n        else:\n            p.right.nextRight = None\n \n    # Set nextRight for other nodes in\n    # pre order fashion\n    connectRecur(p.left)\n    connectRecur(p.right)\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # Constructed binary tree is\n    # 10\n    #     / \\\n    # 8     2\n    # /\n    # 3\n    root = newnode(10)\n    root.left = newnode(8)\n    root.right = newnode(2)\n    root.left.left = newnode(3)\n \n    # Populates nextRight pointer in all nodes\n    connect(root)\n \n    # Let us check the values of nextRight pointers\n    print('Following are populated nextRight',\n          'pointers in the tree (-1 is printed',\n          'if there is no nextRight)')\n    print('nextRight of', root.data, 'is ', end='')\n    if root.nextRight:\n        print(root.nextRight.data)\n    else:\n        print(-1)\n    print('nextRight of', root.left.data, 'is ', end='')\n    if root.left.nextRight:\n        print(root.left.nextRight.data)\n    else:\n        print(-1)\n    print('nextRight of', root.right.data, 'is ', end='')\n    if root.right.nextRight:\n        print(root.right.nextRight.data)\n    else:\n        print(-1)\n    print('nextRight of', root.left.left.data, 'is ', end='')\n    if root.left.left.nextRight:\n        print(root.left.left.nextRight.data)\n    else:\n        print(-1)\n \n# This code is contributed by PranchalK\n"], "Count BST nodes that lie in a given range -  ": ["# Python3 program to count BST nodes \n# within a given range \n \n# Utility function to create new node \nclass newNode: \n \n    # Constructor to create a new node \n    def __init__(self, data): \n        self.data = data \n        self.left = None\n        self.right = None\n \n# Returns count of nodes in BST in \n# range [low, high] \ndef getCount(root, low, high):\n     \n    # Base case \n    if root == None:\n        return 0\n         \n    # Special Optional case for improving \n    # efficiency \n    if root.data == high and root.data == low: \n        return 1\n \n    # If current node is in range, then \n    # include it in count and recur for \n    # left and right children of it \n    if root.data <= high and root.data >= low: \n        return (1 + getCount(root.left, low, high) +\n                    getCount(root.right, low, high))\n \n    # If current node is smaller than low, \n    # then recur for right child \n    elif root.data < low: \n        return getCount(root.right, low, high)\n \n    # Else recur for left child \n    else:\n        return getCount(root.left, low, high)\n \n# Driver Code\nif __name__ == '__main__':\n     \n    # Let us construct the BST shown in \n    # the above figure \n    root = newNode(10) \n    root.left = newNode(5) \n    root.right = newNode(50) \n    root.left.left = newNode(1) \n    root.right.left = newNode(40)\n    root.right.right = newNode(100)\n     \n    # Let us constructed BST shown in above example \n    #     10 \n    #     / \\ \n    # 5     50 \n    # /     / \\ \n    # 1     40 100 \n    l = 5\n    h = 45\n    print('Count of nodes between [', l, ', ', h,'] is ', \n                                    getCount(root, l, h))\n \n# This code is contributed by PranchalK\n"], "Find the maximum path sum between two leaves of a binary tree -  ": ["# Python program to find maximumpath sum between two leaves\n# of a binary tree\n \nINT_MIN = -2**32\n \n# A binary tree node\n \n \nclass Node:\n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Utility function to find maximum sum between any\n# two leaves. This function calculates two values:\n# 1) Maximum path sum between two leaves which are stored\n#    in res\n# 2) The maximum root to leaf path sum which is returned\n# If one side of root is empty, then it returns INT_MIN\n \n \ndef maxPathSumUtil(root, res):\n \n    # Base Case\n    if root is None:\n        return 0\n \n    # if root is leaf node we can return root.data\n    if not root.left and not root.right:\n        return root.data\n \n    # Find maximumsum in left and right subtree. Also\n    # find maximum root to leaf sums in left and right\n    # subtrees ans store them in ls and rs\n    ls = maxPathSumUtil(root.left, res)\n    rs = maxPathSumUtil(root.right, res)\n \n    # If both left and right children exist\n    if root.left is not None and root.right is not None:\n \n        # update result if needed\n        res[0] = max(res[0], ls + rs + root.data)\n \n        # Return maximum possible value for root being\n        # on one side\n        return max(ls, rs) + root.data\n \n    # If any of the two children is empty, return\n    # root sum for root being on one side\n    if root.left is None:\n        return rs + root.data\n    else:\n        return ls + root.data\n \n# The main function which returns sum of the maximum\n# sum path betwee ntwo leaves. THis function mainly\n# uses maxPathSumUtil()\n \n \ndef maxPathSum(root):\n    res = [INT_MIN]\n    res1 = maxPathSumUtil(root, res)\n    # we have to check if root.left is None or root.right is None\n    # for ex:-   10\n    #            /  \\\n    #         None  -5\n    # this will return INT_MIN but answer is 5 which is res1\n    if root.left and root.right:\n        return res[0]\n    return max(res[0], res1)\n \n \n# Driver program to test above function\nroot = Node(-15)\nroot.left = Node(5)\nroot.right = Node(6)\nroot.left.left = Node(-8)\nroot.left.right = Node(1)\nroot.left.left.left = Node(2)\nroot.left.left.right = Node(6)\nroot.right.left = Node(3)\nroot.right.right = Node(9)\nroot.right.right.right = Node(0)\nroot.right.right.right.left = Node(4)\nroot.right.right.right.right = Node(-1)\nroot.right.right.right.right.left = Node(10)\n \nprint('Max pathSum of the given binary tree is', maxPathSum(root))\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"], "Root to leaf path sum equal to a given number -  ": ["# Python3 program to find if\n# there is a root to sum path\n \n# A binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n \n''' \n Given a tree and a sum, return \n true if there is a path from the root\n down to a leaf, such that\n adding up all the values along the path\n equals the given sum.\n  \n Strategy: subtract the node \n value from the sum when recurring down,\n and check to see if the sum \n is 0 when you run out of tree.\n'''\n# s is the sum\n \n \ndef hasPathSum(node, s):\n    ans = 0\n    subSum = s - node.data\n \n    # If we reach a leaf node and sum becomes 0, then\n    # return True\n    if(subSum == 0 and node.left == None and node.right == None):\n        return True\n \n    # Otherwise check both subtrees\n    if node.left is not None:\n        ans = ans or hasPathSum(node.left, subSum)\n    if node.right is not None:\n        ans = ans or hasPathSum(node.right, subSum)\n \n    return ans\n \n# Driver's Code\nif __name__ == '__main__':\n    s = 21\n    root = Node(10)\n    root.left = Node(8)\n    root.right = Node(2)\n    root.left.right = Node(5)\n    root.left.left = Node(3)\n    root.right.left = Node(2)\n     \n    # Function call\n    if hasPathSum(root, s):\n        print('There is a root-to-leaf path with sum %d' % (s))\n    else:\n        print('There is no root-to-leaf path with sum %d' % (s))\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "class Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n \ndef hasPathSum(root, targetSum):\n    if not root:\n        return False\n    s = [root]\n    sums = [root.data]\n    while s:\n        node = s.pop()\n        sum_val = sums.pop()\n        if not node.left and not node.right:\n            if sum_val == targetSum:\n                return True\n        if node.left:\n            s.append(node.left)\n            sums.append(sum_val + node.left.data)\n        if node.right:\n            s.append(node.right)\n            sums.append(sum_val + node.right.data)\n    return False\n \nif __name__ == '__main__':\n    root = Node(10)\n    root.left = Node(8)\n    root.right = Node(2)\n    root.left.left = Node(3)\n    root.left.right = Node(5)\n    root.right.left = Node(2)\n \n    targetSum = 23\n    if hasPathSum(root, targetSum):\n        print('There is a root-to-leaf path with sum', targetSum)\n    else:\n        print('There is no root-to-leaf path with sum', targetSum)\n"], "Maximum sum of nodes in Binary tree such that no two are adjacent -  ": ["# Python3 program to find\n# maximum sum from a subset\n# of nodes of binary tree\n \n# A binary tree node structure\n \n \nclass Node:\n \n    def __init__(self, data):\n \n        self.data = data\n        self.left = None\n        self.right = None\n \n# Utility function to create\n# a new Binary Tree node\n \n \ndef newNode(data):\n \n    temp = Node(data)\n    return temp\n \n# method returns maximum sum\n# possible from subtrees rooted\n# at grandChildrens of node 'node'\n \n \ndef sumOfGrandChildren(node, mp):\n \n    sum = 0\n \n    # call for children of left\n    # child only if it is not NULL\n    if (node.left):\n        sum += (getMaxSumUtil(node.left.left, mp) +\n                getMaxSumUtil(node.left.right, mp))\n \n    # call for children of right\n    # child only if it is not NULL\n    if (node.right):\n        sum += (getMaxSumUtil(node.right.left, mp) +\n                getMaxSumUtil(node.right.right, mp))\n \n    return sum\n \n# Utility method to return\n# maximum sum rooted at node\n# 'node'\n \n \ndef getMaxSumUtil(node, mp):\n \n    if (node == None):\n        return 0\n \n    # If node is already processed\n    # then return calculated\n    # value from map\n    if node in mp:\n        return mp[node]\n \n    # take current node value\n    # and call for all grand children\n    incl = (node.data +\n            sumOfGrandChildren(node, mp))\n \n    # don't take current node\n    # value and call for all children\n    excl = (getMaxSumUtil(node.left, mp) +\n            getMaxSumUtil(node.right, mp))\n \n    # choose maximum from both\n    # above calls and store that\n    # in map\n    mp[node] = max(incl, excl)\n \n    return mp[node]\n \n# Returns maximum sum from\n# subset of nodes of binary\n# tree under given constraints\n \n \ndef getMaxSum(node):\n \n    if (node == None):\n        return 0\n \n    mp = dict()\n    return getMaxSumUtil(node, mp)\n \n \n# Driver code\nif __name__ == '__main__':\n \n    root = newNode(1)\n    root.left = newNode(2)\n    root.right = newNode(3)\n    root.right.left = newNode(4)\n    root.right.right = newNode(5)\n    root.left.left = newNode(1)\n \n    print(getMaxSum(root))\n \n# This code is contributed by Rutvik_56\n", "# Python3 program to find maximum sum in Binary\n# Tree such that no two nodes are adjacent.\n \n# Binary Tree Node\n \n''' utility that allocates a newNode \nwith the given key '''\n \n \nclass newNode:\n \n    # Construct to create a newNode\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n \n \ndef maxSumHelper(root):\n \n    if (root == None):\n \n        sum = [0, 0]\n        return sum\n \n    sum1 = maxSumHelper(root.left)\n    sum2 = maxSumHelper(root.right)\n    sum = [0, 0]\n \n    # This node is included (Left and right\n    # children are not included)\n    sum[0] = sum1[1] + sum2[1] + root.data\n \n    # This node is excluded (Either left or\n    # right child is included)\n    sum[1] = (max(sum1[0], sum1[1]) +\n              max(sum2[0], sum2[1]))\n \n    return sum\n \n \ndef maxSum(root):\n \n    res = maxSumHelper(root)\n    return max(res[0], res[1])\n \n \n# Driver Code\nif __name__ == '__main__':\n    root = newNode(10)\n    root.left = newNode(1)\n    root.left.left = newNode(2)\n    root.left.left.left = newNode(1)\n    root.left.right = newNode(3)\n    root.left.right.left = newNode(4)\n    root.left.right.right = newNode(5)\n    print(maxSum(root))\n \n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n", "# Python program to find maximum sum in Binary Tree\n# such that no two nodes are adjacent.\n \n \nclass Node:\n    def __init__(self, data):\n \n        self.data = data\n        self.left = None\n        self.right = None\n \n \n# declare map /dp array as global\numap = {}\n \n \ndef maxSum(root):\n \n    global umap\n \n    # base case\n    if (root == None):\n        return 0\n \n    # if the max sum from the node is already in\n    # map,return the value\n    if (root in umap):\n        return umap[root]\n \n    # if the current node(root) is included in result\n    # then find maximum sum\n    inc = root.data\n \n    # if left of node exists, add their grandchildren\n    if (root.left):\n        inc += maxSum(root.left.left) + maxSum(root.left.right)\n \n    # if right of node exist,add their grandchildren\n    if (root.right):\n        inc += maxSum(root.right.left) + maxSum(root.right.right)\n \n    # if the current node(root) is excluded, find the\n    # maximum sum\n    ex = maxSum(root.left) + maxSum(root.right)\n \n    # store the maximum of including & excluding the node\n    # in map\n    umap[root] = max(inc, ex)\n    return max(inc, ex)\n \n \n# Driver code\nif __name__ == '__main__':\n  root = Node(10)\n  root.left = Node(1)\n  root.left.left = Node(2)\n  root.left.left.left = Node(1)\n  root.left.right = Node(3)\n  root.left.right.left = Node(4)\n  root.left.right.right = Node(5)\n  print(maxSum(root))\n \n# This code is contributed by shinjanpatra\n", "class Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n \n \nclass Solution:\n \n    def max_sum(self, root):\n        if not root:\n            return 0, 0\n \n        no_root_l, root_l = self.max_sum(root.left)\n        no_root_r, root_r = self.max_sum(root.right)\n \n        root_sum_max = max(root.data, root.data+no_root_l,\n                           root.data+no_root_r, root.data+no_root_r+no_root_l)\n        no_root_sum_max = max(root_l, root_r, root_l + root_r, no_root_l+no_root_r,\n                              root_l + no_root_r, root_r + no_root_l)\n \n        return no_root_sum_max, root_sum_max\n \n    def getMaxSum(self, root):\n        return max(self.max_sum(root))\n", "# Python3 program to find maximum sum from a subset of\n# non-adjacent nodes of binary tree\n \n# A binary tree node structure\n \n \nclass newNode:\n \n    def __init__(self, data):\n \n        self.data = data\n        self.left = None\n        self.right = None\n \n \ndp = [[]]\n \n# Variables and function to index the given Binary tree\n# This indexing will be used in dp\ncnt = 0\ntemp = newNode(0)\n \n \ndef giveIndex(root):\n \n    if (root == None):\n        return None\n    # give the index to the current node and increment the index for next nodes.\n    global cnt\n    cnt += 1\n    newNode1 = newNode(cnt)\n \n    # Recursively calling right and left subtree\n    newNode1.left = giveIndex(root.left)\n    newNode1.right = giveIndex(root.right)\n    return newNode1\n \n \n# Memoization function to store the answer\ndef solve(root, b, temp):\n \n    if (root == None):\n        return 0\n    # If the answer is already calculated return that answer\n    if (dp[temp.data][b] != -1):\n        return dp[temp.data][b]\n \n    # Variable to store the answer for the current node.\n    res = 0\n \n    # if the parent is not selected then we can either select ot not select this node.\n    if (b == 0):\n        res = max(root.data + solve(root.right, 1, temp.right) + solve(root.left, 1,\n                                                                       temp.left), solve(root.right, 0, temp.right) + solve(root.left, 0, temp.left))\n \n    # If parent is selected then we can't select this node.\n    else:\n        res = solve(root.right, 0, temp.right) + solve(root.left, 0, temp.left)\n \n    # return the answer\n    dp[temp.data][b] = res\n    return res\n \n \ndef getMaxSum(root):\n \n    # Initialization of the dp\n    global dp\n    dp = [[-1 for x in range(2)] for x in range(100)]\n    # Calling the indexing function\n    temp = giveIndex(root)\n    # calling the solve function for root with parent not selected\n    res = solve(root, 0, temp)\n \n    return res\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # TEST 1\n    root = newNode(1)\n    root.left = newNode(2)\n    root.right = newNode(3)\n    root.right.left = newNode(4)\n    root.right.right = newNode(5)\n    root.left.left = newNode(1)\n    print(getMaxSum(root))\n \n    # TEST 2\n    root2 = newNode(10)\n    root2.left = newNode(1)\n    root2.left.left = newNode(2)\n    root2.left.left.left = newNode(1)\n    root2.left.right = newNode(3)\n    root2.left.right.left = newNode(4)\n    root2.left.right.right = newNode(5)\n    print(getMaxSum(root2))\n \n# This code is contributed by Abhijeet Kumar(abhijeet19403)\n"], "Maximum Path Sum in a Binary Tree -  ": [], "Merge two BSTs with limited extra space -  ": ["# Class to create a new Tree Node\nclass newNode:\n    def __init__(self, data: int):\n        self.data = data\n        self.left = None\n        self.right = None\n \n \ndef inorder(root: newNode):\n \n    if root:\n        inorder(root.left)\n        print(root.data, end=' ')\n        inorder(root.right)\n \n \ndef merge(root1: newNode, root2: newNode):\n \n    # s1 is stack to hold nodes of first BST\n    s1 = []\n \n    # Current node of first BST\n    current1 = root1\n \n    # s2 is stack to hold nodes of first BST\n    s2 = []\n \n    # Current node of second BST\n    current2 = root2\n \n    # If first BST is empty then the output is the\n    # inorder traversal of the second BST\n    if not root1:\n        return inorder(root2)\n \n    # If the second BST is empty then the output is the\n    # inorder traversal of the first BST\n    if not root2:\n        return inorder(root1)\n \n    # Run the loop while there are nodes not yet printed.\n    # The nodes may be in stack(explored, but not printed)\n    # or may be not yet explored\n    while current1 or s1 or current2 or s2:\n \n        # Following steps follow iterative Inorder Traversal\n        if current1 or current2:\n \n            # Reach the leftmost node of both BSTs and push ancestors of\n            # leftmost nodes to stack s1 and s2 respectively\n            if current1:\n                s1.append(current1)\n                current1 = current1.left\n \n            if current2:\n                s2.append(current2)\n                current2 = current2.left\n \n        else:\n \n            # If we reach a NULL node and either of the stacks is empty,\n            # then one tree is exhausted, print the other tree\n \n            if not s1:\n                while s2:\n                    current2 = s2.pop()\n                    current2.left = None\n                    inorder(current2)\n                    return\n            if not s2:\n                while s1:\n                    current1 = s1.pop()\n                    current1.left = None\n                    inorder(current1)\n                    return\n \n            # Pop an element from both stacks and compare the\n            # popped elements\n            current1 = s1.pop()\n            current2 = s2.pop()\n \n            # If element of first tree is smaller, then print it\n            # and push the right subtree. If the element is larger,\n            # then we push it back to the corresponding stack.\n            if current1.data < current2.data:\n                print(current1.data, end=' ')\n                current1 = current1.right\n                s2.append(current2)\n                current2 = None\n \n            else:\n                print(current2.data, end=' ')\n                current2 = current2.right\n                s1.append(current1)\n                current1 = None\n \n# Driver code\n \n \ndef main():\n \n    # Let us create the following tree as first tree\n    #     3\n    #     / \\\n    # 1 5\n \n    root1 = newNode(3)\n    root1.left = newNode(1)\n    root1.right = newNode(5)\n \n    # Let us create the following tree as second tree\n    #     4\n    #     / \\\n    # 2 6\n    #\n \n    root2 = newNode(4)\n    root2.left = newNode(2)\n    root2.right = newNode(6)\n \n    merge(root1, root2)\n \n \nif __name__ == '__main__':\n    main()\n \n# This code is contributed by Koushik Reddy Bukkasamudram\n", "# Python program to Merge two BSTs with limited extra space\n \n# Structure of a BST Node\n \n \nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n \n \ndef mergeTwoBST(root1, root2):\n    res = []\n    s1, s2 = [], []\n \n    while root1 or root2 or s1 or s2:\n        while root1:\n            s1.append(root1)\n            root1 = root1.left\n \n        while root2:\n            s2.append(root2)\n            root2 = root2.left\n \n        # Step 3 Case 1:-\n        if not s2 or (s1 and s1[-1].val <= s2[-1].val):\n            root1 = s1[-1]\n            del s1[-1]\n            res.append(root1.val)\n            root1 = root1.right\n \n        #  Step 3 case 2 :-\n        else:\n            root2 = s2[-1]\n            del s2[-1]\n            res.append(root2.val)\n            root2 = root2.right\n \n    return res\n \n \n# Driver program to test above functions\nif __name__ == '__main__':\n    root1 = None\n    root2 = None\n \n    ''' \n    Let us create the following tree as first tree\n             3\n            / \\\n           1   5\n    '''\n \n    root1 = Node(3)\n    root1.left = Node(1)\n    root1.right = Node(5)\n \n    ''' \n    Let us create the following tree as second tree\n             4\n            / \\\n           2   6\n    '''\n \n    root2 = Node(4)\n    root2.left = Node(2)\n    root2.right = Node(6)\n \n    ans = mergeTwoBST(root1, root2)\n    for x in ans:\n        print(x, end=' ')\n \n# This code is contributed by Tapesh(tapeshdua420)\n", "class Node:\n    def __init__(self, data):\n      # Utility function to create a new Binary Tree Node\n        self.data = data\n        self.left = None\n        self.right = None\n \n \nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n \n    def insert(self, data):\n        self.root = self.insertRec(self.root, data)\n \n    def insertRec(self, root, data):\n        if root is None:\n            root = Node(data)\n            return root\n \n        if data < root.data:\n            root.left = self.insertRec(root.left, data)\n        elif data > root.data:\n            root.right = self.insertRec(root.right, data)\n \n        return root\n \n    # convert sorted Double linked list\n    def convertIntoSortedDLL(self, root, head):\n      # base case\n        if root is None:\n            return\n \n        self.convertIntoSortedDLL(root.right, head)\n        root.right = head[0]\n \n        if head[0] is not None:\n            head[0].left = root\n \n        head[0] = root\n \n        self.convertIntoSortedDLL(root.left, head)\n \n    # Merge sorted Double linked list\n    def mergeLinkedList(self, head1, head2):\n        dummy = Node(0)\n \n        # tail points to the last result node\n        tail = dummy\n \n        # so tail->next is the place to\n      # add new nodes to the result.\n        while True:\n            if head1 is None:\n              # if either list runs out, use the\n              # other list\n                tail.right = head2\n                break\n \n            if head2 is None:\n                tail.right = head1\n                break\n \n            if head1.data <= head2.data:\n                tail.right = head1\n                head1.left = tail\n                head1 = head1.right\n            else:\n                tail.right = head2\n                head2.left = tail\n                head2 = head2.right\n \n            tail = tail.right\n \n        res = dummy.right\n        res.left = None\n        return res\n \n    # Function to print nodes in a given linked list\n    def printList(self, node):\n        while node is not None:\n            print(node.data, end=' ')\n            node = node.right\n \n \nif __name__ == '__main__':\n    tree1 = BinaryTree()\n    tree2 = BinaryTree()\n \n    # Let us create the following tree as first tree\n    #       3\n    #       / \\\n    #     1   5\n \n    tree1.insert(3)\n    tree1.insert(1)\n    tree1.insert(5)\n \n    # Let us create the following tree as second tree\n    #         4\n    #         / \\\n    #       2   6\n \n    tree2.insert(4)\n    tree2.insert(2)\n    tree2.insert(6)\n \n    # Convert BST into sorted DLL\n    head1 = [None]\n    head2 = [None]\n \n    tree1.convertIntoSortedDLL(tree1.root, head1)\n    tree2.convertIntoSortedDLL(tree2.root, head2)\n \n    # merge sorted DLL\n    ans = tree1.mergeLinkedList(head1[0], head2[0])\n \n    tree1.printList(ans)\n"], "Find k-th smallest element in BST (Order Statistics in BST) -  ": ["# A simple inorder traversal based Python3\n# program to find k-th smallest element\n# in a BST.\n \n# A BST node\n \n \nclass Node:\n \n    def __init__(self, key):\n \n        self.data = key\n        self.left = None\n        self.right = None\n \n# Recursive function to insert an key into BST\n \n \ndef insert(root, x):\n \n    if (root == None):\n        return Node(x)\n    if (x < root.data):\n        root.left = insert(root.left, x)\n    elif (x > root.data):\n        root.right = insert(root.right, x)\n    return root\n \n# Function to find k'th largest element\n# in BST. Here count denotes the number\n# of nodes processed so far\n \n \ndef kthSmallest(root):\n \n    global k\n \n    # Base case\n    if (root == None):\n        return None\n \n    # Search in left subtree\n    left = kthSmallest(root.left)\n \n    # If k'th smallest is found in\n    # left subtree, return it\n    if (left != None):\n        return left\n \n    # If current element is k'th\n    # smallest, return it\n    k -= 1\n    if (k == 0):\n        return root\n \n    # Else search in right subtree\n    return kthSmallest(root.right)\n \n# Function to find k'th largest element in BST\n \n \ndef printKthSmallest(root):\n \n    res = kthSmallest(root)\n \n    if (res == None):\n        print('There are less than k nodes in the BST')\n    else:\n        print('K-th Smallest Element is ', res.data)\n \n \n# Driver code\nif __name__ == '__main__':\n \n    root = None\n    keys = [20, 8, 22, 4, 12, 10, 14]\n \n    for x in keys:\n        root = insert(root, x)\n \n    k = 3\n \n    printKthSmallest(root)\n \n# This code is contributed by mohit kumar 29\n", "# A BST node\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n        self.lCount = 0\n \n# Recursive function to insert a key into BST\ndef insert(root, x):\n    if root is None:\n        return Node(x)\n \n    # If a node is inserted in the left subtree, then lCount of\n    # this node is increased. For simplicity, we are\n    # assuming that all keys (tried to be inserted) are\n    # distinct.\n    if x < root.data:\n        root.left = insert(root.left, x)\n        root.lCount += 1\n    elif x > root.data:\n        root.right = insert(root.right, x)\n    return root\n \n# Preorder traversal function\ndef preorder(root, v):\n    if root is None:\n        return\n    v.append(root.data)\n    preorder(root.left, v)\n    preorder(root.right, v)\n \n# Main function\nif __name__ == '__main__':\n    root = None\n    keys = [20, 8, 22, 4, 12, 10, 14]\n    for x in keys:\n        root = insert(root, x)\n    k = 4\n    v = []\n    preorder(root, v)\n \n    # Sorting the given list\n    v.sort()\n \n    # Return the kth smallest element\n    print(v[k-1])\n", "# A simple inorder traversal based Python3\n# program to find k-th smallest element in a BST.\n \n# A BST node\nclass newNode:\n     \n    def __init__(self, x):\n         \n        self.data = x\n        self.left = None\n        self.right = None\n        self.lCount = 0\n \n# Recursive function to insert\n# an key into BST\ndef insert(root, x):\n     \n    if (root == None):\n        return newNode(x)\n \n    # If a node is inserted in left subtree,\n    # then lCount of this node is increased. \n    # For simplicity, we are assuming that \n    # all keys (tried to be inserted) are\n    # distinct. \n    if (x < root.data):\n        root.left = insert(root.left, x)\n        root.lCount += 1\n \n    elif (x > root.data):\n        root.right = insert(root.right, x);\n         \n    return root\n \n# Function to find k'th largest element\n# in BST. Here count denotes the number \n# of nodes processed so far\ndef kthSmallest(root, k):\n     \n    # Base case\n    if (root == None):\n        return None\n         \n    count = root.lCount + 1\n     \n    if (count == k):\n        return root\n \n    if (count > k):\n        return kthSmallest(root.left, k)\n \n    # Else search in right subtree\n    return kthSmallest(root.right, k - count)\n \n# Driver code\nif __name__ == '__main__':\n     \n    root = None\n    keys = [ 20, 8, 22, 4, 12, 10, 14 ]\n \n    for x in keys:\n        root = insert(root, x)\n \n    k = 4\n    res = kthSmallest(root, k)\n     \n    if (res == None):\n        print('There are less than k nodes in the BST')\n    else:\n        print('K-th Smallest Element is', res.data)\n         \n# This code is contributed by bgangwar59\n", "# Python code to implement the iterative approach\n \n# Definition of a BST node\n \n \nclass Node:\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n \n# Function to insert a new node in BST\n \n \ndef insert(root, key):\n    # If the tree is empty, return a new node\n    if root is None:\n        return Node(key)\n \n    # Otherwise, recur down the tree\n    if key < root.data:\n        root.left = insert(root.left, key)\n    elif key > root.data:\n        root.right = insert(root.right, key)\n \n    # Return the (unchanged) node pointer\n    return root\n \n# Function to find the k-th smallest\n# element in BST\n \n \ndef kthSmallest(root, k):\n    # Create an empty stack\n    stack = []\n \n    # Loop until stack is empty or\n    # k becomes zero\n    while root is not None or len(stack) > 0:\n \n        # Push all the left subtree\n        # nodes onto the stack\n        while root is not None:\n            stack.append(root)\n            root = root.left\n \n        # Pop the top node from the\n        # stack and check if it is\n        # the k-th element\n        root = stack.pop()\n        k -= 1\n \n        if k == 0:\n            return root.data\n \n        # Set root to the right child\n        # and continue with the traversal\n        root = root.right\n \n    # If k is greater than the number\n    # of nodes in BST, return -1\n    return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n    root = None\n    keys = [20, 8, 22, 4, 12, 10, 14]\n \n    # Insert all the keys into BST\n    for x in keys:\n        root = insert(root, x)\n \n    k = 4\n \n    # Find the k-th smallest element in BST\n    kth_smallest = kthSmallest(root, k)\n    if kth_smallest != -1:\n        print('K-th smallest element in BST is:', kth_smallest)\n    else:\n        print('Invalid input')\n"], "Sorted Linked List to Balanced BST -  ": ["# Python3 implementation of above approach\n \n# Link list node \nclass LNode :\n    def __init__(self):\n        self.data = None\n        self.next = None\n \n# A Binary Tree node \nclass TNode :\n    def __init__(self):\n        self.data = None\n        self.left = None\n        self.right = None\n \nhead = None\n \n# This function counts the number of \n# nodes in Linked List and then calls \n# sortedListToBSTRecur() to construct BST \ndef sortedListToBST(): \n    global head\n     \n    # Count the number of nodes in Linked List \n    n = countLNodes(head) \n \n    # Construct BST \n    return sortedListToBSTRecur(n) \n \n# The main function that constructs \n# balanced BST and returns root of it. \n# head -. Pointer to pointer to \n# head node of linked list n -. No.\n# of nodes in Linked List \ndef sortedListToBSTRecur( n) :\n    global head\n     \n    # Base Case \n    if (n <= 0) :\n        return None\n \n    # Recursively construct the left subtree \n    left = sortedListToBSTRecur( int(n/2)) \n \n    # Allocate memory for root, and \n    # link the above constructed left \n    # subtree with root \n    root = newNode((head).data) \n    root.left = left \n \n    # Change head pointer of Linked List\n    # for parent recursive calls \n    head = (head).next\n \n    # Recursively construct the right \n    # subtree and link it with root \n    # The number of nodes in right subtree\n    # is total nodes - nodes in \n    # left subtree - 1 (for root) which is n-n/2-1\n    root.right = sortedListToBSTRecur( n - int(n/2) - 1) \n \n    return root \n \n# UTILITY FUNCTIONS \n \n# A utility function that returns \n# count of nodes in a given Linked List \ndef countLNodes(head) :\n \n    count = 0\n    temp = head \n    while(temp != None): \n     \n        temp = temp.next\n        count = count + 1\n     \n    return count \n \n# Function to insert a node \n#at the beginning of the linked list \ndef push(head, new_data) :\n \n    # allocate node \n    new_node = LNode()\n     \n    # put in the data \n    new_node.data = new_data \n \n    # link the old list of the new node \n    new_node.next = (head) \n \n    # move the head to point to the new node \n    (head) = new_node \n    return head\n \n \n# Function to print nodes in a given linked list \ndef printList(node): \n \n    while(node != None): \n     \n        print( node.data ,end= ' ') \n        node = node.next\n     \n# Helper function that allocates a new node with the \n# given data and None left and right pointers. \ndef newNode(data) :\n \n    node = TNode()\n    node.data = data \n    node.left = None\n    node.right = None\n \n    return node \n \n# A utility function to \n# print preorder traversal of BST \ndef preOrder( node) :\n \n    if (node == None) :\n        return\n    print(node.data, end = ' ' )\n    preOrder(node.left) \n    preOrder(node.right) \n \n# Driver code\n \n# Start with the empty list \nhead = None\n \n# Let us create a sorted linked list to test the functions \n# Created linked list will be 1.2.3.4.5.6.7 \nhead = push(head, 7) \nhead = push(head, 6) \nhead = push(head, 5) \nhead = push(head, 4) \nhead = push(head, 3) \nhead = push(head, 2) \nhead = push(head, 1) \n \nprint('Given Linked List ' )\nprintList(head) \n \n# Convert List to BST \nroot = sortedListToBST() \nprint('\\nPreOrder Traversal of constructed BST ') \npreOrder(root) \n \n# This code is contributed by Arnab Kundu\n"], "Convert a Binary Tree into its Mirror Tree (Invert Binary Tree) -  ": ["# Python3 program to convert a binary\n# tree to its mirror\n \n# Utility function to create a new\n# tree node\n \n \nclass newNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None\n \n \n''' Change a tree so that the roles of the \n    left and right pointers are swapped at\n    every node. \n \nSo the tree... \n        4 \n        / \\ \n    2 5 \n    / \\ \n    1 3 \n \nis changed to... \n    4 \n    / \\ \n    5 2 \n    / \\ \n    3 1 \n'''\n \n \ndef mirror(node):\n \n    if (node == None):\n        return\n    else:\n \n        temp = node\n \n        ''' do the subtrees '''\n        mirror(node.left)\n        mirror(node.right)\n \n        ''' swap the pointers in this node '''\n        temp = node.left\n        node.left = node.right\n        node.right = temp\n \n \n''' Helper function to print Inorder traversal.'''\n \n \ndef inOrder(node):\n \n    if (node == None):\n        return\n \n    inOrder(node.left)\n    print(node.data, end=' ')\n    inOrder(node.right)\n \n \n# Driver code\nif __name__ == '__main__':\n \n    root = newNode(1)\n    root.left = newNode(2)\n    root.right = newNode(3)\n    root.left.left = newNode(4)\n    root.left.right = newNode(5)\n \n    ''' Print inorder traversal of\n        the input tree '''\n    print('Inorder traversal of the',\n          'constructed tree is')\n    inOrder(root)\n \n    ''' Convert tree to its mirror '''\n    mirror(root)\n \n    ''' Print inorder traversal of \n        the mirror tree '''\n    print('\\nInorder traversal of',\n          'the mirror tree is ')\n    inOrder(root)\n \n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n", "# Python3 program to convert a Binary\n# Tree to its mirror\n \n# A binary tree node has data, pointer to\n# left child and a pointer to right child\n# Helper function that allocates a new node\n# with the given data and None left and\n# right pointers\n \n \nclass newNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n \n''' Change a tree so that the roles of the left \n    and right pointers are swapped at every node. \n    So the tree... \n        4 \n        / \\ \n        2 5 \n        / \\ \n    1 3 \n     \n    is changed to... \n        4 \n        / \\ \n        5 2 \n            / \\ \n        3 1 \n    '''\n \n \ndef mirror(root):\n \n    if (root == None):\n        return\n \n    q = []\n    q.append(root)\n \n    # Do BFS. While doing BFS, keep swapping\n    # left and right children\n    while (len(q)):\n \n        # pop top node from queue\n        curr = q[0]\n        q.pop(0)\n \n        # swap left child with right child\n        curr.left, curr.right = curr.right, curr.left\n \n        # append left and right children\n        if (curr.left):\n            q.append(curr.left)\n        if (curr.right):\n            q.append(curr.right)\n \n \n''' Helper function to print Inorder traversal.'''\n \n \ndef inOrder(node):\n    if (node == None):\n        return\n    inOrder(node.left)\n    print(node.data, end=' ')\n    inOrder(node.right)\n \n \n# Driver code\nroot = newNode(1)\nroot.left = newNode(2)\nroot.right = newNode(3)\nroot.left.left = newNode(4)\nroot.left.right = newNode(5)\n \n''' Print inorder traversal of the input tree '''\nprint('Inorder traversal of the constructed tree is')\ninOrder(root)\n \n''' Convert tree to its mirror '''\nmirror(root)\n \n''' Print inorder traversal of the mirror tree '''\nprint('\\nInorder traversal of the mirror tree is')\ninOrder(root)\n \n# This code is contributed by SHUBHAMSINGH10\n"], "Bottom View of a Binary Tree -  ": ["# Python3 program to print Bottom\n# View of Binary Tree\n \n# deque supports efficient pish and pop on both ends\nfrom collections import deque\n  \n# Tree node class\nclass Node:\n     \n    def __init__(self, key):\n         \n        self.data = key\n        self.hd = float('inf')\n        self.left = None\n        self.right = None\n  \n# Method that prints the bottom view.\ndef bottomView(root):\n \n    if (root == None):\n        return\n     \n    # Initialize a variable 'hd' with 0\n    # for the root element.\n    hd = 0\n     \n    # Store minimum and maximum horizontal distance\n    # so that we do not have to sort keys at the end\n    min_hd, max_hd = 0, 0\n     \n    hd_dict = dict()\n  \n    # Queue to store tree nodes in level\n    # order traversal\n    q = deque()\n  \n    # Assign initialized horizontal distance\n    # value to root node and add it to the queue.\n    root.hd = hd\n    q.append(root)  \n  \n    # Loop until the queue is empty (standard\n    # level order loop)\n    while q:\n        curr_node = q.popleft()\n          \n        # Extract the horizontal distance value\n        # from the dequeued tree node.\n        hd = curr_node.hd\n         \n        # Update the minimum and maximum hd\n        min_hd = min(min_hd, hd)\n        max_hd = max(max_hd, hd)\n  \n        # Put the dequeued tree node to dictionary\n        # having key as horizontal distance. Every\n        # time we find a node having same horizontal\n        # distance we need to update the value in\n        # the map.\n        hd_dict[hd] = curr_node.data\n  \n        # If the dequeued node has a left child, add\n        # it to the queue with a horizontal distance hd-1.\n        if curr_node.left:\n            curr_node.left.hd = hd - 1\n            q.append(curr_node.left)\n  \n        # If the dequeued node has a right child, add\n        # it to the queue with a horizontal distance\n        # hd+1.\n        if curr_node.right:\n            curr_node.right.hd = hd + 1\n            q.append(curr_node.right)\n  \n    # Traverse the map from least horizontal distance to\n    # most horizontal distance.\n    for i in range(min_hd, max_hd+1):\n        print(hd_dict[i], end = ' ')\n         \n# Driver Code\nif __name__=='__main__':\n     \n    root = Node(20)\n    root.left = Node(8)\n    root.right = Node(22)\n    root.left.left = Node(5)\n    root.left.right = Node(3)\n    root.right.left = Node(4)\n    root.right.right = Node(25)\n    root.left.right.left = Node(10)\n    root.left.right.right = Node(14)\n     \n    print('Bottom view of the given binary tree :')\n     \n    bottomView(root)\n     \n# This code is contributed by rutvik_56\n", "# Python3 program to print Bottom\n# View of Binary Tree \nclass Node:\n     \n    def __init__(self, key = None, \n                      left = None, \n                     right = None):\n                          \n        self.data = key\n        self.left = left\n        self.right = right\n         \ndef printBottomView(root):\n     \n      # Create a dictionary where\n    # key -> relative horizontal distance\n    # of the node from root node and\n    # value -> pair containing node's \n    # value and its level\n    d = dict()\n     \n    printBottomViewUtil(root, d, 0, 0)\n     \n    # Traverse the dictionary in sorted \n    # order of their keys and print\n    # the bottom view\n    for i in sorted(d.keys()):\n        print(d[i][0], end = ' ')\n \ndef printBottomViewUtil(root, d, hd, level):\n     \n      # Base case\n    if root is None:\n        return\n     \n    # If current level is more than or equal \n    # to maximum level seen so far for the \n    # same horizontal distance or horizontal\n    # distance is seen for the first time, \n    # update the dictionary\n    if hd in d:\n        if level >= d[hd][1]:\n            d[hd] = [root.data, level]\n    else:\n        d[hd] = [root.data, level]\n         \n    # recur for left subtree by decreasing\n    # horizontal distance and increasing\n    # level by 1\n    printBottomViewUtil(root.left, d, hd - 1, \n                                   level + 1)\n     \n    # recur for right subtree by increasing\n    # horizontal distance and increasing \n    # level by 1\n    printBottomViewUtil(root.right, d, hd + 1, \n                                    level + 1)\n \n# Driver Code    \nif __name__ == '__main__':\n     \n    root = Node(20)\n    root.left = Node(8)\n    root.right = Node(22) \n    root.left.left = Node(5) \n    root.left.right = Node(3) \n    root.right.left = Node(4) \n    root.right.right = Node(25) \n    root.left.right.left = Node(10) \n    root.left.right.right = Node(14) \n     \n    print('Bottom view of the given binary tree :')\n     \n    printBottomView(root)\n \n# This code is contributed by tusharroy\n", "from collections import deque, defaultdict\n \n# Tree node class\nclass Node:\n   \n    # data of the node\n    def __init__(self, key):\n        self.data = key\n         \n        # horizontal distance of the node\n        self.hd = float('inf')\n         \n        #left and right references\n        self.left = None\n        self.right = None\n \ndef printBottomView(root):\n    if root is None: return #if root is NULL\n    hash = defaultdict(lambda : 0) # <vertical_index , root->data>\n    leftmost = 0 # to store the leftmost index so that we move from left to right\n    q = deque() # pair<Node*,vertical Index>  for level order traversal.\n    q.append((root, 0)) # push the root and 0 vertial index\n    while q:\n        top = q.popleft() #  store q.front() in top variable\n        temp, ind = top # store the Node in temp for left and right nodes and store the vertical index of current node\n        hash[ind] = temp.data # store the latest vertical_index(key) -> root->data(value)\n        leftmost = min(ind, leftmost) # have the leftmost vertical index\n        if temp.left: q.append((temp.left, ind-1)) # check if any node of left then go in negative direction\n        if temp.right: q.append((temp.right, ind+1)) #check if any node of left then go in positive direction\n    #Traverse each value in hash from leftmost to positive side till key is available\n    for i in range(leftmost, len(hash)):\n          if hash[i]:\n            print(hash[i], end=' ')\n \nroot = Node(20)\nroot.left = Node(8)\nroot.right = Node(22)\nroot.left.left = Node(5)\nroot.left.right = Node(3)\nroot.right.left = Node(4)\nroot.right.right = Node(25)\nroot.left.right.left = Node(10)\nroot.left.right.right = Node(14)\nprint('Bottom view of the given binary tree :')\nprintBottomView(root)\n \n# This code is contributed by phasing17.\n"], "Lowest Common Ancestor in a Binary Tree -  ": ["# Python Program for Lowest Common Ancestor in a Binary Tree\n# O(n) solution to find LCS of two given values n1 and n2\n \n# A binary tree node\nclass Node:\n    # Constructor to create a new binary node\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Finds the path from root node to given root of the tree.\n# Stores the path in a list path[], returns true if path\n# exists otherwise false\ndef findPath(root, path, k):\n \n    # Baes Case\n    if root is None:\n        return False\n \n    # Store this node is path vector. The node will be\n    # removed if not in path from root to k\n    path.append(root.key)\n \n    # See if the k is same as root's key\n    if root.key == k:\n        return True\n \n    # Check if k is found in left or right sub-tree\n    if ((root.left != None and findPath(root.left, path, k)) or\n            (root.right != None and findPath(root.right, path, k))):\n        return True\n \n    # If not present in subtree rooted with root, remove\n    # root from path and return False\n \n    path.pop()\n    return False\n \n# Returns LCA if node n1 , n2 are present in the given\n# binary tree otherwise return -1\ndef findLCA(root, n1, n2):\n \n    # To store paths to n1 and n2 fromthe root\n    path1 = []\n    path2 = []\n \n    # Find paths from root to n1 and root to n2.\n    # If either n1 or n2 is not present , return -1\n    if (not findPath(root, path1, n1) or not findPath(root, path2, n2)):\n        return -1\n \n    # Compare the paths to get the first different value\n    i = 0\n    while(i < len(path1) and i < len(path2)):\n        if path1[i] != path2[i]:\n            break\n        i += 1\n    return path1[i-1]\n \n \n# Driver program to test above function\nif __name__ == '__main__':\n     \n    # Let's create the Binary Tree shown in above diagram\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n     \n    print('LCA(4, 5) = %d' % (findLCA(root, 4, 5,)))\n    print('LCA(4, 6) = %d' % (findLCA(root, 4, 6)))\n    print('LCA(3, 4) = %d' % (findLCA(root, 3, 4)))\n    print('LCA(2, 4) = %d' % (findLCA(root, 2, 4)))\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "# Python program to find LCA of n1 and n2 using one\n# traversal of Binary tree\n \n# A binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new tree node\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# This function returns pointer to LCA of two given\n# values n1 and n2\n# This function assumes that n1 and n2 are present in\n# Binary Tree\n \n \ndef findLCA(root, n1, n2):\n \n    # Base Case\n    if root is None:\n        return None\n \n    # If either n1 or n2 matches with root's key, report\n    #  the presence by returning root (Note that if a key is\n    #  ancestor of other, then the ancestor key becomes LCA\n    if root.key == n1 or root.key == n2:\n        return root\n \n    # Look for keys in left and right subtrees\n    left_lca = findLCA(root.left, n1, n2)\n    right_lca = findLCA(root.right, n1, n2)\n \n    # If both of the above calls return Non-NULL, then one key\n    # is present in once subtree and other is present in other,\n    # So this node is the LCA\n    if left_lca and right_lca:\n        return root\n \n    # Otherwise check if left subtree or right subtree is LCA\n    return left_lca if left_lca is not None else right_lca\n \n \n# Driver code\nif __name__ == '__main__':\n     \n    # Let us create a binary tree given in the above example\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    print('LCA(4, 5) = ', findLCA(root, 4, 5).key)\n    print('LCA(4, 6) = ', findLCA(root, 4, 6).key)\n    print('LCA(3, 4) = ', findLCA(root, 3, 4).key)\n    print('LCA(2, 4) = ', findLCA(root, 2, 4).key)\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "''' Program to find LCA of n1 and n2 using one traversal of\n Binary tree\nIt handles all cases even when n1 or n2 is not there in tree\n'''\n \n# A binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# This function return pointer to LCA of two given values\n# n1 and n2\n# v1 is set as true by this function if n1 is found\n# v2 is set as true by this function if n2 is found\n \n \ndef findLCAUtil(root, n1, n2, v):\n \n    # Base Case\n    if root is None:\n        return None\n \n    # IF either n1 or n2 matches ith root's key, report\n    # the presence by setting v1 or v2 as true and return\n    # root (Note that if a key is ancestor of other, then\n    # the ancestor key becomes LCA)\n    if root.key == n1:\n        v[0] = True\n        return root\n \n    if root.key == n2:\n        v[1] = True\n        return root\n \n    # Look for keys in left and right subtree\n    left_lca = findLCAUtil(root.left, n1, n2, v)\n    right_lca = findLCAUtil(root.right, n1, n2, v)\n \n    # If both of the above calls return Non-NULL, then one key\n    # is present in once subtree and other is present in other,\n    # So this node is the LCA\n    if left_lca and right_lca:\n        return root\n \n    # Otherwise check if left subtree or right subtree is LCA\n    return left_lca if left_lca is not None else right_lca\n \n \ndef find(root, k):\n \n    # Base Case\n    if root is None:\n        return False\n \n    # If key is present at root, or if left subtree or right\n    # subtree , return true\n    if (root.key == k or find(root.left, k) or\n            find(root.right, k)):\n        return True\n \n    # Else return false\n    return False\n \n# This function returns LCA of n1 and n2 on value if both\n# n1 and n2 are present in tree, otherwise returns None\n \n \ndef findLCA(root, n1, n2):\n \n    # Initialize n1 and n2 as not visited\n    v = [False, False]\n \n    # Find lca of n1 and n2 using the technique discussed above\n    lca = findLCAUtil(root, n1, n2, v)\n \n    # Returns LCA only if both n1 and n2 are present in tree\n    if (v[0] and v[1] or v[0] and find(lca, n2) or v[1] and\n            find(lca, n1)):\n        return lca\n \n    # Else return None\n    return None\n \n \n# Driver program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n \nlca = findLCA(root, 4, 5)\n \nif lca is not None:\n    print('LCA(4, 5) = ', lca.key)\nelse:\n    print('Keys are not present')\n \nlca = findLCA(root, 4, 10)\nif lca is not None:\n    print('LCA(4,10) = ', lca.key)\nelse:\n    print('Keys are not present')\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "from collections import deque\n \n# Definition of a binary tree node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Function to build a hash table or a map of parent\n# pointers for each node in the tree\ndef buildParentMap(root):\n    parentMap = {}\n    parentMap[root] = None\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        if node.left:\n            parentMap[node.left] = node\n            queue.append(node.left)\n        if node.right:\n            parentMap[node.right] = node\n            queue.append(node.right)\n    return parentMap\n \n# Function to find the lowest common ancestor of two nodes\n# using an auxiliary data structure\ndef findLCA(root, n1, n2):\n    # Build a hash table or a map of parent pointers for\n    # each node in the tree\n    parentMap = buildParentMap(root)\n \n    # Find the nodes with values n1 and n2\n    p, q = None, None\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        if node.data == n1:\n            p = node\n        if node.data == n2:\n            q = node\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n \n    # Add all the ancestors of the first node to a set or a\n    # list\n    ancestors = set()\n    while p:\n        ancestors.add(p)\n        p = parentMap[p]\n \n    # Traverse up from the second node and check if each\n    # ancestor is already in the set or the list\n    while q:\n        if q in ancestors:\n            return q.data\n        q = parentMap[q]\n \n    return -1 # No common ancestor found\n \n# Driver code\nif __name__ == '__main__':\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n \n    print('LCA(4, 5) = ', findLCA(root, 4, 5))\n    print('LCA(4, 6) = ', findLCA(root, 4, 6))\n    print('LCA(3, 4) = ', findLCA(root, 3, 4))\n    print('LCA(2, 4) = ', findLCA(root, 2, 4))\n"], "Boundary Traversal of binary tree -  ": ["# Python3 program for binary traversal of binary tree\n \n# A binary tree node\nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data \n        self.left = None\n        self.right = None\n \n# A simple function to print leaf nodes of a Binary Tree\ndef printLeaves(root):\n    if(root):\n        printLeaves(root.left)\n         \n        # Print it if it is a leaf node\n        if root.left is None and root.right is None:\n            print(root.data),\n \n        printLeaves(root.right)\n \n# A function to print all left boundary nodes, except a \n# leaf node. Print the nodes in TOP DOWN manner\ndef printBoundaryLeft(root):\n     \n    if(root):\n        if (root.left):\n             \n            # to ensure top down order, print the node\n            # before calling itself for left subtree\n            print(root.data)\n            printBoundaryLeft(root.left)\n         \n        elif(root.right):\n            print (root.data)\n            printBoundaryLeft(root.right)\n         \n        # do nothing if it is a leaf node, this way we\n        # avoid duplicates in output\n \n \n# A function to print all right boundary nodes, except\n# a leaf node. Print the nodes in BOTTOM UP manner\ndef printBoundaryRight(root):\n     \n    if(root):\n        if (root.right):\n            # to ensure bottom up order, first call for\n            # right subtree, then print this node\n            printBoundaryRight(root.right)\n            print(root.data)\n         \n        elif(root.left):\n            printBoundaryRight(root.left)\n            print(root.data)\n \n        # do nothing if it is a leaf node, this way we \n        # avoid duplicates in output\n \n \n# A function to do boundary traversal of a given binary tree\ndef printBoundary(root):\n    if (root):\n        print(root.data)\n         \n        # Print the left boundary in top-down manner\n        printBoundaryLeft(root.left)\n \n        # Print all leaf nodes\n        printLeaves(root.left)\n        printLeaves(root.right)\n \n        # Print the right boundary in bottom-up manner\n        printBoundaryRight(root.right)\n \n \n# Driver program to test above function\nroot = Node(20)\nroot.left = Node(8)\nroot.left.left = Node(4)\nroot.left.right = Node(12)\nroot.left.right.left = Node(10)\nroot.left.right.right = Node(14)\nroot.right = Node(22)\nroot.right.right = Node(25)\nprintBoundary(root)\n \n# This code is contributed by \n# Nikhil Kumar Singh(nickzuck_007)\n", "# Python program to print boundary traversal of binary tree\n \n# A binary tree node has data, pointer to left child\n# and a pointer to right child\nclass Node:\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n \n \ndef isLeaf(node):\n    if node.left == None and node.right == None:\n        return True\n    return False\n \n \ndef addLeftBound(root, res):\n    # Go left left and no left then right but again check from left\n    root = root.left\n    while(root is not None):\n        if isLeaf(root) is not True:\n            res.append(root.data)\n        if(root.left is not None):\n            root = root.left\n        else:\n            root = root.right\n \n \ndef addRightBound(root, res):\n    # Go right right and no right then left but again check from right\n    root = root.right\n    # As we need the reverse of this for Anticlockwise\n    # refer above picture for better understanding\n    stk = []\n    while(root is not None):\n        if isLeaf(root) is not True:\n            stk.append(root.data)\n        if root.right is not None:\n            root = root.right\n        else:\n            root = root.left\n \n    while(len(stk) != 0):\n        res.append(stk.pop(-1))\n \n         \n# its kind of preorder\ndef addLeaves(root, res):\n    if root is None:\n        return\n    if isLeaf(root) is True:\n        res.append(root.data)  # just store leaf nodes\n        return\n    addLeaves(root.left, res)\n    addLeaves(root.right, res)\n \n \ndef boundary(root, res):\n    # Your code here\n    if root is None:\n        return\n    if isLeaf(root) is not True:\n        res.append(root.data)  # if leaf then its done by addLeaf\n    addLeftBound(root, res)\n    addLeaves(root, res)\n    addRightBound(root, res)\n \n \nif __name__ == '__main__':\n    root = Node(20)\n    root.left = Node(8)\n    root.left.left = Node(4)\n    root.left.right = Node(12)\n    root.left.right.left = Node(10)\n    root.left.right.right = Node(14)\n    root.right = Node(22)\n    root.right.right = Node(25)\n \n    res = []\n    boundary(root, res)\n    for i in res:\n        print(i)\n \n# This code is contributed by Yash Agarwal(yashagarwal2852002)\n", "# Definition of a binary tree node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Function to print the left boundary nodes of a binary tree\n \n \ndef printLeftBoundary(root):\n    while root:\n        if root.left or root.right:\n            print(root.data, end=' ')\n        if root.left:\n            root = root.left\n        else:\n            root = root.right\n \n# Function to print the right boundary nodes of a binary tree\n \n \ndef printRightBoundary(root):\n    if not root:\n        return\n    curr = root.right\n    while curr:\n        if curr.left or curr.right:\n            print(curr.data, end=' ')\n        if curr.right:\n            curr = curr.right\n        else:\n            curr = curr.left\n \n# Function to print the leaves of a binary tree\n \n \ndef printLeaves(root):\n    if not root:\n        return\n    printLeaves(root.left)\n    if not root.left and not root.right:\n        print(root.data, end=' ')\n    printLeaves(root.right)\n \n# Function to print the boundary nodes of a binary tree in anticlockwise order\n \n \ndef printBoundary(root):\n    if not root:\n        return\n    print(root.data, end=' ')\n    printLeftBoundary(root.left)\n    printLeaves(root.left)\n    printLeaves(root.right)\n    printRightBoundary(root)\n \n \n# Driver code\nif __name__ == '__main__':\n    # Creating the binary tree\n    root = Node(20)\n    root.left = Node(8)\n    root.left.left = Node(4)\n    root.left.right = Node(12)\n    root.left.right.left = Node(10)\n    root.left.right.right = Node(14)\n    root.right = Node(22)\n    root.right.right = Node(25)\n \n    # Printing the boundary nodes of the binary tree\n    printBoundary(root)\n"], "Print Left View of a Binary Tree -  ": ["# Python program to print left view of Binary Tree\n \n# A binary tree node\nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n \n# Recursive function print left view of a binary tree\ndef leftViewUtil(root, level, max_level):\n \n    # Base Case\n    if root is None:\n        return\n \n    # If this is the first node of its level\n    if (max_level[0] < level):\n        print (root.data, end = ' ')\n        max_level[0] = level\n \n    # Recur for left and right subtree\n    leftViewUtil(root.left, level + 1, max_level)\n    leftViewUtil(root.right, level + 1, max_level)\n \n \n# A wrapper over leftViewUtil()\ndef leftView(root):\n    max_level = [0]\n    leftViewUtil(root, 1, max_level)\n \n \n# Driver program to test above function\nif __name__ == '__main__':\n    root = Node(10)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(7)\n    root.left.right = Node(8)\n    root.right.right = Node(15)\n    root.right.left = Node(12)\n    root.right.right.left = Node(14)\n     \n    leftView(root)\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "# Python3 program to print left view of\n# Binary Tree\n \n# Binary Tree Node\n''' utility that allocates a newNode \nwith the given key '''\n \n \nclass newNode:\n \n    # Construct to create a newNode\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n        self.hd = 0\n \n# function to print left view of\n# binary tree\n \n \ndef printLeftView(root):\n \n    if (not root):\n        return\n \n    q = []\n    q.append(root)\n \n    while (len(q)):\n \n        # number of nodes at current level\n        n = len(q)\n \n        # Traverse all nodes of current level\n        for i in range(1, n + 1):\n            temp = q[0]\n            q.pop(0)\n \n            # Print the left most element\n            # at the level\n            if (i == 1):\n                print(temp.data, end=' ')\n \n            # Add left node to queue\n            if (temp.left != None):\n                q.append(temp.left)\n \n            # Add right node to queue\n            if (temp.right != None):\n                q.append(temp.right)\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    root = newNode(10)\n    root.left = newNode(2)\n    root.right = newNode(3)\n    root.left.left = newNode(7)\n    root.left.right = newNode(8)\n    root.right.right = newNode(15)\n    root.right.left = newNode(12)\n    root.right.right.left = newNode(14)\n    printLeftView(root)\n \n# This code is contributed by\n# Manne SreeCharan\n", "# Python Program to print left view\n \n# Tree Node Class\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# function to get the left view of binary tree\ndef leftView(root):\n    ans = []\n \n    if not root:\n        return ans\n \n    q = []\n    q.append(root)\n    q.append(None)\n    ok = True\n \n    while len(q) != 0:\n        it = q[0]\n        del q[0]\n        if it == None:\n            if ok == False:\n                ok = True\n            if len(q) == 0:\n                break\n \n            else:\n                q.append(None)\n \n        else:\n            if ok:\n                ans.append(it.data)\n                ok = False\n \n            if it.left != None:\n                q.append(it.left)\n            if it.right != None:\n                q.append(it.right)\n \n    return ans\n \n \n# Driver Code\nif __name__ == '__main__':\n    root = Node(10)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(7)\n    root.left.right = Node(8)\n    root.right.right = Node(15)\n    root.right.left = Node(12)\n    root.right.right.left = Node(14)\n \n    vec = leftView(root)\n \n    # print the left view\n    for x in vec:\n        print(x, end=' ')\n    print()\n \n# This code is contributed by Tapesh(tapeshdua420)\n"], "ZigZag Tree Traversal -  ": ["# Python Program to print zigzag traversal\n# of binary tree\n \n# Binary tree node\nclass Node:\n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None\n \n \n# function to print zigzag traversal of \n# binary tree\ndef zigzagtraversal(root):\n \n    # Base Case\n    if root is None:\n        return\n \n    # Create two stacks to store current\n    # and next level\n    currentLevel = []\n    nextLevel = []\n \n    # if ltr is true push nodes from \n    # left to right otherwise from\n    # right to left\n    ltr = True\n \n    # append root to currentlevel stack\n    currentLevel.append(root)\n \n    # Check if stack is empty\n    while len(currentLevel) > 0:\n        # pop from stack\n        temp = currentLevel.pop(-1)\n        # print the data\n        print(temp.data, ' ', end='')\n \n        if ltr:\n            # if ltr is true push left \n            # before right\n            if temp.left:\n                nextLevel.append(temp.left)\n            if temp.right:\n                nextLevel.append(temp.right)\n        else:\n            # else push right before left\n            if temp.right:\n                nextLevel.append(temp.right)\n            if temp.left:\n                nextLevel.append(temp.left)\n \n        if len(currentLevel) == 0:\n            # reverse ltr to push node in\n            # opposite order\n            ltr = not ltr\n            # swapping of stacks\n            currentLevel, nextLevel = nextLevel, currentLevel\n \n \n# Driver program to check above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(7)\nroot.left.right = Node(6)\nroot.right.left = Node(5)\nroot.right.right = Node(4)\nprint('Zigzag Order traversal of binary tree is')\nzigzagtraversal(root)\n \n# This code is contributed by Shweta Singh\n", "# Python code for recursive approach\nfrom collections import defaultdict\nfrom collections import deque\n \n \nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n \n# Function to Build Tree\ndef buildTree(s):\n    # Corner Case\n    if(len(s) == 0 or s[0] == 'N'):\n        return None\n \n    # Creating list of strings from input\n    # string after spliting by space\n    ip = list(map(str, s.split()))\n \n    # Create the root of the tree\n    root = Node(int(ip[0]))\n    size = 0\n    q = deque()\n \n    # Push the root to the queue\n    q.append(root)\n    size = size+1\n \n    # Starting from the second element\n    i = 1\n    while(size > 0 and i < len(ip)):\n        # Get and remove the front of the queue\n        currNode = q[0]\n        q.popleft()\n        size = size-1\n \n        # Get the current node's value from the string\n        currVal = ip[i]\n \n        # If the left child is not null\n        if(currVal != 'N'):\n \n            # Create the left child for the current node\n            currNode.left = Node(int(currVal))\n \n            # Push it to the queue\n            q.append(currNode.left)\n            size = size+1\n        # For the right child\n        i = i+1\n        if(i >= len(ip)):\n            break\n        currVal = ip[i]\n \n        # If the right child is not null\n        if(currVal != 'N'):\n \n            # Create the right child for the current node\n            currNode.right = Node(int(currVal))\n \n            # Push it to the queue\n            q.append(currNode.right)\n            size = size+1\n        i = i+1\n    return root\n \n# Function to calculate height of tree\ndef treeHeight(root):\n    if not root:\n        return 0\n    lHeight = treeHeight(root.left)\n    rHeight = treeHeight(root.right)\n    return max(lHeight, rHeight) + 1\n   \n \n# Helper Function to store the zig zag order traversal\n# of tree in a list recursively\ndef zigZagTraversalRecursion(root, height, lor, ans):\n    # Height = 1 means the tree now has only one node\n    if height <= 1:\n        if root:\n            ans.append(root.data)\n    # When Height > 1\n    else:\n        if lor:\n            if root.left:\n                zigZagTraversalRecursion(root.left, height - 1, lor, ans)\n            if root.right:\n                zigZagTraversalRecursion(root.right, height - 1, lor, ans)\n        else:\n            if root.right:\n                zigZagTraversalRecursion(root.right, height - 1, lor, ans)\n            if root.left:\n                zigZagTraversalRecursion(root.left, height - 1, lor, ans)\n \n# Function to traverse tree in zig zag order\ndef zigZagTraversal(root):\n    ans = []\n    leftOrRight = True\n    height = treeHeight(root)\n    for i in range(1, height + 1):\n        zigZagTraversalRecursion(root, i, leftOrRight, ans)\n        leftOrRight = not leftOrRight\n    return ans\n \n \nif __name__ == '__main__':\n      # Tree:\n    #          1\n    #        /   \\\n    #       /     \\\n    #      /       \\\n    #     2          3\n    #   /   \\       /  \\\n    #  4     5     6     7\n    # / \\   /  \\  / \\   /  \\\n    # 8  9  10 11 12 13 14  15\n \n    s = '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15'\n    root = buildTree(s)\n    res = zigZagTraversal(root)\n \n    print('ZigZag traversal of binary tree is:')\n    for i in range(len(res)):\n        print(res[i], end=' ')\n    print()\n \n# This code is contributed by Tapesh (tapeshdua420)\n", "# Python3 implementation of a O(n) time method for\n# Zigzag order traversal\nfrom collections import deque \n \n# Binary Tree node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Function to print the zigzag traversal\ndef zigZagTraversal(root):\n    q = deque([])\n    v = []\n    q.append(root)\n    v.append(root.data)\n    \n    # set initial level as 1, because root is\n    # already been taken care of.\n    l = 1\n                 \n    while len(q) > 0:\n        n = len(q)\n        for i in range(n):\n            # popping mechanism\n            if (l % 2 == 0):\n                temp = q[-1]\n                q.pop()\n            else:\n                temp = q[0]\n                q.popleft()\n  \n            # pushing mechanism\n            if (l % 2 != 0):\n                if (temp.right):\n                    q.append(temp.right)\n                    v.append(temp.right.data)\n                if (temp.left):\n                    q.append(temp.left)\n                    v.append(temp.left.data)\n            elif (l % 2 == 0):\n                if (temp.left):\n                    q.appendleft(temp.left)\n                    v.append(temp.left.data)\n                if (temp.right):\n                    q.appendleft(temp.right)\n                    v.append(temp.right.data)\n        l+=1 # level plus one\n    return v\n \n# vector to store the traversal order.\nv = []\n \n# create tree\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(7)\nroot.left.right = Node(6)\nroot.right.left = Node(5)\nroot.right.right = Node(4)\nprint('ZigZag Order traversal of binary tree is')\n \nv = zigZagTraversal(root)\n \nfor i in range(len(v)):\n    print(v[i], end = ' ')\n     \n    # This code is contributed by suresh07.\n", "# Python Program to print zigzag traversal\n# of binary tree\n \n# Binary tree node\nclass Node:\n   \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None\n \n \n# function to print zigzag traversal of\n# binary tree\ndef zigzagtraversal(root):\n \n    # Base Case\n    if root is None:\n        return\n    ans = []  # store the traversal in the ans array\n    queue = [root] # use list as queue\n    flag = False\n    while len(queue) != 0:\n \n        n = len(queue)\n        level = []\n        for i in range(n):\n            node = queue[0]\n            queue.pop(0)\n            level.append(node.data)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        flag = not flag\n        if flag == False:\n            level = level[::-1]\n        for i in range(n):\n \n            ans.append(level[i])\n \n    return ans\n \n \n# Driver program to check above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(7)\nroot.left.right = Node(6)\nroot.right.left = Node(5)\nroot.right.right = Node(4)\nprint('Zigzag Order traversal of binary tree is')\n \nv = zigzagtraversal(root)\nfor i in v:\n    print(i,end = ' ')\n#This Code is Contributed By Vivek Maddeshiya\n", "# Python code to implement DFS approach\nfrom typing import List\n \n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n \nclass Solution:\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\n        result = []\n        self.dfs(root, 0, result) # Perform modified preorder traversal\n        for i in range(1, len(result), 2): # Reverse the order of nodes at odd levels\n            result[i] = result[i][::-1]\n        return result\n \n    def dfs(self, root: TreeNode, level: int, result: List[List[int]]) -> None:\n        if not root:\n            return\n        if level >= len(result): # If current level not yet stored, create new level\n            result.append([])\n        result[level].append(root.val) # Store current node in its level\n        self.dfs(root.left, level + 1, result) # Recursively traverse left subtree\n        self.dfs(root.right, level + 1, result) # Recursively traverse right subtree\n \n# Driver code\nif __name__ == '__main__':\n        ''' Constructed binary tree is\n               1\n             /   \\\n            2     3\n           / \\   / \\\n          4   5 6   7\n        '''\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.right.left = TreeNode(6)\n        root.right.right = TreeNode(7)\n \n        sol = Solution()\n        result = sol.zigzagLevelOrder(root)\n \n        # Print zigzag level order traversal\n        print('zig-zag traversal of binary tree is:')\n        for i in range(len(result)):\n            for j in range(len(result[i])):\n                print(result[i][j], end=' ')\n        print()\n"], "Find the Maximum Depth or Height of given Binary Tree -  ": ["# Python3 program to find the maximum depth of tree\n \n# A binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Compute the 'maxDepth' of a tree -- the number of nodes\n# along the longest path from the root node down to the\n# farthest leaf node\n \n \ndef maxDepth(node):\n    if node is None:\n        return 0\n \n    else:\n \n        # Compute the depth of each subtree\n        lDepth = maxDepth(node.left)\n        rDepth = maxDepth(node.right)\n \n        # Use the larger one\n        if (lDepth > rDepth):\n            return lDepth+1\n        else:\n            return rDepth+1\n \n \n# Driver program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\n \n \nprint('Height of tree is %d' % (maxDepth(root)))\n \n# This code is contributed by Amit Srivastav\n", "# Python code to implement the approach\n \n# A Tree node\n \n \nclass Node:\n \n    def __init__(self):\n        self.key = 0\n        self.left, self.right = None, None\n \n# Utility function to create a new node\n \n \ndef newNode(key):\n \n    temp = Node()\n    temp.key = key\n    temp.left, temp.right = None, None\n    return temp\n \n \n# Function to find the height(depth) of the tree\ndef height(root):\n \n    # Initialising a variable to count the\n    # height of tree\n    depth = 0\n \n    q = []\n \n    # appending first level element along with None\n    q.append(root)\n    q.append(None)\n    while(len(q) > 0):\n        temp = q[0]\n        q = q[1:]\n \n        # When None encountered, increment the value\n        if(temp == None):\n            depth += 1\n \n        # If None not encountered, keep moving\n        if(temp != None):\n            if(temp.left):\n                q.append(temp.left)\n \n            if(temp.right):\n                q.append(temp.right)\n \n        # If queue still have elements left,\n        # append None again to the queue.\n        elif(len(q) > 0):\n            q.append(None)\n    return depth\n \n# Driver program\n \n \n# Let us create Binary Tree shown in above example\nroot = newNode(1)\nroot.left = newNode(2)\nroot.right = newNode(3)\n \nroot.left.left = newNode(4)\nroot.left.right = newNode(5)\n \nprint(f'Height(Depth) of tree is: {height(root)}')\n \n \n# This code is contributed by shinjanpatra\n", "# Python3 program to find the height of a tree \n   \n# A binary tree node \nclass Node: \n   \n    # Constructor to create a new node \n    def __init__(self, data): \n        self.key = data \n        self.left = None\n        self.right = None\n   \n# Function to find height of tree \ndef height(root): \n    # Base Case \n    if root is None: \n        return 0\n   \n    # Create an empty queue for level order traversal \n    q = [] \n   \n    # Enqueue Root and initialize height \n    q.append(root) \n    height = 0\n   \n    # Loop while queue is not empty \n    while q: \n   \n        # nodeCount (queue size) indicates number of nodes \n        # at current level \n        nodeCount = len(q) \n   \n        # Dequeue all nodes of current level and Enqueue all \n        # nodes of next level \n        while nodeCount > 0: \n            node = q.pop(0) \n            if node.left is not None: \n                q.append(node.left) \n            if node.right is not None: \n                q.append(node.right) \n            nodeCount -= 1\n        height += 1\n   \n    return height \n   \n# Driver Code \nroot = Node(1) \nroot.left = Node(2) \nroot.right = Node(3) \nroot.left.left = Node(4) \nroot.left.right = Node(5) \n   \nprint('Height(Depth) of tree is', height(root))\n"], "Leaf nodes from Preorder of a Binary Search Tree -  ": ["# Python3 program to print leaf node from\n# preorder of binary search tree.\n \n# Binary Search\ndef binarySearch(inorder, l, r, d):\n \n    mid = (l + r) >> 1\n    if (inorder[mid] == d):\n        return mid\n    elif (inorder[mid] > d):\n        return binarySearch(inorder, l,\n                            mid - 1, d)\n    else:\n        return binarySearch(inorder, \n                            mid + 1, r, d)\n \n# Function to print Leaf Nodes by doing \n# preorder traversal of tree using \n# preorder and inorder arrays.\ndef leafNodesRec(preorder, inorder, \n                      l, r, ind, n):\n \n    # If l == r, therefore no right or left subtree.\n    # So, it must be leaf Node, print it.\n    if(l == r):\n        print(inorder[l], end = ' ')\n        ind[0] = ind[0] + 1\n        return\n \n    # If array is out of bound, return.\n    if (l < 0 or l > r or r >= n):\n        return\n \n    # Finding the index of preorder element\n    # in inorder array using binary search.\n    loc = binarySearch(inorder, l, r, \n                       preorder[ind[0]])\n \n    # Incrementing the index.\n    ind[0] = ind[0] + 1\n \n    # Finding on the left subtree.\n    leafNodesRec(preorder, inorder,     \n                 l, loc - 1, ind, n)\n \n    # Finding on the right subtree.\n    leafNodesRec(preorder, inorder, \n                 loc + 1, r, ind, n)\n \n# Finds leaf nodes from \n# given preorder traversal.\ndef leafNodes(preorder, n):\n \n    # To store inorder traversal\n    inorder = [0] * n \n     \n    # Copy the preorder into another array.\n    for i in range(n):\n        inorder[i] = preorder[i]\n \n    # Finding the inorder by sorting the array.\n    inorder.sort()\n     \n    # Point to the index in preorder.\n    ind = [0]\n     \n    # Print the Leaf Nodes.\n    leafNodesRec(preorder, inorder, 0,\n                 n - 1, ind, n)\n \n \n# Driver Code\npreorder = [890, 325, 290, 530, 965]\nn = len(preorder)\nleafNodes(preorder, n)\n \n# This code is contributed\n# by SHUBHAMSINGH10\n", "# Stack based Python program to print \n# leaf nodes from preorder traversal. \n \n# Print the leaf node from the given \n# preorder of BST. \ndef leafNode(preorder, n):\n    s = [] \n    i = 0\n    for j in range(1, n):\n        found = False\n        if preorder[i] > preorder[j]: \n            s.append(preorder[i])\n \n        else:\n            while len(s) != 0:\n                if preorder[j] > s[-1]:\n                    s.pop(-1)\n                    found = True\n                else:\n                    break\n \n        if found: \n            print(preorder[i], end = ' ')\n        i += 1\n \n    # Since rightmost element is \n    # always leaf node. \n    print(preorder[n - 1])\n \n# Driver code \nif __name__ == '__main__':\n    preorder = [890, 325, 290, 530, 965] \n    n = len(preorder) \n \n    leafNode(preorder, n)\n \n# This code is contributed by PranchalK\n"], "Rearrange characters in a String such that no two adjacent characters are same -  ": ["# Python program to rearrange characters in a string\n# so that no two adjacent characters are same.\n \nfrom heapq import heappush, heappop\nfrom collections import Counter\n \n# A key class for readability\n \n \nclass Key:\n    def __init__(self, character: str, freq: int) -> None:\n        self.character = character\n        self.freq = freq\n \n    def __lt__(self, other: 'Key') -> bool:\n        return self.freq > other.freq\n \n \n# Function to rearrange character of a string\n# so that no char repeat twice\ndef rearrangeString(str: str):\n    n = len(str)\n    # Creating a frequency hashmap\n    count = dict()\n    for i in str:\n        count[ord(i)] = count.get(ord(i), 0) + 1\n \n    pq = []\n    for c in range(97, 123):\n        if count.get(c, 0):\n            heappush(pq, Key(chr(c), count))\n \n    # null character for default previous checking\n    prev = Key('#', -1)\n    str = ''\n \n    while pq:\n        key = heappop(pq)\n        str += key.character\n \n        # Since one character is already added\n        key.freq -= 1\n \n        # We avoid inserting if the frequency drops to 0\n        if prev.freq > 0:\n            heappush(pq, prev)\n \n        prev = key\n \n    if len(str) != n:\n        print('Not possible')\n    else:\n        print(str)\n \n \n# Driver's Code\nif __name__ == '__main__':\n    string = 'bbbaa'\n \n    # Function call\n    rearrangeString(string)\n \n    # This code is contributed by kraanzu.\n", "# Python program for rearranging characters in a string such\n# that no two adjacent are same\n \n# Function to find the char with maximum frequency in the given\n# string\n \n \ndef getMaxCountChar(count):\n    maxCount = 0\n    for i in range(26):\n        if count[i] > maxCount:\n            maxCount = count[i]\n            maxChar = chr(i + ord('a'))\n \n    return maxCount, maxChar\n \n# Main function for rearranging the characters\n \n \ndef rearrangeString(S):\n    N = len(S)\n \n    # if length of string is None return False\n    if not N:\n        return False\n \n    # create a hashmap for the alphabets\n    count = [0] * 26\n    for char in S:\n        count[ord(char) - ord('a')] += 1\n \n    maxCount, maxChar = getMaxCountChar(count)\n \n    # if the char with maximum frequency is more than the half of the\n    # total length of the string than return False\n    if maxCount > (N + 1) // 2:\n        return False\n \n    # create a list for storing the result\n    res = [None] * N\n \n    ind = 0\n \n    # place all occurrences of the char with maximum frequency in\n    # even positions\n    while maxCount:\n        res[ind] = maxChar\n        ind += 2\n        maxCount -= 1\n \n    # replace the count of the char with maximum frequency to zero\n    # as all the maxChar are already placed in the result\n    count[ord(maxChar) - ord('a')] = 0\n \n    # place all other char in the result starting from remaining even\n    # positions and then place in the odd positions\n    for i in range(26):\n        while count[i] > 0:\n            if ind >= N:\n                ind = 1\n            res[ind] = chr(i + ord('a'))\n            ind += 2\n            count[i] -= 1\n \n    # convert the result list to string and return\n    return ''.join(res)\n \n \n# Driver Code\nif __name__ == '__main__':\n    str = 'bbbaa'\n \n    # Function call\n    res = rearrangeString(str)\n    if res:\n        print(res)\n    else:\n        print('Not possible')\n \n# This code is contributed by Manish Thapa\n"], "Kth smallest element in a row-wise and column-wise sorted 2D array -  ": ["# python program for kth largest element in a 2d\n# array sorted row-wise and column-wise\nimport heapq\n \ndef kthSmallest(arr, n, k):\n    pq = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(pq, arr[i][j])\n    c = 0\n    while pq:\n        temp = heapq.heappop(pq)\n        c += 1\n        if c == k:\n            return temp\n    return -1\nif __name__ == '__main__':\n    mat = [\n        [10, 20, 30, 40],\n        [15, 25, 35, 45],\n        [25, 29, 37, 48],\n        [32, 33, 39, 50]\n    ]\n    res = kthSmallest(mat, 4, 7)\n    print('7th smallest element is', res)\n", "# Program for kth largest element in a 2d array \n# sorted row-wise and column-wise \nfrom sys import maxsize \n \n# A structure to store an entry of heap. \n# The entry contains a value from 2D array, \n# row and column numbers of the value \nclass HeapNode: \n    def __init__(self, val, r, c): \n        self.val = val # value to be stored \n        self.r = r # Row number of value in 2D array \n        self.c = c # Column number of value in 2D array \n \n# A utility function to minheapify the node harr[i] \n# of a heap stored in harr[] \ndef minHeapify(harr, i, heap_size): \n    l = i * 2 + 1\n    r = i * 2 + 2\n    if(l < heap_size and r<heap_size and harr[l].val < harr[i].val and harr[r].val < harr[i].val):\n      temp= HeapNode(0,0,0)\n      temp=harr[r]\n      harr[r]=harr[i]\n      harr[i]=harr[l]\n      harr[l]=temp\n      minHeapify(harr ,l,heap_size)\n      minHeapify(harr ,r,heap_size)\n    if (l < heap_size and harr[l].val < harr[i].val):\n      temp= HeapNode(0,0,0)\n      temp=harr[i]\n      harr[i]=harr[l]\n      harr[l]=temp\n      minHeapify(harr ,l,heap_size)\n             \n# This function returns kth smallest element \n# in a 2D array mat[][] \ndef kthSmallest(mat, n, k): \n \n    # k must be greater than 0 and smaller than n*n \n    if k < 0 or k > n * n: \n        return maxsize \n \n    # Create a min heap of elements from \n    # first row of 2D array \n    harr = [0] * n \n    for i in range(n): \n        harr[i] = HeapNode(mat[0][i], 0, i) \n \n    hr = HeapNode(0, 0, 0) \n    for i in range(k): \n \n        # Get current heap root \n        hr = harr[0] \n \n        # Get next value from column of root's value. \n        # If the value stored at root was last value \n        # in its column, then assign INFINITE as next value \n        nextval = mat[hr.r + 1][hr.c] if (hr.r < n - 1) else maxsize \n \n        # Update heap root with next value \n        harr[0] = HeapNode(nextval, hr.r + 1, hr.c) \n \n        # Heapify root \n        minHeapify(harr, 0, n) \n \n    # Return the value at last extracted root \n    return hr.val \n \n# Driver Code \nif __name__ == '__main__': \n    mat = [[10, 20, 30, 40], \n        [15, 25, 35, 45], \n        [25, 29, 37, 48], \n        [32, 33, 39, 50]] \n    print('7th smallest element is', \n            kthSmallest(mat, 4, 7)) \n \n# This code is contributed by Rishabh Chauhan\n", "# kth largest element in a 2d array sorted row-wise and\n# column-wise\n \nimport heapq\n \ndef kthSmallest(mat, n, k):\n    # Using lambda function\n    # [=] in lambda function is for capturing variables which are out of scope i.e. mat[r]\n    # Now, it'll compare elements of heap by elements at mat[first][second]\n    # Capturing the value of mat by reference to prevent copying\n    cmp = lambda a,b: mat[a[0]][a[1]] - mat[b[0]][b[1]]\n \n    # Declaring heap and pushing first element of each row in it\n    heap = [(mat[i][0], i, 0) for i in range(n)]\n    heapq.heapify(heap)\n \n    # Running loop for k-1 times\n    for i in range(k-1):\n        val, row, col = heapq.heappop(heap)\n \n        # After popping, we'll push next element of the row in the heap\n        if col < n-1:\n            heapq.heappush(heap, (mat[row][col+1], row, col+1))\n \n    # On the k'th iteration, heap[0] will be our answer\n    return heap[0][0]\n \n# Driver program to test above function\nmat = [\n    [10, 20, 30, 40],\n    [15, 25, 35, 45],\n    [25, 29, 37, 48],\n    [32, 33, 39, 50]\n]\n \nprint('7th smallest element is', kthSmallest(mat, 4, 7))\n", "# This returns count of elements in matrix\n# less than of equal to num\ndef getElementsGreaterThanOrEqual(num,n,mat): \n    ans = 0\n    for i in range(n):\n       \n        # if num is less than the first element \n        # then no more element in matrix\n        # further are less than or equal to num\n        if (mat[i][0] > num):\n            return ans\n           \n        # if num is greater than last element, \n        # it is greater than all elements\n        # in that row\n        if (mat[i][n - 1] <= num):\n            ans += n\n            continue\n        # This contain the col index of last element \n        # in matrix less than of equal\n        # to num\n        greaterThan = 0\n        jump = n // 2\n        while(jump >= 1):\n                while (greaterThan + jump < n and mat[i][greaterThan + jump] <= num):\n                    greaterThan += jump\n                jump //= 2\n \n        ans += greaterThan + 1\n    return ans\n \n# returns kth smallest index in the matrix\ndef kthSmallest(mat, n, k): \n \n    # We know the answer lies between \n    # the first and the last element\n    # So do a binary search on answer \n    # based on the number of elements\n    # our current element is greater than\n    # the elements in the matrix\n    l,r = mat[0][0],mat[n - 1][n - 1]\n \n    while (l <= r):\n        mid = l + (r - l) // 2\n        greaterThanOrEqualMid = getElementsGreaterThanOrEqual(mid, n, mat)\n \n        if (greaterThanOrEqualMid >= k):\n            r = mid - 1\n        else:\n            l = mid + 1\n \n    return l\n \n# driver code\nn = 4\nmat = [[10, 20, 30, 40],[15, 25, 35, 45],[25, 29, 37, 48],[32, 33, 39, 50]]\nprint(f'7th smallest element is {kthSmallest(mat, 4, 7)}')\n \n# This code is contributed by shinjanpatra\n", "# Python program to implement above approach\ndef kthSmallest(mat, n, k):\n         \n    a = [0 for i in range(n*n)]\n    v=0\n         \n    for i in range(n):\n        for j in range(n):\n            a[v] = mat[i][j]\n            v += 1\n             \n    a.sort()\n    result = a[k - 1]\n    return result\n \n# driver program\n         \nmat = [ [ 10, 20, 30, 40 ],\n            [ 15, 25, 35, 45 ],\n            [ 25, 29, 37, 48 ],\n            [ 32, 33, 39, 50 ] ]\nres = kthSmallest(mat, 4, 7)\n     \nprint('7th smallest element is '+ str(res))\n \n# This code is contributed by shinjanpatra\n", "import heapq\n \n \ndef kthSmallest(matrix, k):\n    # n = size of matrix\n    n = len(matrix)\n \n    # using built-in priority queue which acts as max Heap i.e. largest element will be on top\n    # Kth smallest element can also be seen as largest element in a priority queue of size k\n    # By this logic we pop elements from priority queue when its size becomes greater than k\n    # thus top of priority queue is kth smallest element in matrix\n \n    maxH = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(maxH, -matrix[i][j])\n            if len(maxH) > k:\n                heapq.heappop(maxH)\n    return -maxH[0]\n \n \nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\nprint('8th smallest element is', kthSmallest(matrix, k))\n \n# This code is contributed by Tapesh (tapeshdua420)\n"], "Binary Heap -  ": [], "Find winner of an election where votes are represented as candidate names -  ": ["# Python program to find winner in an election.\nimport math\n \n# We have four Candidates with name as 'John',\n  #'Johnny', 'jamie', 'jackie'.\n# The votes in String array are as per the\n   #votes casted. Print the name of candidates\n   #received Max vote. */\ndef findWinner(votes):\n    n = len(votes);\n    prevCount = 0;\n    result = '';\n \n    # Iterate over every string\n    for i in range(0, n): \n        count = 0;\n \n        # Count the occurrence of current string in the\n        # given votes[]\n        for j in range(0, n): \n            if (votes[i] == votes[j]):\n                count += 1;\n \n            # Maximise the result if count > previous count\n            if (count > prevCount):\n                prevCount = count;\n                result = votes[i];\n         \n            elif (count == prevCount) :\n                result = min(result, votes[i]);\n         \n    # return the result\n    print(result);\n \n# Driver code\nvotes = [ 'john', 'johnny', 'jackie', 'johnny',\n        'john', 'jackie', 'jamie',  'jamie',\n        'john', 'johnny', 'jamie',  'johnny',\n        'john' ];\n \nfindWinner(votes);\n \n# This code is contributed by agrawalpoojaa976.\n", "# Python3 program to find winner in an election.\nfrom collections import defaultdict\n \n''' We have four Candidates with name as 'John',\n'Johnny', 'jamie', 'jackie'.\nThe votes in String array are as per the\nvotes casted. Print the name of candidates\nreceived Max vote. '''\n \n \ndef findWinner(votes):\n \n    # Insert all votes in a hashmap\n    mapObj = defaultdict(int)\n \n    for st in votes:\n        mapObj[st] += 1\n \n    # Traverse through map to find the\n    # candidate with maximum votes.\n    maxValueInMap = 0\n    winner = ''\n \n    for entry in mapObj:\n        key = entry\n        val = mapObj[entry]\n \n        if (val > maxValueInMap):\n            maxValueInMap = val\n            winner = key\n \n        # If there is a tie, pick lexicographically\n        # smaller.\n        else if (val == maxValueInMap and\n                 winner > key):\n            winner = key\n \n    print(winner)\n \n \n# Driver code\nif __name__ == '__main__':\n \n    votes = ['john', 'johnny', 'jackie',\n             'johnny', 'john', 'jackie',\n             'jamie', 'jamie', 'john',\n             'johnny', 'jamie', 'johnny',\n             'john']\n \n    findWinner(votes)\n \n# This code is contributed by ukasp\n"], "Find the longest substring with k unique characters in a given string -  ": ["# Python program to find the longest substring\n# with k unique characters in a given string\n \n# Function to calculate length of\n# longest substring with k characters\ndef longestKSubstr(s, k):\n    n = len(s)\n    answer = -1\n    for i in range(n):\n        for j in range(i+1, n+1):\n            distinct = set(s[i:j])\n            if len(distinct) == k:\n                answer = max(answer, j - i)\n    print(answer)\n \ns = 'aabacbebebe'\nk = 3\n \n# Function Call\nlongestKSubstr(s, k)\n", "# Python program to find the longest substring with k unique \n# characters in a given string \nMAX_CHARS = 26\n \n# This function calculates number of unique characters \n# using a associative array count[]. Returns true if \n# no. of characters are less than required else returns \n# false. \ndef isValid(count, k): \n    val = 0\n    for i in range(MAX_CHARS): \n        if count[i] > 0: \n            val += 1\n \n    # Return true if k is greater than or equal to val \n    return (k >= val) \n \n# Finds the maximum substring with exactly k unique characters \ndef kUniques(s, k): \n    u = 0 # number of unique characters \n    n = len(s) \n \n    # Associative array to store the count \n    count = [0] * MAX_CHARS \n \n    # Traverse the string, fills the associative array \n    # count[] and count number of unique characters \n    for i in range(n): \n        if count[ord(s[i])-ord('a')] == 0: \n            u += 1\n        count[ord(s[i])-ord('a')] += 1\n \n    # If there are not enough unique characters, show \n    # an error message. \n    if u < k: \n        print ('Not enough unique characters')\n        return\n \n    # Otherwise take a window with first element in it. \n    # start and end variables. \n    curr_start = 0\n    curr_end = 0\n \n    # Also initialize values for result longest window \n    max_window_size = 1\n    max_window_start = 0\n \n    # Initialize associative array count[] with zero \n    count = [0] * len(count) \n \n    count[ord(s[0])-ord('a')] += 1 # put the first character \n \n    # Start from the second character and add \n    # characters in window according to above \n    # explanation \n    for i in range(1,n): \n \n        # Add the character 's[i]' to current window \n        count[ord(s[i])-ord('a')] += 1\n        curr_end+=1\n \n        # If there are more than k unique characters in \n        # current window, remove from left side \n        while not isValid(count, k): \n            count[ord(s[curr_start])-ord('a')] -= 1\n            curr_start += 1\n \n        # Update the max window size if required \n        if curr_end-curr_start+1 > max_window_size: \n            max_window_size = curr_end-curr_start+1\n            max_window_start = curr_start \n \n    print ('Max substring is : ' + s[max_window_start:max_window_start  + max_window_size] \n    + ' with length ' + str(max_window_size))\n \n# Driver function \ns = 'aabacbebebe'\nk = 3\nkUniques(s, k) \n \n# This code is contributed by BHAVYA JAIN \n", "def longestkSubstr(S, k):\n    # Create an empty dictionary to store character counts\n    map = {}\n    # Initialize two pointers i and j to -1\n    i = -1\n    j = -1\n    # Initialize ans to -1\n    ans = -1\n \n    # Loop until break statement is reached\n    while True:\n        # Initialize two flags to False\n        flag1 = False\n        flag2 = False\n \n        # Loop until i reaches end of string S\n        while i < len(S) - 1:\n            # Set flag1 to True\n            flag1 = True\n            # Increment i and get character at index i\n            i += 1\n            ch = S[i]\n            # Add character count to dictionary\n            map[ch] = map.get(ch, 0) + 1\n \n            # If number of unique characters is less than k, continue loop\n            if len(map) < k:\n                continue\n            # If number of unique characters is equal to k, update ans if necessary and continue loop\n            elif len(map) == k:\n                len_ = i - j\n                ans = max(len_, ans)\n            # If number of unique characters is greater than k, break loop\n            else:\n                break\n \n        # Loop until j reaches i\n        while j < i:\n            # Set flag2 to True\n            flag2 = True\n            # Increment j and get character at index j\n            j += 1\n            ch = S[j]\n \n            # If character count is 1, remove character from dictionary\n            if map[ch] == 1:\n                del map[ch]\n            # If character count is greater than 1, decrement character \n            # count in dictionary\n            else:\n                map[ch] -= 1\n \n            # If number of unique characters is equal to k, \n            # update ans if necessary and break loop\n            if len(map) == k:\n                len_ = i - j\n                ans = max(ans, len_)\n                break\n            # If number of unique characters is greater than k, continue loop\n            elif len(map) > k:\n                continue\n \n        # If both flags are False, break outer loop (while True)\n        if not flag1 and not flag2:\n            break\n \n    return ans\n \n \n# Test case inputs and function call\ns = 'aabacbebebe'\nk = 3\n \nans = longestkSubstr(s, k)\nprint(ans)\n"], "Find Median from Running Data Stream -  ": ["# Function to find position to insert current element of\n# stream using binary search\n \n \ndef binarySearch(arr, item, low, high):\n \n    if (low >= high):\n        return (low + 1) if (item > arr[low]) else low\n \n    mid = (low + high) // 2\n \n    if (item == arr[mid]):\n        return mid + 1\n \n    if (item > arr[mid]):\n        return binarySearch(arr, item, mid + 1, high)\n \n    return binarySearch(arr, item, low, mid - 1)\n \n# Function to print median of stream of integers\n \n \ndef printMedian(arr, n):\n \n    i, j, pos, num = 0, 0, 0, 0\n    count = 1\n \n    print(f'Median after reading 1 element is {arr[0]}.0')\n \n    for i in range(1, n):\n        median = 0\n        j = i - 1\n        num = arr[i]\n \n        # find position to insert current element in sorted\n        # part of array\n        pos = binarySearch(arr, num, 0, j)\n \n        # move elements to right to create space to insert\n        # the current element\n        while (j >= pos):\n            arr[j + 1] = arr[j]\n            j -= 1\n \n        arr[j + 1] = num\n \n        # increment count of sorted elements in array\n        count += 1\n \n        # if odd number of integers are read from stream\n        # then middle element in sorted order is median\n        # else average of middle elements is median\n        if (count % 2 != 0):\n            median = arr[count // 2] / 1\n \n        else:\n            median = (arr[(count // 2) - 1] + arr[count // 2]) / 2\n \n        print(f'Median after reading {i + 1} elements is {median} ')\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    arr = [5, 15, 1, 3, 2, 8, 7, 9, 10, 6, 11, 4]\n    n = len(arr)\n \n    printMedian(arr, n)\n \n# This code is contributed by rakeshsahni\n \n# This code is modified by Susobhan Akhuli\n", "# Python code to implement the approach\n \nfrom heapq import heappush, heappop, heapify\nimport math\n \n# Function to find the median of stream of data\ndef streamMed(arr, N):\n     \n    # Declaring two min heap\n    g = []\n    s = []\n    for i in range(len(arr)):\n       \n        # Negation for treating it as max heap\n        heappush(s, -arr[i])\n        heappush(g, -heappop(s))\n        if len(g) > len(s):\n            heappush(s, -heappop(g))\n \n        if len(g) != len(s):\n            print(-s[0])\n        else:\n            print((g[0] - s[0])/2)\n \n \n# Driver code\nif __name__ == '__main__':\n    A = [5, 15, 1, 3, 2, 8, 7, 9, 10, 6, 11, 4]\n    N = len(A)\n     \n    # Function call\n    streamMed(A, N)\n"], "Largest subarray with equal number of 0s and 1s -  ": ["# A simple program to find the largest subarray\n# with equal number of 0s and 1s\n \n# This function Prints the starting and ending\n# indexes of the largest subarray with equal \n# number of 0s and 1s. Also returns the size \n# of such subarray.\ndef findSubArray(arr, n):\n \n    sum = 0\n    maxsize = -1\n \n    # Pick a starting point as i\n \n    for i in range(0, n-1):\n     \n        sum = -1 if(arr[i] == 0) else 1\n \n        # Consider all subarrays starting from i\n \n        for j in range(i + 1, n):\n         \n            sum = sum + (-1) if (arr[j] == 0) else sum + 1\n \n            # If this is a 0 sum subarray, then \n            # compare it with maximum size subarray\n            # calculated so far\n \n            if (sum == 0 and maxsize < j-i + 1):\n                 \n                maxsize = j - i + 1\n                startindex = i\n             \n         \n     \n    if (maxsize == -1):\n        print('No such subarray');\n    else:\n        print(startindex, 'to', startindex + maxsize-1);\n \n    return maxsize\n \n# Driver program to test above functions\narr = [1, 0, 0, 1, 0, 1, 1]\nsize = len(arr)\nfindSubArray(arr, size)\n \n# This code is contributed by Smitha Dinesh Semwal\n", "# Python 3 program to find largest \n# subarray with equal number of \n# 0's and 1's. \n \n# Returns largest subarray with \n# equal number of 0s and 1s \ndef maxLen(arr, n): \n \n    # NOTE: Dictionary in python in \n    # implemented as Hash Maps. \n    # Create an empty hash map (dictionary) \n    hash_map = {}  \n    curr_sum = 0\n    max_len = 0\n    ending_index = -1\n \n    for i in range (0, n): \n        if(arr[i] == 0): \n            arr[i] = -1\n        else: \n            arr[i] = 1\n \n    # Traverse through the given array \n    for i in range (0, n): \n     \n        # Add current element to sum \n        curr_sum = curr_sum + arr[i] \n \n        # To handle sum = 0 at last index \n        if (curr_sum == 0): \n            max_len = i + 1\n            ending_index = i \n \n        # If this sum is seen before, \n        if curr_sum in hash_map:\n             \n            # If max_len is smaller than new subarray\n            # Update max_len and ending_index\n            if max_len < i - hash_map[curr_sum]:\n                max_len = i - hash_map[curr_sum]\n                ending_index = i\n        else: \n \n            # else put this sum in dictionary \n            hash_map[curr_sum] = i  \n         \n    for i in range (0, n): \n        if(arr[i] == -1): \n            arr[i] = 0\n        else: \n            arr[i] = 1\n             \n    print (ending_index - max_len + 1, end =' ')\n    print ('to', end = ' ')\n    print (ending_index)\n \n    return max_len\n \n# Driver Code \narr = [1, 0, 0, 1, 0, 1, 1] \nn = len(arr)  \n \nmaxLen(arr, n) \n     \n# This code is contributed \n# by Tarun Garg\n"], "Triplet Sum in Array (3sum) -  ": ["# Python3 program to find a triplet \n# that sum to a given value\n \n# returns true if there is triplet with\n# sum equal to 'sum' present in A[]. \n# Also, prints the triplet\ndef find3Numbers(A, arr_size, sum):\n \n    # Fix the first element as A[i]\n    for i in range( 0, arr_size-2):\n \n        # Fix the second element as A[j]\n        for j in range(i + 1, arr_size-1): \n             \n            # Now look for the third number\n            for k in range(j + 1, arr_size):\n                if A[i] + A[j] + A[k] == sum:\n                    print('Triplet is', A[i],\n                          ', ', A[j], ', ', A[k])\n                    return True\n     \n    # If we reach here, then no \n    # triplet was found\n    return False\n \n# Driver program to test above function \nA = [1, 4, 45, 6, 10, 8]\nsum = 22\narr_size = len(A)\nfind3Numbers(A, arr_size, sum)\n \n# This code is contributed by Smitha Dinesh Semwal \n", "# Python3 program to find a triplet\n \n# returns true if there is triplet\n# with sum equal to 'sum' present\n# in A[]. Also, prints the triplet\ndef find3Numbers(A, arr_size, sum):\n \n    # Sort the elements \n    A.sort()\n \n    # Now fix the first element \n    # one by one and find the\n    # other two elements \n    for i in range(0, arr_size-2):\n     \n \n        # To find the other two elements,\n        # start two index variables from\n        # two corners of the array and\n        # move them toward each other\n         \n        # index of the first element\n        # in the remaining elements\n        l = i + 1\n         \n        # index of the last element\n        r = arr_size-1\n        while (l < r):\n         \n            if( A[i] + A[l] + A[r] == sum):\n                print('Triplet is', A[i], \n                     ', ', A[l], ', ', A[r]);\n                return True\n             \n            elif (A[i] + A[l] + A[r] < sum):\n                l += 1\n            else: # A[i] + A[l] + A[r] > sum\n                r -= 1\n \n    # If we reach here, then\n    # no triplet was found\n    return False\n \n# Driver program to test above function \nA = [1, 4, 45, 6, 10, 8]\nsum = 22\narr_size = len(A)\n \nfind3Numbers(A, arr_size, sum)\n \n# This is contributed by Smitha Dinesh Semwal\n", "# Function to find a triplet with a given sum in an array\ndef find3Numbers(arr, sum):\n \n    # Fix the first element as arr[i]\n    for i in range(len(arr) - 2):\n \n        # Create a set to store potential second elements that complement the desired sum\n        s = set()\n \n        # Calculate the current sum needed to reach the target sum\n        curr_sum = sum - arr[i]\n \n        # Iterate through the subarray arr[i+1:]\n        for j in range(i + 1, len(arr)):\n \n            # Calculate the required value for the second element\n            required_value = curr_sum - arr[j]\n \n            # Check if the required value is present in the set\n            if required_value in s:\n \n                # Triplet is found; print the triplet elements\n                print(f'Triplet is {arr[i]}, {arr[j]}, {required_value}')\n                return True\n \n            # Add the current element to the set for future complement checks\n            s.add(arr[j])\n \n    # If no triplet is found, return False\n    return False\n \n \n# Driver program to test above function\nif __name__ == '__main__':\n    arr = [1, 4, 45, 6, 10, 8]\n    target_sum = 22\n \n    # Call the find3Numbers function to find and print the triplet, if it exists\n    if not find3Numbers(arr, target_sum):\n        print('No triplet found.')\n"], "Longest Consecutive Subsequence -  ": ["# Python3 program to find longest\n# contiguous subsequence\n \n# Returns length of the longest\n# contiguous subsequence\n \n \ndef findLongestConseqSubseq(arr, n):\n \n    ans = 0\n    count = 0\n \n    # Sort the array\n    arr.sort()\n \n    v = []\n \n    v.append(arr[0])\n \n    # Insert repeated elements only\n    # once in the vector\n    for i in range(1, n):\n        if (arr[i] != arr[i - 1]):\n            v.append(arr[i])\n \n    # Find the maximum length\n    # by traversing the array\n    for i in range(len(v)):\n \n        # Check if the current element is\n        # equal to previous element +1\n        if (i > 0 and v[i] == v[i - 1] + 1):\n            count += 1\n \n        # Reset the count\n        else:\n            count = 1\n \n        # Update the maximum\n        ans = max(ans, count)\n \n    return ans\n \n \n# Driver code\narr = [1, 2, 2, 3]\nn = len(arr)\n \nprint('Length of the Longest contiguous subsequence is',\n      findLongestConseqSubseq(arr, n))\n \n# This code is contributed by avanitrachhadiya2155\n", "# Python program to find longest contiguous subsequence\n \n \ndef findLongestConseqSubseq(arr, n):\n \n    s = set()\n    ans = 0\n \n    # Hash all the array elements\n    for ele in arr:\n        s.add(ele)\n \n    # check each possible sequence from the start\n    # then update optimal length\n    for i in range(n):\n \n         # if current element is the starting\n        # element of a sequence\n        if (arr[i]-1) not in s:\n \n            # Then check for next elements in the\n            # sequence\n            j = arr[i]\n            while(j in s):\n                j += 1\n \n            # update  optimal length if this length\n            # is more\n            ans = max(ans, j-arr[i])\n    return ans\n \n \n# Driver code\nif __name__ == '__main__':\n    n = 7\n    arr = [1, 9, 3, 10, 4, 20, 2]\n    print('Length of the Longest contiguous subsequence is ',\n          findLongestConseqSubseq(arr, n))\n \n# Contributed by: Harshit Sidhwa\n", "# Python program for the above approach\nimport bisect\n \n \ndef findLongestConseqSubseq(arr, N):\n    pq = []\n    for i in range(N):\n \n        # adding element from\n        # array to PriorityQueue\n        bisect.insort(pq, arr[i])\n \n    # Storing the first element\n    # of the Priority Queue\n    # This first element is also\n    # the smallest element\n    prev = pq[0]\n    pq.pop(0)\n \n    # Taking a counter variable with value 1\n    c = 1\n \n    # Storing value of max as 1\n    # as there will always be\n    # one element\n    max = 1\n    while(len(pq)):\n        # check if current peek\n        # element minus previous\n        # element is greater than\n        # 1 This is done because\n        # if it's greater than 1\n        # then the sequence\n        # doesn't start or is broken here\n        if(pq[0] - prev > 1):\n            # Store the value of counter to 1\n            # As new sequence may begin\n            c = 1\n \n            # Update the previous position with the\n            # current peek And remove it\n            prev = pq[0]\n            pq.pop(0)\n \n        # Check if the previous\n        # element and peek are same\n        elif(pq[0] - prev == 0):\n            # Update the previous position with the\n            # current peek And remove it\n            prev = pq[0]\n            pq.pop(0)\n \n        # If the difference\n        # between previous element and peek is 1\n        else:\n            # Update the counter\n            # These are consecutive elements\n            c = c + 1\n            # Update the previous position\n            # with the current peek And remove it\n            prev = pq[0]\n            pq.pop(0)\n \n        # Check if current longest\n        # subsequence is the greatest\n        if(max < c):\n            # Store the current subsequence count as\n            # max\n            max = c\n    return max\n \n \n# Driver Code\narr = [1, 9, 3, 10, 4, 20, 2]\nn = 7\nprint('Length of the Longest consecutive subsequence is {}'.format(\n    findLongestConseqSubseq(arr, n)))\n \n \n# This code is contributed by Pushpesh Raj\n"], "Count pairs with given sum -  ": ["# Python3 implementation of simple method\n# to find count of pairs with given sum.\n \n# Returns number of pairs in arr[0..n-1]\n# with sum equal to 'sum'\n \n \ndef getPairsCount(arr, n, K):\n \n    count = 0  # Initialize result\n \n    # Consider all possible pairs\n    # and check their sums\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if arr[i] + arr[j] == K:\n                count += 1\n \n    return count\n \n \n# Driver function\narr = [1, 5, 7, -1]\nn = len(arr)\nK = 6\nprint('Count of pairs is',\n      getPairsCount(arr, n, K))\n \n# This code is contributed by Smitha Dinesh Semwal\n", "# Python code to implement the approach\nimport bisect\n \n# Function to find the count of pairs\n \n \ndef getPairsCount(arr, n, k):\n    arr.sort()\n    x, c = 0, 0\n    for i in range(n-1):\n        x = k-arr[i]\n \n        # Lower bound from i+1\n        y = bisect.bisect_left(arr, x, i+1, n)\n \n        # Upper bound from i+1\n        z = bisect.bisect(arr, x, i+1, n)\n        c = c+z-y\n    return c\n \n \n# Driver function\narr = [1, 5, 7, -1]\nn = len(arr)\nk = 6\n \n# Function call\nprint('Count of pairs is', getPairsCount(arr, n, k))\n \n# This code is contributed by Pushpesh Raj\n", "# Python implementation of simple method to find count of\n# pairs with given sum.\n \n# Returns number of pairs in arr[0..n-1] with sum equal to 'sum'\n \n \ndef getPairsCount(arr, n, sum):\n    unordered_map = {}\n    count = 0\n    for i in range(n):\n        if sum - arr[i] in unordered_map:\n            count += unordered_map[sum - arr[i]]\n        if arr[i] in unordered_map:\n            unordered_map[arr[i]] += 1\n        else:\n            unordered_map[arr[i]] = 1\n    return count\n \n \n# Driver code\narr = [1, 5, 7, -1]\nn = len(arr)\nsum = 6\nprint('Count of pairs is', getPairsCount(arr, n, sum))\n \n# This code is contributed by Manish Thapa\n"], "Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists, and should also be sorted. For example, given following linked lists : 5 -> 8 -> 20 4 -> 11 -> 15 The merged list should be : 4 -> 5 -> 8 -> 11 -> 15 -> 20": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\nclass Solution:\n    # @param A : head node of linked list\n    # @param B : head node of linked list\n    # @return the head node in the linked list\n    def mergeTwoLists(self, A, B):\n        head = None\n        if A.val > B.val:\n            head = B\n            B = B.next\n            if B == None:\n                head.next=A\n                return head \n        else:\n            head = A\n            A = A.next\n            if A==None:\n                head.next=B\n                return head\n\n        current = head\n        while True:\n            if A.val > B.val:\n                current.next = B\n                current = current.next\n                B = B.next\n                if B == None:\n                    current.next = A\n                    break\n            else:\n                current.next = A\n                current = current.next\n                A = A.next\n                if A == None:\n                    current.next = B\n                    break\n        return head\n\n\n\n\n", "Find if there is a rectangle in binary matrix with corners as 1 -  ": ["# A brute force approach based Python3 program to\n# find if there is a rectangle with 1 as corners.\n \n# Returns true if there is a rectangle \n# with 1 as corners.\ndef isRectangle(m):\n \n    # finding row and column size\n    rows = len(m)\n    if (rows == 0):\n        return False\n    columns = len(m[0])\n \n    # scanning the matrix\n    for y1 in range(rows):\n \n        for x1 in range(columns):\n \n            # if any index found 1 then \n            # try for all rectangles\n            if (m[y1][x1] == 1):\n                for y2 in range(y1 + 1, rows):\n                    for x2 in range(x1 + 1, columns):\n                        if (m[y1][x2] == 1 and\n                            m[y2][x1] == 1 and\n                            m[y2][x2] == 1):\n                            return True\n    return False\n \n# Driver code\nmat = [[1, 0, 0, 1, 0],\n       [0, 0, 1, 0, 1],\n       [0, 0, 0, 1, 0],\n       [1, 0, 1, 0, 1]]\n \nif (isRectangle(mat)):\n    print('Yes')\nelse:\n    print('No')\n \n# This code is contributed\n# by mohit kumar 29\n", "# An efficient approach based Python program \n# to find if there is a rectangle with 1 as \n# corners. \n \n# Returns true if there is a rectangle\n# with 1 as corners. \ndef isRectangle(matrix):\n \n    # finding row and column size \n    rows = len(matrix)\n    if (rows == 0):\n        return False\n \n    columns = len(matrix[0])\n \n    # map for storing the index of \n    # combination of 2 1's \n    table = {}\n \n    # scanning from top to bottom \n    # line by line \n    for i in range(rows): \n        for j in range(columns - 1):\n            for k in range(j + 1, columns): \n \n                # if found two 1's in a column \n                if (matrix[i][j] == 1 and\n                    matrix[i][k] == 1):\n \n                    # check if there exists 1's in same \n                    # row previously then return true \n                    if (j in table and k in table[j]):\n                        return True\n \n                    if (k in table and j in table[k]):\n                        return True\n \n                    # store the indexes in hashset \n                    if j not in table:\n                        table[j] = set()\n                    if k not in table:\n                        table[k] = set()\n                    table[j].add(k) \n                    table[k].add(j)\n    return False\n \n# Driver Code\nif __name__ == '__main__':\n    mat = [[ 1, 0, 0, 1, 0 ],\n           [ 0, 0, 1, 0, 1 ],\n           [ 0, 0, 0, 1, 0 ],\n           [ 1, 0, 1, 0, 1 ]] \n    if (isRectangle(mat)):\n        print('Yes')\n    else:\n        print('No')\n     \n# This code is contributed \n# by SHUBHAMSINGH10\n", "# Python3 implementation comes from:\n# https:#github.com/MichaelWehar/FourCornersProblem\n# Written by Niteesh Kumar and Michael Wehar\n# References:\n#   [1] F. Mr\u00e1z, D. Prusa, and M. Wehar. \n#   Two-dimensional Pattern Matching against \n#    Basic Picture Languages. CIAA 2019.\n#   [2] D. Prusa and M. Wehar. Complexity of \n#    Searching for 2 by 2 Submatrices in Boolean \n#    Matrices. DLT 2020.\ndef searchForRectangle( rows,  cols, mat) :\n \n    # Make sure that matrix is non-trivial\n    if (rows < 2 or cols < 2) :\n     \n        return False;\n     \n    # Create map\n    adjsList = dict();\n    if (rows >= cols): \n     \n        # Row-wise\n        num_of_keys = rows;\n         \n        # Convert each row into vector of col indexes\n        for i in range(rows):\n             \n            for j in range(cols):\n         \n                if (mat[i][j]):\n                     \n                    if i not in adjsList:\n                        adjsList[i] = []\n                    adjsList[i].append(j);\n    else :\n     \n        # Col-wise\n        num_of_keys = cols;\n         \n        # Convert each col into vector of row indexes\n        for i in range(rows):\n             \n            for j in range(cols):\n         \n                if (mat[i][j] == 1) :\n                     \n                    if j not in adjsList:\n                        adjsList[j] = []\n                    adjsList[j].append(i);\n                 \n    # Search for a rectangle whose four corners are 1's\n    pairs = dict();\n     \n    for i in range(num_of_keys):\n \n        values = adjsList[i];\n        size = len(values)\n         \n        for j in range(size - 1):\n             \n            for k in range(j + 1, size):\n \n                temp  = (values[j], values[k]);\n                 \n                if temp in pairs:\n                    return True;\n                  \n                else:\n                    pairs[temp] = i;\n    return False;\n \n# Driver code\nmat =   [[ 1, 0, 0, 1, 0 ], [ 0, 1, 1, 1, 1 ], [ 0, 0, 0, 1, 0 ], [ 1, 1, 1, 1, 0 ]];\nif (searchForRectangle(4, 5, mat)):\n    print('Yes');\nelse:\n    print('No')\n     \n# This code is contributed by phasing17.\n"], "Find All Duplicate Subtrees -  ": ["# Python3 program to find averages of \n# all levels in a binary tree. \n \n# Helper function that allocates a \n# new node with the given data and \n# None left and right pointers. \nclass newNode:\n    def __init__(self, data):\n        self.data = data \n        self.left = self.right = None\n \ndef inorder(node, m):\n    if (not node): \n        return '' \n \n    Str = '('\n    Str += inorder(node.left, m) \n    Str += str(node.data) \n    Str += inorder(node.right, m) \n    Str += ')'\n \n    # Subtree already present (Note that \n    # we use unordered_map instead of \n    # unordered_set because we want to print\n    # multiple duplicates only once, consider \n    # example of 4 in above subtree, it \n    # should be printed only once. \n    if (Str in m and m[Str] == 1): \n        print(node.data, end = ' ') \n    if Str in m:\n        m[Str] += 1\n    else:\n        m[Str] = 1\n \n    return Str\n \n# Wrapper over inorder() \ndef printAllDups(root):\n    m = {} \n    inorder(root, m)\n \n# Driver code \nif __name__ == '__main__':\n    root = None\n    root = newNode(1) \n    root.left = newNode(2) \n    root.right = newNode(3) \n    root.left.left = newNode(4) \n    root.right.left = newNode(2) \n    root.right.left.left = newNode(4) \n    root.right.right = newNode(4) \n    printAllDups(root) \n \n# This code is contributed by PranchalK\n"], "Length of longest strict bitonic subsequence -  ": ["def lbs(arr):\n    n = len(arr)\n \n    # Allocate memory for LIS[] and initialize LIS values as 1 for all indexes\n    lis = [1] * n\n \n    # Compute LIS values from left to right\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and abs(arr[i] - arr[j]) == 1 and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n \n    # Allocate memory for lds and initialize LDS values for all indexes\n    lds = [1] * n\n \n    # Compute LDS values from right to left\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j] and abs(arr[i] - arr[j]) == 1 and lds[i] < lds[j] + 1:\n                lds[i] = lds[j] + 1\n \n    # Return the maximum value of lis[i] + lds[i] - 1\n    max_val = lis[0] + lds[0] - 1\n    for i in range(1, n):\n        max_val = max(max_val, lis[i] + lds[i] - 1)\n    return max_val\n \n# Driver program to test above function\narr = [1, 5, 2, 3, 4, 5, 3, 2]\nprint('Length of LBS is', lbs(arr))\n \n# This code is contributed by vikramshirsath177\n", "# Python3 implementation to find length of \n# longest strict bitonic subsequence\n \n# function to find length of longest\n# strict bitonic subsequence\ndef longLenStrictBitonicSub(arr, n):\n \n    # hash table to map the array element \n    # with the length of the longest subsequence \n    # of which it is a part of and is the \n    # last/first element of that subsequence\n    inc, dcr = dict(), dict()\n \n    # arrays to store the length of increasing\n    # and decreasing subsequences which end at \n    # them or start from them\n    len_inc, len_dcr = [0] * n, [0] * n\n \n    # to store the length of longest strict\n    # bitonic subsequence\n    longLen = 0\n \n    # traverse the array elements\n    # from left to right\n    for i in range(n):\n \n        # initialize current length\n        # for element arr[i] as 0\n        len = 0\n \n        # if 'arr[i]-1' is in 'inc'\n        if inc.get(arr[i] - 1) in inc.values():\n            len = inc.get(arr[i] - 1)\n         \n        # update arr[i] subsequence length in 'inc'     \n        # and in len_inc[] \n        inc[arr[i]] = len_inc[i] = len + 1\n     \n    # traverse the array elements\n    # from right to left\n    for i in range(n - 1, -1, -1):\n \n        # initialize current length\n        # for element arr[i] as 0\n        len = 0\n \n        # if 'arr[i]-1' is in 'dcr'\n        if dcr.get(arr[i] - 1) in dcr.values():\n            len = dcr.get(arr[i] - 1)\n         \n        # update arr[i] subsequence length  \n        # in 'dcr' and in len_dcr[] \n        dcr[arr[i]] = len_dcr[i] = len + 1\n     \n    # calculating the length of \n    # all the strict bitonic subsequence \n    for i in range(n):\n        if longLen < (len_inc[i] + len_dcr[i] - 1):\n            longLen = len_inc[i] + len_dcr[i] - 1\n     \n    # required longest length strict \n    # bitonic subsequence \n    return longLen\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [1, 5, 2, 3, 4, 5, 3, 2]\n    n = len(arr)\n    print('Longest length strict bitonic subsequence =',\n           longLenStrictBitonicSub(arr, n))\n \n# This code is contributed by sanjeev2552\n"], "Find Sum of all unique sub-array sum for a given array. -  ": ["# Python3 for finding sum of all \n# unique subarray sum\n \n# function for finding grandSum\ndef findSubarraySum(arr, n):\n     \n    # calculate cumulative sum of array\n    # cArray[0] will store sum of zero elements\n    cArray = [0 for i in range(n + 1)]\n    for i in range(0, n, 1):\n        cArray[i + 1] = cArray[i] + arr[i]\n \n    subArrSum = []\n \n    # store all subarray sum in vector\n    for i in range(1, n + 1, 1):\n        for j in range(i, n + 1, 1):\n            subArrSum.append(cArray[j] -\n                             cArray[i - 1])\n \n    # sort the vector\n    subArrSum.sort(reverse = False)\n \n    # mark all duplicate sub-array\n    # sum to zero\n    totalSum = 0\n    for i in range(0, len(subArrSum) - 1, 1):\n        if (subArrSum[i] == subArrSum[i + 1]):\n            j = i + 1\n            while (subArrSum[j] == subArrSum[i] and\n                           j < len(subArrSum)):\n                subArrSum[j] = 0\n                j += 1\n            subArrSum[i] = 0\n \n    # calculate total sum\n    for i in range(0, len(subArrSum), 1):\n        totalSum += subArrSum[i]\n \n    # return totalSum\n    return totalSum\n \n# Drivers code\nif __name__ == '__main__':\n    arr = [3, 2, 3, 1, 4]\n    n = len(arr)\n    print(findSubarraySum(arr, n))\n     \n# This code is contributed by\n# Sahil_Shelangia\n", "# Python3 for finding sum of all\n# unique subarray sum\n \n# function for finding grandSum\ndef findSubarraySum(arr, n):\n \n    res = 0\n \n    # Go through all subarrays, compute sums\n    # and count occurrences of sums.\n    m = dict()\n    for i in range(n):\n        Sum = 0\n        for j in range(i, n):\n            Sum += arr[j]\n            m[Sum] = m.get(Sum, 0) + 1\n         \n    # Print all those Sums that appear\n    # once.\n    for x in m:\n        if m[x] == 1:\n            res += x\n \n    return res\n \n# Driver code\narr = [3, 2, 3, 1, 4]\nn = len(arr)\nprint(findSubarraySum(arr, n))\n \n# This code is contributed by mohit kumar\n"], "Maximum array from two given arrays keeping order same -  ": ["# Python3 program to implement the\n# above approach\n# Make a set of maximum elements\n# from two arrays A[] and B[]\nfrom collections import defaultdict\n \n \ndef maximizeTheFirstArray(A, B, n):\n \n    # Create copies of A[] and B[]\n    # and sort the copies in\n    # descending order.\n    temp1 = A.copy()\n    temp2 = B.copy()\n    temp1.sort(reverse=True)\n    temp2.sort(reverse=True)\n \n    # Put maximum n distinct\n    # elements of both sorted\n    # arrays in a map.\n    m = defaultdict(int)\n    i = 0\n    j = 0\n \n    while (len(m) < n):\n        if (temp1[i] >= temp2[j]):\n            m[temp1[i]] += 1\n            i += 1\n        else:\n            m[temp2[j]] += 1\n            j += 1\n \n    # Copy elements of A[] to that\n    # are present in hash m.\n    res = []\n \n    for i in range(n):\n        if (A[i] in m):\n            res.append(A[i])\n \n    # Copy elements of B[] to that\n    # are present in hash m. This time\n    # we also check if the element did\n    # not appear twice.\n    for i in range(n):\n        if (B[i] in m and\n                m[B[i]] == 1):\n            res.append(B[i])\n \n    # Print result\n    for i in range(n):\n        print(res[i], end=' ')\n \n \n# Driver code\nif __name__ == '__main__':\n \n    A = [9, 7, 2, 3, 6]\n    B = [7, 4, 8, 0, 1]\n    n = len(A)\n    maximizeTheFirstArray(A, B, n)\n \n# This code is contributed by Chitranayal\n"], "Count subarrays having total distinct elements same as original array -  ": ["# Python3 program to count total number of sub-arrays\n# having total distinct elements same as that\n# original array.\n \n# Function to calculate distinct sub-array\ndef countDistictSubarray(arr, n):\n    unst1 = set(arr)\n    totalDist = len(unst1)\n    count = 0\n \n    for i in range(n):\n        unst = set()\n        for j in range(i, n):\n            unst.add(arr[j])\n            if len(unst) == totalDist:\n                count += 1\n \n    return count\n \n# Driver code\narr = [2, 1, 3, 2, 3]\nn = len(arr)\n \nprint(countDistictSubarray(arr, n))\n# This code is contributed by Prajwal Kandekar\n", "# Python3 program Count total number of \n# sub-arrays having total distinct elements \n# same as that original array.\n \n# Function to calculate distinct sub-array\ndef countDistictSubarray(arr, n):\n \n    # Count distinct elements in whole array\n    vis = dict()\n    for i in range(n):\n        vis[arr[i]] = 1\n    k = len(vis)\n \n    # Reset the container by removing\n    # all elements\n    vid = dict()\n \n    # Use sliding window concept to find\n    # count of subarrays having k distinct\n    # elements.\n    ans = 0\n    right = 0\n    window = 0\n    for left in range(n):\n     \n        while (right < n and window < k):\n \n            if arr[right] in vid.keys():\n                vid[ arr[right] ] += 1\n            else:\n                vid[ arr[right] ] = 1\n \n            if (vid[ arr[right] ] == 1):\n                window += 1\n \n            right += 1\n         \n        # If window size equals to array distinct \n        # element size, then update answer\n        if (window == k):\n            ans += (n - right + 1)\n \n        # Decrease the frequency of previous \n        # element for next sliding window\n        vid[ arr[left] ] -= 1\n \n        # If frequency is zero then decrease \n        # the window size\n        if (vid[ arr[left] ] == 0):\n            window -= 1\n     \n    return ans\n \n# Driver code\narr = [2, 1, 3, 2, 3]\nn = len(arr)\n \nprint(countDistictSubarray(arr, n))\n \n# This code is contributed by\n# mohit kumar 29\n"], "Cuckoo Hashing - Worst case O(1) Lookup! -  ": ["# upper bound on number of elements in our set\nMAXN = 11\n \n# choices for position\nver = 2\n \n# Auxiliary space bounded by a small multiple\n# of MAXN, minimizing wastage\nhashtable = [[float('inf')] * MAXN for _ in range(ver)]\n \n# Array to store possible positions for a key\npos = [0] * ver\n \ndef init_table():\n    '''function to fill hash table with dummy value\n    dummy value: float('inf')\n    number of hashtables: ver'''\n    for i in range(ver):\n        for j in range(MAXN):\n            hashtable[i][j] = float('inf')\n \ndef hash(function, key):\n    '''return hashed value for a key\n    function: ID of hash function according to which key has to hashed\n    key: item to be hashed'''\n    if function == 1:\n        return key % MAXN\n    elif function == 2:\n        return (key // MAXN) % MAXN\n \ndef place(key, table_id, cnt, n):\n    '''function to place a key in one of its possible positions\n    table_id: table in which key has to be placed, also equal to function\n    according to which key must be hashed\n    cnt: number of times function has already been called in order to place\n    the first input key\n    n: maximum number of times function can be recursively called before\n    stopping and declaring presence of cycle'''\n    # if function has been recursively called max number of times, stop\n    # and declare cycle. Rehash.\n    if cnt == n:\n        print(f'{key} unpositioned')\n        print('Cycle present. REHASH.')\n        return\n \n    # calculate and store possible positions for the key. check if key\n    # already present at any of the positions. If YES, return.\n    for i in range(ver):\n        pos[i] = hash(i + 1, key)\n        if hashtable[i][pos[i]] == key:\n            return\n \n    # check if another key is already present at the position for the\n    # new key in the table\n    # If YES: place the new key in its position and place the older key\n    # in an alternate position for it in the next table\n    if hashtable[table_id][pos[table_id]] != float('inf'):\n        dis = hashtable[table_id][pos[table_id]]\n        hashtable[table_id][pos[table_id]] = key\n        place(dis, (table_id + 1) % ver, cnt + 1, n)\n    else: # else: place the new key in its position\n        hashtable[table_id][pos[table_id]] = key\n \ndef print_table():\n    '''function to print hash table contents'''\n    print('Final hash tables:')\n    for i in range(ver):\n        print()\n        for j in range(MAXN):\n            if hashtable[i][j] == float('inf'):\n                print('- ', end='')\n            else:\n                print(f'{hashtable[i][j]} ', end='')\n    print()\n \ndef cuckoo(keys, n):\n    # initialize hash tables to a dummy value (float('inf'))\n    # indicating empty position\n    init_table()\n \n    # start with placing every key at its position in the first\n    # hash table according to first hash function\n    for i in range(n):\n        cnt = 0\n        place(keys[i], 0, cnt, n)\n \n    # print the final hash tables\n    print_table()\n \n# driver function\ndef main():\n    # following array doesn't have any cycles and\n    # hence  all keys will be inserted without any\n    # rehashing \n    keys_1 = [20, 50, 53, 75, 100, 67, 105, 3, 36, 39]\n \n    cuckoo(keys_1, len(keys_1))\n \n    # following array has a cycle and hence we will\n    # have to rehash to position every key\n    keys_2 = [20, 50, 53, 75, 100, 67, 105, 3, 36, 39, 6]\n \n    cuckoo(keys_2, len(keys_2))\n \nif __name__ == '__main__':\n    main()\n \n# This code is contributed by vikramshirsath177\n"], "Elements to be added so that all elements of a range are present in array -  ": ["# python program for above implementation \n  \n# Function to count numbers to be added \ndef countNum(arr, n):  \n      \n    count = 0\n  \n    # Sort the array \n    arr.sort() \n  \n    # Check if elements are consecutive \n    # or not. If not, update count \n    for i in range(0, n-1): \n        if (arr[i] != arr[i+1] and\n            arr[i] != arr[i + 1] - 1): \n            count += arr[i + 1] - arr[i] - 1; \n  \n    return count \n  \n# Drivers code \narr = [ 3, 5, 8, 6 ] \nn = len(arr) \nprint(countNum(arr, n)) \n  \n# This code is contributed by Sam007 \n", "# Function to count numbers to be added \ndef countNum(arr, n): \n  \n    s = dict() \n    count, maxm, minm = 0, -10**9, 10**9\n  \n    # Make a hash of elements and store  \n    # minimum and maximum element \n    for i in range(n): \n        s[arr[i]] = 1\n        if (arr[i] < minm): \n            minm = arr[i] \n        if (arr[i] > maxm): \n            maxm = arr[i] \n      \n    # Traverse all elements from minimum \n    # to maximum and count if it is not \n    # in the hash \n    for i in range(minm, maxm + 1): \n        if i not in s.keys(): \n            count += 1\n    return count \n  \n# Driver code \narr = [3, 5, 8, 6 ] \nn = len(arr) \nprint(countNum(arr, n)) \n      \n# This code is contributed by mohit kumar \n", "import sys \n  \n# Function to count the number of elements to add to the array \n  \n  \ndef countToAdd(arr, N): \n    # Find the minimum and maximum values in the array \n    A = sys.maxsize \n    B = -sys.maxsize - 1\n    for i in range(N): \n        A = min(A, arr[i]) \n        B = max(B, arr[i]) \n  \n    # Create a boolean array called present to keep track of which elements are in the range \n    present = [False] * (B - A + 1) \n  \n    # Loop over the input array, and set the corresponding element in the present array to true for each element \n    for i in range(N): \n        if not present[arr[i] - A]:  # Check if the element is in the range [A, B] \n            present[arr[i] - A] = True\n  \n    # Count the number of elements that are not yet present in the present array \n    count = 0\n    for i in range(A, B + 1): \n        if not present[i - A]:  # Check if the element is in the range [A, B] \n            count += 1\n  \n    # Return the count \n    return count \n  \n  \narr = [4, 7, 2, 8, 5] \nN = len(arr) \n  \n# Call the countToAdd function to find the number of elements to add to the array \ncount = countToAdd(arr, N) \n  \n# Output the result \nprint('Number of elements to be added:', count) \n"], "Range Queries for Frequencies of array elements -  ": ["# Python program to find total   \n# count of an element in a range \n  \n# Returns count of element \n# in arr[left-1..right-1] \ndef findFrequency(arr, n, left, right, element): \n  \n    count = 0\n    for i in range(left - 1, right): \n        if (arr[i] == element): \n            count += 1\n    return count \n  \n  \n# Driver Code \narr = [2, 8, 6, 9, 8, 6, 8, 2, 11] \nn = len(arr) \n  \n# Print frequency of 2 from position 1 to 6 \nprint('Frequency of 2 from 1 to 6 = ', \n        findFrequency(arr, n, 1, 6, 2)) \n  \n# Print frequency of 8 from position 4 to 9 \nprint('Frequency of 8 from 4 to 9 = ', \n        findFrequency(arr, n, 4, 9, 8)) \n          \n      \n# This code is contributed by Anant Agarwal. \n", "# Python3 program to find total count of an element \nfrom collections import defaultdict as dict\nfrom bisect import bisect_left as lower_bound \nfrom bisect import bisect_right as upper_bound \n  \nstore = dict(list) \n  \n# Returns frequency of element  \n# in arr[left-1..right-1] \ndef findFrequency(arr, n, left, right, element): \n      \n    # Find the position of  \n    # first occurrence of element \n    a = lower_bound(store[element], left) \n  \n    # Find the position of \n    # last occurrence of element \n    b = upper_bound(store[element], right) \n  \n    return b - a \n  \n# Driver code \narr = [2, 8, 6, 9, 8, 6, 8, 2, 11] \nn = len(arr) \n  \n# Storing the indexes of \n# an element in the map \nfor i in range(n): \n    store[arr[i]].append(i + 1) \n  \n# Print frequency of 2 from position 1 to 6 \nprint('Frequency of 2 from 1 to 6 = ',  \n       findFrequency(arr, n, 1, 6, 2)) \n  \n# Print frequency of 8 from position 4 to 9 \nprint('Frequency of 8 from 4 to 9 = ', \n       findFrequency(arr, n, 4, 9, 8)) \n  \n# This code is contributed by Mohit Kumar \n"], "All unique triplets that sum up to a given value -  ": ["# Python program to find unique triplets\n# that sum up to a given value.\n \n# Function to find unique triplets that\n# sum up to a given value.\ndef findTriplets(nums, n, Sum):\n    i = 0\n    j = 0\n    k = 0\n \n    # list to store all unique triplets.\n    triplet = []\n \n    # list to store already found triplets\n    # to avoid duplication.\n    uniqTriplets = []\n \n    # Variable used to hold triplet\n    # converted to string form.\n    temp = ''\n \n    # Variable used to store current\n    # triplet which is stored in vector\n    # if it is unique.\n    newTriplet = [0, 0, 0]\n \n    # Sort the input array.\n    nums.sort()\n \n    # Iterate over the array from the\n    # start and consider it as the\n    # first element.\n    for i in range(n - 2):\n         \n        # index of the first element in\n        # the remaining elements.\n        j = i + 1\n \n        # index of the last element.\n        k = n - 1\n \n        while(j < k):\n           \n            # If sum of triplet is equal to\n            # given value, then check if\n            # this triplet is unique or not.\n            # To check uniqueness, convert\n            # triplet to string form and\n            # then check if this string is\n            # present in set or not. If\n            # triplet is unique, then store\n            # it in list.\n            if(nums[i] + nums[j] + nums[k] == Sum):\n                temp = str(nums[i]) + ':' + str(nums[j]) + ':' + str(nums[k])\n                if temp not in uniqTriplets:\n                    uniqTriplets.append(temp)\n                    newTriplet[0] = nums[i]\n                    newTriplet[1] = nums[j]\n                    newTriplet[2] = nums[k]\n                    triplet.append(newTriplet)\n                    newTriplet = [0, 0, 0]\n \n                # Increment the first index\n                # and decrement the last\n                # index of remaining elements.\n                j += 1\n                k -= 1\n                 \n            # If sum is greater than given\n            # value then to reduce sum\n            # decrement the last index.\n            elif(nums[i] + nums[j] + nums[k] > Sum):\n                k -= 1\n                 \n            # If sum is less than given value\n            # then to increase sum increment\n            # the first index of remaining\n            # elements.\n            else:\n                j += 1\n \n    # If no unique triplet is found, then\n       # return 0.\n    if(len(triplet) == 0):\n        return 0\n     \n    # Print all unique triplets stored in\n    # list.\n    for i in range(len(triplet)):\n        print(triplet[i], end = ', ')\n    return 1\n \n# Driver Code\nnums = [12, 3, 6, 1, 6, 9]\nn = len(nums)\nSum = 24\n \n# Function call\nif(not findTriplets(nums, n, Sum)):\n    print('No triplets can be formed.')\n \n# This code is contributed by rag2127\n", "# Python3 program to find all \n# unique triplets without using \n# any extra space.\n \n# Function to all find unique \n# triplets without using extra \n# space\ndef findTriplets(a, n, sum):\n \n    # Sort the input array\n    a.sort()\n \n    # For handling the cases \n    # when no such triplets exits.\n    flag = False\n \n    # Iterate over the array from \n    # start to n-2.\n    for i in range(n - 2):\n        if (i == 0 or\n            a[i] > a[i - 1]):\n \n            # Index of the first \n            # element in remaining \n            # range.\n            start = i + 1\n \n            # Index of the last \n            # element\n            end = n - 1\n \n            # Setting our new target\n            target = sum - a[i]\n \n            while (start < end):\n \n                # Checking if current element\n                # is same as previous\n                if (start > i + 1 and\n                    a[start] == a[start - 1]):\n \n                    start += 1\n                    continue\n \n                # Checking if current\n                # element is same as \n                # previous\n                if (end < n - 1 and\n                    a[end] == a[end + 1]):\n                    end -= 1\n                    continue\n \n                # If we found the triplets \n                # then print it and set the \n                # flag\n                if (target == a[start] + a[end]):\n                    print('[', a[i], ',', \n                          a[start], ',', \n                          a[end], ']',\n                          end = ' ')\n                    flag = True\n                    start += 1\n                    end -= 1\n \n                # If target is greater then\n                #  increment the start index\n                elif (target >\n                     (a[start] + a[end])):\n                    start += 1\n \n                # If target is smaller than\n                # decrement the end index\n                else:\n                    end -= 1\n \n    # If no such triplets found\n    if (flag == False):\n        print('No Such Triplets Exist')\n \n# Driver code\nif __name__ == '__main__':\n \n    a = [12, 3, 6, 1, 6, 9]\n    n = len(a)\n    sum = 24\n \n    # Function call\n    findTriplets(a, n, sum)\n \n# This code is contributed by Chitranayal\n"], "Clone a Binary Tree with Random Pointers -  ": ["# A hashmap based Python program to clone a binary\n# tree with random pointers\n \nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.random = None\n \n# Helper function that allocates a new Node with the\n# given data and None left, right and random pointers.\ndef new_node(key):\n    temp = Node(key)\n    return temp\n \n# Given a binary tree, print its Nodes in inorder\ndef print_inorder(node):\n    if node == None:\n        return\n    # First recur on left subtree\n    print_inorder(node.left)\n    # then print data of Node and its random\n    print('[', node.key, end=', ')\n    if node.random == None:\n        print('None], ', end='')\n    else:\n        print(node.random.key, '], ', end='')\n    # now recur on right subtree\n    print_inorder(node.right)\n \n# This function creates clone by copying key\n# and left and right pointers. This function also\n# stores mapping from given tree node to clone.\ndef copy_left_right_node(tree_node, mymap):\n    if tree_node == None:\n        return None\n    clone_node = new_node(tree_node.key)\n    mymap[tree_node] = clone_node\n    clone_node.left = copy_left_right_node(tree_node.left, mymap)\n    clone_node.right = copy_left_right_node(tree_node.right, mymap)\n    return clone_node\n \n# This function copies random node by using the hashmap built by\n# copy_left_right_node()\ndef copy_random(tree_node, mymap):\n    if tree_node is None:\n        return\n    if tree_node.random is not None:\n        mymap[tree_node].random = mymap[tree_node.random]\n    copy_random(tree_node.left, mymap)\n    copy_random(tree_node.right, mymap)\n \n# This function makes the clone of given tree. It mainly uses\n# copy_left_right_node() and copy_random()\ndef clone_tree(tree):\n    if tree == None:\n        return None\n    mymap = {}\n    new_tree = copy_left_right_node(tree, mymap)\n    copy_random(tree, mymap)\n    return new_tree\n \n# Driver code\nif __name__ == '__main__':\n    # Test Case 1\n    tree = Node(1)\n    tree.left = Node(2)\n    tree.right = Node(3)\n    tree.left.left = Node(4)\n    tree.left.right = Node(5)\n    tree.random = tree.left.right\n    tree.left.left.random = tree\n    tree.left.right.random = tree.right\n \n    # Test Case 2\n    # tree = None\n \n    # Test Case 3\n    # tree = newNode(1)\n \n    # Test Case 4\n    '''\n    tree = newNode(1)\n    tree.left = newNode(2)\n    tree.right = newNode(3)\n    tree.random = tree.right\n    tree.left.random = tree\n    '''\n \n    print('Inorder traversal of original binary tree is:')\n    print_inorder(tree)\n \n    clone = clone_tree(tree)\n \n    print('\\n\\nInorder traversal of cloned binary tree is:')\n    print_inorder(clone)\n"], "Smallest subarray with k distinct numbers -  ": ["# Python 3 program to find minimum range \n# that contains exactly k distinct numbers.\n \n# Prints the minimum range that contains \n# exactly k distinct numbers.\ndef minRange(arr, n, k):\n \n    l = 0\n    r = n\n \n    # Consider every element as \n    # starting point.\n    for i in range(n):\n \n        # Find the smallest window starting\n        # with arr[i] and containing exactly\n        # k distinct elements.\n        s = []\n        for j in range(i, n) :\n            s.append(arr[j])\n            if (len(s) == k):\n                if ((j - i) < (r - l)) :\n                    r = j\n                    l = i\n                 \n                break\n \n        # There are less than k distinct \n        # elements now, so no need to continue.\n        if (j == n):\n            break\n \n    # If there was no window with k distinct\n    # elements (k is greater than total \n    # distinct elements)\n    if (l == 0 and r == n):\n        print('Invalid k')\n    else:\n        print(l, r)\n \n# Driver code \nif __name__ == '__main__':\n     \n    arr = [ 1, 2, 3, 4, 5 ]\n    n = len(arr)\n    k = 3\n    minRange(arr, n, k)\n \n# This code is contributed \n# by ChitraNayal\n", "# Python3 program to find the minimum range \n# that contains exactly k distinct numbers. \nfrom collections import defaultdict\n \n# Prints the minimum range that contains \n# exactly k distinct numbers. \ndef minRange(arr, n, k): \n  \n    # Initially left and right side is -1 \n    # and -1, number of distinct elements \n    # are zero and range is n. \n    l, r = 0, n \n    i = 0\n    j = -1 # Initialize right side \n     \n    hm = defaultdict(lambda:0) \n    while i < n: \n      \n        while j < n: \n          \n            # increment right side. \n            j += 1\n   \n            # if number of distinct elements less than k. \n            if len(hm) < k and j < n:\n                hm[arr[j]] += 1\n   \n            # if distinct elements are equal to k \n            # and length is less than previous length. \n            if len(hm) == k and ((r - l) >= (j - i)): \n              \n                l, r = i, j \n                break\n   \n        # if number of distinct elements less \n        # than k, then break. \n        if len(hm) < k:\n            break\n   \n        # if distinct elements equals to k then \n        # try to increment left side. \n        while len(hm) == k: \n   \n            if hm[arr[i]] == 1: \n                del(hm[arr[i]]) \n            else:\n                hm[arr[i]] -= 1\n   \n            # increment left side. \n            i += 1\n   \n            # it is same as explained in above loop. \n            if len(hm) == k and (r - l) >= (j - i): \n              \n                l, r = i, j \n          \n        if hm[arr[i]] == 1: \n            del(hm[arr[i]]) \n        else:\n            hm[arr[i]] -= 1\n             \n        i += 1\n   \n    if l == 0 and r == n:\n        print('Invalid k') \n    else:\n        print(l, r) \n  \n# Driver code for above function. \nif __name__ == '__main__': \n  \n    arr = [1, 1, 2, 2, 3, 3, 4, 5]  \n    n = len(arr) \n    k = 3\n    minRange(arr, n, k) \n     \n# This code is contributed by Rituraj Jain \n"], "Sorting using trivial hash function -  ": ["# Python3 program to sort an array\n# using hash function\n \n \ndef sortUsingHash(a, n):\n \n    # find the maximum element\n    Max = max(a)\n \n    # create a hash function upto\n    # the max size\n    Hash = [0] * (Max + 1)\n \n    # traverse through all the elements\n    # and keep a count\n    for i in range(0, n):\n        Hash[a[i]] += 1\n \n    # Traverse upto all elements and check\n    # if it is present or not. If it is\n    # present, then print the element the\n    # number of times it's present. Once we\n    # have printed n times, that means we\n    # have printed n elements so break out\n    # of the loop\n    for i in range(0, Max + 1):\n \n        # if present\n        if Hash[i] != 0:\n \n            # print the element that number\n            # of times it's present\n            for j in range(0, Hash[i]):\n                print(i, end=' ')\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    a = [9, 4, 3, 2, 5, 2, 1, 0, 4,\n         3, 5, 10, 15, 12, 18, 20, 19]\n    n = len(a)\n \n    sortUsingHash(a, n)\n \n# This code is contributed by Rituraj Jain\n", "# Python3 program to sort an array using hash\n# function with negative values allowed.\n \n \ndef sortUsingHash(a, n):\n \n    # find the maximum element\n    Max = max(a)\n    Min = abs(min(a))\n \n    # create a hash function upto the max size\n    hashpos = [0] * (Max + 1)\n    hashneg = [0] * (Min + 1)\n \n    # traverse through all the elements and\n    # keep a count\n    for i in range(0, n):\n        if a[i] >= 0:\n            hashpos[a[i]] += 1\n        else:\n            hashneg[abs(a[i])] += 1\n \n    # Traverse up to all negative elements\n    # and check if it is present or not.\n    # If it is present, then print the\n    # element the number of times it's present.\n    # Once we have printed n times, that means\n    # we have printed n elements so break out\n    # of the loop\n    for i in range(Min, 0, -1):\n        if hashneg[i] != 0:\n \n            # print the element that number of times\n            # it's present. Print the negative element\n            for j in range(0, hashneg[i]):\n                print((-1) * i, end=' ')\n \n    # Traverse upto all elements and check if\n    # it is present or not. If it is present,\n    # then print the element the number of\n    # times it's present once we have printed\n    # n times, that means we have printed n\n    # elements, so break out of the loop\n    for i in range(0, Max + 1):\n \n        # if present\n        if hashpos[i] != 0:\n \n            # print the element that number\n            # of times it's present\n            for j in range(0, hashpos[i]):\n                print(i, end=' ')\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    a = [-1, -2, -3, -4, -5, -6,\n         8, 7, 5, 4, 3, 2, 1, 0]\n \n    n = len(a)\n    sortUsingHash(a, n)\n \n# This code is contributed by Rituraj Jain\n"], "Maximum possible difference of two subsets of an array -  ": ["# Python3 find maximum difference \n# of subset sum \n  \nimport math \n  \n# function for maximum subset diff \ndef maxDiff(arr, n) : \n    SubsetSum_1 = 0\n    SubsetSum_2 = 0\n    for i in range(0, n) : \n  \n        isSingleOccurrence = True\n        for j in range(i + 1, n) : \n  \n            # if frequency of any element \n            # is two make both equal to  \n            # zero \n            if (arr[i] == arr[j]) :  \n                isSingleOccurrence = False\n                arr[i] = arr[j] = 0\n                break\n  \n        if (isSingleOccurrence == True) : \n            if (arr[i] > 0) : \n                SubsetSum_1 += arr[i] \n            else : \n                SubsetSum_2 += arr[i] \n  \n    return abs(SubsetSum_1 - SubsetSum_2) \n  \n# Driver Code \narr = [4, 2, -3, 3, -2, -2, 8] \nn = len(arr) \nprint ('Maximum Difference = {}'\n               . format(maxDiff(arr, n))) \n  \n# This code is contributed by Manish Shaw \n# (manishshaw1) \n", "# Python 3 find maximum difference  \n# of subset sum \n  \n# function for maximum subset diff \ndef maxDiff(arr, n): \n  \n    result = 0\n  \n    # sort the array \n    arr.sort() \n  \n    # calculate the result \n    for i in range(n - 1): \n        if (abs(arr[i]) != abs(arr[i + 1])): \n            result += abs(arr[i]) \n  \n        else: \n            pass\n  \n    # check for last element \n    if (arr[n - 2] != arr[n - 1]): \n        result += abs(arr[n - 1]) \n  \n    # return result \n    return result \n  \n# Driver Code \nif __name__ == '__main__': \n      \n    arr = [ 4, 2, -3, 3, -2, -2, 8 ] \n    n = len(arr) \n    print('Maximum Difference = ' , \n                   maxDiff(arr, n)) \n  \n# This code is contributed by ita_c \n", "# Python3 find maximum difference of subset sum \n  \n# function for maximum subset diff \ndef maxDiff(arr, n): \n  \n    hashPositive = dict() \n    hashNegative = dict() \n  \n    SubsetSum_1, SubsetSum_2 = 0, 0\n  \n    # construct hash for positive elements \n    for i in range(n): \n        if (arr[i] > 0): \n            hashPositive[arr[i]] = \\ \n                hashPositive.get(arr[i], 0) + 1\n  \n    # calculate subset sum for positive elements \n    for i in range(n): \n        if (arr[i] > 0 and arr[i] in \n            hashPositive.keys() and \n            hashPositive[arr[i]] == 1): \n            SubsetSum_1 += arr[i] \n  \n    # construct hash for negative elements \n    for i in range(n): \n        if (arr[i] < 0): \n            hashNegative[abs(arr[i])] = \\ \n                hashNegative.get(abs(arr[i]), 0) + 1\n  \n    # calculate subset sum for negative elements \n    for i in range(n): \n        if (arr[i] < 0 and abs(arr[i]) in \n            hashNegative.keys() and \n            hashNegative[abs(arr[i])] == 1): \n            SubsetSum_2 += arr[i] \n  \n    return abs(SubsetSum_1 - SubsetSum_2) \n  \n# Driver Code \narr = [4, 2, -3, 3, -2, -2, 8] \nn = len(arr) \nprint('Maximum Difference =', maxDiff(arr, n)) \n  \n# This code is contributed by mohit kumar \n"], "Implementing own Hash Table with Open Addressing Linear Probing -  ": ["# Our own Hashnode class\nclass HashNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n \n# Our own Hashmap class\nclass HashMap:\n    # hash element array\n    def __init__(self):\n        self.capacity = 20\n        self.size = 0\n        self.arr = [None] * self.capacity\n        # dummy node\n        self.dummy = HashNode(-1, -1)\n \n    # This implements hash function to find index for a key\n    def hashCode(self, key):\n        return key % self.capacity\n \n    # Function to add key value pair\n    def insertNode(self, key, value):\n        temp = HashNode(key, value)\n        # Apply hash function to find index for given key\n        hashIndex = self.hashCode(key)\n        # find next free space\n        while self.arr[hashIndex] is not None and self.arr[hashIndex].key != key and self.arr[hashIndex].key != -1:\n            hashIndex += 1\n            hashIndex %= self.capacity\n        # if new node to be inserted, increase the current size\n        if self.arr[hashIndex] is None or self.arr[hashIndex].key == -1:\n            self.size += 1\n        self.arr[hashIndex] = temp\n \n    # Function to delete a key value pair\n    def deleteNode(self, key):\n        # Apply hash function to find index for given key\n        hashIndex = self.hashCode(key)\n        # finding the node with given key\n        while self.arr[hashIndex] is not None:\n            # if node found\n            if self.arr[hashIndex].key == key:\n                temp = self.arr[hashIndex]\n                # Insert dummy node here for further use\n                self.arr[hashIndex] = self.dummy\n                # Reduce size\n                self.size -= 1\n                return temp.value\n            hashIndex += 1\n            hashIndex %= self.capacity\n        # If not found return None\n        return None\n \n    # Function to search the value for a given key\n    def get(self, key):\n        # Apply hash function to find index for given key\n        hashIndex = self.hashCode(key)\n        counter = 0\n        # finding the node with given key\n        while self.arr[hashIndex] is not None:\n            # If counter is greater than capacity to avoid infinite loop\n            if counter > self.capacity:\n                return None\n            # if node found return its value\n            if self.arr[hashIndex].key == key:\n                return self.arr[hashIndex].value\n            hashIndex += 1\n            hashIndex %= self.capacity\n            counter += 1\n        # If not found return None\n        return 0\n \n    # Return current size\n    def sizeofMap(self):\n        return self.size\n \n    # Return true if size is 0\n    def isEmpty(self):\n        return self.size == 0\n \n    # Function to display the stored key value pairs\n    def display(self):\n        for i in range(self.capacity):\n            if self.arr[i] is not None and self.arr[i].key != -1:\n                print('key = ', self.arr[i].key, ' value = ', self.arr[i].value)\n \n# Driver method to test map class\nif __name__ == '__main__':\n    h = HashMap()\n    h.insertNode(1, 1)\n    h.insertNode(2, 2)\n    h.insertNode(2, 3)\n    h.display()\n    print(h.sizeofMap())\n    print(h.deleteNode(2))\n    print(h.sizeofMap())\n    print(h.isEmpty())\n    print(h.get(2))\n"], "Implementing our Own Hash Table with Separate Chaining in Java -  ": [], "Find subarray with given sum | Set 2 (Handles Negative Numbers) -  ": ["# Python3 program to print subarray\n# with sum as given sum\n \n \n# Returns true if the there is a subarray\n# of arr[] with sum equal to 'sum' otherwise\n# returns false. Also, prints the result */\ndef subArraySum(arr, n, sum):\n \n    # Pick a starting point\n    for i in range(n):\n        curr_sum = 0\n        # try all subarrays starting with 'i'\n        for j in range(i, n):\n            curr_sum += arr[j]\n            if (curr_sum == sum):\n                print('Sum found between indexes', i, 'and', j)\n                return\n \n    print('No subarray found')\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [15, 2, 4, 8, 9, 5, 10, 23]\n    n = len(arr)\n    sum = 23\n \n    # Function Call\n    subArraySum(arr, n, sum)\n \n \n# This code is contributed by phasing17\n", "# Python3 program to print subarray with sum as given sum\n \n# Function to print subarray with sum as given sum\n \n \ndef subArraySum(arr, n, Sum):\n \n    # create an empty map\n    Map = {}\n \n    # Maintains sum of elements so far\n    curr_sum = 0\n \n    for i in range(0, n):\n \n        # add current element to curr_sum\n        curr_sum = curr_sum + arr[i]\n \n        # if curr_sum is equal to target sum\n        # we found a subarray starting from index 0\n        # and ending at index i\n        if curr_sum == Sum:\n \n            print('Sum found between indexes 0 to', i)\n            return\n \n        # If curr_sum - sum already exists in map\n        # we have found a subarray with target sum\n        if (curr_sum - Sum) in Map:\n \n            print('Sum found between indexes',\n                  Map[curr_sum - Sum] + 1, 'to', i)\n \n            return\n \n        Map[curr_sum] = i\n \n    # If we reach here, then no subarray exists\n    print('No subarray with given sum exists')\n \n \n# Driver code\nif __name__ == '__main__':\n \n    arr = [10, 2, -2, -20, 10]\n    n = len(arr)\n    Sum = -10\n \n    # Function call\n    subArraySum(arr, n, Sum)\n \n# This code is contributed by Rituraj Jain\n"], "Design a data structure that supports insert, delete, search and getRandom in constant time -  ": ["'''\nPython program to design a DS that \nsupports following operations\nin Theta(n) time:\na) Insert\nb) Delete\nc) Search\nd) getRandom\n'''\nimport random\n \n# Class to represent the required \n# data structure \nclass MyDS:\n \n    # Constructor (creates a list and a hash)\n    def __init__(self):\n         \n        # A resizable array\n        self.arr = []\n \n        # A hash where keys are lists elements \n        # and values are indexes of the list\n        self.hashd = {} \n \n    # A Theta(1) function to add an element \n    # to MyDS data structure\n    def add(self, x):\n         \n        # If element is already present, \n        # then nothing has to be done\n        if x in self.hashd:\n            return\n \n        # Else put element at\n        # the end of the list\n        s = len(self.arr)\n        self.arr.append(x)\n \n        # Also put it into hash\n        self.hashd[x] = s\n \n    # A Theta(1) function to remove an element\n    # from MyDS data structure \n    def remove(self, x):\n         \n        # Check if element is present\n        index = self.hashd.get(x, None)\n        if index == None:\n            return\n \n        # If present, then remove \n        # element from hash\n        del self.hashd[x]\n \n        # Swap element with last element \n        # so that removal from the list \n        # can be done in O(1) time\n        size = len(self.arr)\n        last = self.arr[size - 1]\n        self.arr[index], \\\n        self.arr[size - 1] = self.arr[size - 1], \\\n                             self.arr[index]\n \n        # Remove last element (This is O(1)) \n        del self.arr[-1]\n \n        # Update hash table for \n        # new index of last element\n        self.hashd[last] = index\n \n    # Returns a random element from MyDS \n    def getRandom(self):\n         \n         \n        # Find a random index from 0 to size - 1\n        index = random.randrange(0, len(self.arr))\n \n        # Return element at randomly picked index \n        return self.arr[index]\n \n    # Returns index of element\n    # if element is present, \n    # otherwise none\n    def search(self, x):\n        return self.hashd.get(x, None)\n \n# Driver Code\nif __name__=='__main__':\n    ds = MyDS()\n    ds.add(10)\n    ds.add(20)\n    ds.add(30)\n    ds.add(40)\n    print(ds.search(30))\n    ds.remove(20)\n    ds.add(50)\n    print(ds.search(50))\n    print(ds.getRandom())\n \n# This code is contributed \n# by Saurabh Singh\n"], "Count distinct elements in every window of size k -  ": ["# Python3 program to count distinct\n# elements in every window of size K\n \nimport math as mt\n \n# Counts distinct elements in window\n# of size K\n \n \ndef countWindowDistinct(win, K):\n \n    dist_count = 0\n \n    # Traverse the window\n    for i in range(K):\n \n        # Check if element arr[i] exists\n        # in arr[0..i-1]\n        j = 0\n        while j < i:\n            if (win[i] == win[j]):\n                break\n            else:\n                j += 1\n        if (j == i):\n            dist_count += 1\n \n    return dist_count\n \n \n# Counts distinct elements in all\n# windows of size k\ndef countDistinct(arr, N, K):\n \n    # Traverse through every window\n    for i in range(N - K + 1):\n        print(countWindowDistinct(arr[i:K + i], K))\n \n \n# Driver's Code\nif __name__=='__main__':\n  arr = [1, 2, 1, 3, 4, 2, 3]\n  K = 4\n  N = len(arr)\n   \n  # Function call\n  countDistinct(arr, N, K)\n \n# This code is contributed by\n# Mohit kumar 29\n", "# An efficient Python program to\n# count distinct elements in\n# every window of size K\nfrom collections import defaultdict\n \n \ndef countDistinct(arr, K, N):\n \n    # Creates an empty hashmap hm\n    mp = defaultdict(lambda: 0)\n \n    # initialize distinct element\n    # count for current window\n    dist_count = 0\n \n    # Traverse the first window and store count\n    # of every element in hash map\n    for i in range(K):\n        if mp[arr[i]] == 0:\n            dist_count += 1\n        mp[arr[i]] += 1\n \n    # Print count of first window\n    print(dist_count)\n \n    # Traverse through the remaining array\n    for i in range(K, N):\n \n        # Remove first element of previous window\n        # If there was only one occurrence,\n        # then reduce distinct count.\n        if mp[arr[i - K]] == 1:\n            dist_count -= 1\n        mp[arr[i - K]] -= 1\n \n    # Add new element of current window\n    # If this element appears first time,\n    # increment distinct element count\n        if mp[arr[i]] == 0:\n            dist_count += 1\n        mp[arr[i]] += 1\n \n        # Print count of current window\n        print(dist_count)\n \n# Driver's code\nif __name__=='__main__':\n  arr = [1, 2, 1, 3, 4, 2, 3]\n  N = len(arr)\n  K = 4\n \n  # Function call\n  countDistinct(arr, K, N)\n \n# This code is contributed by Shrikant13\n"], "Longest Increasing consecutive subsequence -  ": ["def longest_subsequence(a, n):\n    ans = 0\n \n    # Traverse every element to check if any\n    # increasing subsequence starts from this index\n    for i in range(n):\n        # Initialize cnt variable as 1, which defines\n        # the current length of the increasing subsequence\n        cnt = 1\n        for j in range(i + 1, n):\n            if a[j] == (a[i] + cnt):\n                cnt += 1\n \n        # Update the answer if the current length is\n        # greater than the already found length\n        ans = max(ans, cnt)\n \n    return ans\n \nif __name__ == '__main__':\n    a = [3, 10, 3, 11, 4, 5, 6, 7, 8, 12]\n    n = len(a)\n    print(longest_subsequence(a, n))\n", "# python program to find length of the \n# longest increasing subsequence \n# whose adjacent element differ by 1 \n \nfrom collections import defaultdict\nimport sys\n \n# function that returns the length of the \n# longest increasing subsequence \n# whose adjacent element differ by 1 \n \ndef longestSubsequence(a, n):\n    mp = defaultdict(lambda:0)\n \n    # stores the length of the longest \n    # subsequence that ends with a[i] \n    dp = [0 for i in range(n)]\n    maximum = -sys.maxsize\n \n    # iterate for all element \n    for i in range(n):\n \n        # if a[i]-1 is present before i-th index \n        if a[i] - 1 in mp:\n \n            # last index of a[i]-1 \n            lastIndex = mp[a[i] - 1] - 1\n \n            # relation \n            dp[i] = 1 + dp[lastIndex]\n        else:\n            dp[i] = 1\n \n            # stores the index as 1-index as we need to \n            # check for occurrence, hence 0-th index \n            # will not be possible to check \n        mp[a[i]] = i + 1\n \n        # stores the longest length \n        maximum = max(maximum, dp[i])\n    return maximum\n \n \n# Driver Code \na = [3, 10, 3, 11, 4, 5, 6, 7, 8, 12]\nn = len(a)\nprint(longestSubsequence(a, n))\n \n# This code is contributed by Shrikant13\n"], "Find the length of largest subarray with 0 sum -  ": ["# Python program for the above approach\n \n# returns the length\ndef maxLen(arr):\n     \n    # initialize result\n    max_len = 0\n \n    # pick a starting point\n    for i in range(len(arr)):\n         \n        # initialize sum for every starting point\n        curr_sum = 0\n         \n        # try all subarrays starting with 'i'\n        for j in range(i, len(arr)):\n         \n            curr_sum += arr[j]\n \n            # if curr_sum becomes 0, then update max_len\n            if curr_sum == 0:\n                max_len = max(max_len, j-i + 1)\n \n    return max_len\n \n# Driver's code\nif __name__ == '__main__':\n# test array\n    arr = [15, -2, 2, -8, 1, 7, 10, 13]\n     \n    # Function call\n    print ('Length of the longest 0 sum subarray is % d' % maxLen(arr))\n", "# Python program for the above approach\n \n# Returns the maximum length\n \n \ndef maxLen(arr):\n \n    # NOTE: Dictionary in python is\n    # implemented as Hash Maps\n    # Create an empty hash map (dictionary)\n    hash_map = {}\n \n    # Initialize result\n    max_len = 0\n \n    # Initialize sum of elements\n    curr_sum = 0\n \n    # Traverse through the given array\n    for i in range(len(arr)):\n \n        # Add the current element to the sum\n        curr_sum += arr[i]\n \n        if curr_sum == 0:\n            max_len = i + 1\n \n        # NOTE: 'in' operation in dictionary\n        # to search key takes O(1). Look if\n        # current sum is seen before\n        if curr_sum in hash_map:\n            max_len = max(max_len, i - hash_map[curr_sum])\n        else:\n \n            # else put this sum in dictionary\n            hash_map[curr_sum] = i\n \n    return max_len\n \n \n# Driver's code\nif __name__ == '__main__':\n \n    # test array\n    arr = [15, -2, 2, -8, 1, 7, 10, 13]\n \n    # Function call\n    print('Length of the longest 0 sum subarray is % d' % maxLen(arr))\n"], "Longest subarray with sum divisible by K -  ": ["# Python3 implementation to find the longest subarray\n# with sum divisible by k\n \ndef longestSubarrWthSumDivByK(arr, N, k):\n    maxl = 0\n    for i in range(N):\n        sum1 = 0\n        for j in range(i, N):\n            sum1 += arr[j]\n            if sum1 % k == 0:\n                maxl = max(maxl, j - i + 1)\n    return maxl\n \n# Driver code\narr = [2, 7, 6, 1, 4, 5]\nn = len(arr)\nk = 3\n \nprint('Length =', longestSubarrWthSumDivByK(arr, n, k))\n", "# Python3 implementation to find the\n# longest subarray with sum divisible by k\n \n# Function to find the longest\n# subarray with sum divisible by k\n \n \ndef longestSubarrWthSumDivByK(arr, n, k):\n \n    # unordered map 'um' implemented\n    # as hash table\n    um = {}\n \n    # 'mod_arr[i]' stores (sum[0..i] % k)\n    mod_arr = [0 for i in range(n)]\n    max_len = 0\n    curr_sum = 0\n \n    # Traverse arr[] and build up\n    # the array 'mod_arr[]'\n    for i in range(n):\n        curr_sum += arr[i]\n \n        # As the sum can be negative,\n        # taking modulo twice\n        mod_arr[i] = ((curr_sum % k) + k) % k\n \n        # If true then sum(0..i) is\n        # divisible by k\n        if (mod_arr[i] == 0):\n \n            # Update 'max_len'\n            max_len = i + 1\n \n        # If value 'mod_arr[i]' not present in\n        # 'um' then store it in 'um' with index\n        # of its first occurrence\n        elif (mod_arr[i] not in um):\n            um[mod_arr[i]] = i\n \n        else:\n              # If true, then update 'max_len'\n            if (max_len < (i - um[mod_arr[i]])):\n                max_len = i - um[mod_arr[i]]\n \n    # Return the required length of longest subarray\n    # with sum divisible by 'k'\n    return max_len\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    arr = [2, 7, 6, 1, 4, 5]\n    n = len(arr)\n    k = 3\n \n    print('Length =',\n          longestSubarrWthSumDivByK(arr, n, k))\n \n# This code is contributed by Surendra_Gangwar, updated by Kshitij Dwivedi\n", "# function to find the longest subarray\n#  with sum divisible by k\n \n \ndef longestSubarrWthSumDivByK(arr, n, k):\n \n    # unordered map 'um' implemented as\n    # hash table\n    um = {}\n \n    max_len = 0\n    curr_sum = 0\n \n    for i in range(n):\n \n        curr_sum += arr[i]\n        mod = ((curr_sum % k) + k) % k\n        # if true then sum(0..i) is divisible by k\n \n        if mod == 0:\n            # update 'max_len'\n            max_len = i + 1\n \n        # if value 'mod_arr[i]' not present in 'um'\n        # then store it in 'um' with index of its\n        # first occurrence\n        elif mod in um.keys():\n            if max_len < (i - um[mod]):\n                max_len = i - um[mod]\n \n        else:\n            um[mod] = i\n \n    # return the required length of longest subarray with\n    # sum divisible by 'k'\n    return max_len\n \n \narr = [2, 7, 6, 1, 4, 5]\nn = len(arr)\nk = 3\nprint('Length =', longestSubarrWthSumDivByK(arr, n, k))\n \n# This code is contributed by amreshkumar3, and updated by Kshitij Dwivedi\n"], "Find number of Employees Under every Manager -  ": ["class Solution():\n    def __init__(self):\n        pass\n \n    def assignAndPrint(self,t):\n        #We will directly permute over t. Access 2nd element(i.e. manager) of certain tuple and assign the relation in\n        # dictionary. We will assign list of employees to a particular manager so that with iterations, we can append\n        # more employees to that list and list grows.\n        d = dict()\n        for pair in t:\n            if(pair[0]==pair[1]):  # because we dont want to assign self managing role\n                continue\n            if pair[0] not in d:  # assign employee a empty list of employees\n                d[pair[0]] = []\n            # for managers -\n            if pair[1] not in d:\n                d[pair[1]] = [pair[0]]\n            else:\n                d[pair[1]].append(pair[0])\n        #print(d)\n        # now we know how many employees are directly under a particular manager.\n        # now lets count the total number of employees under a particular manager.\n        c = dict()   # store    manager:count of employee    as key value\n        for manager in d:\n            c[manager] = len(d[manager])\n            for employee in d[manager]:\n                c[manager] += len(d[employee])\n            print('{} : {}'.format(manager,c[manager]))     # prints which manager has total how many employees\n        # Note : Employees having no employees under are also considered as managed with 0 employees.\n \n \nif __name__=='__main__':\n    # t is tuple containing employee and boss pair.\n    t = (('A', 'C'),('B', 'C'),('C', 'F'),('D', 'E'),('E', 'F'),('F', 'F'))\n    obj = Solution()\n    obj.assignAndPrint(t)\n"], "Find Itinerary from a given list of tickets -  ": ["class Solution():\n    #Solution class carries method for printing itinerary\n    def __init__(self):\n        pass\n    #method for printing itinerary\n    def printItinerary(self,d):\n        # First step : create a reversed mapping. Here also for storing key value pairs dictionary is used.\n        reverse_d = dict()\n        for i in d:\n            reverse_d[d[i]] = i\n        # Second step : find the starting point. Starting point will be that value which is not present in 'd' as key.\n        for i in reverse_d:\n            if reverse_d[i] not in reverse_d:\n                starting_pt = reverse_d[i]\n                break;\n        #Third step : simply proceed one by one to print whole route. Assuming that there exist Starting point.\n        while(starting_pt in d):\n            print(starting_pt,'->',d[starting_pt],end=', ')\n            starting_pt = d[starting_pt]\n        #method prints here only. Does not return anything.\n \n \nif __name__=='__main__':\n    # Mapping using inbuilt data structure 'dictionary'\n    d = dict()\n    d['Chennai'] = 'Banglore'\n    d['Bombay'] = 'Delhi'\n    d['Goa'] = 'Chennai'\n    d['Delhi'] = 'Goa'\n \n    # call for method that would print itinerary.\n    obj = Solution()\n    obj.printItinerary(d)\n"], "k-th distinct (or non-repeating) element among unique elements in an array. -  ": ["# Python3 program to print k-th distinct\n# element in a given array\n \n# Returns k-th distinct\n# element in arr.\ndef printKDistinct(arr, n, k):\n    dist_count = 0\n    for i in range(n):\n         \n        # Check if current element is\n        # present somewhere else.\n        j = 0\n        while j < n:\n            if (i != j and arr[j] == arr[i]):\n                break\n            j += 1\n \n        # If element is unique\n        if (j == n):\n            dist_count += 1\n \n        if (dist_count == k):\n            return arr[i]\n \n    return -1\n \n# Driver Code\nar = [1, 2, 1, 3, 4, 2]\nn = len(ar)\nk = 2\nprint(printKDistinct(ar, n, k))\n \n# This code is contributed by Mohit Kumar\n", "# Python3 program to print k-th \n# distinct element in a given array\ndef printKDistinct(arr, size, KthIndex):\n    dict = {}\n    vect = []\n    for i in range(size):\n        if(arr[i] in dict):\n            dict[arr[i]] = dict[arr[i]] + 1\n        else:\n            dict[arr[i]] = 1\n    for i in range(size):\n        if(dict[arr[i]] > 1):\n            continue\n        else:\n            KthIndex = KthIndex - 1\n        if(KthIndex == 0):\n            return arr[i]\n    return -1\n \n# Driver Code\narr = [1, 2, 1, 3, 4, 2]\nsize = len(arr)\nprint(printKDistinct(arr, size, 2))\n \n# This code is contributed \n# by Akhand Pratap Singh\n"], "Group words with same set of characters -  ": ["# Python program to print all words that\n# have the same unique character set\n \n# Function to group all strings with same characters\nfrom collections import Counter\n \ndef groupStrings(input):\n    # traverse all strings one by one\n    # dict is an empty dictionary\n    dict={}\n     \n    for word in input:\n        # sort the current string and take it's\n        # sorted value as key\n        # sorted return list of sorted characters\n        # we need to join them to get key as string\n        # Counter() method returns dictionary with frequency of\n        # each character as value\n        wordDict=Counter(word)\n \n        # now get list of keys\n        key = wordDict.keys()\n \n        # now sort these keys\n        key = sorted(key)\n \n        # join these characters to produce key string\n        key = ''.join(key)\n         \n        # now check if this key already exist in\n        # dictionary or not\n        # if exist then simply append current word\n        # in mapped list on key\n        # otherwise first assign empty list to key and\n        # then append current word in it\n        if key in dict.keys():\n            dict[key].append(word)\n        else:\n            dict[key]=[]\n            dict[key].append(word)\n \n        # now traverse complete dictionary and print\n        # list of mapped strings in each key separated by ,\n    for (key,value) in dict.items():\n        print (','.join(dict[key]))\n         \n# Driver program\nif __name__ == '__main__':\n    input=['may','student','students','dog','studentssess','god','cat','act','tab','bat','flow','wolf','lambs','amy','yam','balms','looped','poodle']\n    groupStrings(input)\n"], "Find all pairs (a, b) in an array such that a % b = k -  ": ["# Python3 implementation to find such pairs \n  \n# Function to find pair such that (a % b = k) \ndef printPairs(arr, n, k): \n  \n    isPairFound = True\n  \n    # Consider each and every pair \n    for i in range(0, n): \n      \n        for j in range(0, n): \n          \n            # Print if their modulo equals to k \n            if (i != j and arr[i] % arr[j] == k): \n              \n                print('(', arr[i], ', ', arr[j], ')', \n                                 sep = '', end = ' ') \n                isPairFound = True\n              \n    return isPairFound \n  \n# Driver Code \narr = [2, 3, 5, 4, 7] \nn = len(arr)  \nk = 3\nif (printPairs(arr, n, k) == False): \n    print('No such pair exists') \n  \n#  \n", "# Python3 program to find all pairs  \n# such that a % b = k. \n   \n# Utility function to find the divisors  \n# of n and store in vector v[] \nimport math as mt \n  \ndef findDivisors(n): \n  \n    v = [] \n  \n    # Vector is used to store the divisors \n    for i in range(1, mt.floor(n**(.5)) + 1): \n        if (n % i == 0): \n              \n            # If n is a square number, push \n            # only one occurrence \n            if (n / i == i): \n                v.append(i) \n            else: \n                v.append(i) \n                v.append(n // i) \n                  \n    return v \n  \n# Function to find pairs such that (a%b = k) \ndef printPairs(arr, n, k): \n  \n    # Store all the elements in the map \n    # to use map as hash for finding elements \n    # in O(1) time. \n    occ = dict() \n    for i in range(n): \n        occ[arr[i]] = True\n  \n    isPairFound = False\n  \n    for i in range(n): \n          \n        # Print all the pairs with (a, b) as \n        # (k, numbers greater than k) as \n        # k % (num (> k)) = k i.e. 2%4 = 2 \n        if (occ[k] and k < arr[i]): \n            print('(', k, ',', arr[i], ')', end = ' ') \n            isPairFound = True\n  \n        # Now check for the current element as 'a' \n        # how many b exists such that a%b = k \n        if (arr[i] >= k): \n              \n            # find all the divisors of (arr[i]-k) \n            v = findDivisors(arr[i] - k) \n  \n            # Check for each divisor i.e. arr[i] % b = k \n            # or not, if yes then print that pair. \n            for j in range(len(v)): \n                if (arr[i] % v[j] == k and \n                    arr[i] != v[j] and \n                    occ[v[j]]): \n                    print('(', arr[i], ',', v[j],  \n                                       ')', end = ' ') \n                    isPairFound = True\n  \n    return isPairFound \n  \n# Driver Code \narr = [3, 1, 2, 5, 4] \nn = len(arr) \nk = 2\n  \nif (printPairs(arr, n, k) == False): \n    print('No such pair exists') \n  \n# This code is contributed by mohit kumar \n"], "Sort elements by frequency | Set 4 (Efficient approach using hash) -  ": ["# Used for sorting by frequency. And if frequency is same,\n# then by appearance\nfrom functools import cmp_to_key\n \ndef sortByVal(a,b):\n \n    # If frequency is same then sort by index\n    if (a[1] == b[1]):\n        return a[0] - b[0]\n \n    return b[1] - a[1]\n \n# function to sort elements by frequency\ndef sortByFreq(a, n):\n    res = []\n    m = {}\n    v = []\n \n    for i in range(n):\n \n        # Map m is used to keep track of count\n        # of elements in array\n        if(a[i] in m):\n            m[a[i]] = m[a[i]]+1\n        else:\n            m[a[i]] = 1\n \n    for key,value in m.items():\n        v.append([key,value])\n \n    # Sort the element of array by frequency\n    v.sort(key = cmp_to_key(sortByVal))\n \n    for i in range(len(v)):\n        while(v[i][1]):\n            res.append(v[i][0])\n            v[i][1] -= 1\n \n    return res\n \n \n# Driver program\n \na = [ 2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8 ]\nn = len(a)\nres = []\nres = sortByFreq(a, n)\n \nfor i in range(len(res)):\n    print(res[i],end = ' ')\n \n \n# This code is contributed by shinjanpatra\n", "# python3 program for the above approach\nimport collections\n \n# map all the number and sort by frequency\n \n \ndef the_helper(a, res, n):\n    mp = collections.defaultdict(int)\n    for i in range(n):\n        mp[a[i]] += 1\n    for key, val in mp.items():\n        res.append((val, key))\n    res.sort()\n \n \n# main function\nif __name__ == '__main__':\n    a = [2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8]\n    res = []\n    the_helper(a, res, len(a))\n    res.reverse()\n    for i in range(len(res) - 1):\n        if res[i][0] == res[i+1][0]:\n            for j in range(i+1, len(res)):\n                if res[i][0] == res[j][0] and res[i][1] > res[j][1]:\n                    res[i], res[j] = res[j], res[i]\n    for i in range(len(res)):\n        for j in range(res[i][0]):\n            print(res[i][1], end=' ')\n        # print()  # uncomment to print each frequency on a new line\n"], "Count quadruples from four sorted arrays whose sum is equal to a given value x -  ": ["# A Python3 implementation to count \n# quadruples from four sorted arrays\n# whose sum is equal to a given value x\n \n# function to count all quadruples \n# from four sorted arrays whose sum \n# is equal to a given value x\ndef countquadruples(arr1, arr2, \n                     arr3, arr4, n, x):\n    count = 0\n \n    # generate all possible \n    # quadruples from the four\n    # sorted arrays\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                for l in range(n):\n \n                    # check whether elements of\n                    # quadruple sum up to x or not\n                    if (arr1[i] + arr2[j] +\n                        arr3[k] + arr4[l] == x):\n                        count += 1\n                         \n    # required count of quadruples\n    return count\n \n# Driver Code\narr1 = [1, 4, 5, 6]\narr2 = [2, 3, 7, 8]\narr3 = [1, 4, 6, 10]\narr4 = [2, 4, 7, 8 ]\nn = len(arr1)\nx = 30\nprint('Count = ', countquadruples(arr1, arr2, \n                                   arr3, arr4, n, x))\n \n# This code is contributed \n# by Shrikant13\n", "# Python implementation to count quadruples from\n# four sorted arrays whose sum is equal to a\n# given value x\n \n# find the 'value' in the given array 'arr[]'\n# binary search technique is applied\ndef isPresent(arr,low,high,value):\n    while(low<=high):\n        mid=(low+high)//2\n        # 'value' found\n        if(arr[mid]==value):\n            return True\n        elif(arr[mid]>value):\n            high=mid-1\n        else:\n            low=mid+1\n    # 'value' not found\n    return False\n \n# function to count all quadruples from four\n# sorted arrays whose sum is equal to a given value x\n \ndef countQuadruples(arr1,arr2,arr3,arr4,n,x):\n    count=0\n     \n    #generate all triplets from the 1st three arrays\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                # calculate the sum of elements in\n                # the triplet so generated\n                T=arr1[i]+arr2[j]+arr3[k]\n                 \n                # check if 'x-T' is present in 4th\n                # array or not\n                if(isPresent(arr4,0,n-1,x-T)):\n                    # increment count\n                    count=count+1\n    # required count of quadruples\n    return count\n     \n# Driver program to test above\n \n# four sorted arrays each of size 'n'\narr1=[1, 4, 5, 6]\narr2=[2, 3, 7, 8]\narr3=[1, 4, 6, 10]\narr4=[2, 4, 7, 8]\n \nn=len(arr1)\nx=30\nprint('Count = {}'.format(countQuadruples(arr1,arr2,arr3,arr4,n,x)))\n \n# This code is contributed by Pushpesh Raj.\n", "# Python3 implementation to \n# count quadruples from four \n# sorted arrays whose sum is\n# equal to a given value x\n# count pairs from the two \n# sorted array whose sum\n# is equal to the given 'value'\ndef countPairs(arr1, arr2, \n               n, value):\n   \n     count = 0\n     l = 0\n     r = n - 1\n     \n     # traverse 'arr1[]' from \n     # left to right\n     # traverse 'arr2[]' from \n     # right to left\n     while (l < n and r >= 0):\n          sum = arr1[l] + arr2[r]\n           \n          # if the 'sum' is equal \n          # to 'value', then\n          # increment 'l', decrement \n          # 'r' and increment 'count'\n          if (sum == value):\n               l += 1\n               r -= 1\n               count += 1\n               \n               # if the 'sum' is greater\n               # than 'value', then decrement r\n          elif (sum > value):\n               r -= 1\n               \n          # else increment l\n          else:\n               l += 1\n               \n     # required count of pairs\n     # print(count)\n     return count\n \n# function to count all quadruples\n# from four sorted arrays whose sum \n# is equal to a given value x\ndef countQuadruples(arr1, arr2, \n                    arr3, arr4, \n                    n, x):\n     count = 0\n     \n     # generate all pairs from\n     # arr1[] and arr2[]\n     for i in range(0, n):\n          for j in range(0, n):\n             \n               # calculate the sum of \n               # elements in the pair \n               # so generated\n               p_sum = arr1[i] + arr2[j]\n                 \n               # count pairs in the 3rd \n               # and 4th array having \n               # value 'x-p_sum' and then\n               # accumulate it to 'count\n               count += int(countPairs(arr3, arr4,\n                                       n, x - p_sum))\n     # required count of quadruples\n     return count\n \n# Driver code\narr1 = [1, 4, 5, 6]\narr2 = [2, 3, 7, 8]\narr3 = [1, 4, 6, 10]\narr4 = [2, 4, 7, 8]\nn = len(arr1)\nx = 30\nprint('Count = ', countQuadruples(arr1, arr2, \n                                  arr3, arr4, \n                                  n, x))\n \n# This code is contributed by Stream_Cipher\n", "# Python implementation to count quadruples from\n# four sorted arrays whose sum is equal to a\n# given value x\n \n# function to count all quadruples from four sorted\n# arrays whose sum is equal to a given value x\ndef countQuadruples(arr1, arr2, arr3, arr4, n, x):\n    count = 0\n     \n    # unordered_map 'um' implemented as hash table\n    # for <sum, frequency> tuples   \n    m = {}\n     \n    # count frequency of each sum obtained from the\n    # pairs of arr1[] and arr2[] and store them in 'um'\n    for i in range(n):\n        for j in range(n):\n            if (arr1[i] + arr2[j]) in m:\n                m[arr1[i] + arr2[j]] += 1\n            else:\n                m[arr1[i] + arr2[j]] = 1\n     \n    # generate pair from arr3[] and arr4[]\n    for k in range(n):\n        for l in range(n):\n             \n            # calculate the sum of elements in\n            # the pair so generated\n            p_sum = arr3[k] + arr4[l]\n             \n            # if 'x-p_sum' is present in 'um' then\n            # add frequency of 'x-p_sum' to 'count'\n            if (x - p_sum) in m:\n                count += m[x - p_sum]\n     \n    # required count of quadruples\n    return count\n \n# Driver program to test above\n \n# four sorted arrays each of size 'n'\narr1 = [1, 4, 5, 6]\narr2 = [2, 3, 7, 8 ]\narr3 = [1, 4, 6, 10]\narr4 = [2, 4, 7, 8 ]\n \nn = len(arr1)\nx = 30\nprint('Count =', countQuadruples(arr1, arr2, arr3, arr4, n, x))\n \n# This code is contributed by avanitrachhadiya2155\n"], "Remove minimum number of elements such that no common element exist in both array -  ": ["# Python3 program to find minimum \n# element to remove so no common \n# element exist in both array\n \n# To find no elements to remove\n# so no common element exist\ndef minRemove(a, b, n, m):\n \n    # To store count of array element\n    countA = dict()\n    countB = dict()\n \n    # Count elements of a\n    for i in range(n):\n        countA[a[i]] = countA.get(a[i], 0) + 1\n \n    # Count elements of b\n    for i in range(n):\n        countB[b[i]] = countB.get(b[i], 0) + 1\n \n    # Traverse through all common \n    # element, and pick minimum \n    # occurrence from two arrays\n    res = 0\n    for x in countA:\n        if x in countB.keys():\n            res += min(countA[x],countB[x])\n \n    # To return count of\n    # minimum elements\n    return res\n \n# Driver Code\na = [ 1, 2, 3, 4 ]\nb = [2, 3, 4, 5, 8 ]\nn = len(a)\nm = len(b)\nprint(minRemove(a, b, n, m))\n \n# This code is contributed \n# by mohit kumar\n"], "Minimum number of subsets with distinct elements -  ": ["# A sorting based solution to find the \n# minimum number of subsets of a set \n# such that every subset contains distinct\n# elements.\n \n# function to count subsets such that all\n# subsets have distinct elements.\ndef subset(ar, n):\n \n    # take input and initialize res = 0\n    res = 0\n \n    # sort the array\n    ar.sort()\n \n    # traverse the input array and\n    # find maximum frequency\n    for i in range(0, n) :\n        count = 1\n \n        # for each number find its repetition / frequency\n        for i in range(n - 1):\n            if ar[i] == ar[i + 1]:\n                count+=1\n            else:\n                break\n             \n        # update res\n        res = max(res, count)\n     \n    return res\n \n \n# Driver code\nar = [ 5, 6, 9, 3, 4, 3, 4 ]\nn = len(ar)\nprint(subset(ar, n))\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# A hashing based solution to find the \n# minimum number of subsets of a set such  \n# that every subset contains distinct\n# elements.\n \n# Function to count subsets such that \n# all subsets have distinct elements.\ndef subset(arr, n):\n     \n    # Traverse the input array and\n    # store frequencies of elements\n    mp = {i:0 for i in range(10)}\n    for i in range(n):\n        mp[arr[i]] += 1\n     \n    # Find the maximum value in map.\n    res = 0\n    for key, value in mp.items():\n        res = max(res, value)\n \n    return res\n \n# Driver code\nif __name__ == '__main__':\n    arr = [5, 6, 9, 3, 4, 3, 4]\n    n = len(arr)\n    print(subset(arr, n))\n \n# This code is contributed by\n# Surendra_Gangwar\n", "def minSubsetsDistinctElements(arr):\n    n = len(arr)\n    dp = [0] * n  # Create an array to store the minimum subset count for each element\n \n    distinctElements = set()  # Create a set to store distinct elements \n    dp[0] = 1  # Initialize the first element with 1\n    distinctElements.add(arr[0]) \n \n    for i in range(1, n):  # Iterate through the array starting from the second element\n        if arr[i] not in distinctElements:  \n            distinctElements.add(arr[i])  \n            dp[i] = dp[i - 1]  # The minimum subset count \n                               #remains the same as the previous element\n        else:\n            dp[i] = dp[i - 1] + 1\n            # Clear the set to start tracking distinct elements again\n            distinctElements.clear()\n             # Add the current element as a distinct element\n            distinctElements.add(arr[i]) \n \n    return dp[n - 1] \n \n# Driver code\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4]\n    minSubsets = minSubsetsDistinctElements(arr)\n    print('Minimum number of subsets:', minSubsets)\n \n    arr = [1, 2, 3, 3]\n    minSubsets = minSubsetsDistinctElements(arr)\n    print('Minimum number of subsets:', minSubsets)\n"], "Find missing elements of a range -  ": ["# Function to find and print missing\n# elements in the given range\ndef findMissing(arr, n, low, high):\n    # Loop through the range of numbers from low to high\n    for i in range(low, high+1):\n        found = False\n     \n        # Loop through the array to check if i exists in it\n        for j in range(n):\n            if arr[j] == i:\n                found = True\n                break\n     \n        # If i is not found in the array, print it\n        if not found:\n            print(i, end=' ')\n \n# Driver's code\nif __name__ == '__main__':\n    # Input array\n    arr = [1, 3, 5, 4]\n    n = len(arr)\n    low = 1\n    high = 10\n \n    # Function call\n    findMissing(arr, n, low, high)\n", "# Python library for binary search \nfrom bisect import bisect_left \n \n# A sorting based C++ program to find missing \n# elements from an array \n \n# Print all elements of range [low, high] that \n# are not present in arr[0..n-1] \n \ndef printMissing(arr, n, low, high):\n     \n    # Sort the array\n    arr.sort()\n     \n    # Do binary search for 'low' in sorted \n    # array and find index of first element \n    # which either equal to or greater than \n    # low. \n    ptr = bisect_left(arr, low)\n    index = ptr\n     \n    # Start from the found index and linearly \n    # search every range element x after this \n    # index in arr[] \n    i = index\n    x = low\n    while (i < n and x <= high):\n    # If x doesn't match with current element \n    # print it \n        if(arr[i] != x):\n            print(x, end =' ')\n \n    # If x matches, move to next element in arr[] \n        else:\n            i = i + 1\n    # Move to next element in range [low, high] \n        x = x + 1\n \n    # Print range elements that are greater than the \n    # last element of sorted array. \n    while (x <= high): \n        print(x, end =' ')\n        x = x + 1\n \n \n# Driver code \n \narr = [1, 3, 5, 4] \nn = len(arr)\nlow = 1\nhigh = 10\nprintMissing(arr, n, low, high); \n \n# This code is contributed by YatinGupta\n", "# An array-based Python3 program to \n# find missing elements from an array \n \n# Print all elements of range \n# [low, high] that are not\n# present in arr[0..n-1] \ndef printMissing(arr, n, low, high):\n \n    # Create boolean list of size \n    # high-low+1, each index i \n    # representing whether (i+low)th\n    # element found or not.\n    points_of_range = [False] * (high-low+1) \n     \n    for i in range(n) :\n        # if ith element of arr is in range\n        # low to high then mark corresponding\n        # index as true in array\n        if ( low <= arr[i] and arr[i] <= high ) : \n            points_of_range[arr[i]-low] = True\n \n    # Traverse through the range \n    # and print all elements  whose value\n    # is false\n    for x in range(high-low+1) :\n        if (points_of_range[x]==False) : \n            print(low+x, end = ' ')\n \n# Driver Code \narr = [1, 3, 5, 4]\nn = len(arr)\nlow, high = 1, 10\nprintMissing(arr, n, low, high)\n \n# This code is contributed \n# by Shubh Bansal\n", "# A hashing based Python3 program to \n# find missing elements from an array \n \n# Print all elements of range \n# [low, high] that are not\n# present in arr[0..n-1] \ndef printMissing(arr, n, low, high):\n \n    # Insert all elements of \n    # arr[] in set \n    s = set(arr)\n \n    # Traverse through the range \n    # and print all missing elements \n    for x in range(low, high + 1):\n        if x not in s:\n            print(x, end = ' ')\n \n# Driver Code \narr = [1, 3, 5, 4]\nn = len(arr)\nlow, high = 1, 10\nprintMissing(arr, n, low, high)\n \n# This code is contributed \n# by SamyuktaSHegde \n"], "Check if two arrays are equal or not -  ": ["# Python3 program to find given\n# two array are equal or not\n \n# Returns true if arr1[0..n-1] and\n# arr2[0..m-1] contain same elements.\n \n \ndef areEqual(arr1, arr2, N, M):\n \n    # If lengths of array are not\n    # equal means array are not equal\n    if (N != M):\n        return False\n \n    # Sort both arrays\n    arr1.sort()\n    arr2.sort()\n \n    # Linearly compare elements\n    for i in range(0, N):\n        if (arr1[i] != arr2[i]):\n            return False\n \n    # If all elements were same.\n    return True\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr1 = [3, 5, 2, 5, 2]\n    arr2 = [2, 3, 5, 5, 2]\n    n = len(arr1)\n    m = len(arr2)\n \n    if (areEqual(arr1, arr2, n, m)):\n        print('Yes')\n    else:\n        print('No')\n", "# Python3 program for the above approach\n \n# Returns true if arr1[0..N-1] and\n# arr2[0..M-1] contain same elements.\n \n \ndef is_arr_equal(arr1, arr2):\n        # Check if the length of arrays are\n    # equal or not: A Easy Logic Check\n    if len(arr1) != len(arr2):\n        return False\n \n    # Create a dict named count to\n    # store counts of each element\n    count = {}\n    # Store the elements of arr1\n    # and their counts in the dictionary\n    for i in arr1:\n        if i in count:\n                # Element already in dict, simply increment its count\n            count[i] += 1\n        else:\n                # Element found for first time, initialize it with value 1.\n            count[i] = 1\n \n    # Traverse through arr2 and compare\n    # the elements and its count with\n    # the elements of arr1\n    for i in arr2:\n        # Return false if the element\n        # is not in count or if any element\n        # appears more no. of times than in arr1\n        if i not in count or count[i] == 0:\n            return False\n        else:\n                # If element is found, decrement\n                # its value in the dictionary\n            count[i] -= 1\n    # Return true if both arr1 and\n    # arr2 are equal\n    return True\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr1 = [3, 5, 2, 5, 2]\n    arr2 = [2, 3, 5, 5, 2]\n \n    if is_arr_equal(arr1, arr2):\n        print('Yes')\n    else:\n        print('No')\n"], "Non-overlapping sum of two sets -  ": ["# Python3 program to find Non-overlapping sum \nfrom collections import defaultdict\n \n# Function for calculating \n# Non-overlapping sum of two array \ndef findSum(A, B, n): \n \n    # Insert elements of both arrays \n    Hash = defaultdict(lambda:0)\n    for i in range(0, n): \n        Hash[A[i]] += 1\n        Hash[B[i]] += 1\n \n    # calculate non-overlapped sum \n    Sum = 0\n    for x in Hash: \n        if Hash[x] == 1: \n            Sum += x \n     \n    return Sum\n \n# Driver code \nif __name__ == '__main__': \n \n    A = [5, 4, 9, 2, 3] \n    B = [2, 8, 7, 6, 3] \n     \n    # size of array \n    n = len(A) \n \n    # Function call \n    print(findSum(A, B, n)) \n     \n# This code is contributed \n# by Rituraj Jain\n", "# python program to find Non-overlapping sum\n \n# function for calculating\n# Non-overlapping sum of two array\ndef findSum(A, B, n):\n    sum = 0;\n \n    # Insert elements of Array A in set\n    # and add into sum\n    st = set();\n    for i in range(0,n): \n        st.add(A[i]);\n        sum += A[i];\n     \n    # Check if B's element are there in set\n    # if exist then remove current element from\n    # set, otherwise add current element into sum\n    for i in range (0, n):\n        if (B[i] in st):\n            sum -= B[i];\n        else :\n            sum += B[i];\n \n    # Finally, return sum\n    return sum;\n \n# Driver code\nA = [ 5, 4, 9, 2, 3 ];\nB = [ 2, 8, 7, 6, 3 ];\n \n# size of array\nn = len(A);\n \n# function call\nprint(findSum(A, B, n));\n"], "How to check if two given sets are disjoint? -  ": ["# A Simple python 3 program to check\n# if two sets are disjoint\n \n# Returns true if set1[] and set2[] are disjoint, else false\ndef areDisjoint(set1, set2, m, n):\n    # Take every element of set1[] and search it in set2\n    for i in range(0, m):\n        for j in range(0, n):\n            if (set1[i] == set2[j]):\n                return False\n \n    # If no element of set1 is present in set2\n    return True\n \n \n# Driver program\nset1 = [12, 34, 11, 9, 3]\nset2 = [7, 2, 1, 5]\nm = len(set1)\nn = len(set2)\nprint('yes') if areDisjoint(set1, set2, m, n) else(' No')\n \n# This code ia contributed by Smitha Dinesh Semwal\n", "# A Simple Python 3 program to check\n# if two sets are disjoint\n \n# Returns true if set1[] and set2[]\n# are disjoint, else false\ndef areDisjoint(set1, set2, m, n):\n    # Sort the given two sets\n    set1.sort()\n    set2.sort()\n \n    # Check for same elements  \n    # using merge like process\n    i = 0; j = 0\n    while (i < m and j < n):\n         \n        if (set1[i] < set2[j]):\n            i += 1\n        elif (set2[j] < set1[i]):\n            j += 1\n        else: # if set1[i] == set2[j] \n            return False\n    return True\n \n \n# Driver Code\nset1 = [12, 34, 11, 9, 3]\nset2 = [7, 2, 1, 5]\nm = len(set1)\nn = len(set2)\n \nprint('Yes') if areDisjoint(set1, set2, m, n) else print('No')\n \n# This code is contributed by Smitha Dinesh Semwal\n", "# Function to check if two sets are disjoint\ndef are_disjoint(set1, set2):\n    # Convert the sets to lists and sort set1\n    set1.sort()\n     \n    # Iterate through elements in set2\n    for elem in set2:\n        # Use binary search (bisect) to find the lower bound of elem in set1\n        index = bisect_left(set1, elem)\n         \n        # If element is present in set1, they are not disjoint\n        if index < len(set1) and set1[index] == elem:\n            return False\n     \n    # If no element of set2 is present in set1, they are disjoint\n    return True\n \nfrom bisect import bisect_left\n \n# Driver program to test the function\nif __name__ == '__main__':\n    set1 = [12, 34, 11, 9, 3]\n    set2 = [7, 2, 1, 5]\n    if are_disjoint(set1, set2):\n        print('Yes')\n    else:\n        print('No')\n", "# Python3 program to \n# check if two sets are \n# distinct or not \n# This function prints \n# all distinct elements\ndef areDisjoint(set1, set2, \n                n1, n2):\n   \n  # Creates an empty hashset\n  myset = set([])\n   \n  # Traverse the first set \n  # and store its elements in hash\n  for i in range (n1):\n    myset.add(set1[i])\n     \n  # Traverse the second set \n  # and check if any element of it\n  # is already in hash or not.\n  for i in range (n2):\n    if (set2[i] in myset):\n      return False\n  return True\n \n# Driver method to test above method\nif __name__ == '__main__':\n   \n  set1 = [10, 5, 3, 4, 6]\n  set2 = [8, 7, 9, 3]\n \n  n1 = len(set1)\n  n2 = len(set2)\n   \n  if (areDisjoint(set1, set2,\n                  n1, n2)):\n    print ('Yes')\n  else:\n    print('No')\n \n# This code is contributed by Chitranayal\n", "def areDisjoint(arr1, arr2):\n  set1 = set(arr1)\n  set2 = set(arr2)\n  result = set1.intersection(set2)\n  if len(result) != 0:\n    return False\n  else:\n    return True\narr1 = [10, 5, 3, 4, 6]\narr2 = [8, 7, 9, 3]\nif areDisjoint(arr1, arr2):\n  print('YES')\nelse:\n  print('NO')\n \n# This code is contributed by Prince Kumar\n"], "Find the only repetitive element between 1 to N-1 -  ": ["# Python3 program to find the only\n# repeating element in an array where\n# elements are from 1 to N-1.\n \n \ndef findRepeating(arr, N):\n    for i in range(N):\n        for j in range(i + 1, N):\n            if (arr[i] == arr[j]):\n                return arr[i]\n \n \n# Driver's Code\nif __name__ == '__main__':\n  arr = [9, 8, 2, 6, 1, 8, 5, 3, 4, 7]\n  N = len(arr)\n \n  # Function call\n  print(findRepeating(arr, N))\n \n# This code is contributed by Arpit Jain\n", "# Python3 program to find the only\n# repeating element in an array where\n# elements are from 1 to N-1.\n \n \ndef findRepeating(arr, N):\n    arr.sort()\n    for i in range(1, N):\n        if(arr[i] != i+1):\n            return arr[i]\n \n \n# Driver's Code\nif __name__ == '__main__':\n  arr = [9, 8, 2, 6, 1, 8, 5, 3, 4, 7]\n  N = len(arr)\n \n  # Function call\n  print(findRepeating(arr, N))\n \n# This code is contributed by Arpit Jain\n", "def findRepeating(arr, N):\n    freq = [0]*(N+1) \n    for i in range(N):\n        freq[arr[i]] += 1\n    for i in range(N):\n        if freq[arr[i]] > 1:\n            return arr[i]\n    return -1\n \narr = [9, 8, 2, 6, 1, 8, 5, 3, 4, 7]\nN = len(arr)\n \n# Function call\nprint(findRepeating(arr, N))\n", "# Python3 program to find the only\n# repeating element in an array\n# where elements are from 1 to n-1.\n \n \ndef findRepeating(arr, N):\n    s = set()\n    for i in range(N):\n        if arr[i] in s:\n            return arr[i]\n        s.add(arr[i])\n \n    # If input is correct, we should\n    # never reach here\n    return -1\n \n \n# Driver code\nif __name__ == '__main__':\n  arr = [9, 8, 2, 6, 1, 8, 5, 3]\n  N = len(arr)\n \n  # Function call\n  print(findRepeating(arr, N))\n \n# This code is contributed\n# by Shrikant13\n", "# Python3 program to find the only\n# repeating element in an array where\n# elements are from 1 to N-1.\n \n \ndef findRepeating(arr, N):\n \n    # Find array sum and subtract sum\n    # first n-1 natural numbers from it\n    # to find the result.\n    return sum(arr) - (((N - 1) * N) // 2)\n \n \n# Driver's Code\nif __name__ == '__main__':\n  arr = [9, 8, 2, 6, 1, 8, 5, 3, 4, 7]\n  N = len(arr)\n \n  # Function call\n  print(findRepeating(arr, N))\n \n# This code is contributed\n# by mohit kumar\n", "# Python3 program to find the only\n# repeating element in an array where\n# elements are from 1 to N-1.\n \n \ndef findRepeating(arr, N):\n \n    # res is going to store value of\n    # 1 ^ 2 ^ 3 .. ^ (N-1) ^ arr[0] ^\n    # arr[1] ^ .... arr[n-1]\n    res = 0\n    for i in range(0, N-1):\n        res = res ^ (i+1) ^ arr[i]\n    res = res ^ arr[N-1]\n \n    return res\n \n \n# Driver code\nif __name__ == '__main__':\n  arr = [9, 8, 2, 6, 1, 8, 5, 3, 4, 7]\n  N = len(arr)\n \n  # Function call\n  print(findRepeating(arr, N))\n \n# This code is contributed by Smitha Dinesh Semwal.\n", "# Python3 program to find the only\n# repeating element in an array\n# where elements are from 1 to N-1.\n \n# Function to find repeated element\n \n \ndef findRepeating(arr, N):\n \n    missingElement = 0\n \n    # indexing based\n    for i in range(0, N):\n \n        element = arr[abs(arr[i])]\n \n        if(element < 0):\n            missingElement = arr[i]\n            break\n \n        arr[abs(arr[i])] = -arr[abs(arr[i])]\n \n    return abs(missingElement)\n \n \n# Driver code\nif __name__ == '__main__':\n  arr = [9, 8, 2, 6, 1, 8, 5, 3, 4, 7]\n  N = len(arr)\n   \n  # Function call\n  print(findRepeating(arr, N))\n \n# This code is contributed by Smitha Dinesh Semwal.\n", "class GFG :\n    @staticmethod\n    def  findDuplicate( nums) :\n        slow = nums[0]\n        fast = nums[0]\n        while True :\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if((slow != fast) == False) :\n                    break\n        fast = nums[0]\n        while (slow != fast) :\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n    @staticmethod\n    def main( args) :\n        arr = [9, 8, 2, 6, 1, 8, 5, 3, 4, 7]\n         \n        # Function call\n        ans = GFG.findDuplicate(arr)\n        print(ans)\n     \nif __name__=='__main__':\n    GFG.main([])\n     \n    # This code is contributed by aadityaburujwale.\n"], "Most frequent element in an array -  ": ["# Python3 program to find the most \n# frequent element in an array. \ndef mostFrequent(arr, n): \n  maxcount = 0; \n  element_having_max_freq = 0; \n  for i in range(0, n): \n    count = 0\n    for j in range(0, n): \n      if(arr[i] == arr[j]): \n        count += 1\n    if(count > maxcount): \n      maxcount = count \n      element_having_max_freq = arr[i] \n    \n  return element_having_max_freq; \n  \n# Driver Code \narr = [40,50,30,40,50,30,30] \nn = len(arr) \nprint(mostFrequent(arr, n)) \n  \n# This code is contributed by Arpit Jain \n", "# Python3 program to find the most \n# frequent element in an array. \n  \n  \ndef mostFrequent(arr, n): \n  \n    # Sort the array \n    arr.sort() \n  \n    # find the max frequency using \n    # linear traversal \n    max_count = 1\n    res = arr[0] \n    curr_count = 1\n  \n    for i in range(1, n): \n        if (arr[i] == arr[i - 1]): \n            curr_count += 1\n        else: \n            curr_count = 1\n  \n         # If last element is most frequent \n        if (curr_count > max_count): \n            max_count = curr_count \n            res = arr[i - 1] \n  \n    return res \n  \n  \n# Driver Code \narr = [40,50,30,40,50,30,30] \nn = len(arr) \nprint(mostFrequent(arr, n)) \n  \n# This code is contributed by Smitha Dinesh Semwal. \n", "# Python3 program to find the most  \n# frequent element in an array. \nimport math as mt \n  \ndef mostFrequent(arr, n): \n  \n    # Insert all elements in Hash. \n    Hash = dict() \n    for i in range(n): \n        if arr[i] in Hash.keys(): \n            Hash[arr[i]] += 1\n        else: \n            Hash[arr[i]] = 1\n  \n    # find the max frequency \n    max_count = 0\n    res = -1\n    for i in Hash:  \n        if (max_count < Hash[i]):  \n            res = i \n            max_count = Hash[i] \n          \n    return res \n  \n# Driver Code \narr = [ 40,50,30,40,50,30,30]  \nn = len(arr) \nprint(mostFrequent(arr, n)) \n  \n# This code is contributed  \n# by Mohit kumar 29 \n", "def maxFreq(arr, n): \n      \n    # Using moore's voting algorithm \n    res = 0\n    count = 1\n      \n    for i in range(1, n): \n        if (arr[i] == arr[res]): \n            count += 1\n        else: \n            count -= 1\n          \n        if (count == 0): \n            res = i \n            count = 1\n          \n    return arr[res] \n  \n# Driver code \narr = [ 40, 50, 30, 40, 50, 30, 30 ] \nn = len(arr) \nfreq =  maxFreq(arr, n) \ncount = 0\n  \nfor i in range (n): \n        if(arr[i] == freq): \n            count += 1\n          \nprint('Element ', maxFreq(arr , n),  \n      ' occurs ', count, ' times') \n  \n# This code is contributed by shivanisinghss2110\n"], "Maximum distance between two occurrences of same element in array -  ": ["def max_distance(arr): \n    n = len(arr) \n    max_d = -1\n    for i in range(n - 1): \n        for j in range(i + 1, n): \n            if arr[i] == arr[j]: \n                temp = abs(j - i) \n                max_d = max(max_d, temp) \n    return max_d \n  \n# Driver code \narr = [1, 2, 4, 1, 3, 4, 2, 5, 6, 5] \nprint('Maximum distance between two occurrences of same element in array:', max_distance(arr)) \n", "# Python program to find maximum distance between two \n# same occurrences of a number. \n  \n# Function to find maximum distance between equal elements \ndef maxDistance(arr, n): \n      \n    # Used to store element to first index mapping \n    mp = {} \n  \n    # Traverse elements and find maximum distance between \n    # same occurrences with the help of map. \n    maxDict = 0\n    for i in range(n): \n  \n        # If this is first occurrence of element, insert its \n        # index in map \n        if arr[i] not in mp.keys(): \n            mp[arr[i]] = i \n  \n        # Else update max distance \n        else: \n            maxDict = max(maxDict, i-mp[arr[i]]) \n  \n    return maxDict \n  \n# Driver Program \nif __name__=='__main__': \n    arr = [3, 2, 1, 2, 1, 4, 5, 8, 6, 7, 4, 2] \n    n = len(arr) \n    print (maxDistance(arr, n)) \n          \n# Contributed By: Harshit Sidhwa \n"], "Check if pair with given Sum exists in Array (Two Sum) -  ": ["# This python program tells if there exists a pair in array whose sum results in x.\n \n# Function to find and print pair\n \n \ndef chkPair(A, size, x):\n    for i in range(0, size - 1):\n        for j in range(i + 1, size):\n            if (A[i] + A[j] == x):\n                return 1\n    return 0\n \n \nif __name__ == '__main__':\n    A = [0, -1, 2, -3, 1]\n    x = -2\n    size = len(A)\n \n    if (chkPair(A, size, x)):\n        print('Yes')\n \n    else:\n        print('No')\n \n    # This code is contributed by rakeshsahni\n", "# Python program to find if there are\n# two elements with given sum\n \n# function to check for the given sum\n# in the array\n \n \ndef printPairs(arr, arr_size, sum):\n \n    # Create an empty hash map\n    # using an hashmap allows us to store the indices\n    hashmap = {}\n \n    for i in range(0, arr_size):\n        temp = sum-arr[i]\n        if (temp in hashmap):\n            print('Yes')\n            return\n        hashmap[arr[i]] = i\n    print('No')\n \n \n# driver code\nA = [1, 4, 45, 6, 10, 8]\nn = 16\nprintPairs(A, len(A), n)\n \n# This code will also work in case the array has the same number twice\n# and target is the sum of those numbers\n# Eg: Array = [4,6,4] Target = 8\n \n# This code is contributed by __Achyut Upadhyay__\n", "# Code in Python3 to tell if there\n# exists a pair in array whose\n# sum results in x.\n \n# Function to print pairs\n \n \ndef printPairs(a, n, x):\n \n    rem = []\n \n    for i in range(x):\n \n        # Initializing the rem\n        # values with 0's.\n        rem.append(0)\n \n    for i in range(n):\n        if (a[i] < x):\n \n            # Perform the remainder operation\n            # only if the element is x, as\n            # numbers greater than x can't\n            # be used to get a sum x.Updating\n            # the count of remainders.\n            rem[a[i] % x] += 1\n \n    # Traversing the remainder list from\n    # start to middle to find pairs\n    for i in range(1, x // 2):\n        if (rem[i] > 0 and rem[x - i] > 0):\n \n            # The elements with remainders\n            # i and x-i will result to a\n            # sum of x. Once we get two\n            # elements which add up to x,\n            # we print x and break.\n            print('Yes')\n            break\n \n    # Once we reach middle of\n    # remainder array, we have to\n    # do operations based on x.\n    if (i >= x // 2):\n        if (x % 2 == 0):\n            if (rem[x // 2] > 1):\n \n                # If x is even and we have more\n                # than 1 elements with remainder\n                # x/2, then we will have two\n                # distinct elements which add up\n                # to x. if we dont have than 1\n                # element, print 'No'.\n                print('Yes')\n            else:\n                print('No')\n        else:\n \n            # When x is odd we continue\n            # the same process which we\n            # did in previous loop.\n            if (rem[x // 2] > 0 and\n                    rem[x - x // 2] > 0):\n                print('Yes')\n            else:\n                print('No')\n \n \n# Driver Code\nA = [1, 4, 45, 6, 10, 8]\nn = 16\narr_size = len(A)\n \n# Function calling\nprintPairs(A, arr_size, n)\n \n# This code is contributed by subhammahato348\n"], "Union and Intersection of two Linked List using Hashing -  ": ["# Python code for finding union and intersection of linkedList \n  \n  \nclass linkedList: \n    def __init__(self): \n        self.head = None\n        self.tail = None\n  \n    def insert(self, data): \n        if self.head is None: \n            self.head = Node(data) \n            self.tail = self.head \n        else: \n            self.tail.next = Node(data) \n            self.tail = self.tail.next\n  \n  \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n  \n# return the head of new list containing the intersection of 2 linkedList \n  \n  \ndef findIntersection(head1, head2): \n    # creating a map \n    hashmap = {} \n  \n    # traversing on first list \n    while(head1 != None): \n        data = head1.data \n        if(data not in hashmap.keys()): \n            hashmap[data] = 1\n        head1 = head1.next\n  \n    # making a new linkedList \n    ans = linkedList() \n    while(head2 != None): \n        data = head2.data \n        if(data in hashmap.keys()): \n            # adding data to new list \n            ans.insert(data) \n        head2 = head2.next\n    return ans.head \n  \n# return the head of new list containing the union of 2 linkedList \n  \n  \ndef union(head1, head2): \n    # creating a map \n    hashmap = {} \n  \n    # traversing on first list \n    while(head1 != None): \n        data = head1.data \n        if(data not in hashmap.keys()): \n            hashmap[data] = 1\n        head1 = head1.next\n  \n    while(head2 != None): \n        data = head2.data \n        if(data not in hashmap.keys()): \n            hashmap[data] = 1\n        head2 = head2.next\n  \n    # making a new linkedList \n    ans = linkedList() \n  \n    # traverse on hashmap \n    for key, value in hashmap.items(): \n        ans.insert(key) \n  \n    return ans.head \n  \n  \ndef printList(head): \n    while head: \n        print(head.data, end=' ') \n        head = head.next\n    print() \n  \n  \nif __name__ == '__main__': \n  \n    # first list \n    ll1 = linkedList() \n    ll1.insert(1) \n    ll1.insert(2) \n    ll1.insert(3) \n    ll1.insert(4) \n    ll1.insert(5) \n  \n    # second list \n    ll2 = linkedList() \n    ll2.insert(1) \n    ll2.insert(3) \n    ll2.insert(5) \n    ll2.insert(6) \n  \n    print('First list is ') \n    printList(ll1.head) \n  \n    print('Second list is ') \n    printList(ll2.head) \n  \n    print('Intersection list is') \n    printList(findIntersection(ll1.head, ll2.head)) \n  \n    print('Union list is ') \n    printList(union(ll1.head, ll2.head)) \n  \n  \n# This code is contributed by Arpit Jain \n"], "Find whether an array is subset of another array -  ": ["# Python 3 program to find whether an array\n# is subset of another array\n \n# Return 1 if arr2[] is a subset of\n# arr1[]\n \n \ndef isSubset(arr1, arr2, m, n):\n    i = 0\n    j = 0\n    for i in range(n):\n        for j in range(m):\n            if(arr2[i] == arr1[j]):\n                break\n \n        # If the above inner loop was\n        # not broken at all then arr2[i]\n        # is not present in arr1[]\n        if (j == m):\n            return 0\n \n    # If we reach here then all\n    # elements of arr2[] are present\n    # in arr1[]\n    return 1\n \n \n# Driver code\nif __name__ == '__main__':\n \n    arr1 = [11, 1, 13, 21, 3, 7]\n    arr2 = [11, 3, 7, 1]\n \n    m = len(arr1)\n    n = len(arr2)\n \n    if(isSubset(arr1, arr2, m, n)):\n        print('arr2[] is subset of arr1[] ')\n    else:\n        print('arr2[] is not a subset of arr1[]')\n \n# This code is contributed by ita_c\n", "# Python3 program to find whether an array\n# is subset of another array\n \n# Return 1 if arr2[] is a subset of arr1[]\n \n \ndef isSubset(arr1, arr2, m, n):\n    i = 0\n \n    quickSort(arr1, 0, m-1)\n    for i in range(n):\n        if (binarySearch(arr1, 0, m - 1, arr2[i]) == -1):\n            return 0\n \n    # If we reach here then all elements\n    # of arr2[] are present in arr1[]\n    return 1\n \n# FOLLOWING FUNCTIONS ARE ONLY FOR\n# SEARCHING AND SORTING PURPOSE\n# Standard Binary Search function\n \n \ndef binarySearch(arr, low, high, x):\n    if(high >= low):\n        mid = (low + high)//2\n \n        # Check if arr[mid] is the first\n        # occurrence of x.\n        # arr[mid] is first occurrence if x is\n        # one of the following\n        # is true:\n        # (i) mid == 0 and arr[mid] == x\n        # (ii) arr[mid-1] < x and arr[mid] == x\n        if((mid == 0 or x > arr[mid-1]) and (arr[mid] == x)):\n            return mid\n        elif(x > arr[mid]):\n            return binarySearch(arr, (mid + 1), high, x)\n        else:\n            return binarySearch(arr, low, (mid - 1), x)\n \n    return -1\n \n \ndef partition(A, si, ei):\n    x = A[ei]\n    i = (si - 1)\n \n    for j in range(si, ei):\n        if(A[j] <= x):\n            i += 1\n            A[i], A[j] = A[j], A[i]\n    A[i + 1], A[ei] = A[ei], A[i + 1]\n    return (i + 1)\n \n# Implementation of Quick Sort\n# A[] --> Array to be sorted\n# si --> Starting index\n# ei --> Ending index\n \n \ndef quickSort(A, si, ei):\n    # Partitioning index\n    if(si < ei):\n        pi = partition(A, si, ei)\n        quickSort(A, si, pi - 1)\n        quickSort(A, pi + 1, ei)\n \n \n# Driver code\narr1 = [11, 1, 13, 21, 3, 7]\narr2 = [11, 3, 7, 1]\n \nm = len(arr1)\nn = len(arr2)\n \nif(isSubset(arr1, arr2, m, n)):\n    print('arr2[] is subset of arr1[] ')\nelse:\n    print('arr2[] is not a subset of arr1[] ')\n \n \n# This code is contributed by chandan_jnu\n", "# Python3 program to find whether an array\n# is subset of another array\n \n# Return 1 if arr2[] is a subset of arr1[] */\n \n \ndef isSubset(arr1, arr2, m, n):\n    i = 0\n    j = 0\n    if m < n:\n        return 0\n \n    arr1.sort()\n    arr2.sort()\n \n    while i < n and j < m:\n        if arr1[j] < arr2[i]:\n            j += 1\n        elif arr1[j] == arr2[i]:\n            j += 1\n            i += 1\n        elif arr1[j] > arr2[i]:\n            return 0\n    return False if i < n else True\n \n \n# Driver code\narr1 = [11, 1, 13, 21, 3, 7]\narr2 = [11, 3, 7, 1]\n \nm = len(arr1)\nn = len(arr2)\nif isSubset(arr1, arr2, m, n) == True:\n    print('arr2[] is subset of arr1[] ')\nelse:\n    printf('arr2[] is not a subset of arr1[] ')\n \n# This code is contributed by Shrikant13\n", "# Python3 program to find whether an array\n# is subset of another array\n \n# Return true if arr2[] is a subset\n# of arr1[]\n \n \ndef isSubset(arr1, m, arr2, n):\n \n    # Using STL set for hashing\n    hashset = set()\n \n    # hset stores all the values of arr1\n    for i in range(0, m):\n        hashset.add(arr1[i])\n \n    # Loop to check if all elements\n    # of arr2 also lies in arr1\n    for i in range(0, n):\n        if arr2[i] in hashset:\n            continue\n        else:\n            return False\n \n    return True\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    arr1 = [11, 1, 13, 21, 3, 7]\n    arr2 = [11, 3, 7, 1]\n \n    m = len(arr1)\n    n = len(arr2)\n \n    if (isSubset(arr1, m, arr2, n)):\n        print('arr2[] is subset of arr1[] ')\n    else:\n        print('arr2[] is not a subset of arr1[] ')\n \n# This code is contributed by akhilsaini\n", "# Python3 code\narr1 = [11, 1, 13, 21, 3, 7]\narr2 = [11, 3, 7, 1]\nm = len(arr1)\nn = len(arr2)\ns = set()\nfor i in range(m):\n    s.add(arr1[i])\n \np = len(s)\nfor i in range(n):\n    s.add(arr2[i])\n \nif (len(s) == p):\n    print('arr2[] is subset of arr1[] ')\n \nelse:\n    print('arr2[] is not subset of arr1[] ')\n \n    # This code is contributed by divyeshrabadiya07.\n", "# Python3 program to find whether an array\n# is subset of another array\n \n# Return true if arr2[] is a subset of arr1[]\n \n \ndef isSubset(arr1, m, arr2, n):\n \n    # Create a Frequency Table using STL\n    frequency = {}\n \n    # Increase the frequency of each element\n    # in the frequency table.\n    for i in range(0, m):\n        if arr1[i] in frequency:\n            frequency[arr1[i]] = frequency[arr1[i]] + 1\n        else:\n            frequency[arr1[i]] = 1\n \n    # Decrease the frequency if the\n    # element was found in the frequency\n    # table with the frequency more than 0.\n    # else return 0 and if loop is\n    # completed return 1.\n    for i in range(0, n):\n        if (frequency[arr2[i]] > 0):\n            frequency[arr2[i]] -= 1\n        else:\n            return False\n \n    return True\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    arr1 = [11, 1, 13, 21, 3, 7]\n    arr2 = [11, 3, 7, 1]\n \n    m = len(arr1)\n    n = len(arr2)\n \n    if (isSubset(arr1, m, arr2, n)):\n        print('arr2[] is subset of arr1[] ')\n    else:\n        print('arr2[] is not a subset of arr1[] ')\n \n# This code is contributed by akhilsaini\n"], "Load Factor and Rehashing -  ": ["# Python3 program to implement Rehashing\n \nclass Map:\n \n    class MapNode:\n        def __init__(self,key,value):\n            self.key=key\n            self.value=value\n            self.next=None\n \n    # The bucket array where\n    # the nodes containing K-V pairs are stored\n    buckets=list()\n \n    # No. of pairs stored - n\n    size=0\n \n    # Size of the bucketArray - b\n    numBuckets=0\n \n    # Default loadFactor\n    DEFAULT_LOAD_FACTOR = 0.75\n \n    def __init__(self):\n        Map.numBuckets = 5\n \n        Map.buckets = [None]*Map.numBuckets\n \n        print('HashMap created')\n        print('Number of pairs in the Map: ' + str(Map.size))\n        print('Size of Map: ' + str(Map.numBuckets))\n        print('Default Load Factor : ' + str(Map.DEFAULT_LOAD_FACTOR) + '\\n')\n \n    def getBucketInd(self,key):\n \n        # Using the inbuilt function from the object class\n        hashCode = hash(key)\n \n        # array index = hashCode%numBuckets\n        return (hashCode % Map.numBuckets)\n \n    def insert(self,key,value):\n \n        # Getting the index at which it needs to be inserted\n        bucketInd = self.getBucketInd(key)\n \n        # The first node at that index\n        head = Map.buckets[bucketInd]\n \n        # First, loop through all the nodes present at that index\n        # to check if the key already exists\n        while (head != None):\n \n            # If already present the value is updated\n            if (head.key==key):\n                head.value = value\n                return\n            head = head.next\n \n        # new node with the K and V\n        newElementNode = Map.MapNode(key, value)\n \n        # The head node at the index\n        head = Map.buckets[bucketInd]\n \n        # the new node is inserted\n        # by making it the head\n        # and it's next is the previous head\n        newElementNode.next = head\n \n        Map.buckets[bucketInd]= newElementNode\n \n        print('Pair(\\' {} \\', \\' {} \\') inserted successfully.'.format(key,value))\n \n        # Incrementing size\n        # as new K-V pair is added to the map\n        Map.size+=1\n \n        # Load factor calculated\n        loadFactor = (1* Map.size) / Map.numBuckets\n \n        print('Current Load factor = ' + str(loadFactor))\n \n        # If the load factor is > 0.75, rehashing is done\n        if (loadFactor > Map.DEFAULT_LOAD_FACTOR):\n            print(str(loadFactor) + ' is greater than ' + str(Map.DEFAULT_LOAD_FACTOR))\n            print('Therefore Rehashing will be done.')\n \n            # Rehash\n            self.rehash()\n \n            print('New Size of Map: ' + str(Map.numBuckets))\n \n        print('Number of pairs in the Map: ' + str(Map.size))\n        print('Size of Map: ' + str(Map.numBuckets))\n \n    def rehash(self):\n \n        print('\\n***Rehashing Started***\\n')\n \n        # The present bucket list is made temp\n        temp = Map.buckets\n \n        # New bucketList of double the old size is created\n        buckets =(2 * Map.numBuckets)\n \n        for i in range(2 * Map.numBuckets):\n            # Initialised to null\n            Map.buckets.append(None)\n \n        # Now size is made zero\n        # and we loop through all the nodes in the original bucket list(temp)\n        # and insert it into the new list\n        Map.size = 0\n        Map.numBuckets *= 2\n \n        for i in range(len(temp)):\n \n            # head of the chain at that index\n            head = temp[i]\n \n            while (head != None):\n                key = head.key\n                val = head.value\n \n                # calling the insert function for each node in temp\n                # as the new list is now the bucketArray\n                self.insert(key, val)\n                head = head.next\n \n        print('\\n***Rehashing Ended***')\n \n    def printMap(self):\n \n        # The present bucket list is made temp\n        temp = Map.buckets\n \n        print('Current HashMap:')\n        # loop through all the nodes and print them\n        for i in range(len(temp)):\n \n            # head of the chain at that index\n            head = temp[i]\n \n            while (head != None):\n                print('key = \\' {} \\', val = {}' .format(head.key,head.value))\n \n                head = head.next\n        print()\n \n \nif __name__ == '__main__':\n    # Creating the Map\n    map = Map()\n \n    # Inserting elements\n    map.insert(1, 'Geeks')\n    map.printMap()\n \n    map.insert(2, 'forGeeks')\n    map.printMap()\n \n    map.insert(3, 'A')\n    map.printMap()\n \n    map.insert(4, 'Computer')\n    map.printMap()\n \n    map.insert(5, 'Portal')\n    map.printMap()\n \n# This code is contributed by Amartya Ghosh\n"], "Double Hashing -  ": ["from typing import List\nimport math\n \nMAX_SIZE = 10000001\n \nclass DoubleHash:\n    def __init__(self, n: int):\n        self.TABLE_SIZE = n\n        self.PRIME = self.__get_largest_prime(n - 1)\n        self.keysPresent = 0\n        self.hashTable = [-1] * n\n \n    def __get_largest_prime(self, limit: int) -> int:\n        is_prime = [True] * (limit + 1)\n        is_prime[0], is_prime[1] = False, False\n        for i in range(2, int(math.sqrt(limit)) + 1):\n            if is_prime[i]:\n                for j in range(i * i, limit + 1, i):\n                    is_prime[j] = False\n        for i in range(limit, -1, -1):\n            if is_prime[i]:\n                return i\n \n    def __hash1(self, value: int) -> int:\n        return value % self.TABLE_SIZE\n \n    def __hash2(self, value: int) -> int:\n        return self.PRIME - (value % self.PRIME)\n \n    def is_full(self) -> bool:\n        return self.TABLE_SIZE == self.keysPresent\n \n    def insert(self, value: int) -> None:\n        if value == -1 or value == -2:\n            print('ERROR : -1 and -2 can't be inserted in the table')\n            return\n        if self.is_full():\n            print('ERROR : Hash Table Full')\n            return\n        probe, offset = self.__hash1(value), self.__hash2(value)\n        while self.hashTable[probe] != -1:\n            if -2 == self.hashTable[probe]:\n                break\n            probe = (probe + offset) % self.TABLE_SIZE\n        self.hashTable[probe] = value\n        self.keysPresent += 1\n \n    def erase(self, value: int) -> None:\n        if not self.search(value):\n            return\n        probe, offset = self.__hash1(value), self.__hash2(value)\n        while self.hashTable[probe] != -1:\n            if self.hashTable[probe] == value:\n                self.hashTable[probe] = -2\n                self.keysPresent -= 1\n                return\n            else:\n                probe = (probe + offset) % self.TABLE_SIZE\n \n    def search(self, value: int) -> bool:\n        probe, offset, initialPos, firstItr = self.__hash1(value), self.__hash2(value), self.__hash1(value), True\n        while True:\n            if self.hashTable[probe] == -1:\n                break\n            elif self.hashTable[probe] == value:\n                return True\n            elif probe == initialPos and not firstItr:\n                return False\n            else:\n                probe = (probe + offset) % self.TABLE_SIZE\n            firstItr = False\n        return False\n \n    def print(self) -> None:\n        print(*self.hashTable,sep=', ')\n \nif __name__ == '__main__':\n    myHash = DoubleHash(13)\n \n    # Inserts random element in the hash table\n    insertions = [115, 12, 87, 66, 123]\n    for insertion in insertions:\n        myHash.insert(insertion)\n    print('Status of hash table after initial insertions : ', end='')\n    myHash.print()\n \n    # Searches for random element in the hash table, and prints them if found.\n    queries = [1, 12, 2, 3, 69, 88, 115]\n    n2 = len(queries)\n    print('\\nSearch operation after insertion : ')\n     \n    for i in range(n2):\n        if myHash.search(queries[i]):\n            print(queries[i], 'present')\n             \n    # Deletes random element from the hash table.\n    deletions = [123, 87, 66]\n    n3 = len(deletions)\n     \n    for i in range(n3):\n        myHash.erase(deletions[i])\n         \n    print('Status of hash table after deleting elements : ',end='')\n    myHash.print()\n"], "Index Mapping (or Trivial Hashing) with negatives allowed -  ": ["# Python3 program to implement direct index \n# mapping with negative values allowed.\n \n# Searching if X is Present in the \n# given array or not.\ndef search(X):\n \n    if X >= 0:\n        return has[X][0] == 1\n \n    # if X is negative take the absolute\n    # value of X.\n    X = abs(X)\n    return has[X][1] == 1\n \ndef insert(a, n):\n \n    for i in range(0, n):\n        if a[i] >= 0:\n            has[a[i]][0] = 1\n        else:\n            has[abs(a[i])][1] = 1\n \n# Driver code\nif __name__ == '__main__':\n \n    a = [-1, 9, -5, -8, -5, -2]\n    n = len(a)\n \n    MAX = 1000\n     \n    # Since array is global, it is\n    # initialized as 0.\n    has = [[0 for i in range(2)] \n              for j in range(MAX + 1)]\n    insert(a, n)\n \n    X = -5\n    if search(X) == True:\n        print('Present')\n    else:\n        print('Not Present')\n \n# This code is contributed by Rituraj Jain\n"], "Print all Palindromic Partitions of a String using Backtracking -  ": [], "Find all distinct subset (or subsequence) sums of an array -  ": ["# Python 3 program to print distinct subset sums of\n# a given array.\n \n# sum denotes the current sum of the subset\n# currindex denotes the index we have reached in\n# the given array\ndef distSumRec(arr, n, sum, currindex, s):\n    if (currindex > n):\n        return\n \n    if (currindex == n):\n        s.add(sum)\n        return\n \n    distSumRec(arr, n, sum + arr[currindex], currindex+1, s)\n    distSumRec(arr, n, sum, currindex+1, s)\n \n# This function mainly calls recursive function\n# distSumRec() to generate distinct sum subsets.\n# And finally prints the generated subsets.\ndef printDistSum(arr,n):\n    s = set()\n    distSumRec(arr, n, 0, 0, s)\n \n    # Print the result\n    for i in s:\n        print(i,end = ' ')\n \n# Driver code\nif __name__ == '__main__':\n    arr = [2, 3, 4, 5, 6]\n    n = len(arr)\n    printDistSum(arr, n)\n \n# This code is contributed by\n# Surendra_Gangwar\n", "# Python3 program to print distinct subset \n# Sums of a given array. \n \n# Uses Dynamic Programming to find \n# distinct subset Sums \ndef printDistSum(arr, n):\n \n    Sum = sum(arr)\n     \n    # dp[i][j] would be true if arr[0..i-1] \n    # has a subset with Sum equal to j. \n    dp = [[False for i in range(Sum + 1)] \n                 for i in range(n + 1)]\n                  \n    # There is always a subset with 0 Sum \n    for i in range(n + 1): \n        dp[i][0] = True\n \n    # Fill dp[][] in bottom up manner \n    for i in range(1, n + 1):\n \n        dp[i][arr[i - 1]] = True\n \n        for j in range(1, Sum + 1):\n             \n            # Sums that were achievable \n            # without current array element \n            if (dp[i - 1][j] == True):\n                dp[i][j] = True\n                dp[i][j + arr[i - 1]] = True\n             \n    # Print last row elements \n    for j in range(Sum + 1): \n        if (dp[n][j] == True):\n            print(j, end = ' ')\n \n# Driver code \narr = [2, 3, 4, 5, 6] \nn = len(arr)\nprintDistSum(arr, n) \n \n# This code is contributed \n# by mohit kumar\n", "# Input Vector\na = [2, 3, 4, 5, 6]\n \n# We have to make a constant size for bit-set\n# and to be safe keep it significantly high\nn = len(a)\nmx = 40\n \n# bitset of size mx, dp[i] is 1 if sum i is possible\n# and 0 otherwise\ndp = [0] * mx\n# Sum 0 is always possible\ndp[0] = 1\n \n# dp transitions as explained in article\nfor i in range(n):\n    for j in range(mx - a[i]):\n        dp[j + a[i]] |= dp[j]\n    dp[a[i]] = 1\n \n# Print all the  1s in bit-set, this will be the\n# all the unique sums possible\nfor i in range(mx):\n    if dp[i] == 1:\n        print(i, end=' ')\n"], "Longest Common Substring | DP-29 -  ": ["# Python3 implementation of Finding\n# Length of Longest Common Substring\n \n# Returns length of longest common\n# substring of X[0..m-1] and Y[0..n-1]\n \n \ndef LCSubStr(X, Y, m, n):\n \n    # Create a table to store lengths of\n    # longest common suffixes of substrings.\n    # Note that LCSuff[i][j] contains the\n    # length of longest common suffix of\n    # X[0...i-1] and Y[0...j-1]. The first\n    # row and first column entries have no\n    # logical meaning, they are used only\n    # for simplicity of the program.\n \n    # LCSuff is the table with zero\n    # value initially in each cell\n    LCSuff = [[0 for k in range(n+1)] for l in range(m+1)]\n \n    # To store the length of\n    # longest common substring\n    result = 0\n \n    # Following steps to build\n    # LCSuff[m+1][n+1] in bottom up fashion\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if (i == 0 or j == 0):\n                LCSuff[i][j] = 0\n            elif (X[i-1] == Y[j-1]):\n                LCSuff[i][j] = LCSuff[i-1][j-1] + 1\n                result = max(result, LCSuff[i][j])\n            else:\n                LCSuff[i][j] = 0\n    return result\n \n \n# Driver Code\nX = 'OldSite: .org'\nY = 'NewSite:GeeksQuiz.com'\n \nm = len(X)\nn = len(Y)\n \nprint('Length of Longest Common Substring is',\n      LCSubStr(X, Y, m, n))\n \n# This code is contributed by Soumen Ghosh\n", "# Python implementation of the above approach\n \n# Function to find the length of the\n# longest LCS\ndef LCSubStr(s, t, n, m):\n   \n    # Create DP table\n    dp = [[0 for i in range(m + 1)] for j in range(2)]\n    res = 0\n     \n    for i in range(1,n + 1):\n        for j in range(1,m + 1):\n            if(s[i - 1] == t[j - 1]):\n                dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1\n                if(dp[i % 2][j] > res):\n                    res = dp[i % 2][j]\n            else:\n                dp[i % 2][j] = 0\n    return res\n \n# Driver Code\nX = 'OldSite: .org'\nY = 'NewSite:GeeksQuiz.com'\nm = len(X)\nn = len(Y)\n \n# Function call\nprint(LCSubStr(X,Y,m,n))\n \n# This code is contributed by avanitrachhadiya2155\n", "# Python3 program using to find length of\n# the longest common substring recursion\n \n# Returns length of function for longest\n# common substring of X[0..m-1] and Y[0..n-1]\n \n \ndef lcs(i, j, count):\n \n    if (i == 0 or j == 0):\n        return count\n \n    if (X[i - 1] == Y[j - 1]):\n        count = lcs(i - 1, j - 1, count + 1)\n \n    count = max(count, max(lcs(i, j - 1, 0),\n                           lcs(i - 1, j, 0)))\n \n    return count\n \n \n# Driver code\nif __name__ == '__main__':\n \n    X = 'abcdxyz'\n    Y = 'xyzabcd'\n \n    n = len(X)\n    m = len(Y)\n \n    print(lcs(n, m, 0))\n \n# This code is contributed by Ryuga\n"], "Probability of Knight to remain in the chessboard -  ": ["# Python3 program to find the probability of\n# the Knight to remain inside the chessboard\n# after taking exactly K number of steps\n# size of the chessboard\nN = 8\n \n# Direction vector for the Knight\ndx = [1, 2, 2, 1, -1, -2, -2, -1]\ndy = [2, 1, -1, -2, -2, -1, 1, 2]\n \n# returns true if the knight\n# is inside the chessboard\n \ndef inside(x, y):\n    return (x >= 0 and x < N and y >= 0 and y < N)\n \n# Bottom up approach for finding the\n# probability to go out of chessboard.\n \ndef findProb(start_x, start_y, steps):\n \n    # dp array\n    dp1 = [[[0 for i in range(N+5)] \n            for j in range(N+5)]\n            for k in range(steps + 5)]\n \n    # For 0 number of steps, each\n    # position will have probability 1\n    for i in range(N):\n        for j in range(N):\n            dp1[i][j][0] = 1\n \n    # for every number of steps s\n    for s in range(1, steps + 1):\n \n        # for every position (x,y) after\n        # s number of steps\n        for x in range(N):\n \n            for y in range(N):\n                prob = 0.0\n \n                # For every position reachable from (x,y)\n                for i in range(8):\n                    nx = x + dx[i]\n                    ny = y + dy[i]\n \n                    # if this position lie inside the board\n                    if (inside(nx, ny)):\n                        prob += dp1[nx][ny][s-1] / 8.0\n \n                # store the result\n                dp1[x][y][s] = prob\n \n    # return the result\n    return dp1[start_x][start_y][steps]\n \n# Driver code\n \n# number of steps\nK = 3\n \n# Function Call\nprint(findProb(0, 0, K))\n \n# This code is contributed by Anant Agarwal.\n"], "Minimum number of deletions to make a string palindrome -  ": ["# Python3 program for above approach\n \n# Utility function for calculating\n# Minimum element to delete\ndef utility_fun_for_del(Str, i, j):\n     \n    if (i >= j):\n        return 0\n \n    # Condition to compare characters\n    if (Str[i] == Str[j]):\n         \n        # Recursive function call\n        return utility_fun_for_del(Str, i + 1, \n                                        j - 1)\n \n    # Return value, incrementing by 1\n    # return minimum Element between two values    \n    return (1 + min(utility_fun_for_del(Str, i + 1, j),\n                    utility_fun_for_del(Str, i, j - 1)))\n \n# Function to calculate the minimum\n# Element required to delete for\n# Making string palindrome\ndef min_ele_del(Str):\n \n    # Utility function call\n    return utility_fun_for_del(Str, 0, \n                           len(Str) - 1)\n \n# Driver code\nStr = 'abefbac'\n \nprint('Minimum element of deletions =',\n       min_ele_del(Str))\n \n# This code is contributed by avanitrachhadiya2155\n", "# function definition\ndef transformation(s1,s2,i,j,dp): \n     \n     # base cases\n    if i>=len(s1) or j>=len(s2):\n        return 0\n     \n    # checking the desired condition\n    if s1[i]==s2[j]: \n         \n        # if yes increment the count\n        dp[i][j]=1+transformation(s1,s2,i+1,j+1,dp) \n         \n    # if no    \n    if dp[i][j]!=-1: \n         \n        #return the value from the table\n        return dp[i][j] \n     \n    # else store the max transformation\n    # from the subsequence\n    else: \n        dp[i][j]=max(transformation(s1,s2,i,j+i,dp),\n                     transformation(s1,s2,i+1,j,dp))\n         \n    # return the dp [-1][-1]    \n    return dp[-1][-1] \n \n                      \n \ns1 = ' '\ns2 = 'geeks'\ni=0\nj=0\n \n#initialize the array with -1\ndp=[[-1 for _ in range(len(s1)+1)] for _ in range(len(s2)+1)] \nprint('MINIMUM NUMBER OF DELETIONS: ',\n      len(s1)-transformation(s1,s2,0,0,dp),\n      end=' ')\nprint('MINIMUM NUMBER OF INSERTIONS: ',\n      len(s2)-transformation(s1,s2,0,0,dp),\n      end=' ' )\nprint('LCS LENGTH: ',transformation(s1,s2,0,0,dp))\n \n#code contributed by saikumar kudikala\n", "# Python3 implementation to find \n# minimum number of deletions\n# to make a string palindromic\n  \n# Returns the length of \n# the longest palindromic \n# subsequence in 'str'\ndef lps(str):\n    n = len(str)\n  \n    # Create a table to store\n    # results of subproblems\n    L = [[0 for x in range(n)]for y in range(n)]\n  \n    # Strings of length 1\n    # are palindrome of length 1\n    for i in range(n):\n        L[i][i] = 1\n  \n    # Build the table. Note that \n    # the lower diagonal values \n    # of table are useless and \n    # not filled in the process. \n    # c1 is length of substring\n    for cl in range( 2, n+1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if (str[i] == str[j] and cl == 2):\n                L[i][j] = 2\n            elif (str[i] == str[j]):\n                L[i][j] = L[i + 1][j - 1] + 2\n            else:\n                L[i][j] = max(L[i][j - 1],L[i + 1][j])\n  \n    # length of longest\n    # palindromic subseq\n    return L[0][n - 1]\n  \n# function to calculate \n# minimum number of deletions\ndef minimumNumberOfDeletions( str):\n \n    n = len(str)\n  \n    # Find longest palindromic \n    # subsequence\n    l = lps(str)\n  \n    # After removing characters \n    # other than the lps, we \n    # get palindrome.\n    return (n - l)\n  \n# Driver Code\nif __name__ == '__main__':\n     \n    str = ' '\n    print( 'Minimum number of deletions = '\n         , minimumNumberOfDeletions(str))\n", "# Python 3 implementation to find\n# minimum number of deletions\n# to make a string palindromic\n \n# Returns the length of\n# the longest palindromic\n# subsequence in 'str'\ndef lps(string):\n    n = len(string)\n \n    # List to store computation\n    # of subproblems\n    L = [0] * n\n \n    # Iterate over subproblems to get the current\n    # value from previous computation\n    for i in range(n - 1, -1, -1):\n        # To store previous values\n        back_up = 0\n        for j in range(i, n):\n            if j == i:\n                L[j] = 1\n            elif string[i] == string[j]:\n                temp = L[j]\n                L[j] = back_up + 2\n                back_up = temp\n            else:\n                back_up = L[j]\n                L[j] = max(L[j], L[j - 1])\n \n    # Return final answer\n    return L[n - 1]\n \n# Function to calculate\n# minimum number of deletions\ndef minimumNumberOfDeletions(string):\n    n = len(string)\n \n    # Find longest palindromic\n    # subsequence\n    length = lps(string)\n \n    # After removing characters\n    # other than the lps, we\n    # get a palindrome.\n    return (n - length)\n \n# Driver Code\nif __name__ == '__main__':\n    string = ' '\n    print('Minimum number of deletions =', minimumNumberOfDeletions(string))\n \n     \n# This code is contributed by shivamgupta0987654321\n"], "0/1 Knapsack Problem -  ": ["# This is the memoization approach of \n# 0 / 1 Knapsack in Python in simple \n# we can say recursion + memoization = DP \n  \n  \ndef knapsack(wt, val, W, n): \n  \n    # base conditions \n    if n == 0 or W == 0: \n        return 0\n    if t[n][W] != -1: \n        return t[n][W] \n  \n    # choice diagram code \n    if wt[n-1] <= W: \n        t[n][W] = max( \n            val[n-1] + knapsack( \n                wt, val, W-wt[n-1], n-1), \n            knapsack(wt, val, W, n-1)) \n        return t[n][W] \n    elif wt[n-1] > W: \n        t[n][W] = knapsack(wt, val, W, n-1) \n        return t[n][W] \n  \n# Driver code \nif __name__ == '__main__': \n    profit = [60, 100, 120] \n    weight = [10, 20, 30] \n    W = 50\n    n = len(profit) \n      \n    # We initialize the matrix with -1 at first. \n    t = [[-1 for i in range(W + 1)] for j in range(n + 1)] \n    print(knapsack(weight, profit, W, n)) \n  \n# This code is contributed by Prosun Kumar Sarkar \n", "# A Dynamic Programming based Python \n# Program for 0-1 Knapsack problem \n# Returns the maximum value that can \n# be put in a knapsack of capacity W \n  \n  \ndef knapSack(W, wt, val, n): \n    K = [[0 for x in range(W + 1)] for x in range(n + 1)] \n  \n    # Build table K[][] in bottom up manner \n    for i in range(n + 1): \n        for w in range(W + 1): \n            if i == 0 or w == 0: \n                K[i][w] = 0\n            elif wt[i-1] <= w: \n                K[i][w] = max(val[i-1] \n                              + K[i-1][w-wt[i-1]], \n                              K[i-1][w]) \n            else: \n                K[i][w] = K[i-1][w] \n  \n    return K[n][W] \n  \n  \n# Driver code \nif __name__ == '__main__': \n    profit = [60, 100, 120] \n    weight = [10, 20, 30] \n    W = 50\n    n = len(profit) \n    print(knapSack(W, weight, profit, n)) \n  \n# This code is contributed by Bhavya Jain \n", "# Python code to implement the above approach \n  \n  \ndef knapSack(W, wt, val, n): \n      \n    # Making the dp array \n    dp = [0 for i in range(W+1)] \n  \n    # Taking first i elements \n    for i in range(1, n+1): \n        \n        # Starting from back, \n        # so that we also have data of \n        # previous computation when taking i-1 items \n        for w in range(W, 0, -1): \n            if wt[i-1] <= w: \n                  \n                # Finding the maximum value \n                dp[w] = max(dp[w], dp[w-wt[i-1]]+val[i-1]) \n      \n    # Returning the maximum value of knapsack \n    return dp[W] \n  \n  \n# Driver code \nif __name__ == '__main__': \n    profit = [60, 100, 120] \n    weight = [10, 20, 30] \n    W = 50\n    n = len(profit) \n    print(knapSack(W, weight, profit, n)) \n  \n  \n# This code is contributed by Suyash Saxena\n"], "Min Cost Path | DP-6 -  ": ["# A Naive recursive implementation of MCP(Minimum Cost Path) problem\nimport sys\nR = 3\nC = 3\n \n# Returns cost of minimum cost path from (0,0) to (m, n) in mat[R][C]\n \n \ndef minCost(cost, m, n):\n    if (n < 0 or m < 0):\n        return sys.maxsize\n    elif (m == 0 and n == 0):\n        return cost[m][n]\n    else:\n        return cost[m][n] + min(minCost(cost, m-1, n-1),\n                                minCost(cost, m-1, n),\n                                minCost(cost, m, n-1))\n \n# A utility function that returns minimum of 3 integers */\n \n \ndef min(x, y, z):\n    if (x < y):\n        return x if (x < z) else z\n    else:\n        return y if (y < z) else z\n \n \n# Driver code\ncost = [[1, 2, 3],\n        [4, 8, 2],\n        [1, 5, 3]]\nprint(minCost(cost, 2, 2))\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "R = 3\nC = 3\n \n# Returns cost of minimum cost path\n# from (0,0) to (m, n) in mat[R][C]\ndef min_cost_memoized(cost, m, n, memo):\n    if n < 0 or m < 0:\n        return float('inf')\n    elif m == 0 and n == 0:\n        return cost[m][n]\n \n    if memo[m][n] != -1:\n        return memo[m][n]\n \n    memo[m][n] = cost[m][n] + min(\n        min_cost_memoized(cost, m - 1, n - 1, memo),\n        min_cost_memoized(cost, m - 1, n, memo),\n        min_cost_memoized(cost, m, n - 1, memo)\n    )\n \n    return memo[m][n]\n \n# Returns cost of minimum cost path\n# from (0,0) to (m, n) in mat[R][C]\ndef min_cost(cost, m, n):\n    memo = [[-1] * C for _ in range(R)]  # Initialize memo table with -1\n \n    return min_cost_memoized(cost, m, n, memo)\n \n# Driver code\ncost = [\n    [1, 2, 3],\n    [4, 8, 2],\n    [1, 5, 3]\n]\n \nprint(min_cost(cost, 2, 2))\n", "# Python3 program for the\n# above approach\n \n \ndef minCost(cost, row, col):\n \n    # For 1st column\n    for i in range(1, row):\n        cost[i][0] += cost[i - 1][0]\n \n    # For 1st row\n    for j in range(1, col):\n        cost[0][j] += cost[0][j - 1]\n \n    # For rest of the 2d matrix\n    for i in range(1, row):\n        for j in range(1, col):\n            cost[i][j] += (min(cost[i - 1][j - 1],\n                               min(cost[i - 1][j],\n                                   cost[i][j - 1])))\n \n    # Returning the value in\n    # last cell\n    return cost[row - 1][col - 1]\n \n \n# Driver code\nif __name__ == '__main__':\n \n    row = 3\n    col = 3\n \n    cost = [[1, 2, 3],\n            [4, 8, 2],\n            [1, 5, 3]]\n \n    print(minCost(cost, row, col))\n \n# This code is contributed by Amit Katiyar\n", "# Minimum Cost Path using Dijkstra\u2019s shortest path\n#  algorithm with Min Heap by dinglizeng\n# Python3\n \n# Define the number of rows and the number of columns\nR = 4\nC = 5\n \n# 8 possible moves \ndx = [ 1, -1, 0, 0, 1, 1, -1, -1 ] \ndy = [ 0, 0, 1, -1, 1, -1, 1, -1 ] \n \n# The data structure to store the coordinates of \n#  the unit square and the cost of path from the top \n#  left. \nclass Cell(): \n    def __init__(self, x, y, z): \n        self.x = x \n        self.y = y \n        self.cost = z \n \n# To verify whether a move is within the boundary. \ndef isSafe(x, y): \n    return (x >= 0 and x < R and\n            y >= 0 and y < C) \n \n# This solution is based on Dijkstra\u2019s shortest\n#  path algorithm \n# For each unit square being visited, we examine all\n#  possible next moves in 8 directions, \n# calculate the accumulated cost of path for each\n#  next move, adjust the cost of path of the adjacent \n#  units to the minimum as needed. \n# then add the valid next moves into a Min Heap. \n# The Min Heap pops out the next move with the minimum \n# accumulated cost of path. \n# Once the iteration reaches the last unit at the lower \n# right corner, the minimum cost path will be returned. \ndef minCost(cost, m, n): \n \n    # the array to store the accumulated cost\n    # of path from top left corner \n    dp = [[0 for x in range(C)] for x in range(R)] \n \n    # the array to record whether a unit\n    # square has been visited \n    visited = [[False for x in range(C)] \n                for x in range(R)] \n \n    # Initialize these two arrays, set path cost \n    # to maximum integer value, each unit as \n    # not visited \n    for i in range(R): \n        for j in range(C): \n            dp[i][j] = float('Inf') \n            visited[i][j] = False\n \n    # Define a reverse priority queue. \n    # Priority queue is a heap based implementation. \n    # The default behavior of a priority queue is\n    # to have the maximum element at the top. \n    # The compare class is used in the definition of\n    # the Min Heap. \n    pq = [] \n \n    # initialize the starting top left unit with the \n    # cost and add it to the queue as the first move. \n    dp[0][0] = cost[0][0] \n    pq.append(Cell(0, 0, cost[0][0])) \n \n    while(len(pq)): \n     \n        # pop a move from the queue, ignore the units \n        # already visited \n        cell = pq[0] \n        pq.pop(0) \n        x = cell.x \n        y = cell.y \n        if(visited[x][y]): \n            continue\n \n        # mark the current unit as visited \n        visited[x][y] = True\n \n        # examine all non-visited adjacent units in 8\n        # directions \n        # calculate the accumulated cost of path for\n        # each next move from this unit, \n        # adjust the cost of path for each next\n        # adjacent units to the minimum if possible. \n        for i in range(8): \n            next_x = x + dx[i] \n            next_y = y + dy[i] \n            if(isSafe(next_x, next_y) and\n                not visited[next_x][next_y]): \n                dp[next_x][next_y] = min(dp[next_x][next_y],\n                                        dp[x][y] + cost[next_x][next_y]) \n                pq.append(Cell(next_x, next_y, \n                                dp[next_x][next_y])) \n \n    # return the minimum cost path at the lower \n    # right corner \n    return dp[m][n] \n \n# Driver code \ncost = [[1, 8, 8, 1, 5], \n        [4, 1, 1, 8, 1], \n        [4, 2, 8, 8, 1], \n        [1, 5, 8, 8, 1]] \nprint(minCost(cost, 3, 4)) \n"], "Job Sequencing Problem -  ": ["# Python3 code for the above approach\n \n# function to schedule the jobs take 2\n# arguments array and no of jobs to schedule\n \n \ndef printJobScheduling(arr, t):\n \n    # length of array\n    n = len(arr)\n \n    # Sort all jobs according to\n    # decreasing order of profit\n    for i in range(n):\n        for j in range(n - 1 - i):\n            if arr[j][2] < arr[j + 1][2]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n \n    # To keep track of free time slots\n    result = [False] * t\n \n    # To store result (Sequence of jobs)\n    job = ['-1'] * t\n \n    # Iterate through all given jobs\n    for i in range(len(arr)):\n \n        # Find a free slot for this job\n        # (Note that we start from the\n        # last possible slot)\n        for j in range(min(t - 1, arr[i][1] - 1), -1, -1):\n \n            # Free slot found\n            if result[j] is False:\n                result[j] = True\n                job[j] = arr[i][0]\n                break\n \n    # print the sequence\n    print(job)\n \n \n# Driver's Code\nif __name__ == '__main__':\n    arr = [['a', 2, 100],  # Job Array\n              ['b', 1, 19],\n              ['c', 2, 27],\n              ['d', 1, 25],\n              ['e', 3, 15]]\n \n \n    print('Following is maximum profit sequence of jobs')\n \n    # Function Call\n    printJobScheduling(arr, 3)\n \n# This code is contributed\n# by Anubhav Raj Singh\n", "# Python3 program for the above approach \nimport heapq\n \n \ndef printJobScheduling(arr):\n    n = len(arr)\n \n    # arr[i][0] = job_id, arr[i][1] = deadline, arr[i][2] = profit\n \n    # sorting the array on the\n    # basis of their deadlines\n    arr.sort(key=lambda x: x[1])\n \n    # initialise the result array and maxHeap\n    result = []\n    maxHeap = []\n \n    # starting the iteration from the end\n    for i in range(n - 1, -1, -1):\n \n        # calculate slots between two deadlines\n        if i == 0:\n            slots_available = arr[i][1]\n        else:\n            slots_available = arr[i][1] - arr[i - 1][1]\n \n        # include the profit of job(as priority), deadline\n        # and job_id in maxHeap\n        # note we push negative value in maxHeap to convert\n        # min heap to max heap in python\n        heapq.heappush(maxHeap, (-arr[i][2], arr[i][1], arr[i][0]))\n \n        while slots_available and maxHeap:\n \n            # get the job with max_profit\n            profit, deadline, job_id = heapq.heappop(maxHeap)\n \n            # reduce the slots\n            slots_available -= 1\n \n            # include the job in the result array\n            result.append([job_id, deadline])\n \n    # jobs included might be shuffled\n    # sort the result array by their deadlines\n    result.sort(key=lambda x: x[1])\n \n    for job in result:\n        print(job[0], end=' ')\n    print()\n \n \n# Driver's Code\nif __name__ == '__main__':\n    arr = [['a', 2, 100],  # Job Array\n           ['b', 1, 19],\n           ['c', 2, 27],\n           ['d', 1, 25],\n           ['e', 3, 15]]\n \n    print('Following is maximum profit sequence of jobs')\n \n    # Function Call\n    printJobScheduling(arr)\n \n# This code is contributed\n# by Shivam Bhagat\n"], "Maximum Length Chain of Pairs | DP-20 -  ": ["# Python program for above approach\nclass Pair(object):\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n \n# This function assumes \n# that arr[] is sorted in increasing\n# order according the \n# first (or smaller) values in pairs.\ndef maxChainLength(arr, n):\n     \n    max = 0\n \n    # Initialize MCL(max chain \n    # length) values for all indices\n    mcl = [1 for i in range(n)]\n \n    # Compute optimized chain \n    # length values in bottom up manner\n    for i in range(1, n):\n        for j in range(0, i):\n            if (arr[i].a > arr[j].b and\n                  mcl[i] < mcl[j] + 1):\n                mcl[i] = mcl[j] + 1\n \n    # mcl[i] now stores the maximum\n    # chain length ending with pair i\n \n    # Pick maximum of all MCL values\n    for i in range(n):\n        if (max < mcl[i]):\n            max = mcl[i]\n \n    return max\n \n# Driver program to test above function\narr = [Pair(5, 24), Pair(15, 25), \n       Pair(27, 40), Pair(50, 60)]\n \nprint('Length of maximum size chain is',\n      maxChainLength(arr, len(arr)))\n \n# This code is contributed by Soumen Ghosh\n", "# Python3 implementation of the approach\nfrom typing import List, Tuple\n \ndef max_chain_len(p: List[Tuple[int, int]]) -> int:\n   \n    # Your code here\n    p.sort(key=lambda x: x[1])\n    prev = -1e9\n    ans = 0\n    for x in p:\n        if x[0] > prev:\n            ans += 1\n            prev = x[1]\n    return ans\n \nn = 5\np = [\n    (5, 24),\n    (39, 60),\n    (15, 28),\n    (27, 40),\n    (50, 90)\n]\n \n# Function Call\nprint(max_chain_len(p))\n \n# This code is contributed by phasing17\n", "# Python program for above approach\n \n# Structure val\nclass val:\n    def __init__(self,first,second):\n        self.first = first\n        self.second = second\n     \n# Memoisation function\ndef findMaxChainLen(p, n, prev, pos):\n     \n    global m\n     \n    # Check if pair { pos, prev } exists\n    # in m\n    if (val(pos, prev) in m):\n        return m[val(pos, prev)]\n \n    # Check if pos is >=n\n    if (pos >= n):\n        return 0\n \n    # Check if p[pos].first is\n    # less than prev\n    if (p[pos].first <= prev):\n        return findMaxChainLen(p, n, prev, pos + 1)\n \n    else:\n        ans = max(findMaxChainLen(p, n,\n                            p[pos].second, 0) + 1,\n                    findMaxChainLen(p, n,\n                                prev, pos + 1))\n        m[val(pos, prev)] = ans\n        return ans\n \n# Function to calculate maximum\n# chain length\ndef maxChainLen(p,n):\n \n    global m\n    m.clear()\n \n    # Call memoisation function\n    ans = findMaxChainLen(p, n, 0, 0)\n    return ans\n \n# Driver Code\nn = 5\np = [0]*n\np[0] = val(5,24)\n \np[1] = val(39,60)\n \np[2] = val(15,28)\n \np[3] = val(27,40)\n \np[4] = val(50,90)\n \nm = {}\n \n# Function Call\nprint(maxChainLen(p, n))\n \n# This code is contributed by shinjanpatra\n"], "Minimize the maximum difference between the heights -  ": ["# User function Template\ndef getMinDiff(arr, n, k):\n    arr.sort()\n    ans = arr[n - 1] - arr[0]  # Maximum possible height difference\n \n    tempmin = arr[0]\n    tempmax = arr[n - 1]\n \n    for i in range(1, n):\n        if arr[i] < k:\n            continue\n        tempmin = min(arr[0] + k, arr[i] - k)\n \n        # Minimum element when we\n        # add k to whole array\n        # Maximum element when we\n        tempmax = max(arr[i - 1] + k, arr[n - 1] - k)\n \n        # subtract k from whole array\n        ans = min(ans, tempmax - tempmin)\n \n    return ans\n \n \n# Driver Code Starts\nk = 6\nn = 6\narr = [7, 4, 8, 8, 8, 9]\nans = getMinDiff(arr, n, k)\nprint(ans)\n \n# This code is contributed by ninja_hattori.\n"], "What is Mean in Statistics (Formula, Calculation, Examples & Properties) -  ": ["# Python3 program to find mean\n \n# Function for calculating mean\n \n \ndef findMean(a, n):\n \n    sum = 0\n    for i in range(0, n):\n        sum += a[i]\n \n    return float(sum / n)\n \n \n# Driver program\na = [1, 3, 4, 2, 7, 5, 8, 6]\nn = len(a)\nprint('Mean =', findMean(a, n))\n"], "Tidy Number (Digits in non-decreasing Order) -  ": ["# Python program to check if a number  \n# is Tidy or not. \n  \n# Returns true if num is Tidy \ndef isTidy(num): \n  \n    # To store previous digit (Assigning \n    # initial value which is more than any \n    # digit) \n    prev = 10\n      \n    # Traverse all digits from right to \n    # left and check if any digit is \n    # smaller than previous. \n    while (num): \n        rem = num % 10\n        num /= 10\n        if rem > prev: \n            return False\n        prev = rem \n    return True\n  \n# Driver code \nnum = 1556\nif isTidy(num): \n    print('Yes') \nelse: \n    print('No') \n  \n# This code is contributed by Sharad_Bhardwaj. \n"], "Arrange given numbers to form the biggest number | Set 1 -  ": ["# Python3 program to arrange the\n# given array of numbers\n# to form the largest number\nimport functools\n \n# A comparison function which\n# is used by sort() in\n# printLargest()\ndef myCompare(x, y):\n \n    xy = x\n    yx = y\n \n    # Count length of x and y\n    countx = 0\n    county = 0\n \n    # Count length of X\n    while (x > 0):\n        countx += 1\n        x //= 10\n \n    # Count length of Y\n    while (y > 0):\n        county += 1\n        y //= 10\n \n    x = xy\n    y = yx\n \n    while (countx):\n        countx -= 1\n        yx *= 10\n \n    while (county):\n        county -= 1\n        xy *= 10\n \n    # Append x to y\n    yx += x\n \n    # Append y to x\n    xy += y\n \n    return 1 if xy > yx else -1\n \n# The main function that prints\n# the arrangement with the\n# largest value. The function\n# accepts a vector of strings\ndef printLargest(arr):\n \n    # Sort the numbers using\n    # library sort function. The\n    # function uses our comparison\n    # function myCompare() to\n    # compare two strings. See\n \n    arr.sort(key=functools.cmp_to_key(myCompare))\n    arr.reverse()\n \n    print(''.join(map(str, arr)))\n \n# Driver code\narr = [54, 546, 548, 60]\n \n# Function Hall\nprintLargest(arr)\n \n# This code is contributed by phasing17\n", "# Python3 implementation this is to use itertools.\n# permutations as coded below:\n \nfrom itertools import permutations\ndef largest(l):\n    lst = []\n    for i in permutations(l, len(l)):\n        # provides all permutations of the list values,\n        # store them in list to find max\n        lst.append(''.join(map(str,i))) \n    return max(lst)\n \nprint(largest([54, 546, 548, 60])) #Output 6054854654\n \n# This code is contributed by Raman Monga\n"], "Program to print Sum Triangle for a given array -  ": ["# Python 3 program to print sum triangle \n# for a given array \n  \n# prints sum triangle for arr[0..n-1] \ndef printTriangle(arr, n): \n      \n    # Initialize a 2D array to store triangle \n    tri = [[0 for i in range(n)]  \n              for i in range(n)] \n  \n    # Initialize last row of triangle \n    for i in range(n): \n        tri[n - 1][i] = arr[i] \n  \n    # Fill other rows \n    i = n - 2\n    while(i >= 0): \n        for j in range(0, i + 1, 1): \n            tri[i][j] = (tri[i + 1][j] + \n                         tri[i + 1][j + 1]) \n              \n        i -= 1\n  \n    # Print the triangle \n    for i in range(0, n, 1): \n        for j in range(0, i + 1, 1): \n            print(tri[i][j], end = ' ') \n        print('\\n', end = '') \n  \n# Driver Code \nif __name__ == '__main__': \n    arr = [4, 7, 3, 6, 7] \n    n = len(arr) \n    printTriangle(arr, n) \n      \n# This code is contributed by \n# Shashank_Sharma \n"], "The Lazy Caterer's Problem -  ": ["# A Python 3 program to \n# find the solution to\n# The Lazy Caterer's Problem\n \n# This function receives an \n# integer n and returns the \n# maximum number of pieces \n# that can be made form \n# pancake using n cuts\ndef findPieces( n ):\n \n    # Use the formula\n    return (n * ( n + 1)) // 2 + 1\n \n# Driver Code\nprint(findPieces(1))\nprint(findPieces(2))\nprint(findPieces(3))\nprint(findPieces(50))\n \n# This code is contributed\n# by ihritik\n"], "Program to check if a date is valid or not -  ": ["# Python Program to check  \n# if a date is valid or not \n  \nimport datetime \ndef date_validation(day, month, year): \n      \n    isValidDate = True\n      \n    try : \n        datetime.datetime(int(year),  \n                          int(month), int(day)) \n          \n    except ValueError : \n        isValidDate = False\n          \n    if(isValidDate) : \n        print ('Yes') \n    else : \n        print ('No') \n  \ndate_validation(10,12,2000)  \ndate_validation(31,11,2000) \n  \n# This code is contributed by ajay0007 \n"], "Check if a string can be obtained by rotating another string 2 places -  ": ["# Python 3 program to check if a string \n# is two time rotation of another string.\n \n# Function to check if string2 is \n# obtained by string 1\ndef isRotated(str1, str2):\n \n    if (len(str1) != len(str2)):\n        return False\n     \n    if(len(str1) < 2):\n        return str1 == str2\n    clock_rot = ''\n    anticlock_rot = ''\n    l = len(str2)\n \n    # Initialize string as anti-clockwise rotation\n    anticlock_rot = (anticlock_rot + str2[l - 2:] +\n                                     str2[0: l - 2])\n     \n    # Initialize string as clock wise rotation\n    clock_rot = clock_rot + str2[2:] + str2[0:2]\n \n    # check if any of them is equal to string1\n    return (str1 == clock_rot or\n            str1 == anticlock_rot)\n \n# Driver code\nif __name__ == '__main__':\n     \n    str1 = 'geeks'\n    str2 = 'eksge'\nif isRotated(str1, str2):\n    print('Yes')  \nelse:\n    print('No')\n \n# This code is contributed by ita_c\n", "# Python code for the above approach\n \n# Python code to find if string is rotated by 2 positions\n \ndef isRotated(str1, str2):\n    n = len(str1)\n    clockwise, anticlockwise = True, True\n     \n    # Check if str1 is rotated clockwise\n    for i in range(n):\n        if str1[i] != str2[(i+2) % n]:\n            clockwise = False\n            break\n     \n    # Check if str1 is rotated anticlockwise\n    for i in range(n):\n        if str1[(i+2) % n] != str2[i]:\n            anticlockwise = False\n            break\n             \n    # Return True if str1 is rotated by 2 positions either clockwise or anticlockwise\n    return clockwise or anticlockwise\n \n# Driver code\nif __name__ == '__main__':\n    str1 = 'geeks'\n    str2 = 'eksge'\n    if isRotated(str1, str2):\n        print('Yes')\n    else:\n        print('No')\n \n \n \n# This code is contributed by adityasharmadev01\n"], "Find resultant string after concatenating uncommon characters of given strings -  ": ["# Python3 program Find concatenated string\n# with uncommon characters of given strings\n \n \ndef concatenatedString(s1, s2):\n    res = ''  # result\n    m = {}\n \n    # store all characters of s2 in map\n    for i in range(0, len(s2)):\n        m[s2[i]] = 1\n \n    # Find characters of s1 that are not\n    # present in s2 and append to result\n    for i in range(0, len(s1)):\n        if(not s1[i] in m):\n            res = res + s1[i]\n        else:\n            m[s1[i]] = 2\n \n    # Find characters of s2 that are not\n    # present in s1.\n    for i in range(0, len(s2)):\n        if(m[s2[i]] == 1):\n            res = res + s2[i]\n \n    return res\n \n \n# Driver Code\nif __name__ == '__main__':\n    s1 = 'abcs'\n    s2 = 'cxzca'\n    print(concatenatedString(s1, s2))\n \n# This code is contributed\n# by Sairahul099\n", "def concatenatedString(s1: str, s2: str) -> str:\n    res = ''\n    s = set(s2)\n \n    for c in s1:\n        if c not in s:\n            res += c\n        else:\n            s.remove(c)\n \n    res += ''.join(s)\n \n    return res\n \n# Example usage\ns1 = 'abcs'\ns2 = 'cxzca'\nprint(concatenatedString(s1, s2)) # Output: bsxz\n", "def concatenated_string(s1, s2):\n    # List to count occurrences of characters in s1\n    count1 = [0] * 26\n    # List to count occurrences of characters in s2\n    count2 = [0] * 26\n \n    # Count occurrences of each character in s1\n    for ch in s1:\n        count1[ord(ch) - ord('a')] += 1\n \n    # Count occurrences of each character in s2\n    for ch in s2:\n        count2[ord(ch) - ord('a')] += 1\n \n    modified = ''  # String to store the modified string\n \n    # Iterate over s1 and check for uncommon characters\n    for ch in s1:\n        if count2[ord(ch) - ord('a')] == 0:\n            modified += ch\n \n    # Iterate over s2 and check for uncommon characters\n    for ch in s2:\n        if count1[ord(ch) - ord('a')] == 0:\n            modified += ch\n \n    if not modified:\n        return '-1'\n \n    return modified\n \n# Driver Code\nif __name__ == '__main__':\n    s1 = 'abcs'\n    s2 = 'cxzca'\n \n    print(concatenated_string(s1, s2))\n     \n# This code is contributed by shivamgupta0987654321\n"], "Reverse and Add given number repeatedly to get a Palindrome number -  ": ["# Python Program to implement reverse and add function\n \n# Iterative function to reverse digits of num\ndef reverseDigits(num):\n    rev_num = 0\n    while (num > 0):\n        rev_num = rev_num * 10 + num % 10\n        num = num//10\n    return rev_num\n \n# Function to check whether \n# the number is palindrome or not\ndef isPalindrome(num):\n    return (reverseDigits(num) == num)\n \n# Reverse and Add Function\ndef ReverseandAdd(num):\n    rev_num = 0\n    while (num <= 4294967295):\n        # Reversing the digits of the number\n        rev_num = reverseDigits(num)\n \n        # Adding the reversed number \n        # with the original\n        num = num + rev_num\n \n        # Checking whether the number \n        # is palindrome or not\n        if(isPalindrome(num)):\n            print (num)\n            break\n        else:\n            if (num > 4294967295):\n                print ('No palindrome exist')\n \n# Driver Code\nReverseandAdd(195)\nReverseandAdd(265)\n"], "Perfect Number -  ": ["# Python3 code to check if a given \n# number is perfect or not\n \n# Returns true if n is perfect\ndef isPerfect( n ):\n     \n    # To store sum of divisors\n    sum = 1\n     \n    # Find all divisors and add them\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            sum = sum + i + n/i\n        i += 1\n     \n    # If sum of divisors is equal to\n    # n, then n is a perfect number\n     \n    return (True if sum == n and n!=1 else False)\n \n# Driver program\nprint('Below are all perfect numbers till 10000')\nn = 2\nfor n in range (10000):\n    if isPerfect (n):\n        print(n , ' is a perfect number')\n         \n# This code is contributed by 'Sharad_Bhardwaj'.\n"], "Common Divisors of Two Numbers -  ": ["# Python3 implementation of program \nimport math \n \n# Map to store the count of each\n# prime factor of a \nma = {}\n \n# Function that calculate the count of \n# each prime factor of a number \ndef primeFactorize(a):\n     \n    sqt = int(math.sqrt(a))\n    for i in range(2, sqt, 2):\n        cnt = 0\n         \n        while (a % i == 0): \n            cnt += 1\n            a /= i\n             \n        ma[i] = cnt\n         \n    if (a > 1):\n        ma[a] = 1\n         \n# Function to calculate all common\n# divisors of two given numbers \n# a, b --> input integer numbers \ndef commDiv(a, b):\n     \n    # Find count of each prime factor of a \n    primeFactorize(a)\n     \n    # stores number of common divisors \n    res = 1\n     \n    # Find the count of prime factors \n    # of b using distinct prime factors of a \n    for key, value in ma.items():\n        cnt = 0\n         \n        while (b % key == 0):\n            b /= key\n            cnt += 1\n             \n        # Prime factor of common divisor \n        # has minimum cnt of both a and b \n        res *= (min(cnt, value) + 1)\n         \n    return res\n     \n# Driver code    \na = 12\nb = 24\n \nprint(commDiv(a, b))\n \n# This code is contributed by Stream_Cipher\n", "# Python implementation of program\nfrom math import sqrt\n \n \n# Function to calculate gcd of two numbers\ndef gcd(a, b):\n     \n    if a == 0:\n        return b\n    return gcd(b % a, a)\n   \n# Function to calculate all common divisors \n# of two given numbers \n# a, b --> input integer numbers \ndef commDiv(a, b):\n     \n    # find GCD of a, b\n    n = gcd(a, b)\n \n    # Count divisors of n\n    result = 0\n    for i in range(1,int(sqrt(n))+1):\n \n        # if i is a factor of n\n        if n % i == 0:\n \n            # check if divisors are equal\n            if n/i == i:\n                result += 1\n            else:\n                result += 2\n                 \n    return result\n \n# Driver program to run the case \nif __name__ == '__main__':\n    a = 12\n    b = 24; \n    print(commDiv(a, b))\n", "import math\n \ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n \ndef count_common_divisors(a, b):\n    gcd_ab = gcd(a, b)\n    count = 0\n \n    for i in range(1, int(math.sqrt(gcd_ab)) + 1):\n        if gcd_ab % i == 0:\n            count += 2\n            if i * i == gcd_ab:\n                count -= 1\n \n    return count\n \na = 12\nb = 18\n \ncommon_divisors = count_common_divisors(a, b)\nprint('The number of common divisors of', a, 'and', b, 'is', common_divisors, '.')\n \n# This code is contributed by Prajwal Kandekar\n"], "Check if a number is a power of another number -  ": ["# python program to check\n# if a number is power of\n# another number\n \n# Returns true if y is a\n# power of x \ndef isPower (x, y):\n     \n    # The only power of 1\n    # is 1 itself\n    if (x == 1):\n        return (y == 1)\n         \n    # Repeatedly compute\n    # power of x\n    pow = 1\n    while (pow < y):\n        pow = pow * x\n \n    # Check if power of x\n    # becomes y\n    return (pow == y)\n     \n     \n# Driver Code\n# check the result for\n# true/false and print.\nif(isPower(10, 1)):\n    print(1)\nelse:\n    print(0)\n \nif(isPower(1, 20)):\n    print(1)\nelse:\n    print(0)\nif(isPower(2, 128)):\n    print(1)\nelse:\n    print(0)\nif(isPower(2, 30)):\n    print(1)\nelse:\n    print(0)\n     \n# This code is contributed\n# by Sam007.\n", "# Python program to check if given number y\n# is power of x\nimport math\n \ndef is_power(x, y):\n    # logarithm function to calculate value\n    res1 = math.log(y) / math.log(x)\n    res2 = math.log(y) / math.log(x) # Note: this is float\n \n    # compare to the result1 or result2 both are equal\n    return res1 == res2\n \n# Driven program\nif __name__ == '__main__':\n    print(is_power(2, 128))\n"], "Program to find sum of prime numbers between 1 to n -  ": ["# Python program to find sum of primes\n# in range from 1 to n.\n \n# Returns sum of primes in range from\n# 1 to n\n \ndef sumOfPrimes(n):\n    # list to store prime numbers\n    prime = [True] * (n + 1)\n     \n    # Create a boolean array 'prime[0..n]'\n    # and initialize all entries it as true.\n    # A value in prime[i] will finally be\n    # false if i is Not a prime, else true.\n     \n    p = 2\n    while p * p <= n:\n        # If prime[p] is not changed, then\n        # it is a prime\n        if prime[p] == True:\n            # Update all multiples of p\n            i = p * 2\n            while i <= n:\n                prime[i] = False\n                i += p\n        p += 1   \n          \n    # Return sum of primes generated through\n    # Sieve.\n    sum = 0\n    for i in range (2, n + 1):\n        if(prime[i]):\n            sum += i\n    return sum\n \n# Driver code\nn = 11\nprint(sumOfPrimes(n))\n \n# This code is contributed by Sachin Bisht\n"], "Find if two rectangles overlap -  ": ["# Python program to check if rectangles overlap\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n# Returns true if two rectangles(l1, r1) \n# and (l2, r2) overlap\ndef do_overlap(l1, r1, l2, r2):\n     \n    # if rectangle has area 0, no overlap\n    if l1.x == r1.x or l1.y == r1.y or r2.x == l2.x or l2.y == r2.y:\n        return False\n     \n    # If one rectangle is on left side of other\n    if l1.x > r2.x or l2.x > r1.x:\n        return False\n \n    # If one rectangle is above other\n    if r1.y > l2.y or r2.y > l1.y:\n        return False\n \n    return True\n \n# Driver Code\nif __name__ == '__main__':\n    l1 = Point(0, 10)\n    r1 = Point(10, 0)\n    l2 = Point(5, 5)\n    r2 = Point(15, 0)\n \n    if(do_overlap(l1, r1, l2, r2)):\n        print('Rectangles Overlap')\n    else:\n        print('Rectangles Don't Overlap')\n \n# This code is contributed by Vivek Kumar Singh\n"], "How to check if given four points form a square -  ": ["# A Python3 program to check if\n# four given points form a square or not.\nclass Point:\n     \n    # Structure of a point in 2D space\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n# A utility function to find square of \n# distance from point 'p' to point 'q'\ndef distSq(p, q):\n    return (p.x - q.x) * (p.x - q.x) +\\\n           (p.y - q.y) * (p.y - q.y)\n \n# This function returns true if (p1, p2, p3, p4) \n# form a square, otherwise false\ndef isSquare(p1, p2, p3, p4):\n \n    d2 = distSq(p1, p2) # from p1 to p2\n    d3 = distSq(p1, p3) # from p1 to p3\n    d4 = distSq(p1, p4) # from p1 to p4\n \n    if d2 == 0 or d3 == 0 or d4 == 0:    \n        return False\n \n    # If lengths if (p1, p2) and (p1, p3) are same, then\n    # following conditions must be met to form a square.\n    # 1) Square of length of (p1, p4) is same as twice\n    # the square of (p1, p2)\n    # 2) Square of length of (p2, p3) is same\n    # as twice the square of (p2, p4)\n \n    if d2 == d3 and 2 * d2 == d4 and \\\n                    2 * distSq(p2, p4) == distSq(p2, p3):\n        return True\n \n    # The below two cases are similar to above case\n    if d3 == d4 and 2 * d3 == d2 and \\\n                    2 * distSq(p3, p2) == distSq(p3, p4):\n        return True\n \n    if d2 == d4 and 2 * d2 == d3 and \\\n                    2 * distSq(p2, p3) == distSq(p2, p4):\n        return True\n \n    return False\n \n# Driver Code\nif __name__=='__main__':\n    p1 = Point(20, 10)\n    p2 = Point(10, 20)\n    p3 = Point(20, 20)\n    p4 = Point(10, 10)\n     \n    if isSquare(p1, p2, p3, p4):\n        print('Yes') \n    else:\n        print('No')\n \n# This code is contributed by Mayank Chaudhary\n# aka chaudhary_19\n"], "Maximum Sum of Products of Two Arrays -  ": ["# Python program to calculate \n# maximum sum of products of \n# two arrays \n \n# Function that calculates \n# maximum sum of products \n# of two arrays \ndef maximumSOP(a, b) :\n \n    # Variable to store the sum of \n    # products of array elements \n    sop = 0\n \n    # length of the arrays \n    n = len(a)\n \n    # Sorting both the arrays \n    a.sort()\n    b.sort()\n \n    # Traversing both the arrays \n    # and calculating sum of product\n    for i in range(n) :\n        sop += a[i] * b[i]\n \n    return sop\n \n# Driver code     \nif __name__ == '__main__' :\n \n    A = [1, 2, 3]\n    B = [4, 5, 1]\n \n    print(maximumSOP(A, B))\n \n# This code is contributed by ANKITRAI1\n"], "Check if the door is open or closed -  ": ["def print_status_of_doors(n):\n    for i in range(1, n + 1):\n        divisors = 0\n        for j in range(1, i + 1):\n            if i % j == 0:\n                divisors += 1\n        if divisors % 2 == 0:\n            print('closed', end=' ')\n        else:\n            print('open', end=' ')\n \nn = 5\nprint_status_of_doors(n)\n", "# Python 3 implementation of\n# doors open or closed\nimport math\n \n# Function to check whether\n# 'n' has even number of \n# factors or not\ndef hasEvenNumberOfFactors(n):\n \n    root_n = math.sqrt(n) \n \n    # if 'n' is a perfect square\n    # it has odd number of factors\n    if ((root_n * root_n) == n):\n        return False\n \n    # else 'n' has even\n    # number of factors\n    return True\n \n# Function to find and print\n# status of each door\ndef printStatusOfDoors(n):\n \n    for i in range(1, n + 1):\n     \n        # If even number of factors\n        # final status is closed\n        if (hasEvenNumberOfFactors(i) == True):\n            print('closed', end =' ') \n \n        # else odd number of factors\n        # final status is open\n        else:\n            print('open', end =' ') \n     \n# Driver program\nn = 5\n \nprintStatusOfDoors(n) \n \n# This code is contributed by Smitha Dinesh Semwal\n"], "Binary representation of a given number -  ": ["def bin(n) :\n     \n    i = 1 << 31\n    while(i > 0) :\n     \n        if((n & i) != 0) :\n         \n            print('1', end = '')\n         \n        else :\n            print('0', end = '')\n             \n        i = i // 2\n             \nbin(7)\nprint()\nbin(4)\n \n# This code is contributed by divyeshrabadiya07.\n", "# Python3 Program for the binary\n# representation of a given number\n \n \ndef bin(n):\n \n    if n > 1:\n        bin(n//2)\n \n    print(n % 2, end='')\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    bin(7)\n    print()\n    bin(4)\n \n# This code is contributed by ANKITRAI1\n", "# Python 3 implementation of above approach\n \n# Function to convert decimal to\n# binary number\n \n \ndef bin(n):\n \n    if (n > 1):\n        bin(n >> 1)\n    print(n & 1, end='')\n \n \n# Driver code\nbin(131)\nprint()\nbin(3)\n \n# This code is contributed by PrinciRaj1992\n", "# Importing the necessary module\nimport sys\n \n# Initialize two variables with values 5 and -5\nn = 5\nm = -5\n \n# Using the format function to convert integers to binary\nb = bin(n & int('1'*8, 2))[2:].zfill(8)\nb1 = bin(m & int('1'*8, 2))[2:].zfill(8)\n \n# Printing the binary representation of n and m\nprint('Binary of 5:', b)\nprint('Binary of -5:', b1)\n \n# This code is contributed by Vikram_Shirsat\n", "def binary(num):\n    return int(bin(num).split('0b')[1])\n \nif __name__ == '__main__' :\n    x = 10\n    binary_x = binary(x)\n    print('the binary number is :',binary_x)\n \n# This code is contributed by Rishika Gupta.\n"], "Middle of three using minimum comparisons -  ": ["# Python3 program to find middle \n# of three distinct numbers\n \ndef middleOfThree(a, b, c):\n     \n    # Checking for b\n    if ((a < b and b < c) or (c < b and b < a)) :\n        return b;\n \n    # Checking for a\n    if ((b < a and a < c) or (c < a and a < b)) :\n        return a;\n \n    else :\n        return c\n \n# Driver Code\na = 20\nb = 30\nc = 40\nprint(middleOfThree(a, b, c))\n \n# This code is contributed by rishabh_jain\n", "# Python3 program to find middle \n# of three distinct numbers\n \n# Function to find the middle of three numbers\ndef middleOfThree(a, b, c) :\n     \n    # Compare each three number to find \n    # middle number. Enter only if a > b\n    if a > b : \n        if (b > c):\n            return b\n        elif (a > c) :\n            return c\n        else :\n            return a \n    else:\n        # Decided a is not greater than b.\n        if (a > c) :\n            return a\n        elif (b > c) :\n            return c\n        else :\n            return b\n \n# Driver Code\na = 20\nb = 30\nc = 40\nprint( middleOfThree(a, b, c) )\n \n# This code is contributed by rishabh_jain\n", "# Python3 program to find middle \n# of three distinct numbers\n \n# Function to find the middle of three number\ndef middleOfThree(a, b, c) :\n     \n    # x is positive if a is greater than b. \n    # x is negative if b is greater than a.\n    x = a - b\n \n    # Similar to x\n    y = b - c\n     \n    # Similar to x and y.\n    z = a - c \n \n    # Checking if b is middle (x and y \n    # both are positive)\n    if x * y > 0:\n        return b\n \n    # Checking if c is middle (x and z \n    # both are positive)\n    elif (x * z > 0) :\n        return c\n    else :\n        return a\n \n# Driver Code\na = 20\nb = 30\nc = 40\nprint(middleOfThree(a, b, c))\n \n# This code is contributed by rishabh_jain\n"], "How will you print numbers from 1 to 100 without using a loop? -  ": ["# Python3 program to Print\n# numbers from 1 to n \n \ndef printNos(n):\n    if n > 0:\n        printNos(n - 1)\n        print(n, end = ' ')\n \n# Driver code \nprintNos(100)\n \n# This code is contributed by Smitha Dinesh Semwal\n", "def printNos(initial, last):\n    if(initial<=last):\n        print(initial)\n        printNos(initial+1,last)\nprintNos(1,10)\n", "class Main:\n    i = 1\n \n    @staticmethod\n    def OUT():\n        print(Main.i, end=' ')\n        Main.i += 1\n \n    @staticmethod\n    def LEVEL():\n        Main.OUT(); Main.OUT(); Main.OUT(); Main.OUT(); Main.OUT(); Main.OUT(); Main.OUT(); Main.OUT(); Main.OUT(); Main.OUT()\n \n    @staticmethod\n    def PRINT():\n        # 100 = 10\u00d710\n        Main.LEVEL(); Main.LEVEL(); Main.LEVEL(); Main.LEVEL(); Main.LEVEL(); Main.LEVEL(); Main.LEVEL(); Main.LEVEL(); Main.LEVEL(); Main.LEVEL()\n \n    @staticmethod\n    def main(args):\n        # prints numbers from 1 to 100\n        Main.PRINT()\n \nMain.main(None)\n", "# Use the range function to generate a sequence of numbers from 1 to 100\nnumbers = range(1, 101)\n \n# Use the map function to print each number in the sequence\nlist(map(print, numbers))\n", "f = lambda x: print(x, end=' ') or f(x+1) if x < 100 else None\nf(1)\n"], "Program for Celsius To Fahrenheit conversion -  ": ["# Python code to convert Celsius scale \n# to Fahrenheit scale \n  \n  \ndef Cel_To_Fah(n): \n  \n    # Used the formula \n    return (n*1.8)+32\n  \n  \n# Driver Code \nif __name__ == '__main__': \n  n = 20\n  \n  # Function call \n  print(int(Cel_To_Fah(n))) \n  \n# This code is contributed by Chinmoy Lenka \n"], "Convert from any base to decimal and vice versa -  ": ["# Python program to convert a \n# number from any base to decimal\n \n# To return value of a char. \n# For example, 2 is returned \n# for '2'. 10 is returned for 'A', \n# 11 for 'B' \ndef val(c):\n    if c >= '0' and c <= '9':\n        return ord(c) - ord('0')\n    else:\n        return ord(c) - ord('A') + 10;\n \n# Function to convert a number \n# from given base 'b' to decimal \ndef toDeci(str,base):\n    llen = len(str)\n    power = 1 #Initialize power of base\n    num = 0     #Initialize result\n \n    # Decimal equivalent is str[len-1]*1 + \n    # str[len-2]*base + str[len-3]*(base^2) + ... \n    for i in range(llen - 1, -1, -1):\n         \n        # A digit in input number must \n        # be less than number's base \n        if val(str[i]) >= base:\n            print('Invalid Number')\n            return -1\n        num += val(str[i]) * power\n        power = power * base\n    return num\n     \n# Driver code\nstrr = '11A'\nbase = 16\nprint('Decimal equivalent of', strr, \n              'in base', base, 'is', \n                 toDeci(strr, base))\n \n# This code is contributed \n# by Sahil shelangia\n", "# Python3 Program to convert decimal to \n# any given base\n \n# To return char for a value. For example \n# '2' is returned for 2. 'A' is returned \n# for 10. 'B' for 11\ndef reVal(num):\n \n    if (num >= 0 and num <= 9):\n        return chr(num + ord('0'));\n    else:\n        return chr(num - 10 + ord('A'));\n \n# Utility function to reverse a string\ndef strev(str):\n \n    len = len(str);\n    for i in range(int(len / 2)):\n        temp = str[i];\n        str[i] = str[len - i - 1];\n        str[len - i - 1] = temp;\n \n# Function to convert a given decimal \n# number to a base 'base' and\ndef fromDeci(res, base, inputNum):\n \n    index = 0; # Initialize index of result\n \n    # Convert input number is given base \n    # by repeatedly dividing it by base \n    # and taking remainder\n    while (inputNum > 0):\n        res+= reVal(inputNum % base);\n        inputNum = int(inputNum / base);\n \n    # Reverse the result\n    res = res[::-1];\n \n    return res;\n \n# Driver Code\ninputNum = 282;\nbase = 16;\nres = '';\nprint('Equivalent of', inputNum, 'in base', \n       base, 'is', fromDeci(res, base, inputNum));\n \n# This code is contributed by mits \n", "n = '1100'\nb = 2\nprint(int(n, b))\n"], "Program to check if two given matrices are identical -  ": ["# Python3 Program to check if two \n# given matrices are identical \n  \nN = 4\n   \n# This function returns 1 \n# if A[][] and B[][] are identical \n# otherwise returns 0 \ndef areSame(A,B): \n      \n    for i in range(N): \n        for j in range(N): \n            if (A[i][j] != B[i][j]): \n                return 0\n    return 1\n  \n# driver code \nA= [ [1, 1, 1, 1], \n    [2, 2, 2, 2], \n    [3, 3, 3, 3], \n    [4, 4, 4, 4]] \n   \nB= [ [1, 1, 1, 1], \n    [2, 2, 2, 2], \n    [3, 3, 3, 3], \n    [4, 4, 4, 4]] \n                      \nif (areSame(A, B)==1): \n    print('Matrices are identical') \nelse: \n    print('Matrices are not identical') \n  \n# This code is contributed \n# by Anant Agarwal. \n"], "Missing characters to make a string Pangram -  ": ["# Python3 program to find characters \n# that needs to be added to make Pangram \nMAX_CHAR = 26\n \n# Returns characters that needs \n# to be added to make str \ndef missingChars(Str):\n     \n    # A boolean array to store characters \n    # present in string. \n    present = [False for i in range(MAX_CHAR)]\n \n    # Traverse string and mark characters \n    # present in string. \n    for i in range(len(Str)):\n        if (Str[i] >= 'a' and Str[i] <= 'z'):\n            present[ord(Str[i]) - ord('a')] = True\n        else if (Str[i] >= 'A' and Str[i] <= 'Z'):\n            present[ord(Str[i]) - ord('A')] = True\n \n    # Store missing characters in alphabetic \n    # order. \n    res = ''\n \n    for i in range(MAX_CHAR):\n        if (present[i] == False):\n            res += chr(i + ord('a'))\n             \n    return res\n \n# Driver code\nStr = 'The quick brown fox jumps over the dog'\n \nprint(missingChars(Str))\n \n# This code is contributed by avanitrachhadiya2155\n"], "Area of Incircle of a Right Angled Triangle -  ": ["# Python3 code to find the area of inscribed\n# circle of right angled triangle\nPI = 3.14159265\n \n# Function to find the area of\n# inscribed circle\n \n \ndef area_inscribed(P, B, H):\n    return ((P + B - H)*(P + B - H)*(PI / 4))\n \n \n# Driver code\nP = 3\nB = 4\nH = 5\nprint(area_inscribed(P, B, H))\n"], "Lexicographically Next Permutation of given String -  ": ["def next_permutation(s: str) -> str:\n    \n    # Convert the input string to a list of characters\n    arr = list(s)\n    n = len(arr)\n    i = n - 2\n     \n    # Find the largest index i such that arr[i] < arr[i+1]\n    while i >= 0 and arr[i] >= arr[i+1]:\n        i -= 1\n    \n     # If no such index exists, return 'No next Permutation'\n    if i < 0:\n        return 'No next Permutation possible'\n    j = n - 1\n     \n     # Find the largest index j such that arr[i] < arr[j]\n    while j >= 0 and arr[j] <= arr[i]:\n        j -= 1\n    # Swap arr[i] and arr[j]\n    arr[i], arr[j] = arr[j], arr[i]\n    # Reverse the sublist arr[start:end+1]\n    rev(arr, i+1, n-1)\n    return ''.join(arr)\n \n # Function to reverse the array\ndef rev(arr: list, start: int, end: int) -> None:\n    while start < end:\n        swap(arr, start, end)\n        start += 1\n        end -= 1\n # Function to swap two numbers\ndef swap(arr: list, i: int, j: int) -> None:\n    temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n \n# Driver code\nif __name__ == '__main__':\n    s = 'gfg'\n    print(next_permutation(s))\n"], "Efficiently compute sums of diagonals of a matrix -  ": ["# A simple Python program to \n# find sum of diagonals\nMAX = 100\n \ndef printDiagonalSums(mat, n):\n \n    principal = 0\n    secondary = 0;\n    for i in range(0, n): \n        for j in range(0, n): \n \n            # Condition for principal diagonal\n            if (i == j):\n                principal += mat[i][j]\n \n            # Condition for secondary diagonal\n            if ((i + j) == (n - 1)):\n                secondary += mat[i][j]\n         \n    print('Principal Diagonal:', principal)\n    print('Secondary Diagonal:', secondary)\n \n# Driver code\na = [[ 1, 2, 3, 4 ],\n     [ 5, 6, 7, 8 ], \n     [ 1, 2, 3, 4 ],\n      [ 5, 6, 7, 8 ]]\nprintDiagonalSums(a, 4)\n \n# This code is contributed \n# by ihritik\n", "# A simple Python3 program to find\n# sum of diagonals\nMAX = 100\n \ndef printDiagonalSums(mat, n):\n \n    principal = 0\n    secondary = 0\n    for i in range(0, n): \n        principal += mat[i][i]\n        secondary += mat[i][n - i - 1]\n         \n    print('Principal Diagonal:', principal)\n    print('Secondary Diagonal:', secondary)\n \n# Driver code\na = [[ 1, 2, 3, 4 ],\n     [ 5, 6, 7, 8 ], \n     [ 1, 2, 3, 4 ],\n     [ 5, 6, 7, 8 ]]\nprintDiagonalSums(a, 4)\n \n# This code is contributed\n# by ihritik\n"], "Program to multiply two matrices -  ": ["# Python3 program to multiply two matrices \n  \n  \ndef mulMat(mat1, mat2, R1, R2, C1, C2): \n    # List to store matrix multiplication result \n    rslt = [[0, 0, 0, 0], \n            [0, 0, 0, 0], \n            [0, 0, 0, 0], \n            [0, 0, 0, 0]] \n  \n    for i in range(0, R1): \n        for j in range(0, C2): \n            for k in range(0, R2): \n                rslt[i][j] += mat1[i][k] * mat2[k][j] \n  \n    print('Multiplication of given two matrices is:') \n    for i in range(0, R1): \n        for j in range(0, C2): \n            print(rslt[i][j], end=' ') \n        print('\\n', end='') \n  \n  \n# Driver code \nif __name__ == '__main__': \n    R1 = 2\n    R2 = 2\n    C1 = 2\n    C2 = 2\n      \n    # First matrix. M is a list \n    mat1 = [[1, 1], \n           [2, 2]] \n      \n    \n    # Second matrix. N is a list \n    mat2 = [[1, 1], \n           [2, 2]] \n  \n    if C1 != R2: \n        print('The number of columns in Matrix-1  must be equal to the number of rows in ' + 'Matrix-2', end='') \n        print('\\n', end='') \n        print('Please update MACROs according to your array dimension in #define section', end='') \n        print('\\n', end='') \n    else: \n        # Call matrix_multiplication function \n        mulMat(mat1, mat2, R1, R2, C1, C2) \n  \n# This code is contributed by Aarti_Rathi \n", "# Python program to multiply two \n# rectangular matrices \n  \n# Multiplies two matrices mat1[][] \n# and mat2[][] and prints result. \n# (m1) x (m2) and (n1) x (n2) are \n# dimensions of given matrices. \ndef multiply(m1, m2, mat1, n1, n2, mat2): \n    res = [[0 for x in range(n2)] for y in range(m1)] \n    for i in range(m1): \n        for j in range(n2): \n            res[i][j] = 0\n            for x in range(m2): \n                res[i][j] += mat1[i][x] * mat2[x][j] \n    for i in range(m1): \n        for j in range(n2): \n            print(res[i][j], end=' ') \n        print() \n  \n# Driver code \nm1 = 2\nm2 = 2\nn1 = 2\nn2 = 2\nmat1 = [[1, 1], [2, 2]] \nmat2 = [[1, 1], [2, 2]] \n  \n# Function call \nmultiply(m1, m2, mat1, n1, n2, mat2) \n  \n# This code is contributed by Tapesh(tapeshdua420) \n"], "Program for subtraction of matrices -  ": ["# Python 3 program for subtraction  \n# of matrices \n  \nN = 4\n  \n# This function returns 1 \n# if A[][] and B[][] are identical \n# otherwise returns 0 \ndef subtract(A, B, C): \n      \n    for i in range(N): \n        for j in range(N): \n            C[i][j] = A[i][j] - B[i][j]  \n  \n# Driver Code \nA = [ [1, 1, 1, 1], \n      [2, 2, 2, 2], \n      [3, 3, 3, 3], \n      [4, 4, 4, 4]] \n  \nB = [ [1, 1, 1, 1], \n      [2, 2, 2, 2], \n      [3, 3, 3, 3], \n      [4, 4, 4, 4]] \n                      \nC = A[:][:] # To store result \n      \nsubtract(A, B, C) \n  \nprint('Result matrix is') \nfor i in range(N): \n    for j in range(N): \n        print(C[i][j], ' ', end = '') \n    print() \n      \n# This code is contributed \n# by Anant Agarwal. \n"], "Program for addition of two matrices -  ": ["# Python3 program for addition \n# of two matrices \n  \nN = 4\n  \n# This function adds A[][] \n# and B[][], and stores \n# the result in C[][] \n  \n  \ndef add(A, B, C): \n  \n    for i in range(N): \n        for j in range(N): \n            C[i][j] = A[i][j] + B[i][j] \n  \n  \n# driver code \nA = [[1, 1, 1, 1], \n     [2, 2, 2, 2], \n     [3, 3, 3, 3], \n     [4, 4, 4, 4]] \n  \nB = [[1, 1, 1, 1], \n     [2, 2, 2, 2], \n     [3, 3, 3, 3], \n     [4, 4, 4, 4]] \n  \nC = A[:][:]  # To store result \n  \nadd(A, B, C) \n  \nprint('Result matrix is') \nfor i in range(N): \n    for j in range(N): \n        print(C[i][j], ' ', end='') \n    print() \n  \n# This code is contributed \n# by Anant Agarwal. \n"], "Sort string of characters -  ": ["# Python3 program to sort a string  \n# of characters  \n  \n# function to print string in \n# sorted order  \ndef sortString(str) : \n    str = ''.join(sorted(str)) \n    print(str) \n  \n# Driver Code \ns = ' '\nsortString(s)  \n  \n# This code is contributed by Smitha \n", "# Python 3 program to sort a string  \n# of characters \n  \nMAX_CHAR = 26\n  \n# function to print string in sorted order \ndef sortString(str): \n      \n    # Hash array to keep count of characters. \n    # Initially count of all characters is  \n    # initialized to zero. \n    charCount = [0 for i in range(MAX_CHAR)] \n      \n    # Traverse string and increment  \n    # count of characters \n    for i in range(0, len(str), 1): \n          \n        # 'a'-'a' will be 0, 'b'-'a' will be 1, \n        # so for location of character in count  \n        # array we will do str[i]-'a'. \n        charCount[ord(str[i]) - ord('a')] += 1\n      \n    # Traverse the hash array and print  \n    # characters \n    for i in range(0, MAX_CHAR, 1): \n        for j in range(0, charCount[i], 1): \n            print(chr(ord('a') + i), end = '') \n  \n# Driver Code \nif __name__ == '__main__': \n    s = ' '\n    sortString(s) \n      \n# This code is contributed by \n# Sahil_Shelangia \n"], "Count the number of unique characters in a given String -  ": ["# Python 3 program of the above approach\n \n# Program to count the number of\n# unique characters in a string\ndef cntDistinct(st):\n \n    # Set to store unique characters\n    # in the given string\n    s = set([])\n \n    # Loop to traverse the string\n    for i in range(len(st)):\n \n        # Insert current character\n        # into the set\n        s.add(st[i])\n \n    # Return Answer\n    return len(s)\n \n# Driver Code\nif __name__ == '__main__':\n \n    st = ' '\n    print(cntDistinct(st))\n \n    # This code is contributed by ukasp.\n", "def cntDistinct(str):\n    # created a empty dictionary over here\n    count = {}\n    for i in range(len(str)):\n        # we are checking that if element already exist\n        # we will be incrementing the count of element by 1\n        if str[i] in count:\n            count[str[i]] += 1\n        # if exist in count then insert that element \n        # and initialize its count by 1\n        else:\n            count[str[i]] = 1\n    return len(count)\n \nstring = ' '\nans = cntDistinct(string)\nprint(ans)\n", "# Function to count distinct characters\ndef countDistinct(s):\n    s = s.lower() # convert the string to lowercase\n    n = len(s) # size of string\n    a = [0] * 26 # an array of size 26, initialize with 0\n \n    # iterate over the string s\n    for i in range(n):\n        index = ord(s[i]) - ord('a') # calculate index by (s[i] - 'a') in ASCII value\n        a[index] = 1 # Set the value at index to 1\n \n    count = 0 # Take a counter with 0\n    for i in range(26): # Loop to 26\n        # count no. of index having value 1\n        if a[i] == 1:\n            count += 1\n    return count\n \n# Driver code\ns = ' ' # string taken\nprint(countDistinct(s)) # Print answer\n"], "Conversion of whole String to uppercase or lowercase using STL in C++ -  ": [], "C function to Swap strings -  ": [], "Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1->1->2, return 1->2. Given 1->1->2->3->3, return 1->2->3.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    def deleteDuplicates(self, A):\n        node = A\n        while node and node.next:\n            while node.next and node.val == node.next.val:\n                node.next = node.next.next\n            node = node.next\n        return A\n\n\n", "Move all zeroes to end of array -  ": ["# Python3 code to move all zeroes \n# at the end of array \n  \n# Function which pushes all \n# zeros to end of an array. \ndef pushZerosToEnd(arr, n): \n    count = 0 # Count of non-zero elements \n      \n    # Traverse the array. If element  \n    # encountered is non-zero, then \n    # replace the element at index \n    # 'count' with this element \n    for i in range(n): \n        if arr[i] != 0: \n              \n            # here count is incremented \n            arr[count] = arr[i] \n            count+=1\n      \n    # Now all non-zero elements have been \n    # shifted to front and 'count' is set \n    # as index of first 0. Make all  \n    # elements 0 from count to end. \n    while count < n: \n        arr[count] = 0\n        count += 1\n          \n# Driver code \narr = [1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9] \nn = len(arr) \npushZerosToEnd(arr, n) \nprint('Array after pushing all zeros to end of array:') \nprint(arr) \n  \n# This code is contributed by 'Abhishek Sharma 44' \n", "# Python Program to move all zeros to the end \nA = [5, 6, 0, 4, 6, 0, 9, 0, 8] \nn = len(A) \nj = 0\nfor i in range(n): \n    if A[i] != 0: \n        A[j], A[i] = A[i], A[j]  # Partitioning the array \n        j += 1\nprint(A)  # Print the array \n  \n# This code is contributed by Tapesh(tapeshdua420) \n", "# C++ program to shift all zeros \n# to right most side of array \n# without affecting order of non-zero \n# elements \n  \n# Given list \narr = [5, 6, 0, 4, 6, 0, 9, 0, 8] \n  \n# Storing all non zero values \nnonZeroValues = [x for x in arr if x != 0]  \n  \n# Storing all zeroes \nzeroes = [j for j in arr if j == 0]  \n  \n# Updating the answer \narr = nonZeroValues + zeroes \n  \n# Printing the answer \nprint( 'array after shifting zeros to right side: ', arr)\n", "# Python Program to move all zeros to the end \n  \nA = [5, 6, 0, 4, 6, 0, 9, 0, 8] \nn = len(A) \nB = [0] * n \nj = 0\ncount = 0\n  \nfor i in range(n): \n    if A[i] != 0: \n        B[j] = A[i] \n        j += 1\n    else: \n        count += 1\n  \nwhile count > 0: \n    B[j] = 0\n    count -= 1\n    j += 1\n  \nfor i in range(n): \n    A[i] = B[i] \n  \nfor i in range(n): \n    print(A[i], end=' ') # Print the array \n  \n# This code is contributed by Prajwal Kandekar\n"], "Find Second largest element in an array -  ": ["# Python3 program to find second \n# largest element in an array \n  \n# Function to print the \n# second largest elements \n  \n  \ndef print2largest(arr, arr_size): \n  \n    # There should be \n    # atleast two elements \n    if (arr_size < 2): \n        print(' Invalid Input ') \n        return\n  \n    # Sort the array \n    arr.sort \n  \n    # Start from second last \n    # element as the largest \n    # element is at last \n    for i in range(arr_size-2, -1, -1): \n  \n        # If the element is not \n        # equal to largest element \n        if (arr[i] != arr[arr_size - 1]): \n  \n            print('The second largest element is', arr[i]) \n            return\n  \n    print('There is no second largest element') \n  \n  \n# Driver code \narr = [12, 35, 1, 10, 34, 1] \nn = len(arr) \nprint2largest(arr, n) \n  \n# This code is contributed by divyeshrabadiya07 \n", "# Python3 code for the above approach \n  \nif __name__ == '__main__': \n    # Given vector \n    v = [12, 35, 1, 10, 34, 1] \n    # Print the second largest element in the vector \n      \n     # Converting the given vector to a set to remove duplicates \n    s = set(v) \n    # Sorting the set \n    s = sorted(s) \n      \n    print('The Second Largest Element in Vector is: ',s[-2]) \n      \n    #This code is contributed by nikhilsainiofficial546\n", "# Python3 program to find  \n# second largest element  \n# in an array \n  \n# Function to print  \n# second largest elements \ndef print2largest(arr, arr_size): \n  \n    # There should be atleast  \n    # two elements \n    if (arr_size < 2): \n        print(' Invalid Input '); \n        return; \n  \n    largest = second = -2454635434; \n  \n    # Find the largest element \n    for i in range(0, arr_size): \n        largest = max(largest, arr[i]); \n  \n    # Find the second largest element \n    for i in range(0, arr_size): \n        if (arr[i] != largest): \n            second = max(second, arr[i]); \n  \n    if (second == -2454635434): \n        print('There is no second ' + \n              'largest element'); \n    else: \n        print('The second largest ' + \n              'element is \\n', second); \n  \n# Driver code \nif __name__ == '__main__': \n    \n    arr = [12, 35, 1,  \n           10, 34, 1]; \n    n = len(arr); \n    print2largest(arr, n); \n  \n# This code is contributed by shikhasingrajput\n", "# Python program to \n# find second largest  \n# element in an array \n  \n  \n# Function to print the \n# second largest elements  \ndef print2largest(arr, arr_size): \n  \n    # There should be atleast \n        # two elements  \n    if (arr_size < 2): \n      \n        print(' Invalid Input ') \n        return\n      \n  \n    first = second = -2147483648\n    for i in range(arr_size): \n      \n        # If current element is \n                # smaller than first \n        # then update both \n                # first and second  \n        if (arr[i] > first): \n          \n            second = first \n            first = arr[i] \n          \n  \n        # If arr[i] is in \n                # between first and  \n        # second then update second  \n        elif (arr[i] > second and arr[i] != first): \n            second = arr[i] \n      \n    if (second == -2147483648): \n        print('There is no second largest element') \n    else: \n        print('The second largest element is', second) \n  \n  \n# Driver program to test \n# above function  \narr = [12, 35, 1, 10, 34, 1] \nn = len(arr) \n  \nprint2largest(arr, n) \n  \n# This code is contributed \n# by Anant Agarwal. \n", "from collections import defaultdict \n  \ndef second_largest(n, vec): \n    # size of array should be greater than 1 \n    if n < 2: \n        print('Invalid Input') \n        return\n  \n    count = defaultdict(int) \n    for i in range(n): \n        count[vec[i]] += 1\n  \n    # Checking if count size is equal to 1 it \n    # means only largest element exist there is no second  \n    # largest element \n    if len(count) == 1: \n        print('No Second largest element exist') \n        return\n  \n    # sort the dictionary by key in descending order \n    count_sorted = sorted(count.items(), key=lambda x: x[0], reverse=True) \n    second_largest = None\n    for i, (key, value) in enumerate(count_sorted): \n        if i == 1: \n            second_largest = key \n            break\n  \n    if second_largest is not None: \n        print('The second largest element is:', second_largest) \n  \nvec = [12, 35, 1, 10, 34, 1] \nsecond_largest(len(vec), vec) \n  \n# This code is contributed by divyansh2212\n", "import queue \n  \n# Given vector \nv = [12, 35, 1, 10, 34, 1] \n  \n# Made a priority queue \npq = queue.PriorityQueue() \n  \n# Inserting all the elements from vector v to priority queue pq \nfor i in range(len(v)): \n    pq.put(-v[i]) \n  \n# Remove largest element from pq \npq.get() \n  \n# Now top of priority queue is second largest element \nprint('The Second Largest Element in Vector is:', -pq.get()) \n# This code is contributed by Prajwal Kandekar \n"], "Find the largest three distinct elements in an array -  ": ["# Python3 code to find largest three\n# elements in an array\nimport sys\n \n# Function to print three largest \n# elements \ndef print3largest(arr, arr_size):\n \n    # There should be atleast three\n    # elements \n    if (arr_size < 3):\n     \n        print(' Invalid Input ')\n        return\n     \n    third = first = second = -sys.maxsize\n     \n    for i in range(0, arr_size):\n     \n        # If current element is greater\n        # than first\n        if (arr[i] > first):\n         \n            third = second\n            second = first\n            first = arr[i]\n         \n \n        # If arr[i] is in between first\n        # and second then update second \n        elif (arr[i] > second):\n         \n            third = second\n            second = arr[i]\n         \n        elif (arr[i] > third):\n            third = arr[i]\n     \n    print('Three largest elements are',\n                  first, second, third)\n \n# Driver program to test above function \narr = [12, 13, 1, 10, 34, 1]\nn = len(arr)\nprint3largest(arr, n)\n \n# This code is contributed by Smitha Dinesh Semwal \n# and edited by Ayush Singla(@ayusin51).\n", "# Python3 code to find largest\n# three elements in an array\ndef find3largest(arr, n):\n    arr = sorted(arr) # It uses Tuned Quicksort with\n                      # avg. case Time complexity = O(nLogn)\n \n    check = 0\n    count = 1\n \n    for i in range(1, n + 1):\n \n        if(count < 4):\n            if(check != arr[n - i]):\n                 \n                # to handle duplicate values\n                print(arr[n - i], end = ' ')\n                check = arr[n - i]\n                count += 1\n        else:\n            break\n \n# Driver code\narr = [12, 45, 1, -1, 45, \n       54, 23, 5, 0, -10]\nn = len(arr)\nfind3largest(arr, n)\n \n# This code is contributed by mohit kumar\n", "# Python program to implement\n# the above approach\n \n# Driver Code\nV = [ 11, 65, 193, 36, 209, 664, 32 ];\nV.sort()\nV.reverse()\n \nprint(f'first =  {V[0]}');\nprint(f'second =  {V[1]}');\nprint(f'third =  {V[2]}');\n     \n# This code is contributed by Saurabh Jaiswal\n"], "Generating subarrays using recursion -  ": ["# Python3 code to print all possible subarrays \n# for given array using recursion\n \n# Recursive function to print all possible subarrays \n# for given array\ndef printSubArrays(arr, start, end):\n     \n    # Stop if we have reached the end of the array    \n    if end == len(arr):\n        return\n     \n    # Increment the end point and start from 0\n    elif start > end:\n        return printSubArrays(arr, 0, end + 1)\n         \n    # Print the subarray and increment the starting\n    # point\n    else:\n        print(arr[start:end + 1])\n        return printSubArrays(arr, start + 1, end)\n         \n# Driver code\narr = [1, 2, 3]\nprintSubArrays(arr, 0, 0)\n"], "Search, Insert, and Delete in an Sorted Array | Array Operations -  ": ["# python 3  program to implement \n# binary search in sorted array \n  \n  \ndef binarySearch(arr, low, high, key): \n  \n    mid = (low + high)/2\n  \n    if (key == arr[int(mid)]): \n        return mid \n  \n    if (key > arr[int(mid)]): \n        return binarySearch(arr, \n                            (mid + 1), high, key) \n  \n    if (key < arr[int(mid)]): \n        return binarySearch(arr, low, (mid-1), key) \n  \n    return 0\n  \n  \n# Driver code \nif __name__ == '__main__': \n    # Let us search 3 in below array \n    arr = [5, 6, 7, 8, 9, 10] \n    n = len(arr) \n    key = 10\n  \n    # Function call \n    print('Index:', int(binarySearch(arr, 0, n-1, key))) \n  \n# This code is contributed by \n# Smitha Dinesh Semwal \n", "# Python3 program to implement insert \n# operation in an sorted array. \n  \n# Inserts a key in arr[] of given capacity. \n# n is current size of arr[]. This function \n# returns n+1 if insertion is successful, else n. \n  \n  \ndef insertSorted(arr, n, key, capacity): \n  \n    # Cannot insert more elements if n is \n    # already more than or equal to capacity \n    if (n >= capacity): \n        return n \n  \n    i = n - 1\n    while i >= 0 and arr[i] > key: \n        arr[i + 1] = arr[i] \n        i -= 1\n  \n    arr[i + 1] = key \n  \n    return (n + 1) \n  \n  \n# Driver Code \nif __name__ == '__main__': \n    arr = [12, 16, 20, 40, 50, 70] \n  \n    for i in range(20): \n        arr.append(0) \n  \n    capacity = len(arr) \n    n = 6\n    key = 26\n  \n    print('Before Insertion: ', end=' ') \n    for i in range(n): \n        print(arr[i], end=' ') \n  \n    # Function call \n    n = insertSorted(arr, n, key, capacity) \n  \n    print('\\nAfter Insertion: ', end='') \n    for i in range(n): \n        print(arr[i], end=' ') \n  \n# This code is contributed by Mohit Kumar \n", "# Python program to implement delete operation in a \n# sorted array \n  \n# /* Function to delete an element */ \n  \n  \ndef deleteElement(arr, n, key): \n  \n    # Find position of element to be deleted \n    pos = binarySearch(arr, 0, n - 1, key) \n  \n    if (pos == -1): \n        print('Element not found') \n        return n \n  \n    # Deleting element \n    for i in range(pos, n - 1): \n        arr[i] = arr[i + 1] \n  \n    return n - 1\n  \n# To search a key to be deleted \n  \n  \ndef binarySearch(arr, low, high, key): \n  \n    if (high < low): \n        return -1\n    mid = (low + high) // 2\n  \n    if (key == arr[mid]): \n        return mid \n    if (key > arr[mid]): \n        return binarySearch(arr, (mid + 1), high, key) \n  \n    return binarySearch(arr, low, (mid - 1), key) \n  \n  \n# Driver code \nif __name__ == '__main__': \n    arr = [10, 20, 30, 40, 50] \n  \n    n = len(arr) \n    key = 30\n  \n    print('Array before deletion') \n  \n    for i in range(n): \n        print(arr[i], end=' ') \n  \n    # Function call \n    n = deleteElement(arr, n, key) \n    print('\\n\\nArray after deletion') \n    for i in range(n): \n        print(arr[i], end=' ') \n  \n# This code is contributed by shubhamsingh10 \n"], "Search, Insert, and Delete in an Unsorted Array | Array Operations -  ": ["# Python program for searching in\n# unsorted array\n \n \ndef findElement(arr, n, key):\n    for i in range(n):\n        if (arr[i] == key):\n            return i\n           \n    # If the key is not found\n    return -1\n \n \n# Driver's code\nif __name__ == '__main__':\n    arr = [12, 34, 10, 6, 40]\n    key = 40\n    n = len(arr)\n \n    # search operation\n    index = findElement(arr, n, key)\n    if index != -1:\n        print('Element Found at position: ' + str(index + 1))\n    else:\n        print('Element not found')\n \n    # Thanks to Aditi Sharma for contributing\n    # this code\n", "# Python program for inserting\n# an element in an unsorted array\n \n# method to insert element\n \n \ndef insert(arr, element):\n    arr.append(element)\n \n \n# Driver's code\nif __name__ == '__main__':\n    # declaring array and key to insert\n    arr = [12, 16, 20, 40, 50, 70]\n    key = 26\n \n    # array before inserting an element\n    print('Before Inserting: ')\n    print(arr)\n \n    # array after Inserting element\n    insert(arr, key)\n    print('After Inserting: ')\n    print(arr)\n \n    # Thanks to Aditi Sharma for contributing\n    # this code\n", "# python Program to Insert an element\n# at a specific position in an Array\ndef insertElement(arr, n, x, pos) :\n     \n    # shift elements to the right\n    # which are on the right side of pos\n    for i in range(n-1,pos-1,-1) :\n        arr[i + 1] = arr[i]\n         \n    arr[pos] = x\n \n# Driver's code\nif __name__ == '__main__':\n    # Declaring array and key to delete\n    # here -1 is for empty space\n    arr = [2, 4, 1, 8, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]\n    n = 5\n     \n    print('Before insertion : ')\n    for i in range(0,n) :\n        print(arr[i],end=' ')\n \n    print('\\n')\n \n    x = 10;\n    pos = 2;\n   \n    # Function call\n    insertElement(arr, n, x, pos);\n    n+=1\n \n    print('After insertion : ')\n    for i in range(0,n) :\n        print(arr[i],end=' ')\n         \n #This Code is contributed by aditya942003patil\n", "# Python program to delete an element\n# from an unsorted array\n \n# Driver's code\nif __name__ == '__main__':\n    # Declaring array and key to delete\n    arr = [10, 50, 30, 40, 20]\n    key = 30\n  \n    print('Array before deletion:')\n    print (arr)\n  \n    # deletes key if found in the array \n    # otherwise shows error not in list\n    arr.remove(key)\n    print('Array after deletion')\n    print(arr)\n  \n    # This code is contributed by Aditi Sharma. \n"], "Print array after it is right rotated K times -  ": ["# Python3 implementation of right rotation \n# of an array K number of times\n \n# Function to rightRotate array\ndef RightRotate(a, n, k):\n \n    # If rotation is greater \n    # than size of array\n    k = k % n;\n \n    for i in range(0, n):\n \n        if(i < k):\n \n            # Printing rightmost \n            # kth elements\n            print(a[n + i - k], end = ' ');\n \n        else:\n \n            # Prints array after\n            # 'k' elements\n            print(a[i - k], end = ' ');\n \n    print('\\n');\n \n# Driver code\nArray = [ 1, 2, 3, 4, 5 ];\nN = len(Array);\nK = 2;\n     \nRightRotate(Array, N, K);\n \n# This code is contributed by Code_Mech\n", "class GFG :\n    @staticmethod\n    def main( args) :\n        arr = [1, 3, 5, 7, 9, 11]\n        n = len(arr)\n        k = 3\n        # No. of rotations\n        k = k % n\n        i = 0\n        j = 0\n        # Reverse last k numbers\n        i = n - k\n        j = n - 1\n        while (i < j) :\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n            i += 1\n            j -= 1\n        # Reverse the first n-k terms\n        i = 0\n        j = n - k - 1\n        while (i < j) :\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n            i += 1\n            j -= 1\n        # Reverse the entire array\n        i = 0\n        j = n - 1\n        while (i < j) :\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n            i += 1\n            j -= 1\n        # Print the rotated array\n        t = 0\n        while (t < n) :\n            print(str(arr[t]) + ' ', end ='')\n            t += 1\n     \n \nif __name__=='__main__':\n    GFG.main([])\n     \n    # This code is contributed by aadityaburujwale.\n", "def rotate_array(arr, n, k):\n    # Reduce the number of rotations\n    k %= n\n \n    # Reverse the first part of the array\n    arr[:n - k] = arr[:n - k][::-1]\n \n    # Reverse the second part of the array\n    arr[n - k:] = arr[n - k:][::-1]\n \n    # Reverse the entire array\n    arr[:] = arr[::-1]\n \n \n# Driver code\narr = [1, 3, 5, 7, 9]\nn = len(arr)\nk = 2\n \nrotate_array(arr, n, k)\n \nfor i in range(n):\n    print(arr[i], end=' ')\n \nprint()\n \n# This code is contributed by Dwaipayan Bandyopadhyay\n"], "Program for array left rotation by d positions. -  ": ["def rotate(L, d, n):\n    k = L.index(d)\n    new_lis = []\n    new_lis = L[k+1:]+L[0:k+1]\n    return new_lis\n \n \nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    d = 2\n    N = len(arr)\n \n    # Function call\n    arr = rotate(arr, d, N)\n    for i in arr:\n        print(i, end=' ')\n", "# Python program to rotate an array by d elements\n \n# Function to left rotate arr[] of size n by d\ndef Rotate(arr, d, n):\n  p = 1\n  while(p <= d):\n    last = arr[0]\n    for i in range (n - 1):\n      arr[i] = arr[i + 1]\n    arr[n - 1] = last\n    p = p + 1\n     \n# Function to print an array\ndef printArray(arr, size):\n  for i in range (size):\n    print(arr[i] ,end = ' ')\n     \n# Driver code\narr = [1, 2, 3, 4, 5, 6, 7]\nN = len(arr)\nd = 2\n \n# Function calling\nRotate(arr, d, N)\nprintArray(arr, N)\n \n# This code is contributed by Atul_kumar_Shrivastava\n", "# Python3 program to rotate an array by\n# d elements\n# Function to left rotate arr[] of size n by d\n \n \ndef leftRotate(arr, d, n):\n    d = d % n\n    g_c_d = gcd(d, n)\n    for i in range(g_c_d):\n \n        # move i-th values of blocks\n        temp = arr[i]\n        j = i\n        while 1:\n            k = j + d\n            if k >= n:\n                k = k - n\n            if k == i:\n                break\n            arr[j] = arr[k]\n            j = k\n        arr[j] = temp\n \n# UTILITY FUNCTIONS\n# function to print an array\n \n \ndef printArray(arr, size):\n    for i in range(size):\n        print('% d' % arr[i], end=' ')\n \n# Function to get gcd of a and b\n \n \ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n \n \n# Driver program to test above functions\narr = [1, 2, 3, 4, 5, 6, 7]\nn = len(arr)\nd = 2\nleftRotate(arr, d, n)\nprintArray(arr, n)\n \n# This code is contributed by Shreyanshi Arun\n"], "Minimize count of 0s in Binary String by changing K-size substring to 1s at most Q times -  ": ["# Python 3 program for the above approach\nimport sys\ndef cnt(s,ch):\n    count  = 0\n    for x in s:\n        if x == ch:\n            count += 1\n    return count\n \n# Function to find the minimum number of\n# zeroes after changing the value of all\n# elements of any substring of at most K\n# elements to 1 at most Q number of times\ndef minZeroeCount(S, K, Q):\n   \n    # Stores the size of the given string\n    N = len(S)\n \n    # If no operation is possible, return\n    # the count of 0 in the initial string\n    if (K == 0 or Q == 0):\n        return cnt(S,'0')\n \n    # If all the elements of the given string\n    # can be selected in Q operations\n    if (Q >= int(N/K) + 1):\n        return 0\n \n    # 2D vector to store the dp states,\n    # initially having all the values\n    # as INT_MAX\n    dp = [[sys.maxsize for i in range(Q + 1)] for j in range(N + 1)]\n \n    # Loop to initialize dp[0][j] = 0\n    # for all j in the range [0, Q],\n    for j in range(Q + 1):\n        dp[0][j] = 0\n \n    # Loop to initialize dp[0][j] = count\n    # of 0 in prefix of length i for all\n    # i in the range [1, N],\n    for i in range(1,N+1,1):\n        dp[i][0] = dp[i - 1][0] + (S[i - 1] == '0')\n \n    # Traverse over all dp[][] states\n    for i in range(1, N + 1, 1):\n        for j in range(1, Q + 1, 1):\n           \n            # Find the value of dp[i][j]\n            dp[i][j] = min(dp[max(0, i - K)][j - 1], dp[i - 1][j]+(S[i - 1] == '0'))\n \n    # Return answer\n    return dp[N][Q]\n \n# Driver Code\nif __name__ == '__main__':\n    S = '0100010110'\n    K = 3\n    Q = 2\n    print(minZeroeCount(S, K, Q))\n     \n    # This code is contributed by SURENDRA_GANGWAR.\n"], "Shortest path by removing K walls -  ": ["# Python3 code to implement the approach\n \n# Function to find the minimum number of steps\ndef shortestPath(mat, k):\n \n    n = len(mat)\n    m = len(mat[0])\n    if (n == 1 and m == 1 and (mat[0][0] == 0 or k >= 1)):\n        return 0\n \n    visited = [[[False for _ in range(k+1)]\n                for _ in range(m)] for _ in range(n)]\n    steps = 0\n \n    q = []\n    q.append([0, 0, k])\n \n    ar1 = [1, -1, 0, 0]\n    ar2 = [0, 0, -1, 1]\n \n    # Loop to run a BFS\n    while (len(q) != 0):\n        size = len(q)\n \n        steps += 1\n        while (size):\n            curr = q.pop(0)\n            i = curr[0]\n            j = curr[1]\n            w = curr[2]\n \n            visited[i][j][w] = True\n            for dir in range(0, 4):\n                new_x = i + ar1[dir]\n                new_y = j + ar2[dir]\n                new_k = w\n                if (new_x >= 0 and new_x < n and new_y >= 0\n                        and new_y < m):\n                    if (mat[new_x][new_y] == 0\n                            and (not visited[new_x][new_y][new_k])):\n                        if (new_x == n - 1\n                                and new_y == m - 1):\n                            return steps\n                        q.append([new_x, new_y, new_k])\n                        visited[new_x][new_y][new_k] = True\n \n                    elif (mat[new_x][new_y] == 1\n                          and new_k >= 1\n                          and (not visited[new_x][new_y]\n                               [new_k - 1])):\n                        if (new_x == n - 1\n                                and new_y == m - 1):\n                            return steps\n                        q.append([new_x, new_y, new_k - 1])\n                        visited[new_x][new_y][new_k - 1] = True\n            size -= 1\n    return -1\n \n# Driver code\nif __name__ == '__main__':\n \n    mat = [[0, 0, 0], [0, 0, 1], [0, 1, 0]]\n    K = 1\n \n    # Function call\n    print(shortestPath(mat, K))\n \n    # This code is contributed by rakeshsahni\n"], "Find number of closed islands in given Matrix -  ": ["# Python3 program for the above approach\n \n# DFS Traversal to find the count of\n# island surrounded by water\ndef dfs(matrix, visited, x, y, n, m):\n     \n    # If the land is already visited\n    # or there is no land or the\n    # coordinates gone out of matrix\n    # break function as there\n    # will be no islands\n    if (x < 0 or y < 0 or\n        x >= n or y >= m or\n        visited[x][y] == True or\n        matrix[x][y] == 0):\n        return\n         \n    # Mark land as visited\n    visited[x][y] = True\n \n    # Traverse to all adjacent elements\n    dfs(matrix, visited, x + 1, y, n, m);\n    dfs(matrix, visited, x, y + 1, n, m);\n    dfs(matrix, visited, x - 1, y, n, m);\n    dfs(matrix, visited, x, y - 1, n, m);\n \n# Function that counts the closed island\ndef countClosedIsland(matrix, n, m):\n     \n    # Create boolean 2D visited matrix\n    # to keep track of visited cell\n  \n    # Initially all elements are\n    # unvisited.\n    visited = [[False for i in range(m)]\n                      for j in range(n)]\n \n    # Mark visited all lands\n    # that are reachable from edge\n    for i in range(n):\n        for j in range(m):\n             \n            # Traverse corners\n            if ((i * j == 0 or i == n - 1 or\n                 j == m - 1) and matrix[i][j] == 1 and\n                 visited[i][j] == False):\n                dfs(matrix, visited, i, j, n, m)\n \n    # To stores number of closed islands\n    result = 0\n \n    for i in range(n):\n        for j in range(m):\n             \n            # If the land not visited\n            # then there will be atleast\n            # one closed island\n            if (visited[i][j] == False and\n                 matrix[i][j] == 1):\n                result += 1\n                 \n                # Mark all lands associated\n                # with island visited.\n                dfs(matrix, visited, i, j, n, m)\n \n    # Return the final count\n    return result\n \n#  Driver Code\n \n# Given size of Matrix\nN = 5\nM = 8\n \n# Given Matrix\nmatrix = [ [ 0, 0, 0, 0, 0, 0, 0, 1 ],\n           [ 0, 1, 1, 1, 1, 0, 0, 1 ],\n           [ 0, 1, 0, 1, 0, 0, 0, 1 ],\n           [ 0, 1, 1, 1, 1, 0, 1, 0 ], \n           [ 0, 0, 0, 0, 0, 0, 0, 1 ] ]\n            \n# Function Call \nprint(countClosedIsland(matrix, N, M))\n \n# This code is contributed by rag2127\n", "# Python3 program for the above approach\n \n# DFS Traversal to find the count of\n# island surrounded by water\ndef dfs(matrix, visited, x, y, n, m, hasCornerCell):\n     \n    # If the land is already visited\n    # or there is no land or the\n    # coordinates gone out of matrix\n    # break function as there\n    # will be no islands\n    if (x < 0 or y < 0 or\n        x >= n or y >= m or\n        visited[x][y] == True or\n         matrix[x][y] == 0):\n        return\n \n    if (x == 0 or y == 0 or\n        x == n - 1 or y == m - 1):\n        if (matrix[x][y] == 1):\n            hasCornerCell = True\n \n    # Mark land as visited\n    visited[x][y] = True\n \n    # Traverse to all adjacent elements\n    dfs(matrix, visited, x + 1, y, n, m, hasCornerCell)\n    dfs(matrix, visited, x, y + 1, n, m, hasCornerCell)\n    dfs(matrix, visited, x - 1, y, n, m, hasCornerCell)\n    dfs(matrix, visited, x, y - 1, n, m, hasCornerCell)\n \n# Function that counts the closed island\ndef countClosedIsland(matrix, n, m):\n     \n    # Create boolean 2D visited matrix\n    # to keep track of visited cell\n \n    # Initially all elements are\n    # unvisited.\n    visited = [[False for i in range(m)] \n                      for j in range(n)] \n    result = 0\n     \n    # Mark visited all lands\n    # that are reachable from edge\n    for i in range(n): \n        for j in range(m):\n            if ((i != 0 and j != 0 and\n                 i != n - 1 and j != m - 1) and\n                 matrix[i][j] == 1 and\n                visited[i][j] == False):\n \n                # Determine if the island is closed\n                hasCornerCell = False\n \n                # hasCornerCell will be updated to\n                # true while DFS traversal if there\n                # is a cell with value '1' on the corner \n                dfs(matrix, visited, i, j,\n                    n, m, hasCornerCell)\n \n                # If the island is closed\n                if (not hasCornerCell):\n                    result = result + 1\n \n    # Return the final count\n    return result\n     \n# Driver Code\n \n# Given size of Matrix\nN, M = 5, 8\n \n# Given Matrix\nmatrix = [ [ 0, 0, 0, 0, 0, 0, 0, 1 ],\n           [ 0, 1, 1, 1, 1, 0, 0, 1 ],\n           [ 0, 1, 0, 1, 0, 0, 0, 1 ],\n           [ 0, 1, 1, 1, 1, 0, 1, 0 ],\n           [ 0, 0, 0, 0, 0, 0, 0, 1 ] ]\n \n# Function Call\nprint(countClosedIsland(matrix, N, M))\n \n# This code is contributed by divyeshrabadiya07\n", "# Python program for the above approach\ndx = [-1, 0, 1, 0 ]\ndy = [0, 1, 0, -1]\n \nglobal matrix\n \n# DFS Traversal to find the count of\n# island surrounded by water\ndef bfs(x, y, n, m):\n   \n    # To store the popped cell\n    temp = []\n     \n    # To store the cell of BFS\n    Q = []\n     \n    # Push the current cell\n    Q.append([x, y])\n     \n    # Until Q is not empty\n    while(len(Q) > 0):\n        temp = Q.pop()\n         \n        # Mark current cell\n        # as visited\n        visited[temp[0]][temp[1]] = True\n         \n        # Iterate in all four directions\n        for i in range(4):\n            x = temp[0] + dx[i]\n            y = temp[1] + dy[i]\n             \n            # Cell out of the matrix\n            if(x < 0 or y < 0 or x >= n or y >= n or visited[x][y] == True or matrix[x][y] == 0):\n                continue\n            # Check is adjacent cell is\n            # 1 and not visited\n            if(visited[x][y] == False and matrix[x][y] == 1):\n                Q.append([x, y])\n \n# Function that counts the closed island\ndef countClosedIsland(n, m):\n     \n    # Create boolean 2D visited matrix\n    # to keep track of visited cell\n  \n    # Initially all elements are\n    # unvisited.\n    global visited\n    visited = [[False for i in range(m)] for j in range(n)]\n \n    # Mark visited all lands\n    # that are reachable from edge\n    for i in range(n):\n        for j in range(m):\n           \n            # Traverse corners\n            if((i * j == 0 or i == n - 1 or j == m - 1) and matrix[i][j] == 1 and visited[i][j] == False):\n                bfs(i, j, n, m);\n                 \n    # To stores number of closed islands\n    result = 0\n    for i in range(n):\n        for j in range(m):\n           \n            # If the land not visited\n            # then there will be atleast\n            # one closed island\n            if(visited[i][j] == False and matrix[i][j] == 1):\n                result += 1\n                 \n                # Mark all lands associated\n                # with island visited\n                bfs(i, j, n, m);\n                 \n    # Return the final count\n    return result\n   \n# Driver Code\n \n# Given size of Matrix\nN = 5\nM = 8\n \n# Given Matrix\nmatrix = [[ 0, 0, 0, 0, 0, 0, 0, 1],\n          [0, 1, 1, 1, 1, 0, 0, 1],\n          [0, 1, 0, 1, 0, 0, 0, 1 ],\n          [0, 1, 1, 1, 1, 0, 1, 0 ],\n          [0, 0, 0, 0, 0, 0, 0, 1]]\n \n# Function Call\nprint(countClosedIsland(N, M))\n \n# This code is contributed by avanitrachhadiya2155\n", "# python 3 program for the above approach\n \n# Function that implements the Find\ndef Find(hashSet, val):\n   \n    # Get the val\n    parent = val\n     \n    # Until parent is not found\n    while (parent != hashSet[parent]):\n        parent = hashSet[parent]\n \n    # Return the parent\n    return parent\n \n# Function that implements the Union\ndef Union(hashSet, first, second):\n   \n    # Find the first father\n    first_father = Find(hashSet, first)\n \n    # Find the second father\n    second_father = Find(hashSet, second)\n \n    # If both are unequals then update\n    # first father as ssecond_father\n    if (first_father != second_father):\n        hashSet[first_father] = second_father\n \n# Recursive Function that change all\n# the corners connected 1s to 0s\ndef change(matrix, x, y, n, m):\n   \n    # If already zero then return\n    if (x < 0 or y < 0 or x > m - 1 or y > n - 1 or matrix[x][y] == '0'):\n        return\n \n    # Change the current cell to '0'\n    matrix[x][y] = '0'\n \n    # Recursive Call for all the\n    # four corners\n    change(matrix, x + 1, y, n, m)\n    change(matrix, x, y + 1, n, m)\n    change(matrix, x - 1, y, n, m)\n    change(matrix, x, y - 1, n, m)\n \n# Function that changes all the\n# connected 1s to 0s at the corners\ndef changeCorner(matrix):\n   \n    # Dimensions of matrix\n    m = len(matrix)\n    n = len(matrix[0])\n \n    # Traverse the matrix\n    for i in range(m):\n        for j in range(n):\n           \n            # If corner cell\n            if (i * j == 0 or i == m - 1 or j == n - 1):\n               \n                # If value is 1s, then\n                # recursively change to 0\n                if (matrix[i][j] == '1'):\n                    change(matrix, i, j, n, m)\n \n# Function that counts the number\n# of island in the given matrix\ndef numIslands(matrix):\n    if (len(matrix) == 0):\n        return 0\n \n    # Dimensions of the matrix\n    m = len(matrix)\n    n = len(matrix[0])\n \n    # Make all the corners connecting\n    # 1s to zero\n    changeCorner(matrix)\n \n    # First convert to 1 dimension\n    # position and convert all the\n    # connections to edges\n    edges = []\n    for i in range(m):\n        for j in range(n):\n           \n            # If the cell value is 1\n            if (matrix[i][j] == '1'):\n                id = i * n + j\n \n                # Move right\n                if (j + 1 < n):\n                    # If right cell is\n                    # 1 then make it as\n                    # an edge\n                    if (matrix[i][j + 1] == '1'):\n                        right = i * n + j + 1\n \n                        # Push in edge vector\n                        edges.append([id, right])\n                # Move down\n                if (i + 1 < m):\n                   \n                    # If right cell is\n                    # 1 then make it as\n                    # an edge\n                    if (matrix[i + 1][j] == '1'):\n                        down = (i + 1) * n + j\n \n                        # Push in edge vector\n                        edges.append([id, down])\n \n    # Construct the Union Find structure\n    hashSet = [0 for i in range(m*n)]\n    for i in range(m*n):\n        hashSet[i] = i\n \n    # Next apply Union Find for all\n    # the edges stored\n    for edge in edges:\n        Union(hashSet, edge[0], edge[1])\n \n    # To count the number of connected\n    # islands\n    numComponents = 0\n \n    # Traverse to find the islands\n    for i in range(m*n):\n        if (matrix[i // n][i % n] == '1' and hashSet[i] == i):\n            numComponents += 1\n \n    # Return the count of the island\n    return numComponents\n \n# Driver Code\nif __name__ == '__main__':\n   \n    # Given size of Matrix\n    N = 5\n    M = 8\n \n    # Given Matrix\n    matrix = [['0', '0', '0', '0', '0', '0', '0', '1'],\n              ['0', '1', '1', '1', '1', '0', '0', '1'],\n              ['0', '1', '0', '1', '0', '0', '0', '1'],\n              ['0', '1', '1', '1', '1', '0', '1', '0'],\n              ['0', '0', '0', '0', '0', '0', '0', '1']]\n \n    # Function Call\n    print(numIslands(matrix))\n \n    # This code is contributed by bgangwar59.\n"], "Print all possible shortest chains to reach a target word -  ": ["# Python Program to implement\n# the above approach\nfrom collections import deque\nfrom typing import Deque, List, Set\n \n# Function to print all possible shortest\n# sequences starting from start to target.\ndef displaypath(res: List[List[str]]):\n    for i in res:\n        print('[ ', end='')\n        for j in i:\n            print(j, end=', ')\n        print(']')\n \n# Find words differing by a single\n# character with word\ndef addWord(word: str, Dict: Set):\n    res: List[str] = []\n    wrd = list(word)\n     \n    # Find next word in dict by changing\n    # each element from 'a' to 'z'\n    for i in range(len(wrd)):\n        s = wrd[i]\n        c = 'a'\n        while c <= 'z':\n            wrd[i] = c\n            if ''.join(wrd) in Dict:\n                res.append(''.join(wrd))\n            c = chr(ord(c) + 1)\n        wrd[i] = s\n    return res\n \n# Function to get all the shortest possible\n# sequences starting from 'start' to 'target'\ndef findLadders(Dictt: List[str], beginWord: str, endWord: str):\n \n    # Store all the shortest path.\n    res: List[List[str]] = []\n \n    # Store visited words in list\n    visit = set()\n \n    # Queue used to find the shortest path\n    q: Deque[List[str]] = deque()\n \n    # Stores the distinct words from given list\n    Dict = set()\n    for i in Dictt:\n        Dict.add(i)\n    q.append([beginWord])\n \n    # Stores whether the shortest\n    # path is found or not\n    flag = False\n    while q:\n        size = len(q)\n        for i in range(size):\n \n            # Explore the next level\n            cur = q[0]\n            q.popleft()\n            newadd = []\n \n            # Find words differing by a\n            # single character\n            newadd = addWord(cur[-1], Dict)\n \n            # Add words to the path.\n            for j in range(len(newadd)):\n                newline = cur.copy()\n                newline.append(newadd[j])\n \n                # Found the target\n                if (newadd[j] == endWord):\n                    flag = True\n                    res.append(newline)\n \n                visit.add(newadd[j])\n                q.append(newline)\n \n        # If already reached target\n        if (flag):\n            break\n \n        # Erase all visited words.\n        for it in visit:\n            Dict.remove(it)\n        visit.clear()\n    return res\n \n# Driver Code\nif __name__ == '__main__':\n \n    string = ['ted', 'tex', 'red', 'tax', 'tad', 'den', 'rex', 'pee']\n    beginWord = 'red'\n    endWord = 'tax'\n \n    res = findLadders(string, beginWord, endWord)\n \n    displaypath(res)\n \n# This code is contributed by sanjeev2552\n"], "Articulation Points (or Cut Vertices) in a Graph -  ": ["# A recursive function to traverse the graph without\n# considering the ith vertex and its associated edges\ndef dfs(adj, V, vis, i, curr):\n    vis[curr] = 1\n    for x in adj[curr]:\n        if x != i and not vis[x]:\n            dfs(adj, V, vis, i, x)\n \n# Function to find Articulation Points in the graph\ndef AP(adj, V):\n    for i in range(1, V + 1):\n \n        # To keep track of number of components of graph\n        components = 0\n \n        # To keep track of visited vertices\n        vis = [0] * (V + 1)\n \n        # Iterating over the graph after removing vertex i\n        # and its associated edges\n        for j in range(1, V + 1):\n            if j != i:\n \n                # If the jth vertex is not visited, it will\n                # form a new component.\n                if not vis[j]:\n \n                    # Increasing the number of components.\n                    components += 1\n \n                    # dfs call for the jth vertex\n                    dfs(adj, V, vis, i, j)\n \n        # If number of components is more than 1 after\n        # removing the ith vertex then vertex i is an\n        # articulation point.\n        if components > 1:\n            print(i)\n \n# Utility function to add an edge\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n \n# Driver Code\nif __name__ == '__main__':\n    # Create graphs given in above diagrams\n    print('Articulation points in the graph')\n    V = 5\n    adj1 = [[] for _ in range(V + 1)]\n    addEdge(adj1, 1, 2)\n    addEdge(adj1, 2, 3)\n    addEdge(adj1, 1, 3)\n    addEdge(adj1, 3, 4)\n    addEdge(adj1, 4, 5)\n    AP(adj1, V)\n \n # This code is contributed by shivamgupta310570\n", "# Python program to find articulation points in an undirected graph\n  \nfrom collections import defaultdict\n  \n# This class represents an undirected graph \n# using adjacency list representation\nclass Graph:\n  \n    def __init__(self, vertices):\n        self.V = vertices # No. of vertices\n        self.graph = defaultdict(list) # default dictionary to store graph\n        self.Time = 0\n  \n    # function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n  \n    '''A recursive function that find articulation points \n    using DFS traversal\n    u --> The vertex to be visited next\n    visited[] --> keeps track of visited vertices\n    disc[] --> Stores discovery times of visited vertices\n    parent[] --> Stores parent vertices in DFS tree\n    ap[] --> Store articulation points'''\n    def APUtil(self, u, visited, ap, parent, low, disc):\n \n        # Count of children in current node \n        children = 0\n \n        # Mark the current node as visited and print it\n        visited[u]= True\n \n        # Initialize discovery time and low value\n        disc[u] = self.Time\n        low[u] = self.Time\n        self.Time += 1\n \n        # Recur for all the vertices adjacent to this vertex\n        for v in self.graph[u]:\n            # If v is not visited yet, then make it a child of u\n            # in DFS tree and recur for it\n            if visited[v] == False :\n                parent[v] = u\n                children += 1\n                self.APUtil(v, visited, ap, parent, low, disc)\n \n                # Check if the subtree rooted with v has a connection to\n                # one of the ancestors of u\n                low[u] = min(low[u], low[v])\n \n                # u is an articulation point in following cases\n                # (1) u is root of DFS tree and has two or more children.\n                if parent[u] == -1 and children > 1:\n                    ap[u] = True\n \n                #(2) If u is not root and low value of one of its child is more\n                # than discovery value of u.\n                if parent[u] != -1 and low[v] >= disc[u]:\n                    ap[u] = True   \n                     \n                # Update low value of u for parent function calls    \n            elif v != parent[u]: \n                low[u] = min(low[u], disc[v])\n \n \n    # The function to do DFS traversal. It uses recursive APUtil()\n    def AP(self):\n  \n        # Mark all the vertices as not visited \n        # and Initialize parent and visited, \n        # and ap(articulation point) arrays\n        visited = [False] * (self.V)\n        disc = [float('Inf')] * (self.V)\n        low = [float('Inf')] * (self.V)\n        parent = [-1] * (self.V)\n        ap = [False] * (self.V) # To store articulation points\n \n        # Call the recursive helper function\n        # to find articulation points\n        # in DFS tree rooted with vertex 'i'\n        for i in range(self.V):\n            if visited[i] == False:\n                self.APUtil(i, visited, ap, parent, low, disc)\n \n        for index, value in enumerate (ap):\n            if value == True: print (index,end=' ')\n \n # Create a graph given in the above diagram\ng1 = Graph(5)\ng1.addEdge(1, 0)\ng1.addEdge(0, 2)\ng1.addEdge(2, 1)\ng1.addEdge(0, 3)\ng1.addEdge(3, 4)\n  \nprint ('\\nArticulation points in first graph ')\ng1.AP()\n \ng2 = Graph(4)\ng2.addEdge(0, 1)\ng2.addEdge(1, 2)\ng2.addEdge(2, 3)\nprint ('\\nArticulation points in second graph ')\ng2.AP()\n \n  \ng3 = Graph (7)\ng3.addEdge(0, 1)\ng3.addEdge(1, 2)\ng3.addEdge(2, 0)\ng3.addEdge(1, 3)\ng3.addEdge(1, 4)\ng3.addEdge(1, 6)\ng3.addEdge(3, 5)\ng3.addEdge(4, 5)\nprint ('\\nArticulation points in third graph ')\ng3.AP()\n \n# This code is contributed by Neelam Yadav\n"], "Tarjan's Algorithm to find Strongly Connected Components -  ": ["# Python program to find strongly connected components in a given\n# directed graph using Tarjan's algorithm (single DFS)\n#Complexity : O(V+E)\n \nfrom collections import defaultdict\n \n# This class represents an directed graph\n# using adjacency list representation\n \n \nclass Graph:\n \n    def __init__(self, vertices):\n        # No. of vertices\n        self.V = vertices\n \n        # default dictionary to store graph\n        self.graph = defaultdict(list)\n \n        self.Time = 0\n \n    # function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n \n    '''A recursive function that find finds and prints strongly connected\n    components using DFS traversal\n    u --> The vertex to be visited next\n    disc[] --> Stores discovery times of visited vertices\n    low[] -- >> earliest visited vertex (the vertex with minimum\n                discovery time) that can be reached from subtree\n                rooted with current vertex\n     st -- >> To store all the connected ancestors (could be part\n           of SCC)\n     stackMember[] --> bit/index array for faster check whether\n                  a node is in stack\n    '''\n \n    def SCCUtil(self, u, low, disc, stackMember, st):\n \n        # Initialize discovery time and low value\n        disc[u] = self.Time\n        low[u] = self.Time\n        self.Time += 1\n        stackMember[u] = True\n        st.append(u)\n \n        # Go through all vertices adjacent to this\n        for v in self.graph[u]:\n \n            # If v is not visited yet, then recur for it\n            if disc[v] == -1:\n \n                self.SCCUtil(v, low, disc, stackMember, st)\n \n                # Check if the subtree rooted with v has a connection to\n                # one of the ancestors of u\n                # Case 1 (per above discussion on Disc and Low value)\n                low[u] = min(low[u], low[v])\n \n            elif stackMember[v] == True:\n \n                '''Update low value of 'u' only if 'v' is still in stack\n                (i.e. it's a back edge, not cross edge).\n                Case 2 (per above discussion on Disc and Low value) '''\n                low[u] = min(low[u], disc[v])\n \n        # head node found, pop the stack and print an SCC\n        w = -1  # To store stack extracted vertices\n        if low[u] == disc[u]:\n            while w != u:\n                w = st.pop()\n                print(w, end=' ')\n                stackMember[w] = False\n \n            print()\n \n    # The function to do DFS traversal.\n    # It uses recursive SCCUtil()\n \n    def SCC(self):\n \n        # Mark all the vertices as not visited\n        # and Initialize parent and visited,\n        # and ap(articulation point) arrays\n        disc = [-1] * (self.V)\n        low = [-1] * (self.V)\n        stackMember = [False] * (self.V)\n        st = []\n \n        # Call the recursive helper function\n        # to find articulation points\n        # in DFS tree rooted with vertex 'i'\n        for i in range(self.V):\n            if disc[i] == -1:\n                self.SCCUtil(i, low, disc, stackMember, st)\n \n \n# Create a graph given in the above diagram\ng1 = Graph(5)\ng1.addEdge(1, 0)\ng1.addEdge(0, 2)\ng1.addEdge(2, 1)\ng1.addEdge(0, 3)\ng1.addEdge(3, 4)\nprint('SSC in first graph ')\ng1.SCC()\n \ng2 = Graph(4)\ng2.addEdge(0, 1)\ng2.addEdge(1, 2)\ng2.addEdge(2, 3)\nprint('\\nSSC in second graph ')\ng2.SCC()\n \n \ng3 = Graph(7)\ng3.addEdge(0, 1)\ng3.addEdge(1, 2)\ng3.addEdge(2, 0)\ng3.addEdge(1, 3)\ng3.addEdge(1, 4)\ng3.addEdge(1, 6)\ng3.addEdge(3, 5)\ng3.addEdge(4, 5)\nprint('\\nSSC in third graph ')\ng3.SCC()\n \ng4 = Graph(11)\ng4.addEdge(0, 1)\ng4.addEdge(0, 3)\ng4.addEdge(1, 2)\ng4.addEdge(1, 4)\ng4.addEdge(2, 0)\ng4.addEdge(2, 6)\ng4.addEdge(3, 2)\ng4.addEdge(4, 5)\ng4.addEdge(4, 6)\ng4.addEdge(5, 6)\ng4.addEdge(5, 7)\ng4.addEdge(5, 8)\ng4.addEdge(5, 9)\ng4.addEdge(6, 4)\ng4.addEdge(7, 9)\ng4.addEdge(8, 9)\ng4.addEdge(9, 8)\nprint('\\nSSC in fourth graph ')\ng4.SCC()\n \n \ng5 = Graph(5)\ng5.addEdge(0, 1)\ng5.addEdge(1, 2)\ng5.addEdge(2, 3)\ng5.addEdge(2, 4)\ng5.addEdge(3, 0)\ng5.addEdge(4, 2)\nprint('\\nSSC in fifth graph ')\ng5.SCC()\n \n# This code is contributed by Neelam Yadav\n"], "Minimum Cost Path with Left, Right, Bottom and Up moves allowed -  ": ["# Python program to get least cost path in a grid from\n# top-left to bottom-right\nfrom functools import cmp_to_key\n \nROW = 5\nCOL = 5\n \ndef mycmp(a,b):\n     \n    if (a.distance == b.distance):\n        if (a.x != b.x):\n            return (a.x - b.x)\n        else:\n            return (a.y - b.y)\n    return (a.distance - b.distance)\n \n# structure for information of each cell\nclass cell:\n \n    def __init__(self,x, y, distance):\n        self.x = x\n        self.y = y\n        self.distance = distance\n \n# Utility method to check whether a point is\n# inside the grid or not\ndef isInsideGrid(i, j):\n    return (i >= 0 and i < ROW and j >= 0 and j < COL)\n \n# Method returns minimum cost to reach bottom\n# right from top left\ndef shortest(grid, row, col):\n    dis = [[0 for i in range(col)]for j in range(row)]\n \n    # initializing distance array by INT_MAX\n    for i in range(row):\n        for j in range(col):\n            dis[i][j] = 1000000000\n \n    # direction arrays for simplification of getting\n    # neighbour\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n \n    st = []\n \n    # insert (0, 0) cell with 0 distance\n    st.append(cell(0, 0, 0))\n \n    # initialize distance of (0, 0) with its grid value\n    dis[0][0] = grid[0][0]\n \n    # loop for standard dijkstra's algorithm\n    while (len(st)!=0):\n \n        # get the cell with minimum distance and delete\n        # it from the set\n        k = st[0]\n        st = st[1:]\n \n        # looping through all neighbours\n        for i in range(4):\n \n            x = k.x + dx[i]\n            y = k.y + dy[i]\n \n            # if not inside boundary, ignore them\n            if (isInsideGrid(x, y) == 0):\n                continue\n \n            # If distance from current cell is smaller, then\n            # update distance of neighbour cell\n            if (dis[x][y] > dis[k.x][k.y] + grid[x][y]):\n                # update the distance and insert new updated\n                # cell in set\n                dis[x][y] = dis[k.x][k.y] + grid[x][y]\n                st.append(cell(x, y, dis[x][y]))\n \n        st.sort(key=cmp_to_key(mycmp))\n \n    # uncomment below code to print distance\n    # of each cell from (0, 0)\n \n    # for i in range(row):\n    #     for j in range(col):\n    #         print(dis[i][j] ,end= ' ')\n    #     print()\n \n    # dis[row - 1][col - 1] will represent final\n    # distance of bottom right cell from top left cell\n    return dis[row - 1][col - 1]\n \n# Driver code to test above methods\n \ngrid = [[31, 100, 65, 12, 18], [10, 13, 47, 157, 6], [100, 113, 174, 11, 33], [88, 124, 41, 20, 140],[99, 32, 111, 41, 20]]\nprint(shortest(grid, ROW, COL))\n \n# This code is contributed by shinjanpatra\n"], "Construct binary palindrome by repeated appending and trimming -  ": ["# Python3 code to form binary palindrome\n \n# function to apply DFS \ndef dfs(parent, ans, connectchars):\n     \n    # set the parent marked \n    ans[parent] = 1\n \n    # if the node has not been visited \n    # set it and its children marked\n    for i in range(len(connectchars[parent])):\n        if (not ans[connectchars[parent][i]]):\n            dfs(connectchars[parent][i], ans, \n                             connectchars)\n \ndef printBinaryPalindrome(n, k):\n    arr = [0] * n\n    ans = [0] * n\n \n    # link which digits must be equal \n    connectchars = [[] for i in range(k)] \n \n    for i in range(n):\n        arr[i] = i % k \n \n    # connect the two indices\n    for i in range(int(n / 2)):\n        connectchars[arr[i]].append(arr[n - i - 1]) \n        connectchars[arr[n - i - 1]].append(arr[i])\n \n    # set everything connected to \n    # first character as 1 \n    dfs(0, ans, connectchars) \n \n    for i in range(n):\n        print(ans[arr[i]], end = '')\n \n# Driver Code \nif __name__ == '__main__':\n \n    n = 10\n    k = 4\n    printBinaryPalindrome(n, k)\n \n# This code is contributed by PranchalK\n"], "Shortest path to reach one prime to other by changing single digit at a time -  ": ["# Python3 program to reach a prime number \n# from another by changing single digits  \n# and using only prime numbers.\nimport queue \n \nclass Graph: \n     \n    def __init__(self, V):\n        self.V = V; \n        self.l = [[] for i in range(V)]\n         \n    def addedge(self, V1, V2):\n        self.l[V1].append(V2); \n        self.l[V2].append(V1);\n \n    # in1 and in2 are two vertices of graph  \n    # which are actually indexes in pset[] \n    def bfs(self, in1, in2):\n        visited = [0] * self.V\n        que = queue.Queue()\n        visited[in1] = 1\n        que.put(in1)\n        while (not que.empty()): \n            p = que.queue[0] \n            que.get()\n            i = 0\n            while i < len(self.l[p]):\n                if (not visited[self.l[p][i]]):\n                    visited[self.l[p][i]] = visited[p] + 1\n                    que.put(self.l[p][i])\n                if (self.l[p][i] == in2):\n                    return visited[self.l[p][i]] - 1\n                i += 1\n     \n    # Returns true if num1 and num2 \n    # differ by single digit.\n     \n# Finding all 4 digit prime numbers \ndef SieveOfEratosthenes(v):\n     \n    # Create a boolean array 'prime[0..n]' and  \n    # initialize all entries it as true. A value \n    # in prime[i] will finally be false if i is \n    # Not a prime, else true. \n    n = 9999\n    prime = [True] * (n + 1)\n \n    p = 2\n    while p * p <= n:\n \n        # If prime[p] is not changed, \n        # then it is a prime \n        if (prime[p] == True):\n \n            # Update all multiples of p\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n \n    # Forming a vector of prime numbers\n    for p in range(1000, n + 1):\n        if (prime[p]): \n            v.append(p)\n     \ndef compare(num1, num2):\n     \n    # To compare the digits \n    s1 = str(num1) \n    s2 = str(num2)\n    c = 0\n    if (s1[0] != s2[0]):\n        c += 1\n    if (s1[1] != s2[1]):\n        c += 1\n    if (s1[2] != s2[2]):\n        c += 1\n    if (s1[3] != s2[3]): \n        c += 1\n \n    # If the numbers differ only by a single \n    # digit return true else false \n    return (c == 1)\n     \ndef shortestPath(num1, num2):\n     \n    # Generate all 4 digit \n    pset = [] \n    SieveOfEratosthenes(pset) \n \n    # Create a graph where node numbers \n    # are indexes in pset[] and there is \n    # an edge between two nodes only if \n    # they differ by single digit. \n    g = Graph(len(pset))\n    for i in range(len(pset)):\n        for j in range(i + 1, len(pset)):\n            if (compare(pset[i], pset[j])): \n                g.addedge(i, j)     \n \n    # Since graph nodes represent indexes \n    # of numbers in pset[], we find indexes\n    # of num1 and num2. \n    in1, in2 = None, None\n    for j in range(len(pset)):\n        if (pset[j] == num1):\n            in1 = j\n    for j in range(len(pset)):\n        if (pset[j] == num2): \n            in2 = j\n \n    return g.bfs(in1, in2)\n \n# Driver code \nif __name__ == '__main__':\n \n    num1 = 1033\n    num2 = 8179\n    print(shortestPath(num1, num2))\n \n# This code is contributed by PranchalK\n"], "Given a matrix of \u2018O\u2019 and \u2018X\u2019, replace 'O' with 'X' if surrounded by 'X' -  ": ["# Python3 program to replace all 'O's with\n# 'X's if surrounded by 'X'\n \n# Size of given matrix is M x N\nM = 6\nN = 6\n \n# A recursive function to replace previous \n# value 'prevV' at '(x, y)' and all surrounding\n# values of (x, y) with new value 'newV'.\ndef floodFillUtil(mat, x, y, prevV, newV):\n \n    # Base Cases\n    if (x < 0 or x >= M or y < 0 or y >= N):\n        return\n \n    if (mat[x][y] != prevV):\n        return\n \n    # Replace the color at (x, y)\n    mat[x][y] = newV\n \n    # Recur for north, east, south and west \n    floodFillUtil(mat, x + 1, y, prevV, newV)\n    floodFillUtil(mat, x - 1, y, prevV, newV)\n    floodFillUtil(mat, x, y + 1, prevV, newV)\n    floodFillUtil(mat, x, y - 1, prevV, newV)\n \n# Returns size of maximum size subsquare\n#  matrix surrounded by 'X'\ndef replaceSurrounded(mat):\n \n    # Step 1: Replace all 'O's with '-'\n    for i in range(M):\n        for j in range(N):\n            if (mat[i][j] == 'O'):\n                mat[i][j] = '-'\n \n    # Call floodFill for all '-' \n    # lying on edges\n     # Left Side\n    for i in range(M):\n        if (mat[i][0] == '-'):\n            floodFillUtil(mat, i, 0, '-', 'O')\n     \n    # Right side\n    for i in range(M): \n        if (mat[i][N - 1] == '-'):\n            floodFillUtil(mat, i, N - 1, '-', 'O')\n     \n    # Top side\n    for i in range(N): \n        if (mat[0][i] == '-'):\n            floodFillUtil(mat, 0, i, '-', 'O')\n     \n    # Bottom side\n    for i in range(N): \n        if (mat[M - 1][i] == '-'):\n            floodFillUtil(mat, M - 1, i, '-', 'O')\n \n    # Step 3: Replace all '-' with 'X'\n    for i in range(M):\n        for j in range(N):\n            if (mat[i][j] == '-'):\n                mat[i][j] = 'X'\n \n# Driver code\nif __name__ == '__main__':\n \n    mat = [ [ 'X', 'O', 'X', 'O', 'X', 'X' ], \n            [ 'X', 'O', 'X', 'X', 'O', 'X' ], \n            [ 'X', 'X', 'X', 'O', 'X', 'X' ], \n            [ 'O', 'X', 'X', 'X', 'X', 'X' ], \n            [ 'X', 'X', 'X', 'O', 'X', 'O' ], \n            [ 'O', 'O', 'X', 'O', 'O', 'O' ] ]; \n \n    replaceSurrounded(mat)\n \n    for i in range(M):\n        print(*mat[i])\n \n# This code is contributed by himanshu77\n"], "Flood fill Algorithm - how to implement fill() in paint? -  ": ["# Python3 program to implement \n# flood fill algorithm\n \n# Dimensions of paint screen \nM = 8\nN = 8\n \n# A recursive function to replace \n# previous color 'prevC' at '(x, y)' \n# and all surrounding pixels of (x, y) \n# with new color 'newC' and \ndef floodFillUtil(screen, x, y, prevC, newC):\n     \n    # Base cases\n    if (x < 0 or x >= M or y < 0 or\n        y >= N or screen[x][y] != prevC or\n        screen[x][y] == newC):\n        return\n \n    # Replace the color at (x, y)\n    screen[x][y] = newC\n \n    # Recur for north, east, south and west\n    floodFillUtil(screen, x + 1, y, prevC, newC)\n    floodFillUtil(screen, x - 1, y, prevC, newC)\n    floodFillUtil(screen, x, y + 1, prevC, newC)\n    floodFillUtil(screen, x, y - 1, prevC, newC)\n \n# It mainly finds the previous color on (x, y) and \n# calls floodFillUtil() \ndef floodFill(screen, x, y, newC):\n    prevC = screen[x][y]\n    if(prevC==newC):\n      return\n    floodFillUtil(screen, x, y, prevC, newC)\n \n# Driver Code\nscreen = [[1, 1, 1, 1, 1, 1, 1, 1], \n          [1, 1, 1, 1, 1, 1, 0, 0], \n          [1, 0, 0, 1, 1, 0, 1, 1], \n          [1, 2, 2, 2, 2, 0, 1, 0], \n          [1, 1, 1, 2, 2, 0, 1, 0], \n          [1, 1, 1, 2, 2, 2, 2, 0], \n          [1, 1, 1, 1, 1, 2, 1, 1], \n          [1, 1, 1, 1, 1, 2, 2, 1]]\n \nx = 4\ny = 4\nnewC = 3\nfloodFill(screen, x, y, newC)\n \nprint ('Updated screen after call to floodFill:')\nfor i in range(M):\n    for j in range(N):\n        print(screen[i][j], end = ' ')\n    print()\n \n# This code is contributed by Ashutosh450\n# Updated by Arun Pandey\n", "# Python3 program for above approach\n \n# Function to check valid coordinate\ndef validCoord(x, y, n, m):\n    if x < 0 or y < 0:\n        return 0\n    if x >= n or y >= m:\n        return 0\n    return 1\n \n# Function to run bfs\ndef bfs(n, m, data, X, Y, color):\n   \n  # Visiting array\n  vis = [[0 for i in range(101)] for j in range(101)]\n     \n  # Creating queue for bfs\n  obj = []\n     \n  # Pushing pair of {x, y}\n  obj.append([X, Y])\n     \n  # Marking {x, y} as visited\n  vis[X][Y] = 1\n     \n  # Until queue is empty\n  while len(obj) > 0:\n     \n    # Extracting front pair\n    coord = obj[0]\n    x = coord[0]\n    y = coord[1]\n    preColor = data[x][y]\n   \n    data[x][y] = color\n       \n    # Popping front pair of queue\n    obj.pop(0)\n   \n    # For Upside Pixel or Cell\n    if validCoord(x + 1, y, n, m) == 1 and vis[x + 1][y] == 0 and data[x + 1][y] == preColor:\n      obj.append([x + 1, y])\n      vis[x + 1][y] = 1\n       \n    # For Downside Pixel or Cell\n    if validCoord(x - 1, y, n, m) == 1 and vis[x - 1][y] == 0 and data[x - 1][y] == preColor:\n      obj.append([x - 1, y])\n      vis[x - 1][y] = 1\n       \n    # For Right side Pixel or Cell\n    if validCoord(x, y + 1, n, m) == 1 and vis[x][y + 1] == 0 and data[x][y + 1] == preColor:\n      obj.append([x, y + 1])\n      vis[x][y + 1] = 1\n       \n    # For Left side Pixel or Cell\n    if validCoord(x, y - 1, n, m) == 1 and vis[x][y - 1] == 0 and data[x][y - 1] == preColor:\n      obj.append([x, y - 1])\n      vis[x][y - 1] = 1\n     \n  # Printing The Changed Matrix Of Pixels\n  for i in range(n):\n    for j in range(m):\n      print(data[i][j], end = ' ')\n    print()\n  print()\n \nn = 8\nm = 8\n \ndata = [\n  [ 1, 1, 1, 1, 1, 1, 1, 1 ],\n  [ 1, 1, 1, 1, 1, 1, 0, 0 ],\n  [ 1, 0, 0, 1, 1, 0, 1, 1 ],\n  [ 1, 2, 2, 2, 2, 0, 1, 0 ],\n  [ 1, 1, 1, 2, 2, 0, 1, 0 ],\n  [ 1, 1, 1, 2, 2, 2, 2, 0 ],\n  [ 1, 1, 1, 1, 1, 2, 1, 1 ],\n  [ 1, 1, 1, 1, 1, 2, 2, 1 ],\n]\n \nx, y, color = 4, 4, 3\n \n# Function Call\nbfs(n, m, data, x, y, color)\n \n# This code is contributed by decode2207.\n"], "Bridges in a graph -  ": ["# Python program to find bridges in a given undirected graph\n#Complexity : O(V+E)\n  \nfrom collections import defaultdict\n  \n#This class represents an undirected graph using adjacency list representation\nclass Graph:\n  \n    def __init__(self,vertices):\n        self.V= vertices #No. of vertices\n        self.graph = defaultdict(list) # default dictionary to store graph\n        self.Time = 0\n  \n    # function to add an edge to graph\n    def addEdge(self,u,v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n  \n    '''A recursive function that finds and prints bridges\n    using DFS traversal\n    u --> The vertex to be visited next\n    visited[] --> keeps track of visited vertices\n    disc[] --> Stores discovery times of visited vertices\n    parent[] --> Stores parent vertices in DFS tree'''\n    def bridgeUtil(self,u, visited, parent, low, disc):\n \n        # Mark the current node as visited and print it\n        visited[u]= True\n \n        # Initialize discovery time and low value\n        disc[u] = self.Time\n        low[u] = self.Time\n        self.Time += 1\n \n        #Recur for all the vertices adjacent to this vertex\n        for v in self.graph[u]:\n            # If v is not visited yet, then make it a child of u\n            # in DFS tree and recur for it\n            if visited[v] == False :\n                parent[v] = u\n                self.bridgeUtil(v, visited, parent, low, disc)\n \n                # Check if the subtree rooted with v has a connection to\n                # one of the ancestors of u\n                low[u] = min(low[u], low[v])\n \n \n                ''' If the lowest vertex reachable from subtree\n                under v is below u in DFS tree, then u-v is\n                a bridge'''\n                if low[v] > disc[u]:\n                    print ('%d %d' %(u,v))\n     \n                     \n            elif v != parent[u]: # Update low value of u for parent function calls.\n                low[u] = min(low[u], disc[v])\n \n \n    # DFS based function to find all bridges. It uses recursive\n    # function bridgeUtil()\n    def bridge(self):\n  \n        # Mark all the vertices as not visited and Initialize parent and visited, \n        # and ap(articulation point) arrays\n        visited = [False] * (self.V)\n        disc = [float('Inf')] * (self.V)\n        low = [float('Inf')] * (self.V)\n        parent = [-1] * (self.V)\n \n        # Call the recursive helper function to find bridges\n        # in DFS tree rooted with vertex 'i'\n        for i in range(self.V):\n            if visited[i] == False:\n                self.bridgeUtil(i, visited, parent, low, disc)\n         \n  \n# Create a graph given in the above diagram\ng1 = Graph(5)\ng1.addEdge(1, 0)\ng1.addEdge(0, 2)\ng1.addEdge(2, 1)\ng1.addEdge(0, 3)\ng1.addEdge(3, 4)\n \n  \nprint ('Bridges in first graph ')\ng1.bridge()\n \ng2 = Graph(4)\ng2.addEdge(0, 1)\ng2.addEdge(1, 2)\ng2.addEdge(2, 3)\nprint ('\\nBridges in second graph ')\ng2.bridge()\n \n  \ng3 = Graph (7)\ng3.addEdge(0, 1)\ng3.addEdge(1, 2)\ng3.addEdge(2, 0)\ng3.addEdge(1, 3)\ng3.addEdge(1, 4)\ng3.addEdge(1, 6)\ng3.addEdge(3, 5)\ng3.addEdge(4, 5)\nprint ('\\nBridges in third graph ')\ng3.bridge()\n \n \n#This code is contributed by Neelam Yadav\n"], "Strongly Connected Components -  ": ["class GFG:\n    # dfs Function to reach destination\n    def dfs(self, curr, des, adj, vis):\n        # If current node is the destination, return True\n        if curr == des:\n            return True\n        vis[curr] = 1\n        for x in adj[curr]:\n            if not vis[x]:\n                if self.dfs(x, des, adj, vis):\n                    return True\n        return False\n     \n    # To tell whether there is a path from source to destination\n    def isPath(self, src, des, adj):\n        vis = [0] * (len(adj) + 1)\n        return self.dfs(src, des, adj, vis)\n     \n    # Function to return all the strongly connected components of a graph.\n    def findSCC(self, n, a):\n        # Stores all the strongly connected components.\n        ans = []\n         \n        # Stores whether a vertex is a part of any Strongly Connected Component\n        is_scc = [0] * (n + 1)\n         \n        adj = [[] for _ in range(n + 1)]\n         \n        for i in range(len(a)):\n            adj[a[i][0]].append(a[i][1])\n         \n        # Traversing all the vertices\n        for i in range(1, n + 1):\n            if not is_scc[i]:\n                # If a vertex i is not a part of any SCC, insert it into a new SCC list\n                # and check for other vertices whether they can be part of this list.\n                scc = [i]\n                for j in range(i + 1, n + 1):\n                    # If there is a path from vertex i to vertex j and vice versa,\n                    # put vertex j into the current SCC list.\n                    if not is_scc[j] and self.isPath(i, j, adj) and self.isPath(j, i, adj):\n                        is_scc[j] = 1\n                        scc.append(j)\n                # Insert the SCC containing vertex i into the final list.\n                ans.append(scc)\n        return ans\n \n# Driver Code Starts\nif __name__ == '__main__':\n    obj = GFG()\n    V = 5\n    edges = [\n        [1, 3], [1, 4], [2, 1], [3, 2], [4, 5]\n    ]\n    ans = obj.findSCC(V, edges)\n    print('Strongly Connected Components are:')\n    for x in ans:\n        for y in x:\n            print(y, end=' ')\n        print()\n         \n# This code is contributed by shivamgupta310570\n"], "Kruskal\u2019s Minimum Spanning Tree (MST) Algorithm -  ": ["# Python program for Kruskal's algorithm to find \n# Minimum Spanning Tree of a given connected, \n# undirected and weighted graph \n  \n  \n# Class to represent a graph \nclass Graph: \n  \n    def __init__(self, vertices): \n        self.V = vertices \n        self.graph = [] \n  \n    # Function to add an edge to graph \n    def addEdge(self, u, v, w): \n        self.graph.append([u, v, w]) \n  \n    # A utility function to find set of an element i \n    # (truly uses path compression technique) \n    def find(self, parent, i): \n        if parent[i] != i: \n  \n            # Reassignment of node's parent \n            # to root node as \n            # path compression requires \n            parent[i] = self.find(parent, parent[i]) \n        return parent[i] \n  \n    # A function that does union of two sets of x and y \n    # (uses union by rank) \n    def union(self, parent, rank, x, y): \n  \n        # Attach smaller rank tree under root of \n        # high rank tree (Union by Rank) \n        if rank[x] < rank[y]: \n            parent[x] = y \n        elif rank[x] > rank[y]: \n            parent[y] = x \n  \n        # If ranks are same, then make one as root \n        # and increment its rank by one \n        else: \n            parent[y] = x \n            rank[x] += 1\n  \n    # The main function to construct MST \n    # using Kruskal's algorithm \n    def KruskalMST(self): \n  \n        # This will store the resultant MST \n        result = [] \n  \n        # An index variable, used for sorted edges \n        i = 0\n  \n        # An index variable, used for result[] \n        e = 0\n  \n        # Sort all the edges in \n        # non-decreasing order of their \n        # weight \n        self.graph = sorted(self.graph, \n                            key=lambda item: item[2]) \n  \n        parent = [] \n        rank = [] \n  \n        # Create V subsets with single elements \n        for node in range(self.V): \n            parent.append(node) \n            rank.append(0) \n  \n        # Number of edges to be taken is less than to V-1 \n        while e < self.V - 1: \n  \n            # Pick the smallest edge and increment \n            # the index for next iteration \n            u, v, w = self.graph[i] \n            i = i + 1\n            x = self.find(parent, u) \n            y = self.find(parent, v) \n  \n            # If including this edge doesn't \n            # cause cycle, then include it in result \n            # and increment the index of result \n            # for next edge \n            if x != y: \n                e = e + 1\n                result.append([u, v, w]) \n                self.union(parent, rank, x, y) \n            # Else discard the edge \n  \n        minimumCost = 0\n        print('Edges in the constructed MST') \n        for u, v, weight in result: \n            minimumCost += weight \n            print('%d -- %d == %d' % (u, v, weight)) \n        print('Minimum Spanning Tree', minimumCost) \n  \n  \n# Driver code \nif __name__ == '__main__': \n    g = Graph(4) \n    g.addEdge(0, 1, 10) \n    g.addEdge(0, 2, 6) \n    g.addEdge(0, 3, 5) \n    g.addEdge(1, 3, 15) \n    g.addEdge(2, 3, 4) \n  \n    # Function call \n    g.KruskalMST() \n  \n# This code is contributed by Neelam Yadav \n# Improved by James Gra\u00e7a-Jones \n"], "Minimum number of swaps required to sort an array -  ": ["# Python3 program to find \n# minimum number of swaps \n# required to sort an array \n  \n# Function returns the minimum \n# number of swaps required to \n# sort the array \n  \n  \ndef minSwaps(arr): \n    n = len(arr) \n  \n    # Create two arrays and use \n    # as pairs where first array \n    # is element and second array \n    # is position of first element \n    arrpos = [*enumerate(arr)] \n  \n    # Sort the array by array element \n    # values to get right position of \n    # every element as the elements \n    # of second array. \n    arrpos.sort(key=lambda it: it[1]) \n  \n    # To keep track of visited elements. \n    # Initialize all elements as not \n    # visited or false. \n    vis = {k: False for k in range(n)} \n  \n    # Initialize result \n    ans = 0\n    for i in range(n): \n  \n        # already swapped or \n        # already present at \n        # correct position \n        if vis[i] or arrpos[i][0] == i: \n            continue\n  \n        # find number of nodes \n        # in this cycle and \n        # add it to ans \n        cycle_size = 0\n        j = i \n  \n        while not vis[j]: \n  \n            # mark node as visited \n            vis[j] = True\n  \n            # move to next node \n            j = arrpos[j][0] \n            cycle_size += 1\n  \n        # update answer by adding \n        # current cycle \n        if cycle_size > 0: \n            ans += (cycle_size - 1) \n  \n    # return answer \n    return ans \n  \n  \n# Driver Code \narr = [1, 5, 4, 3, 2] \nprint(minSwaps(arr)) \n  \n# This code is contributed \n# by Dharan Aditya \n", "# Function returns the \n# minimum number of swaps \n# required to sort the array \nfrom functools import cmp_to_key \n  \n  \ndef cmp(a, b): \n    return a - b \n  \n  \ndef minSwaps(nums): \n    Len = len(nums) \n    map = {} \n    for i in range(Len): \n        map[nums[i]] = i \n  \n    nums = sorted(nums, key=cmp_to_key(cmp)) \n  \n    # To keep track of visited elements. Initialize \n    # all elements as not visited or false. \n    visited = [False for col in range(Len)] \n  \n    # Initialize result \n    ans = 0\n    for i in range(Len): \n  \n        # already swapped and corrected or \n        # already present at correct pos \n        if (visited[i] or map[nums[i]] == i): \n            continue\n  \n        j, cycle_size = i, 0\n        while (visited[j] == False): \n            visited[j] = True\n  \n            # move to next node \n            j = map[nums[j]] \n            cycle_size += 1\n  \n        # Update answer by adding current cycle. \n        if (cycle_size > 0): \n            ans += (cycle_size - 1) \n  \n    return ans \n  \n  \n# Driver program to test the above function \na = [1, 5, 4, 3, 2] \nprint(minSwaps(a)) \n  \n# This code is contributed by shinjanpatra \n", "# Python3 program to find \n# minimum number of swaps \n# required to sort an array \n  \n# Return the minimum number \n# of swaps required to sort \n# the array \n  \n  \ndef minSwaps(arr, N): \n  \n    ans = 0\n    temp = arr.copy() \n    temp.sort() \n    for i in range(N): \n  \n        # This is checking whether \n        # the current element is \n        # at the right place or not \n        if (arr[i] != temp[i]): \n            ans += 1\n  \n            # Swap the current element \n            # with the right index \n            # so that arr[0] to arr[i] \n            # is sorted \n            swap(arr, i, \n                 indexOf(arr, temp[i])) \n  \n    return ans \n  \n  \ndef swap(arr, i, j): \n  \n    temp = arr[i] \n    arr[i] = arr[j] \n    arr[j] = temp \n  \n  \ndef indexOf(arr, ele): \n  \n    for i in range(len(arr)): \n        if (arr[i] == ele): \n            return i \n    return -1\n  \n  \n# Driver code \nif __name__ == '__main__': \n    a = [101, 758, 315, 730, \n         472, 619, 460, 479] \n    n = len(a) \n  \n    # Output will be 5 \n    print(minSwaps(a, n)) \n  \n# This code is contributed by Chitranayal \n", "# Python3 program to find \n# minimum number of swaps \n# required to sort an array \n  \n# Return the minimum number \n# of swaps required to sort \n# the array \n  \n  \ndef minSwap(arr, n): \n  \n    ans = 0\n    temp = arr.copy() \n  \n    # Dictionary which stores the \n    # indexes of the input array \n    h = {} \n  \n    temp.sort() \n  \n    for i in range(n): \n  \n        # h.[arr[i] \n        h[arr[i]] = i \n  \n    init = 0\n  \n    for i in range(n): \n  \n        # This is checking whether \n        # the current element is \n        # at the right place or not \n        if (arr[i] != temp[i]): \n            ans += 1\n            init = arr[i] \n  \n            # If not, swap this element \n            # with the index of the \n            # element which should come here \n            arr[i], arr[h[temp[i]]] = arr[h[temp[i]]], arr[i] \n  \n            # Update the indexes in \n            # the hashmap accordingly \n            h[init] = h[temp[i]] \n            h[temp[i]] = i \n  \n    return ans \n  \n  \n# Driver code \na = [101, 758, 315, 730, \n     472, 619, 460, 479] \nn = len(a) \n  \n  \nprint(minSwap(a, n)) \n  \n# This code is contributed by avanitrachhadiya2155 \n"], "Find a Mother Vertex in a Graph -  ": ["# Python3 program to find a mother vertex in O(V+E) time\nfrom collections import defaultdict\n \n# This class represents a directed graph using adjacency list\n# representation\n \n \nclass Graph:\n \n    def __init__(self, vertices):\n        self.V = vertices  # No. of vertices\n        self.graph = defaultdict(list)  # default dictionary\n \n    # A recursive function to print DFS starting from v\n    def DFSUtil(self, v, visited):\n \n        # Mark the current node as visited and print it\n        visited[v] = True\n \n        # Recur for all the vertices adjacent to this vertex\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited)\n \n    # Add w to the list of v\n    def addEdge(self, v, w):\n        self.graph[v].append(w)\n \n    # Returns a mother vertex if exists. Otherwise returns -1\n    def findMother(self):\n \n        # visited[] is used for DFS. Initially all are\n        # initialized as not visited\n        visited = [False]*(self.V)\n \n        # To store last finished vertex (or mother vertex)\n        v = 0\n \n        # Do a DFS traversal and find the last finished\n        # vertex\n        for i in range(self.V):\n            if visited[i] == False:\n                self.DFSUtil(i, visited)\n                v = i\n \n        # If there exist mother vertex (or vertices) in given\n        # graph, then v must be one (or one of them)\n \n        # Now check if v is actually a mother vertex (or graph\n        # has a mother vertex). We basically check if every vertex\n        # is reachable from v or not.\n \n        # Reset all values in visited[] as false and do\n        # DFS beginning from v to check if all vertices are\n        # reachable from it or not.\n        visited = [False]*(self.V)\n        self.DFSUtil(v, visited)\n        if any(i == False for i in visited):\n            return -1\n        else:\n            return v\n \n \n# Driver code\nif __name__ == '__main__':\n  g = Graph(7)\n  g.addEdge(0, 1)\n  g.addEdge(0, 2)\n  g.addEdge(1, 3)\n  g.addEdge(4, 1)\n  g.addEdge(6, 4)\n  g.addEdge(5, 6)\n  g.addEdge(5, 2)\n  g.addEdge(6, 0)\n \n  # Function call\n  print('A mother vertex is ' + str(g.findMother()))\n \n# This code is contributed by Neelam Yadav\n"], "Distance of nearest cell having 1 in a binary matrix -  ": ["# Python3 program to find distance of\n# nearest cell having 1 in a binary matrix.\n \n# Print distance of nearest cell\n# having 1 for each cell.\n \n \ndef printDistance(mat):\n    global N, M\n    ans = [[None] * M for i in range(N)]\n \n    # Initialize the answer matrix\n    # with INT_MAX.\n    for i in range(N):\n        for j in range(M):\n            ans[i][j] = 999999999999\n \n    # For each cell\n    for i in range(N):\n        for j in range(M):\n \n            # Traversing the whole matrix\n            # to find the minimum distance.\n            for k in range(N):\n                for l in range(M):\n \n                    # If cell contain 1, check\n                    # for minimum distance.\n                    if (mat[k][l] == 1):\n                        ans[i][j] = min(ans[i][j],\n                                        abs(i - k) + abs(j - l))\n \n    # Printing the answer.\n    for i in range(N):\n        for j in range(M):\n            print(ans[i][j], end=' ')\n        print()\n \n \n# Driver Code\nif __name__ == '__main__':\n  N = 3\n  M = 4\n  mat = [[0, 0, 0, 1],\n         [0, 0, 1, 1],\n         [0, 1, 1, 0]]\n \n  # Function call\n  printDistance(mat)\n \n# This code is contributed by PranchalK\n", "# Python3 program for the above approach\n \nimport sys\n \n \nclass matrix_element:\n \n    def __init__(self, row, col):\n        self.row = row\n        self.col = col\n \n \ndef printDistance(arr):\n    Row_Count = len(arr)\n    Col_Count = len(arr[0])\n \n    q = []\n \n    # Adding all ones in queue\n    for i in range(Row_Count):\n        for j in range(Col_Count):\n            if (arr[i][j] == 1):\n                q.append(matrix_element(i, j))\n \n    # In order to find min distance we will again\n    # traverse all elements in Matrix. If its zero then\n    # it will check against all 1's in Queue. Whatever\n    # will be dequeued from queued, will be enqueued\n    # back again.\n \n    Queue_Size = len(q)\n    for i in range(Row_Count):\n \n        for j in range(Col_Count):\n \n            distance = 0\n            min_distance = sys.maxsize\n \n            if (arr[i][j] == 0):\n \n                for k in range(Queue_Size):\n \n                    One_Pos = q[0]\n                    q = q[1:]\n                    One_Row = One_Pos.row\n                    One_Col = One_Pos.col\n                    distance = abs(One_Row - i) + abs(One_Col - j)\n                    min_distance = min(min_distance, distance)\n                    if (min_distance == 1):\n \n                        arr[i][j] = 1\n                        q.append(matrix_element(One_Row, One_Col))\n                        break\n \n                    q.append(matrix_element(One_Row, One_Col))\n \n                    arr[i][j] = min_distance\n \n            else:\n                arr[i][j] = 0\n \n    # print elements\n    for i in range(Row_Count):\n        for j in range(Col_Count):\n            print(arr[i][j], end=' ')\n \n        print()\n \n \n# Driver code\nif __name__ == '__main__':\n  arr = [[0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 1, 0]]\n \n  # Function call\n  printDistance(arr)\n \n# This code is contributed by shinjanpatra\n", "# Python3 program to find distance of nearest\n# cell having 1 in a binary matrix.\nfrom collections import deque\n \nMAX = 500\nN = 3\nM = 4\n \n# Making a class of graph with bfs function.\ng = [[] for i in range(MAX)]\nn, m = 0, 0\n \n# Function to create graph with N*M nodes\n# considering each cell as a node and each\n# boundary as an edge.\n \n \ndef createGraph():\n \n    global g, n, m\n \n    # A number to be assigned to a cell\n    k = 1\n \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n \n            # If last row, then add edge on right side.\n            if (i == n):\n \n                # If not bottom right cell.\n                if (j != m):\n                    g[k].append(k + 1)\n                    g[k + 1].append(k)\n \n            # If last column, then add edge toward down.\n            elif (j == m):\n                g[k].append(k+m)\n                g[k + m].append(k)\n \n            # Else makes an edge in all four directions.\n            else:\n                g[k].append(k + 1)\n                g[k + 1].append(k)\n                g[k].append(k+m)\n                g[k + m].append(k)\n \n            k += 1\n \n# BFS function to find minimum distance\n \n \ndef bfs(visit, dist, q):\n \n    global g\n    while (len(q) > 0):\n        temp = q.popleft()\n \n        for i in g[temp]:\n            if (visit[i] != 1):\n                dist[i] = min(dist[i], dist[temp] + 1)\n                q.append(i)\n                visit[i] = 1\n \n    return dist\n \n# Printing the solution.\n \n \ndef prt(dist):\n \n    c = 1\n    for i in range(1, n * m + 1):\n        print(dist[i], end=' ')\n        if (c % m == 0):\n            print()\n \n        c += 1\n \n# Find minimum distance\n \n \ndef findMinDistance(mat):\n \n    global g, n, m\n \n    # Creating a graph with nodes values assigned\n    # from 1 to N x M and matrix adjacent.\n    n, m = N, M\n    createGraph()\n \n    # To store minimum distance\n    dist = [0] * MAX\n \n    # To mark each node as visited or not in BFS\n    visit = [0] * MAX\n \n    # Initialising the value of distance and visit.\n    for i in range(1, M * N + 1):\n        dist[i] = 10**9\n        visit[i] = 0\n \n    # Inserting nodes whose value in matrix\n    # is 1 in the queue.\n    k = 1\n    q = deque()\n    for i in range(N):\n        for j in range(M):\n            if (mat[i][j] == 1):\n                dist[k] = 0\n                visit[k] = 1\n                q.append(k)\n \n            k += 1\n \n    # Calling for Bfs with given Queue.\n    dist = bfs(visit, dist, q)\n \n    # Printing the solution.\n    prt(dist)\n \n \n# Driver code\nif __name__ == '__main__':\n \n    mat = [[0, 0, 0, 1],\n           [0, 0, 1, 1],\n           [0, 1, 1, 0]]\n \n    # Function call\n    findMinDistance(mat)\n \n# This code is contributed by mohit kumar 29\n", "# Python3 code to implement the approach\n \n# Function to find distance of nearest\ndef printDistance(grid):\n    # Code here\n    n = len(grid)\n    m = len(grid[0]) # n = no. of row , m = no. of column\n    q = [] # to do multisource Breadth-First Search store\n            # the initial index of 1s\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                q.append([i, j])\n                grid[i][j] = 0 # mark the starting index as 0.\n            else:\n                grid[i][j] = float('inf') # rest marked as infinity. (Not visited)\n    row = [-1, 1, 0, 0]\n    col = [0, 0, -1, 1] # (up,down,left,right index from current (x,y))\n    while len(q): # till it visit each index\n        top = q.pop(0)\n        x = top[0]\n        y = top[1]\n        time = grid[x][y] # time of current distance at index (x,y)\n        for i in range(4):\n            newx = x + row[i]\n            newy = y + col[i]\n            if newx >= 0 and newx < n and newy >= 0 and newy < m and grid[newx][newy] == float('inf'): # only for Non visited\n                grid[newx][newy] = time + 1 # time of current distance at index (x,y) + 1\n                q.append([newx, newy]) # storing index for getting the index of adjacent of {newx,newy}.\n    return grid # returning the updated matrix\n \n# Driver code\ngrid = [[0, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1]]\nprint(*printDistance(grid), sep = '\\n')\n"], "Count all possible Paths between two Vertices -  ": ["# Python 3 program to count all paths\n# from a source to a destination.\n \n# A directed graph using adjacency\n# list representation\n \n \nclass Graph:\n \n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for i in range(V)]\n \n    def addEdge(self, u, v):\n \n        # Add v to u\u2019s list.\n        self.adj[u].append(v)\n \n    # Returns count of paths from 's' to 'd'\n    def countPaths(self, s, d):\n \n        # Mark all the vertices\n        # as not visited\n        visited = [False] * self.V\n \n        # Call the recursive helper\n        # function to print all paths\n        pathCount = [0]\n        self.countPathsUtil(s, d, visited, pathCount)\n        return pathCount[0]\n \n    # A recursive function to print all paths\n    # from 'u' to 'd'. visited[] keeps track\n    # of vertices in current path. path[]\n    # stores actual vertices and path_index\n    # is current index in path[]\n    def countPathsUtil(self, u, d,\n                       visited, pathCount):\n        visited[u] = True\n \n        # If current vertex is same as\n        # destination, then increment count\n        if (u == d):\n            pathCount[0] += 1\n \n        # If current vertex is not destination\n        else:\n \n            # Recur for all the vertices\n            # adjacent to current vertex\n            i = 0\n            while i < len(self.adj[u]):\n                if (not visited[self.adj[u][i]]):\n                    self.countPathsUtil(self.adj[u][i], d,\n                                        visited, pathCount)\n                i += 1\n \n        visited[u] = False\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # Create a graph given in the\n    # above diagram\n    g = Graph(4)\n    g.addEdge(0, 1)\n    g.addEdge(0, 2)\n    g.addEdge(0, 3)\n    g.addEdge(2, 0)\n    g.addEdge(2, 1)\n    g.addEdge(1, 3)\n \n    s = 2\n    d = 3\n     \n    # Function call\n    print(g.countPaths(s, d))\n \n# This code is contributed by PranchalK\n"], "Get Level of a node in a Binary Tree -  ": ["# Python3 program to Get Level of a\n# node in a Binary Tree\n \n# Helper function that allocates a\n# new node with the given data and\n# None left and right pairs.\n \n \nclass newNode:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Helper function for getLevel(). It\n# returns level of the data if data is\n# present in tree, otherwise returns 0\n \n \ndef getLevelUtil(node, data, level):\n    if (node == None):\n        return 0\n \n    if (node.data == data):\n        return level\n \n    downlevel = getLevelUtil(node.left,\n                             data, level + 1)\n    if (downlevel != 0):\n        return downlevel\n \n    downlevel = getLevelUtil(node.right,\n                             data, level + 1)\n    return downlevel\n \n# Returns level of given data value\n \n \ndef getLevel(node, data):\n \n    return getLevelUtil(node, data, 1)\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # Let us construct the Tree shown\n    # in the above figure\n    root = newNode(3)\n    root.left = newNode(2)\n    root.right = newNode(5)\n    root.left.left = newNode(1)\n    root.left.right = newNode(4)\n    for x in range(1, 6):\n        level = getLevel(root, x)\n        if (level):\n            print('Level of', x,\n                  'is', getLevel(root, x))\n        else:\n            print(x, 'is not present in tree')\n \n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n", "# Python3 program to print level in which X is present in\n# binary tree\n \n# A node structure\nclass Node:\n    # A utility function to create a new node\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n \ndef printLevel(root, X):\n    # Base Case\n    if root is None:\n        return 0\n    # Create an empty queue\n    # for level order traversal\n    q = []\n    #Create a var represent current level of tree\n    currLevel = 1\n    # Enqueue Root \n    q.append(root)\n     \n    while(len(q) > 0):\n        size = len(q)\n        for i in range(size):\n            node = q.pop(0)\n            if(node.data == X):\n                return currLevel\n            # Enqueue left child\n            if node.left is not None:\n                q.append(node.left)\n            # Enqueue right child\n            if node.right is not None:\n                q.append(node.right)\n        currLevel += 1\n    return 0\n \n# Driver Program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(7)\nroot.right.right = Node(6)\n \nprint(printLevel(root, 6))\n \n# This code is contributed by Abhijeet Kumar(abhijeet19403)\n"], "Topological Sorting -  ": ["# Python program to print topological sorting of a DAG\nfrom collections import defaultdict\n \n# Class to represent a graph\n \n \nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)  # dictionary containing adjacency List\n        self.V = vertices  # No. of vertices\n \n    # function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n \n    # A recursive function used by topologicalSort\n    def topologicalSortUtil(self, v, visited, stack):\n \n        # Mark the current node as visited.\n        visited[v] = True\n \n        # Recur for all the vertices adjacent to this vertex\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.topologicalSortUtil(i, visited, stack)\n \n        # Push current vertex to stack which stores result\n        stack.append(v)\n \n    # The function to do Topological Sort. It uses recursive\n    # topologicalSortUtil()\n    def topologicalSort(self):\n        # Mark all the vertices as not visited\n        visited = [False]*self.V\n        stack = []\n \n        # Call the recursive helper function to store Topological\n        # Sort starting from all vertices one by one\n        for i in range(self.V):\n            if visited[i] == False:\n                self.topologicalSortUtil(i, visited, stack)\n \n        # Print contents of the stack\n        print(stack[::-1])  # return list in reverse order\n \n \n# Driver Code\nif __name__ == '__main__':\n    g = Graph(6)\n    g.addEdge(5, 2)\n    g.addEdge(5, 0)\n    g.addEdge(4, 0)\n    g.addEdge(4, 1)\n    g.addEdge(2, 3)\n    g.addEdge(3, 1)\n \n    print('Following is a Topological Sort of the given graph')\n \n    # Function Call\n    g.topologicalSort()\n \n# This code is contributed by Neelam Yadav\n"], "Find whether there is path between two cells in matrix -  ": ["# Python3 program to find\n# path between two cell in matrix\n \n# Method for finding and printing\n# whether the path exists or not\n \n \ndef isPath(matrix, n):\n \n    # Defining visited array to keep\n    # track of already visited indexes\n    visited = [[False for x in range(n)]\n               for y in range(n)]\n \n    # Flag to indicate whether the\n    # path exists or not\n    flag = False\n \n    for i in range(n):\n        for j in range(n):\n \n            # If matrix[i][j] is source\n            # and it is not visited\n            if (matrix[i][j] == 1 and not\n                    visited[i][j]):\n \n                # Starting from i, j and\n                # then finding the path\n                if (checkPath(matrix, i,\n                              j, visited)):\n \n                    # If path exists\n                    flag = True\n                    break\n    if (flag):\n        print('YES')\n    else:\n        print('NO')\n \n# Method for checking boundaries\n \n \ndef isSafe(i, j, matrix):\n \n    if (i >= 0 and i < len(matrix) and\n            j >= 0 and j < len(matrix[0])):\n        return True\n    return False\n \n# Returns true if there is a\n# path from a source(a\n# cell with value 1) to a\n# destination(a cell with\n# value 2)\n \n \ndef checkPath(matrix, i, j,\n              visited):\n \n    # Checking the boundaries, walls and\n    # whether the cell is unvisited\n    if (isSafe(i, j, matrix) and\n        matrix[i][j] != 0 and not\n            visited[i][j]):\n \n        # Make the cell visited\n        visited[i][j] = True\n \n        # If the cell is the required\n        # destination then return true\n        if (matrix[i][j] == 2):\n            return True\n \n        # traverse up\n        up = checkPath(matrix, i - 1,\n                       j, visited)\n \n        # If path is found in up\n        # direction return true\n        if (up):\n            return True\n \n        # Traverse left\n        left = checkPath(matrix, i,\n                         j - 1, visited)\n \n        # If path is found in left\n        # direction return true\n        if (left):\n            return True\n \n        # Traverse down\n        down = checkPath(matrix, i + 1,\n                         j, visited)\n \n        # If path is found in down\n        # direction return true\n        if (down):\n            return True\n \n        # Traverse right\n        right = checkPath(matrix, i,\n                          j + 1, visited)\n \n        # If path is found in right\n        # direction return true\n        if (right):\n            return True\n \n    # No path has been found\n    return False\n \n \n# Driver code\nif __name__ == '__main__':\n \n    matrix = [[0, 3, 0, 1],\n              [3, 0, 3, 3],\n              [2, 3, 3, 3],\n              [0, 3, 3, 3]]\n \n    # calling isPath method\n    isPath(matrix, 4)\n \n# This code is contributed by Chitranayal\n", "# Python3 program to find path between two\n# cell in matrix\nfrom collections import defaultdict\n \n \nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n \n    # add edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n \n    # BFS function to find path from source to sink\n    def BFS(self, s, d):\n \n        # Base case\n        if s == d:\n            return True\n \n        # Mark all the vertices as not visited\n        visited = [False]*(len(self.graph) + 1)\n \n        # Create a queue for BFS\n        queue = []\n        queue.append(s)\n \n        # Mark the current node as visited and\n        # enqueue it\n        visited[s] = True\n        while(queue):\n \n            # Dequeue a vertex from queue\n            s = queue.pop(0)\n \n            # Get all adjacent vertices of the\n            # dequeued vertex s. If a adjacent has\n            # not been visited, then mark it visited\n            # and enqueue it\n            for i in self.graph[s]:\n \n                # If this adjacent node is the destination\n                # node, then return true\n                if i == d:\n                    return True\n \n                # Else, continue to do BFS\n                if visited[i] == False:\n                    queue.append(i)\n                    visited[i] = True\n \n        # If BFS is complete without visiting d\n        return False\n \n \ndef isSafe(i, j, matrix):\n    if i >= 0 and i <= len(matrix) and j >= 0 and j <= len(matrix[0]):\n        return True\n    else:\n        return False\n \n# Returns true if there is a path from a source (a\n# cell with value 1) to a destination (a cell with\n# value 2)\n \n \ndef findPath(M):\n    s, d = None, None  # source and destination\n    N = len(M)\n    g = Graph()\n \n    # create graph with n * n node\n    # each cell consider as node\n    k = 1  # Number of current vertex\n    for i in range(N):\n        for j in range(N):\n            if (M[i][j] != 0):\n \n                # connect all 4 adjacent cell to\n                # current cell\n                if (isSafe(i, j + 1, M)):\n                    g.addEdge(k, k + 1)\n                if (isSafe(i, j - 1, M)):\n                    g.addEdge(k, k - 1)\n                if (isSafe(i + 1, j, M)):\n                    g.addEdge(k, k + N)\n                if (isSafe(i - 1, j, M)):\n                    g.addEdge(k, k - N)\n \n            if (M[i][j] == 1):\n                s = k\n \n            # destination index\n            if (M[i][j] == 2):\n                d = k\n            k += 1\n \n    # find path Using BFS\n    return g.BFS(s, d)\n \n \n# Driver code\nif __name__ == '__main__':\n    M = [[0, 3, 0, 1], [3, 0, 3, 3], [2, 3, 3, 3], [0, 3, 3, 3]]\n    if findPath(M):\n        print('Yes')\n    else:\n        print('No')\n \n# This Code is Contributed by Vikash Kumar 37\n", "class BFSElement:\n    def __init__(self, i, j):\n        self.i = i\n        self.j = j\n \n \nR, C = 4, 4\n \n \ndef findPath(M):\n \n    # 1) Create BFS queue q\n    q = []\n \n    # 2)scan the matrix\n    for i in range(R):\n        for j in range(C):\n \n            # if there exists a cell in the matrix such\n            # that its value is 1 then append it to q\n            if (M[i][j] == 1):\n                q.append(BFSElement(i, j))\n                break\n \n    # 3) run BFS algorithm with q.\n    while (len(q) != 0):\n        x = q[0]\n        q = q[1:]\n \n        i = x.i\n        j = x.j\n \n        # skipping cells which are not valid.\n        # if outside the matrix bounds\n        if (i < 0 or i >= R or j < 0 or j >= C):\n            continue\n \n        # if they are walls (value is 0).\n        if (M[i][j] == 0):\n            continue\n \n        # 3.1) if in the BFS algorithm process there was a\n        # vertex x=(i,j) such that M[i][j] is 2 stop and\n        # return True\n        if (M[i][j] == 2):\n            return True\n \n        # marking as wall upon successful visitation\n        M[i][j] = 0\n \n        # appending to queue u=(i,j+1),u=(i,j-1)\n        # u=(i+1,j),u=(i-1,j)\n        for k in range(-1, 2, 2):\n            q.append(BFSElement(i + k, j))\n            q.append(BFSElement(i, j + k))\n \n    # BFS algorithm terminated without returning True\n    # then there was no element M[i][j] which is 2, then\n    # return false\n    return False\n \n \n# Main Driver code\nM = [[0, 3, 0, 1],\n     [3, 0, 3, 3],\n     [2, 3, 3, 3],\n     [0, 3, 3, 3]]\nif(findPath(M) == True):\n    print('Yes')\nelse:\n    print('No')\n \n# This code is contributed by shinjanpatra\n"], "Detect Cycle in a Directed Graph -  ": ["# Python program to detect cycle\n# in a graph\n \nfrom collections import defaultdict\n \n \nclass Graph():\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n \n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n \n    def isCyclicUtil(self, v, visited, recStack):\n \n        # Mark current node as visited and\n        # adds to recursion stack\n        visited[v] = True\n        recStack[v] = True\n \n        # Recur for all neighbours\n        # if any neighbour is visited and in\n        # recStack then graph is cyclic\n        for neighbour in self.graph[v]:\n            if visited[neighbour] == False:\n                if self.isCyclicUtil(neighbour, visited, recStack) == True:\n                    return True\n            elif recStack[neighbour] == True:\n                return True\n \n        # The node needs to be popped from\n        # recursion stack before function ends\n        recStack[v] = False\n        return False\n \n    # Returns true if graph is cyclic else false\n    def isCyclic(self):\n        visited = [False] * (self.V + 1)\n        recStack = [False] * (self.V + 1)\n        for node in range(self.V):\n            if visited[node] == False:\n                if self.isCyclicUtil(node, visited, recStack) == True:\n                    return True\n        return False\n \n \n# Driver code\nif __name__ == '__main__':\n    g = Graph(4)\n    g.addEdge(0, 1)\n    g.addEdge(0, 2)\n    g.addEdge(1, 2)\n    g.addEdge(2, 0)\n    g.addEdge(2, 3)\n    g.addEdge(3, 3)\n \n    if g.isCyclic() == 1:\n        print('Graph contains cycle')\n    else:\n        print('Graph doesn't contain cycle')\n \n# Thanks to Divyanshu Mehta for contributing this code\n", "from collections import deque\n \n \nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n \n    def addEdge(self, v, w):\n        self.adj[v].append(w)\n \n    def isCyclic(self):\n        inDegree = [0] * self.V\n        q = deque()\n        visited = 0\n \n        # Calculate in-degree of each vertex\n        for u in range(self.V):\n            for v in self.adj[u]:\n                inDegree[v] += 1\n \n        # Enqueue vertices with 0 in-degree\n        for u in range(self.V):\n            if inDegree[u] == 0:\n                q.append(u)\n \n        # BFS traversal\n        while q:\n            u = q.popleft()\n            visited += 1\n \n            # Reduce in-degree of adjacent vertices\n            for v in self.adj[u]:\n                inDegree[v] -= 1\n                # If in-degree becomes 0, enqueue the vertex\n                if inDegree[v] == 0:\n                    q.append(v)\n \n        return visited != self.V  # If not all vertices are visited, there is a cycle\n \n \n# Main driver code\ng = Graph(6)\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 3)\ng.addEdge(4, 1)\ng.addEdge(4, 5)\ng.addEdge(5, 3)\n \nif g.isCyclic():\n    print('Graph contains a cycle.')\nelse:\n    print('Graph does not contain a cycle.')\n# This code is contributed by Rishabh Mathur\n"], "Maximum Bipartite Matching -  ": ["# Python program to find \n# maximal Bipartite matching.\n \nclass GFG:\n    def __init__(self,graph):\n         \n        # residual graph\n        self.graph = graph \n        self.ppl = len(graph)\n        self.jobs = len(graph[0])\n \n    # A DFS based recursive function\n    # that returns true if a matching \n    # for vertex u is possible\n    def bpm(self, u, matchR, seen):\n \n        # Try every job one by one\n        for v in range(self.jobs):\n \n            # If applicant u is interested \n            # in job v and v is not seen\n            if self.graph[u][v] and seen[v] == False:\n                 \n                # Mark v as visited\n                seen[v] = True\n \n                '''If job 'v' is not assigned to\n                   an applicant OR previously assigned \n                   applicant for job v (which is matchR[v]) \n                   has an alternate job available. \n                   Since v is marked as visited in the \n                   above line, matchR[v]  in the following\n                   recursive call will not get job 'v' again'''\n                if matchR[v] == -1 or self.bpm(matchR[v], \n                                               matchR, seen):\n                    matchR[v] = u\n                    return True\n        return False\n \n    # Returns maximum number of matching \n    def maxBPM(self):\n        '''An array to keep track of the \n           applicants assigned to jobs. \n           The value of matchR[i] is the \n           applicant number assigned to job i, \n           the value -1 indicates nobody is assigned.'''\n        matchR = [-1] * self.jobs\n         \n        # Count of jobs assigned to applicants\n        result = 0\n        for i in range(self.ppl):\n             \n            # Mark all jobs as not seen for next applicant.\n            seen = [False] * self.jobs\n             \n            # Find if the applicant 'u' can get a job\n            if self.bpm(i, matchR, seen):\n                result += 1\n        return result\n \n \nbpGraph =[[0, 1, 1, 0, 0, 0],\n          [1, 0, 0, 1, 0, 0],\n          [0, 0, 1, 0, 0, 0],\n          [0, 0, 1, 1, 0, 0],\n          [0, 0, 0, 0, 0, 0],\n          [0, 0, 0, 0, 0, 1]]\n \ng = GFG(bpGraph)\n \nprint ('Maximum number of applicants that can get job is %d ' % g.maxBPM())\n \n# This code is contributed by Neelam Yadav\n"], "Check whether a given graph is Bipartite or not -  ": ["# Python program to find out whether a \n# given graph is Bipartite or not\n \nclass Graph():\n \n    def __init__(self, V):\n        self.V = V\n        self.graph = [[0 for column in range(V)] \\\n                                for row in range(V)]\n \n    # This function returns true if graph G[V][V] \n    # is Bipartite, else false\n    def isBipartite(self, src):\n \n        # Create a color array to store colors \n        # assigned to all vertices. Vertex\n        # number is used as index in this array. \n        # The value '-1' of  colorArr[i] is used to \n        # indicate that no color is assigned to \n        # vertex 'i'. The value 1 is used to indicate \n        # first color is assigned and value 0\n        # indicates second color is assigned.\n        colorArr = [-1] * self.V\n \n        # Assign first color to source\n        colorArr[src] = 1\n \n        # Create a queue (FIFO) of vertex numbers and \n        # enqueue source vertex for BFS traversal\n        queue = []\n        queue.append(src)\n \n        # Run while there are vertices in queue \n        # (Similar to BFS)\n        while queue:\n \n            u = queue.pop()\n \n            # Return false if there is a self-loop\n            if self.graph[u][u] == 1:\n                return False;\n \n            for v in range(self.V):\n \n                # An edge from u to v exists and destination \n                # v is not colored\n                if self.graph[u][v] == 1 and colorArr[v] == -1:\n \n                    # Assign alternate color to this \n                    # adjacent v of u\n                    colorArr[v] = 1 - colorArr[u]\n                    queue.append(v)\n \n                # An edge from u to v exists and destination \n                # v is colored with same color as u\n                elif self.graph[u][v] == 1 and colorArr[v] == colorArr[u]:\n                    return False\n \n        # If we reach here, then all adjacent \n        # vertices can be colored with alternate \n        # color\n        return True\n \n# Driver program to test above function\ng = Graph(4)\ng.graph = [[0, 1, 0, 1],\n            [1, 0, 1, 0],\n            [0, 1, 0, 1],\n            [1, 0, 1, 0]\n            ]\n             \nprint ('Yes' if g.isBipartite(0) else 'No')\n \n# This code is contributed by Divyanshu Mehta\n", "# Python3 program to find out whether a\n# given graph is Bipartite or not\n \n \nclass Graph():\n \n    def __init__(self, V):\n        self.V = V\n        self.graph = [[0 for column in range(V)]\n                      for row in range(V)]\n \n        self.colorArr = [-1 for i in range(self.V)]\n \n    # This function returns true if graph G[V][V]\n    # is Bipartite, else false\n    def isBipartiteUtil(self, src):\n \n        # Create a color array to store colors\n        # assigned to all vertices. Vertex\n        # number is used as index in this array.\n        # The value '-1' of self.colorArr[i] is used\n        # to indicate that no color is assigned to\n        # vertex 'i'. The value 1 is used to indicate\n        # first color is assigned and value 0\n        # indicates second color is assigned.\n \n        # Assign first color to source\n \n        # Create a queue (FIFO) of vertex numbers and\n        # enqueue source vertex for BFS traversal\n        queue = []\n        queue.append(src)\n \n        # Run while there are vertices in queue\n        # (Similar to BFS)\n        while queue:\n \n            u = queue.pop()\n \n            # Return false if there is a self-loop\n            if self.graph[u][u] == 1:\n                return False\n \n            for v in range(self.V):\n \n                # An edge from u to v exists and\n                # destination v is not colored\n                if (self.graph[u][v] == 1 and\n                        self.colorArr[v] == -1):\n \n                    # Assign alternate color to\n                    # this adjacent v of u\n                    self.colorArr[v] = 1 - self.colorArr[u]\n                    queue.append(v)\n \n                # An edge from u to v exists and destination\n                # v is colored with same color as u\n                elif (self.graph[u][v] == 1 and\n                      self.colorArr[v] == self.colorArr[u]):\n                    return False\n \n        # If we reach here, then all adjacent\n        # vertices can be colored with alternate\n        # color\n        return True\n \n    def isBipartite(self):\n        self.colorArr = [-1 for i in range(self.V)]\n        for i in range(self.V):\n            if self.colorArr[i] == -1:\n                if not self.isBipartiteUtil(i):\n                    return False\n        return True\n \n \n# Driver Code\ng = Graph(4)\ng.graph = [[0, 1, 0, 1],\n           [1, 0, 1, 0],\n           [0, 1, 0, 1],\n           [1, 0, 1, 0]]\n \nprint ('Yes' if g.isBipartite() else 'No')\n \n# This code is contributed by Anshuman Sharma\n", "def isBipartite(V, adj):\n    # vector to store colour of vertex\n    # assigning all to -1 i.e. uncoloured\n    # colours are either 0 or 1\n    # for understanding take 0 as red and 1 as blue\n    col = [-1]*(V)\n   \n    # queue for BFS storing {vertex , colour}\n    q = []\n   \n    #loop incase graph is not connected\n    for i in range(V):\n       \n        # if not coloured\n        if (col[i] == -1):\n           \n            # colouring with 0 i.e. red\n            q.append([i, 0])\n            col[i] = 0\n           \n            while len(q) != 0:\n                p = q[0]\n                q.pop(0)\n               \n                # current vertex\n                v = p[0]\n                 \n                # colour of current vertex\n                c = p[1]\n                   \n                # traversing vertexes connected to current vertex\n                for j in adj[v]:\n                   \n                    # if already coloured with parent vertex color\n                    # then bipartite graph is not possible\n                    if (col[j] == c):\n                        return False\n                   \n                    # if uncoloured\n                    if (col[j] == -1):\n                       \n                        # colouring with opposite color to that of parent\n                        if c == 1:\n                            col[j] = 0\n                        else:\n                            col[j] = 1\n                        q.append([j, col[j]])\n     \n    # if all vertexes are coloured such that\n    # no two connected vertex have same colours\n    return True\n \nV, E = 4, 8\n \n# adjacency list for storing graph\nadj = []\nadj.append([1,3])\nadj.append([0,2])\nadj.append([1,3])\nadj.append([0,2])\n  \nans = isBipartite(V, adj)\n \n# returns 1 if bipartite graph is possible\nif (ans):\n    print('Yes')\n     \n# returns 0 if bipartite graph is not possible\nelse:\n    print('No')\n     \n    # This code is contributed by divyesh072019.\n", "# Python3 program to find out whether a given \n# graph is Bipartite or not using recursion. \nV = 4\n \ndef colorGraph(G, color, pos, c): \n     \n    if color[pos] != -1 and color[pos] != c: \n        return False\n         \n    # color this pos as c and all its neighbours and 1-c \n    color[pos] = c \n    ans = True\n    for i in range(0, V): \n        if G[pos][i]: \n            if color[i] == -1: \n                ans &= colorGraph(G, color, i, 1-c) \n                 \n            if color[i] !=-1 and color[i] != 1-c: \n                return False\n          \n        if not ans: \n            return False\n      \n    return True\n  \ndef isBipartite(G): \n     \n    color = [-1] * V \n         \n    #start is vertex 0 \n    pos = 0\n    # two colors 1 and 0 \n    return colorGraph(G, color, pos, 1) \n \nif __name__ == '__main__': \n  \n    G = [[0, 1, 0, 1], \n         [1, 0, 1, 0], \n         [0, 1, 0, 1], \n         [1, 0, 1, 0]] \n      \n    if isBipartite(G): print('Yes') \n    else: print('No') \n \n# This code is contributed by Rituraj Jain\n"], "Snake and Ladder Problem -  ": ["# Python3 program to find minimum number\n# of dice throws required to reach last\n# cell from first cell of a given\n# snake and ladder board\n \n# An entry in queue used in BFS\n \n \nclass QueueEntry(object):\n    def __init__(self, v=0, dist=0):\n        self.v = v\n        self.dist = dist\n \n \n'''This function returns minimum number of\ndice throws required to. Reach last cell \nfrom 0'th cell in a snake and ladder game.\nmove[] is an array of size N where N is \nno. of cells on board. If there is no \nsnake or ladder from cell i, then move[i] \nis -1. Otherwise move[i] contains cell to\nwhich snake or ladder at i takes to.'''\n \n \ndef getMinDiceThrows(move, N):\n \n    # The graph has N vertices. Mark all\n    # the vertices as not visited\n    visited = [False] * N\n \n    # Create a queue for BFS\n    queue = []\n \n    # Mark the node 0 as visited and enqueue it\n    visited[0] = True\n \n    # Distance of 0't vertex is also 0\n    # Enqueue 0'th vertex\n    queue.append(QueueEntry(0, 0))\n \n    # Do a BFS starting from vertex at index 0\n    qe = QueueEntry()  # A queue entry (qe)\n    while queue:\n        qe = queue.pop(0)\n        v = qe.v  # Vertex no. of queue entry\n \n        # If front vertex is the destination\n        # vertex, we are done\n        if v == N - 1:\n            break\n \n        # Otherwise dequeue the front vertex\n        # and enqueue its adjacent vertices\n        # (or cell numbers reachable through\n        # a dice throw)\n        j = v + 1\n        while j <= v + 6 and j < N:\n \n            # If this cell is already visited,\n            # then ignore\n            if visited[j] is False:\n \n                # Otherwise calculate its\n                # distance and mark it\n                # as visited\n                a = QueueEntry()\n                a.dist = qe.dist + 1\n                visited[j] = True\n \n                # Check if there a snake or ladder\n                # at 'j' then tail of snake or top\n                # of ladder become the adjacent of 'i'\n                a.v = move[j] if move[j] != -1 else j\n \n                queue.append(a)\n \n            j += 1\n \n    # We reach here when 'qe' has last vertex\n    # return the distance of vertex in 'qe\n    return qe.dist\n \n \n# driver code\nN = 30\nmoves = [-1] * N\n \n# Ladders\nmoves[2] = 21\nmoves[4] = 7\nmoves[10] = 25\nmoves[19] = 28\n \n# Snakes\nmoves[26] = 0\nmoves[20] = 8\nmoves[16] = 3\nmoves[18] = 6\n \nprint('Min Dice throws required is {0}'.\n      format(getMinDiceThrows(moves, N)))\n \n# This code is contributed by Ajitesh Pathak\n", "from typing import List, Dict\n \n \ndef min_throw(n: int, arr: List[int]) -> int:\n    # Initialise an array t of length 31, we will use from\n    # index to 1 to 30\n    t = [-1] * 31\n \n    # create a dictionary to store snakes and ladders start\n    # and end for better efficiency\n    h = {}\n    for i in range(0, 2 * n, 2):\n        # store start as key and end as value\n        h[arr[i]] = arr[i + 1]\n \n    # final ans\n    return sol(1, h, t)\n \n# recursive function\n \n \ndef sol(i: int, h: Dict[int, int], t: List[int]) -> int:\n    # base condition\n    if i >= 30:\n        return 0\n \n    # checking if block is already visited or\n    # not(memoization).\n    elif t[i] != -1:\n        return t[i]\n \n    # initialising min as max int value\n    min_value = float('inf')\n \n    # for loop for every dice value from 1 to 6\n    for j in range(1, 7):\n        # incrementing value of i with dice value i.e j\n        # taking new variable k\n        # ->taking new variable so that we dont change i\n        # as we will need it again in another iteration\n        k = i + j\n        if k in h:\n            # checking if this is a snake or ladder\n            # if a snake then we continue as we dont\n            # need a snake\n            if h[k] < k:\n                continue\n            # updating if it's a ladder to ladder end value\n            k = h[k]\n        # updating min in every iteration for getting\n        # minimum throws from this particular block\n        min_value = min(min_value, sol(k, h, t) + 1)\n \n    # updating value of t[i] to min\n    # memoization\n    t[i] = min_value\n    return t[i]\n \n \n# Given a 5x6 snakes and ladders board\n# You are given an integer N denoting the total\n# number of snakes and ladders and a list arr[]\n# of 2*N size where 2*i and (2*i + 1)th values\n# denote the starting and ending point respectively\n# of ith snake or ladder\nN = 8\narr = [3, 22, 5, 8, 11, 26, 20, 29, 17, 4, 19, 7, 27, 1, 29, 9]\n \nprint('Min Dice throws required is', min_throw(N, arr))\n# This code is contributed by sanjanasikarwar24\n"], "Find if an array of strings can be chained to form a circle | Set 1 -  ": ["# Python program to check if a given directed graph is Eulerian or not\nCHARS = 26\n \n# A class that represents an undirected graph\nclass Graph(object):\n    def __init__(self, V):\n        self.V = V      # No. of vertices\n        self.adj = [[] for x in range(V)]  # a dynamic array\n        self.inp = [0] * V\n \n    # function to add an edge to graph\n    def addEdge(self, v, w):\n        self.adj[v].append(w)\n        self.inp[w]+=1\n \n    # Method to check if this graph is Eulerian or not\n    def isSC(self):\n        # Mark all the vertices as not visited (For first DFS)\n        visited = [False] * self.V\n \n        # Find the first vertex with non-zero degree\n        n = 0\n        for n in range(self.V):\n            if len(self.adj[n]) > 0:\n                break\n \n        # Do DFS traversal starting from first non zero degree vertex.\n        self.DFSUtil(n, visited)\n \n        # If DFS traversal doesn't visit all vertices, then return false.\n        for i in range(self.V):\n            if len(self.adj[i]) > 0 and visited[i] == False:\n                return False\n \n        # Create a reversed graph\n        gr = self.getTranspose()\n \n        # Mark all the vertices as not visited (For second DFS)\n        for i in range(self.V):\n            visited[i] = False\n \n        # Do DFS for reversed graph starting from first vertex.\n        # Starting Vertex must be same starting point of first DFS\n        gr.DFSUtil(n, visited)\n \n        # If all vertices are not visited in second DFS, then\n        # return false\n        for i in range(self.V):\n            if len(self.adj[i]) > 0 and visited[i] == False:\n                return False\n \n        return True\n \n    # This function returns true if the directed graph has an eulerian\n    # cycle, otherwise returns false\n    def isEulerianCycle(self):\n \n        # Check if all non-zero degree vertices are connected\n        if self.isSC() == False:\n            return False\n \n        # Check if in degree and out degree of every vertex is same\n        for i in range(self.V):\n            if len(self.adj[i]) != self.inp[i]:\n                return False\n \n        return True\n \n    # A recursive function to do DFS starting from v\n    def DFSUtil(self, v, visited):\n \n        # Mark the current node as visited and print it\n        visited[v] = True\n \n        # Recur for all the vertices adjacent to this vertex\n        for i in range(len(self.adj[v])):\n            if not visited[self.adj[v][i]]:\n                self.DFSUtil(self.adj[v][i], visited)\n \n    # Function that returns reverse (or transpose) of this graph\n    # This function is needed in isSC()\n    def getTranspose(self):\n        g = Graph(self.V)\n        for v in range(self.V):\n            # Recur for all the vertices adjacent to this vertex\n            for i in range(len(self.adj[v])):\n                g.adj[self.adj[v][i]].append(v)\n                g.inp[v]+=1\n        return g\n \n# This function takes an of strings and returns true\n# if the given array of strings can be chained to\n# form cycle\ndef canBeChained(arr, n):\n \n    # Create a graph with 'alpha' edges\n    g = Graph(CHARS)\n \n    # Create an edge from first character to last character\n    # of every string\n    for i in range(n):\n        s = arr[i]\n        g.addEdge(ord(s[0])-ord('a'), ord(s[len(s)-1])-ord('a'))\n \n    # The given array of strings can be chained if there\n    # is an eulerian cycle in the created graph\n    return g.isEulerianCycle()\n \n# Driver program\narr1 = ['for', 'geek', 'rig', 'kaf']\nn1 = len(arr1)\nif canBeChained(arr1, n1):\n    print ('Can be chained')\nelse:\n    print ('Cant be chained')\n \narr2 = ['aab', 'abb']\nn2 = len(arr2)\nif canBeChained(arr2, n2):\n    print ('Can be chained')\nelse:\n    print ('Can't be chained')\n \n# This code is contributed by BHAVYA JAIN\n"], "Find the ordering of task from given dependencies (Course Schedule II) -  ": ["# Python program to find order to process tasks\n# so that all tasks can be finished. This program\n# mainly uses Kahn's algorithm.\nfrom collections import deque\n \n# Returns adjacency list representation of graph from\n# given set of pairs.\ndef make_graph(numTasks, prerequisites):\n    graph = [set() for _ in range(numTasks)]\n    for u, v in prerequisites:\n        graph[v].add(u)\n    return graph\n \n# Computes in-degree of every vertex\ndef compute_indegree(graph):\n    indegrees = [0] * len(graph)\n    for neighbors in graph:\n        for neigh in neighbors:\n            indegrees[neigh] += 1\n    return indegrees\n \n# main function for topological sorting\ndef findOrder(numTasks, prerequisites):\n    # Create an adjacency list\n    graph = make_graph(numTasks, prerequisites)\n     \n    # Find vertices of zero degree\n    indegrees = compute_indegree(graph)\n    zeros = deque([i for i, degree in enumerate(indegrees) if degree == 0])\n     \n    # Find vertices in topological order\n    # starting with vertices of 0 degree\n    # and reducing degrees of adjacent.\n    toposort = []\n    while zeros:\n        zero = zeros.popleft()\n        toposort.append(zero)\n        for neigh in graph[zero]:\n            indegrees[neigh] -= 1\n            if indegrees[neigh] == 0:\n                zeros.append(neigh)\n    return toposort if len(toposort) == numTasks else []\n \n# Driver code\nif __name__ == '__main__':\n    numTasks = 4\n    # for prerequisites: [[1, 0], [2, 1], [3, 2]]\n    prerequisites = [(1, 0), (2, 1), (3, 2)]\n    toposort = findOrder(numTasks, prerequisites)\n    print(toposort)\n \n# This code is contributed by Aman Kumar.\n", "#  Python program to find Topological sorting using\n#  DFS\n \n#  Returns adjacency list representation of graph from\n#  given set of pairs.\ndef make_graph(numTasks, prerequisites):\n    graph = {i: [] for i in range(numTasks)}\n    for pre in prerequisites:\n        graph[pre[1]].append(pre[0])\n    return graph\n \n \n#  Does DFS and adds nodes to Topological Sort\ndef dfs(graph, node, onpath, visited, toposort):\n    if visited[node]:\n        return False\n    onpath[node] = visited[node] = True\n    for neigh in graph[node]:\n        if onpath[neigh] or dfs(graph, neigh, onpath, visited, toposort):\n            return True\n    toposort.append(node)\n    return onpath[node] == False\n \n \n#  Returns an order of tasks so that all tasks can be\n#  finished.\ndef findOrder(numTasks, prerequisites):\n    graph = make_graph(numTasks, prerequisites)\n    toposort = []\n    onpath = [False for i in range(numTasks)]\n    visited = [False for i in range(numTasks)]\n    for i in range(numTasks):\n        if not visited[i] and dfs(graph, i, onpath, visited, toposort):\n            return\n    toposort = toposort[::-1]\n    return toposort\n \n# Driver code\nif __name__ == '__main__':\n    numTasks = 4\n    prerequisites = [[1, 0], [2, 1], [3, 2]]\n    v = findOrder(numTasks, prerequisites)\n    for i in range(len(v)):\n        print(v[i], end=' ')\n"], "Detect cycle in an undirected graph -  ": ["# Python Program to detect cycle in an undirected graph\nfrom collections import defaultdict\n \n# This class represents a undirected\n# graph using adjacency list representation\n \n \nclass Graph:\n \n    def __init__(self, vertices):\n \n        # No. of vertices\n        self.V = vertices  # No. of vertices\n \n        # Default dictionary to store graph\n        self.graph = defaultdict(list)\n \n    # Function to add an edge to graph\n    def addEdge(self, v, w):\n \n        # Add w to v_s list\n        self.graph[v].append(w)\n \n        # Add v to w_s list\n        self.graph[w].append(v)\n \n    # A recursive function that uses\n    # visited[] and parent to detect\n    # cycle in subgraph reachable from vertex v.\n    def isCyclicUtil(self, v, visited, parent):\n \n        # Mark the current node as visited\n        visited[v] = True\n \n        # Recur for all the vertices\n        # adjacent to this vertex\n        for i in self.graph[v]:\n \n            # If the node is not\n            # visited then recurse on it\n            if visited[i] == False:\n                if(self.isCyclicUtil(i, visited, v)):\n                    return True\n            # If an adjacent vertex is\n            # visited and not parent\n            # of current vertex,\n            # then there is a cycle\n            elif parent != i:\n                return True\n \n        return False\n \n    # Returns true if the graph\n    # contains a cycle, else false.\n \n    def isCyclic(self):\n \n        # Mark all the vertices\n        # as not visited\n        visited = [False]*(self.V)\n \n        # Call the recursive helper\n        # function to detect cycle in different\n        # DFS trees\n        for i in range(self.V):\n \n            # Don't recur for u if it\n            # is already visited\n            if visited[i] == False:\n                if(self.isCyclicUtil\n                   (i, visited, -1)) == True:\n                    return True\n \n        return False\n \n \n# Create a graph given in the above diagram\ng = Graph(5)\ng.addEdge(1, 0)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(0, 3)\ng.addEdge(3, 4)\n \nif g.isCyclic():\n    print('Graph contains cycle')\nelse:\n    print('Graph doesn't contain cycle ')\ng1 = Graph(3)\ng1.addEdge(0, 1)\ng1.addEdge(1, 2)\n \n \nif g1.isCyclic():\n    print('Graph contains cycle')\nelse:\n    print('Graph doesn't contain cycle ')\n \n# This code is contributed by Neelam Yadav\n"], "Introduction to Disjoint Set (Union-Find Algorithm) -  ": ["# Finds the representative of the set\n# that i is an element of\n \ndef find(i):\n \n    # If i is the parent of itself\n    if (parent[i] == i):\n \n        # Then i is the representative of\n        # this set\n        return i\n    else:\n \n        # Else if i is not the parent of\n        # itself, then i is not the\n        # representative of his set. So we\n        # recursively call Find on its parent\n        return find(parent[i])\n \n # The code is contributed by Nidhi goel\n", "# Unites the set that includes i\n# and the set that includes j\n \ndef union(parent, rank, i, j):\n    # Find the representatives\n    # (or the root nodes) for the set\n    # that includes i\n    irep = find(parent, i)\n     \n    # And do the same for the set\n    # that includes j\n    jrep = find(parent, j)\n     \n    # Make the parent of i\u2019s representative\n    # be j\u2019s  representative effectively\n    # moving all of i\u2019s set into j\u2019s set)\n     \n    parent[irep] = jrep\n", "#  Finds the representative of the set that i\n# is an element of.\n \n \ndef find(i):\n \n    # If i is the parent of itself\n    if Parent[i] == i:\n \n        # Then i is the representative \n        return i\n    else:\n \n        # Recursively find the representative.\n        result = find(Parent[i])\n \n        # We cache the result by moving i\u2019s node \n        # directly under the representative of this\n        # set\n        Parent[i] = result\n       \n        # And then we return the result\n        return result\n \n# The code is contributed by Arushi  Jindal. \n", "# Python3 program to implement Disjoint Set Data\n# Structure.\n \nclass DisjSet:\n    def __init__(self, n):\n        # Constructor to create and\n        # initialize sets of n items\n        self.rank = [1] * n\n        self.parent = [i for i in range(n)]\n \n \n    # Finds set of given item x\n    def find(self, x):\n         \n        # Finds the representative of the set\n        # that x is an element of\n        if (self.parent[x] != x):\n             \n            # if x is not the parent of itself\n            # Then x is not the representative of\n            # its set,\n            self.parent[x] = self.find(self.parent[x])\n             \n            # so we recursively call Find on its parent\n            # and move i's node directly under the\n            # representative of this set\n \n        return self.parent[x]\n \n \n    # Do union of two sets represented\n    # by x and y.\n    def Union(self, x, y):\n         \n        # Find current sets of x and y\n        xset = self.find(x)\n        yset = self.find(y)\n \n        # If they are already in same set\n        if xset == yset:\n            return\n \n        # Put smaller ranked item under\n        # bigger ranked item if ranks are\n        # different\n        if self.rank[xset] < self.rank[yset]:\n            self.parent[xset] = yset\n \n        elif self.rank[xset] > self.rank[yset]:\n            self.parent[yset] = xset\n \n        # If ranks are same, then move y under\n        # x (doesn't matter which one goes where)\n        # and increment rank of x's tree\n        else:\n            self.parent[yset] = xset\n            self.rank[xset] = self.rank[xset] + 1\n \n# Driver code\nobj = DisjSet(5)\nobj.Union(0, 2)\nobj.Union(4, 2)\nobj.Union(3, 1)\nif obj.find(4) == obj.find(0):\n    print('Yes')\nelse:\n    print('No')\nif obj.find(1) == obj.find(0):\n    print('Yes')\nelse:\n    print('No')\n \n# This code is contributed by ng24_7.\n"], "Transitive closure of a graph -  ": ["# Python program for transitive closure using Floyd Warshall Algorithm \n#Complexity : O(V^3)\n \nfrom collections import defaultdict\n \n#Class to represent a graph\nclass Graph:\n \n    def __init__(self, vertices):\n        self.V = vertices\n \n    # A utility function to print the solution\n    def printSolution(self, reach):\n        print ('Following matrix transitive closure of the given graph ')    \n        for i in range(self.V):\n            for j in range(self.V):\n                if (i == j):\n                  print ('%7d\\t' % (1),end=' ')\n                else:\n                  print ('%7d\\t' %(reach[i][j]),end=' ')\n            print()\n     \n     \n    # Prints transitive closure of graph[][] using Floyd Warshall algorithm\n    def transitiveClosure(self,graph):\n        '''reach[][] will be the output matrix that will finally\n        have reachability values.\n        Initialize the solution matrix same as input graph matrix'''\n        reach =[i[:] for i in graph]\n        '''Add all vertices one by one to the set of intermediate\n        vertices.\n         ---> Before start of a iteration, we have reachability value\n         for all pairs of vertices such that the reachability values\n          consider only the vertices in set \n        {0, 1, 2, .. k-1} as intermediate vertices.\n          ----> After the end of an iteration, vertex no. k is\n         added to the set of intermediate vertices and the \n        set becomes {0, 1, 2, .. k}'''\n        for k in range(self.V):\n             \n            # Pick all vertices as source one by one\n            for i in range(self.V):\n                 \n                # Pick all vertices as destination for the\n                # above picked source\n                for j in range(self.V):\n                     \n                    # If vertex k is on a path from i to j, \n                       # then make sure that the value of reach[i][j] is 1\n                    reach[i][j] = reach[i][j] or (reach[i][k] and reach[k][j])\n \n        self.printSolution(reach)\n         \ng= Graph(4)\n \ngraph = [[1, 1, 0, 1],\n         [0, 1, 1, 0],\n         [0, 0, 1, 1],\n         [0, 0, 0, 1]]\n \n#Print the solution\ng.transitiveClosure(graph)\n \n#This code is contributed by Neelam Yadav\n"], "Depth First Search or DFS for a Graph -  ": ["# Python3 program to print DFS traversal\n# from a given  graph\nfrom collections import defaultdict\n \n \n# This class represents a directed graph using\n# adjacency list representation\nclass Graph:\n \n    # Constructor\n    def __init__(self):\n \n        # Default dictionary to store graph\n        self.graph = defaultdict(list)\n \n     \n    # Function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n \n     \n    # A function used by DFS\n    def DFSUtil(self, v, visited):\n \n        # Mark the current node as visited\n        # and print it\n        visited.add(v)\n        print(v, end=' ')\n \n        # Recur for all the vertices\n        # adjacent to this vertex\n        for neighbour in self.graph[v]:\n            if neighbour not in visited:\n                self.DFSUtil(neighbour, visited)\n \n     \n    # The function to do DFS traversal. It uses\n    # recursive DFSUtil()\n    def DFS(self, v):\n \n        # Create a set to store visited vertices\n        visited = set()\n \n        # Call the recursive helper function\n        # to print DFS traversal\n        self.DFSUtil(v, visited)\n \n \n# Driver's code\nif __name__ == '__main__':\n    g = Graph()\n    g.addEdge(0, 1)\n    g.addEdge(0, 2)\n    g.addEdge(1, 2)\n    g.addEdge(2, 0)\n    g.addEdge(2, 3)\n    g.addEdge(3, 3)\n \n    print('Following is Depth First Traversal (starting from vertex 2)')\n     \n    # Function call\n    g.DFS(2)\n \n# This code is contributed by Neelam Yadav\n"], "Breadth First Search or BFS for a Graph -  ": ["# Python3 Program to print BFS traversal\n# from a given source vertex. BFS(int s)\n# traverses vertices reachable from s.\n \nfrom collections import defaultdict\n \n \n# This class represents a directed graph\n# using adjacency list representation\nclass Graph:\n \n    # Constructor\n    def __init__(self):\n \n        # Default dictionary to store graph\n        self.graph = defaultdict(list)\n \n    # Function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n \n    # Function to print a BFS of graph\n    def BFS(self, s):\n \n        # Mark all the vertices as not visited\n        visited = [False] * (max(self.graph) + 1)\n \n        # Create a queue for BFS\n        queue = []\n \n        # Mark the source node as\n        # visited and enqueue it\n        queue.append(s)\n        visited[s] = True\n \n        while queue:\n \n            # Dequeue a vertex from\n            # queue and print it\n            s = queue.pop(0)\n            print(s, end=' ')\n \n            # Get all adjacent vertices of the\n            # dequeued vertex s.\n            # If an adjacent has not been visited,\n            # then mark it visited and enqueue it\n            for i in self.graph[s]:\n                if visited[i] == False:\n                    queue.append(i)\n                    visited[i] = True\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Create a graph given in\n    # the above diagram\n    g = Graph()\n    g.addEdge(0, 1)\n    g.addEdge(0, 2)\n    g.addEdge(1, 2)\n    g.addEdge(2, 0)\n    g.addEdge(2, 3)\n    g.addEdge(3, 3)\n \n    print('Following is Breadth First Traversal'\n          ' (starting from vertex 2)')\n    g.BFS(2)\n \n# This code is contributed by Neelam Yadav\n"], "Print Adjacency List for a Directed Graph -  ": ["# Python program for the above approach\n \n# Function to add edges\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n   \n# Function to print adjacency list\ndef adjacencylist(adj, V):\n     \n    for i in range (0, V):\n        print(i, '->', end='')\n         \n        for x in  adj[i]: \n            print(x , ' ', end='')\n       \n        print()\n     \n# Function to initialize the adjacency list\n# of the given graph\ndef initGraph(V, edges, noOfEdges):\n \n    adj = [0]* 3\n     \n    for i in range(0, len(adj)):\n        adj[i] = []\n   \n    # Traverse edges array and make edges\n    for i in range(0, noOfEdges) :\n \n         # Function call to make an edge\n        addEdge(adj, edges[i][0], edges[i][1])\n     \n \n    # Function Call to print adjacency list\n    adjacencylist(adj, V)\n   \n# Driver Code\n   \n# Given vertices\nV = 3\n \n# Given edges\nedges =  [[0, 1 ],  [1, 2 ],  [2, 0 ]] \n \nnoOfEdges = 3;\n \n# Function Call\ninitGraph(V, edges, noOfEdges)\n \n# This code is contributed by AR_Gaurav\n"], "Maximize the number of uncolored vertices appearing along the path from root vertex and the colored vertices -  ": ["# Python3 program to Maximize the number\n# of uncolored vertices occurring between\n# the path from root vertex and the colored vertices\ng = []\ndepth = []\nsubtree = []\ndiff = []\n \n# Constructor\ndef graph(n):\n    global g, depth, subtree, diff\n    g = [[] for i in range(n + 1)]\n    depth = [0]*(n + 1)\n    subtree = [0]*(n + 1)\n    diff = [0]*(n + 1)\n \n# Function to push edges\ndef push(a, b):\n    global g\n    g[a].append(b)\n    g[b].append(a)\n \n# function for dfs traversal\ndef dfs(v, p):\n    global depth, subtree, g, diff\n \n    # Store depth of vertices\n    depth[v] = depth[p] + 1\n    subtree[v] = 1\n    for i in g[v]:\n        if (i == p):\n            continue\n \n        # Calculate number of vertices\n        # in subtree of all vertices\n        subtree[v] += dfs(i, v)\n \n    # Computing the difference\n    diff[v] = depth[v] - subtree[v]\n    return subtree[v]\n \n# Function that print maximum number of\n# uncolored vertices occur between root vertex\n# and all colored vertices\ndef solution(n, k):\n    global diff\n \n    # Computing first k largest difference\n    diff = sorted(diff)[::-1]\n     \n    # nth_element(diff + 1, diff + k, diff + n + 1, cmp)\n    sum = 2\n    for i in range(1, k + 1):\n        sum += diff[i]\n \n    # Print the result\n    print (sum)\n \n# Driver Code\nif __name__ == '__main__':\n    N = 7\n    k = 4\n \n    # initialise graph\n    graph(N)\n    push(1, 2)\n    push(1, 3)\n    push(1, 4)\n    push(3, 5)\n    push(3, 6)\n    push(4, 7)\n    dfs(1, 0)\n    solution(N, k)\n \n# This code is contributed by mohit kumar 29.\n"], "Hopcroft\u2013Karp Algorithm for Maximum Matching | Set 2 (Implementation) -  ": ["# Python3 implementation of Hopcroft Karp algorithm for\n# maximum matching\nfrom queue import Queue\n \nINF = 2147483647\nNIL = 0\n \n# A class to represent Bipartite graph for Hopcroft\n# 3 Karp implementation\nclass BipGraph(object):\n    # Constructor\n    def __init__(self, m, n):\n        # m and n are number of vertices on left\n        # and right sides of Bipartite Graph\n        self.__m = m\n        self.__n = n\n        # adj[u] stores adjacents of left side\n        # vertex 'u'. The value of u ranges from 1 to m.\n        # 0 is used for dummy vertex\n        self.__adj = [[] for _ in range(m+1)]\n \n    # To add edge from u to v and v to u\n    def addEdge(self, u, v):\n        self.__adj[u].append(v)  # Add u to v\u2019s list.\n \n    # Returns true if there is an augmenting path, else returns\n    # false\n    def bfs(self):\n        Q = Queue()\n        # First layer of vertices (set distance as 0)\n        for u in range(1, self.__m+1):\n            # If this is a free vertex, add it to queue\n            if self.__pairU[u] == NIL:\n                # u is not matched3\n                self.__dist[u] = 0\n                Q.put(u)\n            # Else set distance as infinite so that this vertex\n            # is considered next time\n            else:\n                self.__dist[u] = INF\n        # Initialize distance to NIL as infinite\n        self.__dist[NIL] = INF\n        # Q is going to contain vertices of left side only.\n        while not Q.empty():\n            # Dequeue a vertex\n            u = Q.get()\n            # If this node is not NIL and can provide a shorter path to NIL\n            if self.__dist[u] < self.__dist[NIL]:\n                # Get all adjacent vertices of the dequeued vertex u\n                for v in self.__adj[u]:\n                    #  If pair of v is not considered so far\n                    # (v, pairV[V]) is not yet explored edge.\n                    if self.__dist[self.__pairV[v]] == INF:\n                        # Consider the pair and add it to queue\n                        self.__dist[self.__pairV[v]] = self.__dist[u] + 1\n                        Q.put(self.__pairV[v])\n        # If we could come back to NIL using alternating path of distinct\n        # vertices then there is an augmenting path\n        return self.__dist[NIL] != INF\n \n    # Returns true if there is an augmenting path beginning with free vertex u\n    def dfs(self, u):\n        if u != NIL:\n            # Get all adjacent vertices of the dequeued vertex u\n            for v in self.__adj[u]:\n                if self.__dist[self.__pairV[v]] == self.__dist[u] + 1:\n                    # If dfs for pair of v also returns true\n                    if self.dfs(self.__pairV[v]):\n                        self.__pairV[v] = u\n                        self.__pairU[u] = v\n                        return True\n            # If there is no augmenting path beginning with u.\n            self.__dist[u] = INF\n            return False\n        return True\n \n    def hopcroftKarp(self):\n        # pairU[u] stores pair of u in matching where u\n        # is a vertex on left side of Bipartite Graph.\n        # If u doesn't have any pair, then pairU[u] is NIL\n        self.__pairU = [0 for _ in range(self.__m+1)]\n \n        # pairV[v] stores pair of v in matching. If v\n        # doesn't have any pair, then pairU[v] is NIL\n        self.__pairV = [0 for _ in range(self.__n+1)]\n \n        # dist[u] stores distance of left side vertices\n        # dist[u] is one more than dist[u'] if u is next\n        # to u'in augmenting path\n        self.__dist = [0 for _ in range(self.__m+1)]\n        # Initialize result\n        result = 0\n \n        # Keep updating the result while there is an\n        # augmenting path.\n        while self.bfs():\n            # Find a free vertex\n            for u in range(1, self.__m+1):\n                # If current vertex is free and there is\n                # an augmenting path from current vertex\n                if self.__pairU[u] == NIL and self.dfs(u):\n                    result += 1\n        return result\n \n \n# Driver Program\nif __name__ == '__main__':\n    g = BipGraph(4, 4)\n    g.addEdge(1, 2)\n    g.addEdge(1, 3)\n    g.addEdge(2, 1)\n    g.addEdge(3, 2)\n    g.addEdge(4, 2)\n    g.addEdge(4, 4)\n    print('Size of maximum matching is %d' % g.hopcroftKarp())\n"], "Largest subset of Graph vertices with edges of 2 or more colors -  ": ["# Python3 program to find size of subset  \n# of graph vertex such that each vertex \n# has more than 1 color edges \n  \n# function to calculate max subset size  \ndef subsetGraph(C): \n    global N \n      \n    # set for number of vertices  \n    vertices = set() \n    for i in range(N): \n        vertices.add(i)  \n  \n    # loop for deletion of vertex from set  \n    while (len(vertices) != 0): \n          \n        # if subset has only 1 vertex return 0  \n        if (len(vertices) == 1):  \n            return 1\n  \n        # for each vertex iterate and keep removing  \n        # a vertex while we find a vertex with all  \n        # edges of same color.  \n        someone_removed = False\n        for x in vertices: \n              \n            # note down different color values  \n            # for each vertex  \n            values = set() \n            for y in vertices: \n                if (y != x):  \n                    values.add(C[x][y])  \n  \n            # if only one color is found  \n            # erase that vertex (bad vertex)  \n            if (len(values) == 1): \n                vertices.remove(x)  \n                someone_removed = True\n                break\n  \n        # If no vertex was removed in the  \n        # above loop.  \n        if (not someone_removed):  \n            break\n  \n    return len(vertices) \n  \n# Driver Code \n  \n# Number of vertices  \nN = 6\nC = [[0, 9, 2, 4, 7, 8],  \n     [9, 0, 9, 9, 7, 9], \n     [2, 9, 0, 3, 7, 6], \n     [4, 9, 3, 0, 7, 1], \n     [7, 7, 7, 7, 0, 7], \n     [8, 9, 6, 1, 7, 0]] \nprint(subsetGraph(C)) \n  \n# This code is contributed by PranchalK \n"], "Maximum number of soldier in a team -  ": ["# Python code for the above approach : \n \n# Function to perform Bipartite Coloring\ndef bipartite_color(v, g, colr, paint):\n    global one, zero, flag\n \n    # If the vertex is already colored\n    if colr[v] != -1:\n        # If the previous color and current paint\n        # contradict each other, then our answer\n        # won't exist\n        if colr[v] != paint:\n            flag = False\n        return\n \n    # Paint the current vertex v\n    colr[v] = paint\n \n    # If paint is 1\n    if paint:\n        one += 1\n    # If paint is 0\n    else:\n        zero += 1\n \n    # Recursive calls on the child of vertex v\n    for child in g[v]:\n        # Giving the complementary color to the\n        # child, i.e., if colr[v]=1 then\n        # colr[child]=0 and vice versa\n        bipartite_color(child, g, colr, not paint)\n \n# Function to find the maximum number of soldiers\ndef maximum_soldier(N, arr):\n    global one, zero, flag\n \n    # Creating a graph with an upper bound of 20001\n    g = [[] for _ in range(20001)]\n \n    # Set to store all the unique soldiers\n    st = set()\n     \n    for i in range(N):\n        # u and v store the soldier\n        u, v = arr[i][0], arr[i][1]\n \n        # Initializing the graph\n        g[u].append(v)\n        g[v].append(u)\n \n        # Inserting u and v into the set\n        st.add(u)\n        st.add(v)\n \n    # To store all the unique soldiers from the set\n    soldiers = list(st)\n \n    # Initializing the result as ans=0\n    ans = 0\n \n    # colr[] to apply Bipartite coloring\n    colr = [-1] * 20001\n \n    # Loop for each soldier\n    for e in soldiers:\n        # If already colored, continue\n        if colr[e] != -1:\n            continue\n \n        # one and zero are our two colors\n        one = 0\n        zero = 0\n \n        # Applying Bipartite Coloring\n        bipartite_color(e, g, colr, 0)\n \n        # Updating our answer\n        ans += max(one, zero)\n \n    if flag:\n        print(ans)\n    else:\n        print(-1)\n \nif __name__ == '__main__':\n    # Input test case\n    N = 4\n    arr = [[1, 2], [2, 3], [2, 4], [2, 5]]\n    flag = True\n \n    # Function call\n    maximum_soldier(N, arr)\n     \n # this code is contributed by uttamdp_10\n"], "Channel Assignment Problem -  ": ["# A Depth First Search based recursive \n# function that returns true if a matching\n# for vertex u is possible \ndef bpm(table, u, seen, matchR):\n    global M, N\n     \n    # Try every receiver one by one \n    for v in range(N):\n         \n        # If sender u has packets to send to \n        # receiver v and receiver v is not \n        # already mapped to any other sender \n        # just check if the number of packets \n        # is greater than '0' because only one\n        # packet can be sent in a time frame anyways \n        if (table[u][v] > 0 and not seen[v]):\n            seen[v] = True # Mark v as visited \n \n            # If receiver 'v' is not assigned to any \n            # sender OR previously assigned sender \n            # for receiver v (which is matchR[v]) has \n            # an alternate receiver available. Since \n            # v is marked as visited in the above line,  \n            # matchR[v] in the following recursive call\n            # will not get receiver 'v' again \n            if (matchR[v] < 0 or bpm(table, matchR[v], \n                                       seen, matchR)):\n                matchR[v] = u \n                return True\n    return False\n \n# Returns maximum number of packets \n# that can be sent parallelly in 1 \n# time slot from sender to receiver \ndef maxBPM(table):\n    global M, N\n     \n    # An array to keep track of the receivers \n    # assigned to the senders. The value of \n    # matchR[i] is the sender ID assigned to \n    # receiver i. The value -1 indicates nobody \n    # is assigned.\n \n    # Initially all receivers are not mapped\n    # to any senders \n    matchR = [-1] * N\n \n    result = 0 # Count of receivers assigned to senders\n    for u in range(M):\n         \n        # Mark all receivers as not seen \n        # for next sender \n        seen = [0] * N\n \n        # Find if the sender 'u' can be assigned\n        # to the receiver \n        if (bpm(table, u, seen, matchR)): \n            result += 1\n \n    print('The number of maximum packets sent', \n          'in the time slot is', result)\n \n    for x in range(N):\n        if (matchR[x] + 1 != 0): \n            print('T', matchR[x] + 1, '-> R', x + 1) \n    return result\n \n# Driver Code\nM = 3\nN = 4\n \ntable = [[0, 2, 0], [3, 0, 1], [2, 4, 0]]\nmax_flow = maxBPM(table)\n \n# This code is contributed by PranchalK\n"], "Number of sink nodes in a graph -  ": ["# Python3 program to count number if sink nodes\n \n# Return the number of Sink NOdes. \ndef countSink(n, m, edgeFrom, edgeTo):\n     \n    # Array for marking the non-sink node. \n    mark = [0] * (n + 1)\n \n    # Marking the non-sink node.\n    for i in range(m):\n        mark[edgeFrom[i]] = 1\n \n    # Counting the sink nodes. \n    count = 0\n    for i in range(1, n + 1):\n        if (not mark[i]): \n            count += 1\n \n    return count\n \n# Driver Code\nif __name__ == '__main__': \n     \n    n = 4\n    m = 2\n    edgeFrom = [2, 4] \n    edgeTo = [3, 3]\n \n    print(countSink(n, m, edgeFrom, edgeTo))\n \n# This code is contributed by PranchalK\n"], "Determine whether a universal sink exists in a directed graph -  ": ["# Python3 program to find whether a \n# universal sink exists in a directed graph\nclass Graph:\n \n    # constructor to initialize number of \n    # vertices and size of adjacency matrix\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adjacency_matrix = [[0 for i in range(vertices)]\n                                    for j in range(vertices)]\n \n    def insert(self, s, destination):\n \n        # make adjacency_matrix[i][j] = 1 \n        # if there is an edge from i to j\n        self.adjacency_matrix[s - 1][destination - 1] = 1\n \n    def issink(self, i):\n        for j in range(self.vertices):\n \n            # if any element in the row i is 1, it means\n            # that there is an edge emanating from the\n            # vertex, which means it cannot be a sink\n            if self.adjacency_matrix[i][j] == 1:\n                return False\n \n            # if any element other than i in the column\n            # i is 0, it means that there is no edge from\n            # that vertex to the vertex we are testing\n            # and hence it cannot be a sink\n            if self.adjacency_matrix[j][i] == 0 and j != i:\n                return False\n \n        # if none of the checks fails, return true\n        return True\n \n    # we will eliminate n-1 non sink vertices so that\n    # we have to check for only one vertex instead of\n    # all n vertices\n    def eliminate(self):\n        i = 0\n        j = 0\n        while i < self.vertices and j < self.vertices:\n \n            # If the index is 1, increment the row \n            # we are checking by 1\n            # else increment the column\n            if self.adjacency_matrix[i][j] == 1:\n                i += 1\n            else:\n                j += 1\n \n        # If i exceeds the number of vertices, it\n        # means that there is no valid vertex in\n        # the given vertices that can be a sink\n        if i > self.vertices:\n            return -1\n        elif self.issink(i) is False:\n            return -1\n        else:\n            return i\n \n# Driver Code\nif __name__ == '__main__':\n \n    number_of_vertices = 6\n    number_of_edges = 5\n    g = Graph(number_of_vertices)\n \n    # input set 1\n    # g.insert(1, 6)\n    # g.insert(2, 6)\n    # g.insert(3, 6)\n    # g.insert(4, 6)\n    # g.insert(5, 6)\n     \n    # input set 2\n    g.insert(1, 6)\n    g.insert(2, 3)\n    g.insert(2, 4)\n    g.insert(4, 3)\n    g.insert(5, 3)\n \n    vertex = g.eliminate()\n \n    # returns 0 based indexing of vertex. \n    # returns -1 if no sink exits.\n    # returns the vertex number-1 if sink is found\n    if vertex >= 0:\n        print('Sink found at vertex %d' % (vertex + 1))\n    else:\n        print('No Sink')\n \n# This code is contributed by\n# sanjeev2552\n"], "A Peterson Graph Problem -  ": ["# Python3 program to find the\n# path in Peterson graph\n# path to be checked \n \n# adjacency matrix. \nadj = [[False for i in range(10)] for j in range(10)]\n \n# resulted path - way \nresult = [0]\n \n# we are applying breadth first search\n# here\ndef findthepath(S, v):\n    result[0] = v \n    for i in range(1, len(S)):\n         \n        # first traverse the outer graph\n        if (adj[v][ord(S[i]) - ord('A')] or\n            adj[ord(S[i]) - ord('A')][v]):\n            v = ord(S[i]) - ord('A')\n             \n        # then traverse the inner graph\n        else if (adj[v][ord(S[i]) - ord('A') + 5] or\n               adj[ord(S[i]) - ord('A') + 5][v]):\n            v = ord(S[i]) - ord('A') + 5\n         \n        # if the condition failed to satisfy\n        # return false\n        else:\n            return False\n         \n        result.append(v)\n         \n    return True\n \n# driver code\n# here we have used adjacency matrix to make\n# connections between the connected nodes\nadj[0][1] = adj[1][2] = adj[2][3] = \\\nadj[3][4] = adj[4][0] = adj[0][5] = \\\nadj[1][6] = adj[2][7] = adj[3][8] = \\\nadj[4][9] = adj[5][7] = adj[7][9] = \\\nadj[9][6] = adj[6][8] = adj[8][5] = True\n \n# path to be checked\nS= 'ABB'\nS=list(S)\nif (findthepath(S, ord(S[0]) - ord('A')) or\n    findthepath(S, ord(S[0]) - ord('A') + 5)):\n    print(*result, sep = '')\nelse:\n    print('-1')\n     \n# This code is contributed by SHUBHAMSINGH10\n"], "Transitive Closure of a Graph using DFS -  ": ["# Python program to print transitive\n# closure of a graph.\nfrom collections import defaultdict\n  \nclass Graph:\n  \n    def __init__(self,vertices):\n        # No. of vertices\n        self.V = vertices\n  \n        # default dictionary to store graph\n        self.graph = defaultdict(list)\n  \n        # To store transitive closure\n        self.tc = [[0 for j in range(self.V)] for i in range(self.V)]\n  \n    # function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n  \n    # A recursive DFS traversal function that finds\n    # all reachable vertices for s\n    def DFSUtil(self, s, v):\n  \n        # Mark reachability from s to v as true.\n        if(s == v):\n            if( v in self.graph[s]):\n              self.tc[s][v] = 1\n        else:\n            self.tc[s][v] = 1\n  \n        # Find all the vertices reachable through v\n        for i in self.graph[v]:\n            if self.tc[s][i] == 0:\n                if s==i:\n                   self.tc[s][i]=1\n                else:\n                   self.DFSUtil(s, i)\n  \n    # The function to find transitive closure. It uses\n    # recursive DFSUtil()\n    def transitiveClosure(self):\n  \n        # Call the recursive helper function to print DFS\n        # traversal starting from all vertices one by one\n        for i in range(self.V):\n            self.DFSUtil(i, i)\n         \n        print(self.tc)\n  \n# Create a graph given in the above diagram\ng = Graph(4)\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\n  \ng.transitiveClosure()\n"], "Determining topology formed in a Graph -  ": ["def findTopology(edges):\n    # Initialize a dictionary to store the\n    # connections for each node\n    connections = {}\n \n    # Iterate over the edges and update\n    # the connections dictionary\n    for (node1, node2) in edges:\n        if node1 not in connections:\n            connections[node1] = [node2]\n        else:\n            connections[node1].append(node2)\n        if node2 not in connections:\n            connections[node2] = [node1]\n        else:\n            connections[node2].append(node1)\n \n    # Determine the topology based\n    # on the connections\n    if all(len(v) == 2 for v in connections.values()):\n        topology = 'linear'\n    elif all(len(v) == 1 for v in connections.values()):\n        topology = 'star'\n    elif all(len(v) == 2 for v in connections.values()) and (edges[0][0] == edges[-1][1]):\n        topology = 'ring'\n    else:\n        topology = 'mesh'\n \n    # Print the topology\n    return topology\n \n \n# Create a list of edges\nedges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6),\n         (6, 1), (1, 3), (2, 4), (3, 5), (4, 6)]\nprint(findTopology(edges))\n \n# this code is contributed by prophet1999\n"], "Check whether given degrees of vertices represent a Graph or Tree -  ": [], "Push Relabel Algorithm | Set 2 (Implementation) -  ": ["# python program to implement push-relabel algorithm for \n# getting maximum flow of graph \nclass Edge: \n     \n    def __init__(self, flow, capacity, u, v):\n        self.flow = flow\n        self.capacity = capacity\n        self.u = u\n        self.v = v\n \n# Represent a Vertex \nclass Vertex:\n   \n    def __init__(self, h, e_flow):\n        self.h = h\n        self.e_flow = e_flow\n \n         \n# To represent a flow network \nclass Graph:\n     \n    # int V;    # No. of vertices \n    # vector<Vertex> ver; \n    # vector<Edge> edge; \n    def __init__(self, V):\n         \n        self.V = V; \n        self.edge = []\n        self.ver = []\n        # all vertices are initialized with 0 height \n        # and 0 excess flow \n        for i in range(V):\n            self.ver.append(Vertex(0, 0))\n     \n    def addEdge(self, u, v, capacity):\n        # flow is initialized with 0 for all edge \n        self.edge.append(Edge(0, capacity, u, v))\n \n \n    def preflow(self, s):\n         \n        # Making h of source Vertex equal to no. of vertices \n        # Height of other vertices is 0. \n        self.ver[s].h = len(self.ver); \n \n        for i in range(len(self.edge)): \n             \n            # If current edge goes from source \n            if (self.edge[i].u == s):\n                # Flow is equal to capacity \n                self.edge[i].flow = self.edge[i].capacity\n \n                # Initialize excess flow for adjacent v \n                self.ver[self.edge[i].v].e_flow += self.edge[i].flow\n \n                # Add an edge from v to s in residual graph with \n                # capacity equal to 0 \n                self.edge.append(Edge(-self.edge[i].flow, 0, self.edge[i].v, s))\n                 \n \n    # returns index of overflowing Vertex \n    def overFlowVertex(self):\n         \n        for i in range(1, len(self.ver)-1): \n             \n            if(self.ver[i].e_flow > 0):\n                return i\n \n        # -1 if no overflowing Vertex \n        return -1\n     \n \n    # Update reverse flow for flow added on ith Edge \n    def updateReverseEdgeFlow(self, i, flow):\n         \n        u = self.edge[i].v\n        v = self.edge[i].u \n \n        for j in range(0, len(self.edge)): \n            if (self.edge[j].v == v and self.edge[j].u == u):\n                self.edge[j].flow -= flow\n                return\n \n        # adding reverse Edge in residual graph \n        e = Edge(0, flow, u, v)\n        self.edge.append(e)\n         \n \n    # To push flow from overflowing vertex u \n    def push(self, u): \n         \n        # Traverse through all edges to find an adjacent (of u) \n        # to which flow can be pushed \n        for i in range(0, len(self.edge)): \n             \n            # Checks u of current edge is same as given \n            # overflowing vertex \n            if (self.edge[i].u == u):\n                # if flow is equal to capacity then no push \n                # is possible \n                if (self.edge[i].flow == self.edge[i].capacity):\n                    continue; \n \n                # Push is only possible if height of adjacent \n                # is smaller than height of overflowing vertex \n                if (self.ver[u].h > self.ver[self.edge[i].v].h):\n                     \n                    # Flow to be pushed is equal to minimum of \n                    # remaining flow on edge and excess flow. \n                    flow = min(self.edge[i].capacity - self.edge[i].flow, self.ver[u].e_flow)\n \n                    # Reduce excess flow for overflowing vertex \n                    self.ver[u].e_flow -= flow; \n \n                    # Increase excess flow for adjacent \n                    self.ver[self.edge[i].v].e_flow += flow; \n \n                    # Add residual flow (With capacity 0 and negative \n                    # flow) \n                    self.edge[i].flow += flow; \n \n                    self.updateReverseEdgeFlow(i, flow); \n \n                    return True; \n \n        return False;  \n     \n     \n    # function to relabel vertex u \n    def relabel(self, u):\n        # Initialize minimum height of an adjacent \n        mh = 2100000\n \n        # Find the adjacent with minimum height \n        for i in range(len(self.edge)):  \n            if (self.edge[i].u == u):\n                 \n                # if flow is equal to capacity then no \n                # relabeling \n                if (self.edge[i].flow == self.edge[i].capacity):\n                    continue; \n \n                # Update minimum height \n                if (self.ver[self.edge[i].v].h < mh):\n                    mh = self.ver[self.edge[i].v].h; \n \n                    # updating height of u \n                    self.ver[u].h = mh + 1; \n \n     \n    # main function for printing maximum flow of graph \n    def getMaxFlow(self, s, t):\n         \n        self.preflow(s); \n \n        # loop until none of the Vertex is in overflow \n        while (self.overFlowVertex() != -1):\n             \n            u = self.overFlowVertex(); \n            if (self.push(u) == False):\n                self.relabel(u); \n \n        # ver.back() returns last Vertex, whose \n        # e_flow will be final maximum flow \n        return self.ver[len(self.ver)-1].e_flow\n \n     \n# Driver program to test above functions \nV = 6; \ng = Graph(V);\n \n# Creating above shown flow network \ng.addEdge(0, 1, 16); \ng.addEdge(0, 2, 13); \ng.addEdge(1, 2, 10); \ng.addEdge(2, 1, 4); \ng.addEdge(1, 3, 12); \ng.addEdge(2, 4, 14); \ng.addEdge(3, 2, 9); \ng.addEdge(3, 5, 20); \ng.addEdge(4, 3, 7); \ng.addEdge(4, 5, 4); \n \n# Initialize source and sink \ns = 0\nt = 5; \n \nprint('Maximum flow is ',  g.getMaxFlow(s, t));\n \n# The code is contributed by Arushi goel. \n"], "Roots of a tree which give minimum height -  ": ["# Python program to find root which gives minimum\n# height to tree\n \n# This class represents a undirected graph using\n# adjacency list representation\n \n \nclass Graph:\n \n    # Constructor of graph, initialize adjacency list\n    # and degree vector\n    def __init__(self, V, addEdge, rootForMinimumHeight):\n        self.V = V\n        self.adj = dict((i, []) for i in range(V))\n        self.degree = list()\n        for i in range(V):\n            self.degree.append(0)\n \n        # The below lines allows us define methods outside\n        # of class definition\n        # Check http://bit.ly/2e5HfrW for better explanation\n        Graph.addEdge = addEdge\n        Graph.rootForMinimumHeight = rootForMinimumHeight\n \n \n# addEdge method adds vertex to adjacency list and\n# increases degree by 1\ndef addEdge(self, v, w):\n    self.adj[v].append(w)  # Adds w to v's list\n    self.adj[w].append(v)  # Adds v to w's list\n    self.degree[v] += 1      # increment degree of v by 1\n    self.degree[w] += 1      # increment degree of w by 1\n \n \n# Method to return roots which gives minimum height to tree\ndef rootForMinimumHeight(self):\n \n    from queue import Queue\n    q = Queue()\n \n    # First enqueue all leaf nodes in queue\n    for i in range(self.V):\n        if self.degree[i] == 1:\n            q.put(i)\n \n    # loop until total vertex remains less than 2\n    while(self.V > 2):\n        p = q.qsize()\n        self.V -= p\n        for i in range(p):\n            t = q.get()\n \n            # for each neighbour, decrease its degree and\n            # if it become leaf, insert into queue\n            for j in self.adj[t]:\n                self.degree[j] -= 1\n                if self.degree[j] == 1:\n                    q.put(j)\n \n    #  Copying the result from queue to result vector\n    res = list()\n    while(q.qsize() > 0):\n        res.append(q.get())\n \n    return res\n \n \n# Driver code\ng = Graph(6, addEdge, rootForMinimumHeight)\ng.addEdge(0, 3)\ng.addEdge(1, 3)\ng.addEdge(2, 3)\ng.addEdge(4, 3)\ng.addEdge(5, 4)\n \n# Function call \nres = g.rootForMinimumHeight()\nfor i in res:\n    print (i,end=' ')\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"], "Check if there exists a connected graph that satisfies the given conditions -  ": ["# Python3 implementation of the approach \nimport numpy as np;\n \n# Function to find the required graph \ndef connected_graph(n, k) : \n \n    # If no such graph exists \n    if (k > (n - 1) * (n - 2) / 2) :\n        print(-1) ; \n        return; \n \n    # Consider edge between all vertices \n    isEdge = np.zeros((n, n)); \n    for i in range(n) :\n        for j in range(i + 1, n) :\n            isEdge[i][j] = True; \n \n    # Remove K vertices \n    cnt = 0; \n    for i in range(1, n) :\n        for j in range(i + 1 , n) :\n            if (cnt < k) :\n                isEdge[i][j] = False; \n                cnt += 1; \n \n    # Store all the edges \n    vec = []; \n    for i in range(n) : \n        for j in range(i + 1, n) :\n            if (isEdge[i][j]) :\n                vec.append([i, j]); \n \n    # Print all the edges \n    print(len(vec)); \n    for i in range(len(vec)) :\n        print(vec[i][0] + 1, vec[i][1] + 1); \n \n# Driver code \nif __name__ == '__main__' : \n \n    n = 5; k = 3;\n \n    # Function call \n    connected_graph(n, k); \n \n# This code is contributed by Ankit Rai\n"], "Check if incoming edges in a vertex of directed graph is equal to vertex itself or not -  ": ["# Python3 implementation to check if the\n# incoming edges in a vertex of directed\n# graph is equal to the vertex itself or not\n \n# A utility function to\n# add an edge in an\n# directed graph\ndef add_edge(adj, x, y):\n     \n    adj[x] = adj[x] + [y]\n \n# Function to check that given graph\n# in-degree value equal to vertex value\ndef Indegree(adj, v):\n \n    # Create array indeg\n    # initialized to zero\n    indeg = [0] * v\n \n    # Traversing across all\n    # vertex to compute\n    # in degree value\n    for i in range(v):\n        for j in range(len(adj[i])):\n            indeg[adj[i][j]] += 1\n \n    # Check in degree value\n    # equal to vertex value\n    for i in range(v):\n        if(i == indeg[i]):\n            continue\n        else:\n            return False\n \n    return True\n \n# Driver code\nif __name__ == '__main__':\n \n    v = 4\n \n    # To store adjacency list of graph\n    adj = [[]] * 4\n    add_edge(adj, 0, 1)\n    add_edge(adj, 1, 2)\n    add_edge(adj, 0, 2)\n    add_edge(adj, 0, 3)\n    add_edge(adj, 1, 3)\n    add_edge(adj, 2, 3)\n \n    if(Indegree(adj, v)):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed by Shivam Singh\n"], "Implement Secure Hashing Algorithm - 512 ( SHA-512 ) as Functional Programming Paradigm -  ": [], "You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 342 + 465 = 807 Make sure there are no trailing zeros in the output list So, 7 -> 0 -> 8 -> 0 is not a valid response even though the value is still 807.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @param B : head node of linked list\n    # @return the head node in the linked list\n    def addTwoNumbers(self, A, B):\n        dummy = ListNode(0)\n        a, b, c = A, B, dummy\n        carry = False\n        while a or b or carry:\n            total = int(carry)\n            if a:\n                total += a.val\n                a = a.next\n            if b:\n                total += b.val\n                b = b.next\n            \n            if total >= 10:\n                carry = True\n                total %= 10\n            else:\n                carry = False\n            new = ListNode(total)\n            c.next = new\n            c = new\n        \n        return dummy.next\n\n\n", "Improving Linear Search Technique -  ": ["# Python3 program for transposition to\n# improve the Linear Search Algorithm\n \n \n# Structure of the array\nclass Array :\n    def __init__(self,a=[0]*10,size=10,l=0) -> None:\n        self.A=a\n        self.size=size\n        self.length=l\n \n# Function to print array element\ndef Display(arr):\n \n    # Traverse the array arr[]\n    for i in range(arr.length) :\n        print(arr.A[i],end=' ')\n     \n    print()\n \n \n# Function that performs the Linear\n# Search Transposition\ndef LinearSearchTransposition(arr, key):\n \n    # Traverse the array\n    for i in range(arr.length) :\n \n        # If key is found, then swap\n        # the element with it's\n        # previous index\n        if (key == arr.A[i]) :\n \n            # If key is first element\n            if (i == 0):\n                return i\n \n            arr.A[i],arr.A[i - 1]=arr.A[i - 1],arr.A[i]\n \n            return i\n         \n     \n    return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n    # Given array arr[]\n    arr=Array([2, 23, 14, 5, 6, 9, 8, 12], 10, 8) \n \n    print('Elements before Linear Search Transposition: ')\n \n    # Function Call for displaying\n    # the array arr[]\n    Display(arr)\n \n    # Function Call for transposition\n    LinearSearchTransposition(arr, 14)\n \n    print('Elements after Linear Search Transposition: ')\n \n    # Function Call for displaying\n    # the array arr[]\n    Display(arr)\n", "# Python3 program for transposition to\n# improve the Linear Search Algorithm\n \n \n# Structure of the array\nclass Array :\n    def __init__(self,a=[0]*10,size=10,l=0) -> None:\n        self.A=a\n        self.size=size\n        self.length=l\n \n# Function to print array element\ndef Display(arr):\n \n    # Traverse the array arr[]\n    for i in range(arr.length) :\n        print(arr.A[i],end=' ')\n     \n    print()\n \n \n# Function that performs the move to\n# front operation for Linear Search\ndef LinearSearchMoveToFront(arr, key:int):\n \n    # Traverse the array\n    for i in range(arr.length) :\n \n        # If key is found, then swap\n        # the element with 0-th index\n        if (key == arr.A[i]) :\n            arr.A[i], arr.A[0]=arr.A[0],arr.A[i]\n            return i\n         \n     \n    return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n    # Given array arr[]\n    arr=Array([2, 23, 14, 5, 6, 9, 8, 12], 10, 8) \n \n    print('Elements before Linear Search Transposition: ',end='')\n \n    # Function Call for displaying\n    # the array arr[]\n    Display(arr)\n \n    # Function Call for transposition\n    LinearSearchMoveToFront(arr, 14)\n \n    print('Elements after Linear Search Transposition: ',end='')\n \n    # Function Call for displaying\n    # the array arr[]\n    Display(arr)\n", "from typing import List\n \ndef linear_search_with_hash_table(arr: List[int], target: int) -> int:\n    # Create a hash table to map each element to its position\n    hash_table = {}\n    for i in range(len(arr)):\n        hash_table[arr[i]] = i\n \n    # Search for the target element in the hash table\n    if target in hash_table:\n        return hash_table[target]\n    else:\n        return -1\n \n# Main function\nif __name__ == '__main__':\n    arr = [1, 5, 3, 9, 2, 7]\n    target = 9\n \n    index = linear_search_with_hash_table(arr, target)\n    if index != -1:\n        print('Found', target, 'at index', index)\n    else:\n        print(target, 'not found in the list')\n"], "Interactive Problems in Competitive Programming -  ": ["if __name__=='__main__':\n    lower_bound = 2; \n    upper_bound = 10; \n \n    # Number to be guessed is 6 \n \n    # Iterating from lower_bound to upper_bound \n    for i in range(lower_bound, upper_bound + 1):\n        print(i)\n \n        # Input the response from the judge \n        response = int(input())\n \n        if (response == 0):\n            print('Number guessed is :', i, end = '') \n            break; \n \n            # This code is contributed by rutvik_56\n", "lower_bound = 2\nupper_bound = 10\n \n# Number to be guessed is 9\n \n# Applying Binary Search interactively\nwhile (lower_bound <= upper_bound) :\n    mid = (lower_bound + upper_bound) // 2\n \n    # Print guessed number\n    print(mid)\n \n    # Input the response from the judge\n    response = int(input())\n \n    if (response == -1) :\n        lower_bound = mid + 1\n     \n    elif (response == 1) :\n        upper_bound = mid - 1\n     \n    elif (response == 0) :\n        print('Number guessed is :', mid)\n        break\n"], "Longest alternating subsequence -  ": ["# Python3 program to find longest\n# alternating subsequence in an array\n \n# Function to return max of two numbers\n \n \ndef Max(a, b):\n \n    if a > b:\n        return a\n    else:\n        return b\n \n# Function to return longest alternating\n# subsequence length\n \n \ndef zzis(arr, n):\n    '''las[i][0] = Length of the longest \n        alternating subsequence ending at\n        index i and last element is greater\n        than its previous element\n    las[i][1] = Length of the longest \n        alternating subsequence ending \n        at index i and last element is\n        smaller than its previous element'''\n    las = [[0 for i in range(2)]\n           for j in range(n)]\n \n    # Initialize all values from 1\n    for i in range(n):\n        las[i][0], las[i][1] = 1, 1\n \n    # Initialize result\n    res = 1\n \n    # Compute values in bottom up manner\n    for i in range(1, n):\n \n        # Consider all elements as\n        # previous of arr[i]\n        for j in range(0, i):\n \n            # If arr[i] is greater, then\n            # check with las[j][1]\n            if (arr[j] < arr[i] and\n                    las[i][0] < las[j][1] + 1):\n                las[i][0] = las[j][1] + 1\n \n            # If arr[i] is smaller, then\n            # check with las[j][0]\n            if(arr[j] > arr[i] and\n               las[i][1] < las[j][0] + 1):\n                las[i][1] = las[j][0] + 1\n \n        # Pick maximum of both values at index i\n        if (res < max(las[i][0], las[i][1])):\n            res = max(las[i][0], las[i][1])\n \n    return res\n \n \n# Driver Code\narr = [10, 22, 9, 33, 49, 50, 31, 60]\nn = len(arr)\n \nprint('Length of Longest alternating subsequence is',\n      zzis(arr, n))\n \n# This code is contributed by divyesh072019\n", "# Python3 program for above approach\ndef LAS(arr, n):\n \n    # 'inc' and 'dec' initialized as 1\n    # as single element is still LAS\n    inc = 1\n    dec = 1\n \n    # Iterate from second element\n    for i in range(1, n):\n \n        if (arr[i] > arr[i-1]):\n \n            # 'inc' changes if 'dec'\n            # changes\n            inc = dec + 1\n        elif (arr[i] < arr[i-1]):\n \n            # 'dec' changes if 'inc'\n            # changes\n            dec = inc + 1\n \n    # Return the maximum length\n    return max(inc, dec)\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [10, 22, 9, 33, 49, 50, 31, 60]\n    n = len(arr)\n \n    # Function Call\n    print(LAS(arr, n))\n"], "Count number of coins required to make a given value (Coin Change II) -  ": ["# Recursive Python3 program for\n# coin change problem.\n \n# Returns the count of ways we can sum\n# coins[0...n-1] coins to get sum 'sum'\n \n \ndef count(coins, n, sum):\n \n    # If sum is 0 then there is 1\n    # solution (do not include any coin)\n    if (sum == 0):\n        return 1\n \n    # If sum is less than 0 then no\n    # solution exists\n    if (sum < 0):\n        return 0\n \n    # If there are no coins and sum\n    # is greater than 0, then no\n    # solution exist\n    if (n <= 0):\n        return 0\n \n    # count is sum of solutions (i)\n    # including coins[n-1] (ii) excluding coins[n-1]\n    return count(coins, n - 1, sum) + count(coins, n, sum-coins[n-1])\n \n \n# Driver program to test above function\ncoins = [1, 2, 3]\nn = len(coins)\nprint(count(coins, n, 5))\n \n# This code is contributed by Smitha Dinesh Semwal\n", "# Python program for the above approach\n \n# Recursive function to count the numeber of distinct ways\n# to make the sum by using n coins\n \n \ndef count(coins, sum, n, dp):\n  # Base Case\n    if (sum == 0):\n        dp[n][sum] = 1\n        return dp[n][sum]\n \n     # If number of coins is 0 or sum is less than 0 then there is no way to make the sum.\n    if (n == 0 or sum < 0):\n        return 0\n \n     # If the subproblem is previously calculated then simply return the result\n    if (dp[n][sum] != -1):\n        return dp[n][sum]\n \n      # Two options for the current coin\n \n    dp[n][sum] = count(coins, sum - coins[n - 1], n, dp) + \\\n        count(coins, sum, n - 1, dp)\n \n    return dp[n][sum]\n \n \n# Driver code\nif __name__ == '__main__':\n    tc = 1\n    while (tc != 0):\n        n = 3\n        sum = 5\n        coins = [1, 2, 3]\n        dp = [[-1 for i in range(sum+1)] for j in range(n+1)]\n        res = count(coins, sum, n, dp)\n        print(res)\n        tc -= 1\n", "# Function to calculate the total distinct ways to make a sum using n coins of different denominations\ndef count(coins, n, target_sum):\n    # 2D dp array where n is the number of coin denominations and target_sum is the target sum\n    dp = [[0 for j in range(target_sum + 1)] for i in range(n + 1)]\n \n    # Represents the base case where the target sum is 0, and there is only one way to make change: by not selecting any coin\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            # Add the number of ways to make change without using the current coin\n            dp[i][j] += dp[i - 1][j]\n \n            if j - coins[i - 1] >= 0:\n                # Add the number of ways to make change using the current coin\n                dp[i][j] += dp[i][j - coins[i - 1]]\n \n    return dp[n][target_sum]\n \n# Driver Code\nif __name__ == '__main__':\n    coins = [1, 2, 3]\n    n = 3\n    target_sum = 5\n    print(count(coins, n, target_sum))\n"], "Find the smallest positive integer value that cannot be represented as sum of any subset of a given array -  ": ["# Python3 program to find the smallest\n# positive value that cannot be\n# represented as sum of subsets \n# of a given sorted array\n \n# Returns the smallest number \n# that cannot be represented as sum\n# of subset of elements from set\n# represented by sorted array arr[0..n-1]\ndef findSmallest(arr, n):\n \n    res = 1 #Initialize result\n \n    # Traverse the array and increment\n    # 'res' if arr[i] is smaller than\n    # or equal to 'res'.\n    for i in range (0, n ):\n        if arr[i] <= res:\n            res = res + arr[i]\n        else:\n            break\n    return res\n \n \n# Driver program to test above function\narr1 = [1, 3, 4, 5]\nn1 = len(arr1)\nprint(findSmallest(arr1, n1))\n \narr2= [1, 2, 6, 10, 11, 15]\nn2 = len(arr2)\nprint(findSmallest(arr2, n2))\n \narr3= [1, 1, 1, 1]\nn3 = len(arr3)\nprint(findSmallest(arr3, n3))\n \narr4 = [1, 1, 3, 4]\nn4 = len(arr4)\nprint(findSmallest(arr4, n4))\n \n# This code is.contributed by Smitha Dinesh Semwal\n", "def smallest_positive_integer(arr):\n    n = len(arr)\n    s = sum(arr)\n    dp = [False]*(s+1)\n    dp[0] = True\n    for i in range(n):\n        for j in range(s, arr[i]-1, -1):\n            if dp[j-arr[i]]:\n                dp[j] = True\n    for i in range(1, s+1):\n        if not dp[i]:\n            return i\n    return s+1\n \narr=[1, 3, 4, 5]\nprint(smallest_positive_integer(arr))\narr=[1, 2, 6, 10, 11, 15]\nprint(smallest_positive_integer(arr))\narr=[1, 1, 1, 1]\nprint(smallest_positive_integer(arr))\narr=[1,1,3,4]\nprint(smallest_positive_integer(arr))\n"], "Partition problem | DP-18 -  ": ["# A recursive Python3 program for\n# partition problem\n \n# A utility function that returns\n# true if there is a subset of\n# arr[] with sum equal to given sum\n \n \ndef isSubsetSum(arr, n, sum):\n    # Base Cases\n    if sum == 0:\n        return True\n    if n == 0 and sum != 0:\n        return False\n \n    # If last element is greater than sum, then\n    # ignore it\n    if arr[n-1] > sum:\n        return isSubsetSum(arr, n-1, sum)\n \n    ''' else, check if sum can be obtained by any of \n    the following\n    (a) including the last element\n    (b) excluding the last element'''\n \n    return isSubsetSum(arr, n-1, sum) or isSubsetSum(arr, n-1, sum-arr[n-1])\n \n# Returns true if arr[] can be partitioned in two\n# subsets of equal sum, otherwise false\n \n \ndef findPartion(arr, n):\n    # Calculate sum of the elements in array\n    sum = 0\n    for i in range(0, n):\n        sum += arr[i]\n    # If sum is odd, there cannot be two subsets\n    # with equal sum\n    if sum % 2 != 0:\n        return false\n \n    # Find if there is subset with sum equal to\n    # half of total sum\n    return isSubsetSum(arr, n, sum // 2)\n \n \n# Driver code\nif __name__ == '__main__':\n  arr = [3, 1, 5, 9, 12]\n  n = len(arr)\n \n  # Function call\n  if findPartion(arr, n) == True:\n      print('Can be divided into two subsets of equal sum')\n  else:\n      print('Can not be divided into two subsets of equal sum')\n \n# This code is contributed by shreyanshi_arun.\n", "# A recursive JavaScript program for partition problem\n \n# A utility function that returns true if there is\n# a subset of arr[] with sun equal to given sum\n \n \ndef isSubsetSum(arr, n, sum, dp):\n \n    # Base Cases\n    if (sum == 0):\n        return True\n    if (n == 0 and sum != 0):\n        return False\n \n    # return solved subproblem\n    if (dp[n][sum] != -1):\n        return dp[n][sum]\n \n    # If last element is greater than sum, then\n    # ignore it\n    if (arr[n - 1] > sum):\n        return isSubsetSum(arr, n - 1, sum, dp)\n \n        # else, check if sum can be obtained by any of\n        # the following\n        # (a) including the last element\n        # (b) excluding the last element\n \n    # also store the subproblem in dp matrix\n    dp[n][sum] = isSubsetSum(\n        arr, n - 1, sum, dp) or isSubsetSum(arr, n - 1, sum - arr[n - 1], dp)\n \n    return dp[n][sum]\n \n# Returns true if arr[] can be partitioned in two\n# subsets of equal sum, otherwise false\n \n \ndef findPartiion(arr, n):\n \n    # Calculate sum of the elements in array\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n \n    # If sum is odd, there cannot be two subsets\n    # with equal sum\n    if (sum % 2 != 0):\n        return False\n \n    # To store overlapping subproblems\n    dp = [[-1]*(sum+1) for i in range(n+1)]\n \n    # Find if there is subset with sum equal to\n    # half of total sum\n    return isSubsetSum(arr, n, sum // 2, dp)\n \n# Driver code\n \n \narr = [3, 1, 5, 9, 12]\nn = len(arr)\n \n# Function call\nif (findPartiion(arr, n) == True):\n    print('Can be divided into two subsets of equal sum')\nelse:\n    print('Can not be divided into two subsets of equal sum')\n \narr2 = [3, 1, 5, 9, 14]\nn2 = len(arr2)\n \nif (findPartiion(arr2, n2) == True):\n    print('Can be divided into two subsets of equal sum')\nelse:\n    print('Can not be divided into two subsets of equal sum')\n \n# This code is contributed by shinjanpatra.\n", "# Dynamic Programming based python\n# program to partition problem\n \n# Returns true if arr[] can be\n# partitioned in two subsets of\n# equal sum, otherwise false\n \n \ndef findPartition(arr, n):\n    sum = 0\n    i, j = 0, 0\n \n    # calculate sum of all elements\n    for i in range(n):\n        sum += arr[i]\n \n    if sum % 2 != 0:\n        return false\n \n    part = [[True for i in range(n + 1)]\n            for j in range(sum // 2 + 1)]\n \n    # initialize top row as true\n    for i in range(0, n + 1):\n        part[0][i] = True\n \n    # initialize leftmost column,\n    # except part[0][0], as 0\n    for i in range(1, sum // 2 + 1):\n        part[i][0] = False\n \n    # fill the partition table in\n    # bottom up manner\n    for i in range(1, sum // 2 + 1):\n \n        for j in range(1, n + 1):\n            part[i][j] = part[i][j - 1]\n \n            if i >= arr[j - 1]:\n                part[i][j] = (part[i][j] or\n                              part[i - arr[j - 1]][j - 1])\n \n    return part[sum // 2][n]\n \n \n# Driver Code\narr = [3, 1, 1, 2, 2, 1]\nn = len(arr)\n \n# Function call\nif findPartition(arr, n) == True:\n    print('Can be divided into two',\n          'subsets of equal sum')\nelse:\n    print('Can not be divided into ',\n          'two subsets of equal sum')\n \n# This code is contributed\n# by mohit kumar 29\n", "# A Dynamic Programming based\n# Python3 program to partition problem\n \n# Returns true if arr[] can be partitioned\n# in two subsets of equal sum, otherwise false\n \n \ndef findPartiion(arr, n):\n    Sum = 0\n \n    # Calculate sum of all elements\n    for i in range(n):\n        Sum += arr[i]\n    if (Sum % 2 != 0):\n        return 0\n    part = [0] * ((Sum // 2) + 1)\n \n    # Initialize the part array as 0\n    for i in range((Sum // 2) + 1):\n        part[i] = 0\n \n    # Fill the partition table in bottom up manner\n    for i in range(n):\n \n        # the element to be included\n        # in the sum cannot be\n        # greater than the sum\n        for j in range(Sum // 2, arr[i] - 1, -1):\n \n            # check if sum - arr[i]\n            # could be formed\n            # from a subset\n            # using elements\n            # before index i\n            if (part[j - arr[i]] == 1 or j == arr[i]):\n                part[j] = 1\n \n    return part[Sum // 2]\n \n \n# Driver code\narr = [1, 3, 3, 2, 3, 2]\nn = len(arr)\n \n# Function call\nif (findPartiion(arr, n) == 1):\n    print('Can be divided into two subsets of equal sum')\nelse:\n    print('Can not be divided into two subsets of equal sum')\n \n    # This code is contributed by divyeshrabadiya07\n"], "Given a sorted array and a number x, find the pair in array whose sum is closest to x -  ": ["# Python3 program to find the pair \n# with sum \n# closest to a given no. \n  \nimport sys \n  \n# Prints the pair with sum closest to x \n  \ndef printClosest(arr, n, x): \n    res_l = res_r = 0    # To store indexes of result pair \n    temp = sys.maxsize    # variable to store current minimum difference     \n  \n    for i in range(n-1): \n        for j in range(i+1, n): \n              # if found more closest pair \n            if abs(arr[i] + arr[j] - x) < temp: \n                res_l = i \n                res_r = j \n                temp = abs(arr[i] + arr[j] - x) \n      \n    print('The closest pair is', arr[res_l], 'and', arr[res_r]) \n  \n#driver code \narr = [10, 22, 28, 29, 30, 40] \nx = 54\nn = len(arr) \nprintClosest(arr, n, x) \n", "# Python program to find the pair with sum closest \n# to a given no using above approach. \nimport sys \n  \n# Function to prints the pair with sum closest to x \ndef closestPair(arr, n, x): \n    \n    # Initialize variables pointing to the \n    # first and last elements of the array \n    l, r = 0, n - 1\n  \n    # To store indexes of result pair \n    res_l, res_r = 0, 0\n  \n    # variable to store current minimum difference \n    minDiff = sys.maxsize \n  \n    # Iterate over the array using \n    for i in range(n): \n        e = arr[i] \n  \n        # Use binary search to find the element \n        # 'elem' in the array such that 'e+elem' \n        # is closest to 'x'. \n        left, right = i + 1, n - 1\n        while left <= right: \n            mid = (left + right) // 2\n  \n            if arr[mid] + e == x: \n                res_l = i \n                res_r = mid \n                minDiff = 0\n                break\n  \n            # Check if this pair is closer than the \n            # closest pair so far \n            if abs(arr[mid] + e - x) < minDiff: \n                minDiff = abs(arr[mid] + e - x) \n                res_l = i \n                res_r = mid \n  \n            if arr[mid] + e < x: \n                left = mid + 1\n            else: \n                right = mid - 1\n  \n    # Print the pair \n    print('The closest pair is', arr[res_l], 'and', arr[res_r]) \n  \n  \n# Driver program to test above functions \narr = [10, 22, 28, 29, 30, 40] \nx = 54\nn = len(arr) \n  \n# Function Call \nclosestPair(arr, n, x) \n  \n# This Code is Contributed by prasad264\n", "# Python3 program to find the pair \n# with sum  \n# closest to a given no. \n  \n# A sufficiently large value greater \n# than any  \n# element in the input array \nMAX_VAL = 1000000000\n  \n  \n#Prints the pair with sum closest to x \n  \ndef printClosest(arr, n, x): \n      \n    # To store indexes of result pair \n    res_l, res_r = 0, 0\n      \n    #Initialize left and right indexes \n    # and difference between \n    # pair sum and x \n    l, r, diff = 0, n-1, MAX_VAL \n      \n    # While there are elements between l and r \n    while r > l: \n        # Check if this pair is closer than the  \n        # closest pair so far \n        if abs(arr[l] + arr[r] - x) < diff: \n            res_l = l \n            res_r = r \n            diff = abs(arr[l] + arr[r] - x) \n      \n        if arr[l] + arr[r] > x: \n        # If this pair has more sum, move to  \n        # smaller values. \n            r -= 1\n        else: \n        # Move to larger values \n            l += 1\n          \n    print('The closest pair is {} and {}'\n         .format(arr[res_l], arr[res_r])) \n  \n  \n# Driver code to test above \nif __name__ == '__main__': \n    arr = [10, 22, 28, 29, 30, 40] \n    n = len(arr) \n    x=54\n    printClosest(arr, n, x) \n  \n# This code is contributed by Tuhin Patra \n"], "Find the missing and repeating number -  ": ["def printTwoElements(arr):\n    n = len(arr)\n    temp = [0] * n  # Creating temp array of size n with initial values as 0.\n    repeatingNumber = -1\n    missingNumber = -1\n \n    for i in range(n):\n        temp[arr[i] - 1] += 1\n        if temp[arr[i] - 1] > 1:\n            repeatingNumber = arr[i]\n    for i in range(n):\n        if temp[i] == 0:\n            missingNumber = i + 1\n            break\n \n    print('The repeating number is', repeatingNumber, '.')\n    print('The missing number is', missingNumber, '.')\n \n \narr = [7, 3, 4, 5, 5, 6, 2]\nprintTwoElements(arr)\n \n# This code is contributed by vivek1208\n", "# Python3 code to Find the repeating \n# and the missing elements\n \ndef printTwoElements( arr, size):\n    for i in range(size):\n        if arr[abs(arr[i])-1] > 0:\n            arr[abs(arr[i])-1] = -arr[abs(arr[i])-1]\n        else:\n            print('The repeating element is ', abs(arr[i]))\n             \n    for i in range(size):\n        if arr[i]>0:\n            print('and the missing element is ', i + 1)\n \n# Driver program to test above function */\narr = [7, 3, 4, 5, 5, 6, 2]\nn = len(arr)\nprintTwoElements(arr, n)\n \n# This code is contributed by 'Abhishek Sharma 44'\n", "# Python3 program to find the repeating \n# and missing elements \n \n# The output of this function is stored \n# at x and y \ndef getTwoElements(arr, n):\n     \n    global x, y\n    x = 0\n    y = 0\n     \n    # Will hold xor of all elements \n    # and numbers from 1 to n \n    xor1 = arr[0]\n     \n    # Get the xor of all array elements\n    for i in range(1, n):\n        xor1 = xor1 ^ arr[i]\n         \n    # XOR the previous result with numbers \n    # from 1 to n\n    for i in range(1, n + 1):\n        xor1 = xor1 ^ i\n     \n    # Will have only single set bit of xor1\n    set_bit_no = xor1 & ~(xor1 - 1)\n     \n    # Now divide elements into two \n    # sets by comparing a rightmost set \n    # bit of xor1 with the bit at the same \n    # position in each element. Also, \n    # get XORs of two sets. The two \n    # XORs are the output elements. \n    # The following two for loops \n    # serve the purpose\n    for i in range(n):\n        if (arr[i] & set_bit_no) != 0:\n             \n            # arr[i] belongs to first set\n            x = x ^ arr[i]\n        else:\n             \n            # arr[i] belongs to second set\n            y = y ^ arr[i]\n             \n    for i in range(1, n + 1):\n        if (i & set_bit_no) != 0:\n             \n            # i belongs to first set\n            x = x ^ i\n        else:\n             \n            # i belongs to second set\n            y = y ^ i \n         \n    # x and y hold the desired \n    # output elements \n     \n# Driver code\narr = [ 1, 3, 4, 5, 5, 6, 2 ]\nn = len(arr)\n     \ngetTwoElements(arr, n)\n \nprint('The missing element is', x,\n      'and the repeating number is', y)\n     \n# This code is contributed by stutipathak31jan\n", "# Python3 program to find the \n# repeating and missing elements \n# using Maps\ndef main():\n     \n    arr = [ 4, 3, 6, 2, 1, 1 ]\n     \n    numberMap = {}\n     \n    max = len(arr)\n    for i in arr:\n        if not i in numberMap:\n            numberMap[i] = True\n             \n        else:\n            print('Repeating =', i)\n     \n    for i in range(1, max + 1):\n        if not i in numberMap:\n            print('Missing =', i)\nmain()\n \n# This code is contributed by stutipathak31jan\n", "def repeatedNumber(A):\n     \n    length = len(A)\n    Sum_N = (length * (length + 1)) // 2\n    Sum_NSq = ((length * (length + 1) *\n                     (2 * length + 1)) // 6)\n     \n    missingNumber, repeating = 0, 0\n     \n    for i in range(len(A)):\n        Sum_N -= A[i]\n        Sum_NSq -= A[i] * A[i]\n         \n    missingNumber = (Sum_N + Sum_NSq //\n                             Sum_N) // 2\n    repeating = missingNumber - Sum_N\n     \n    ans = []\n    ans.append(repeating)\n    ans.append(missingNumber)\n     \n    return ans\n \n# Driver code\nv = [ 4, 3, 6, 2, 1, 6, 7 ]\nres = repeatedNumber(v)\n \nfor i in res:\n    print(i, end = ' ')\n \n# This code is contributed by stutipathak31jan \n"], "Maximum Sum Path in Two Arrays -  ": ["# Python program to find maximum sum path \n  \n# This function returns the sum of elements on maximum path from \n# beginning to end \n  \n  \ndef maxPathSum(ar1, ar2, m, n): \n  \n    # initialize indexes for ar1[] and ar2[] \n    i, j = 0, 0\n  \n    # Initialize result and current sum through ar1[] and ar2[] \n    result, sum1, sum2 = 0, 0, 0\n  \n    # Below 3 loops are similar to merge in merge sort \n    while (i < m and j < n): \n  \n        # Add elements of ar1[] to sum1 \n        if ar1[i] < ar2[j]: \n            sum1 += ar1[i] \n            i += 1\n  \n        # Add elements of ar2[] to sum2 \n        elif ar1[i] > ar2[j]: \n            sum2 += ar2[j] \n            j += 1\n  \n        else:   # we reached a common point \n  \n            # Take the maximum of two sums and add to result \n            result += max(sum1, sum2) + ar1[i] \n            # update sum1 and sum2 to be considered fresh for next elements \n            sum1 = 0\n            sum2 = 0\n            # update i and j to move to next element in each array \n            i += 1\n            j += 1\n  \n    # Add remaining elements of ar1[] \n    while i < m: \n        sum1 += ar1[i] \n        i += 1\n    # Add remaining elements of b[] \n    while j < n: \n        sum2 += ar2[j] \n        j += 1\n  \n    # Add maximum of two sums of remaining elements \n    result += max(sum1, sum2) \n  \n    return result \n  \n  \n# Driver code \nar1 = [2, 3, 7, 10, 12, 15, 30, 34] \nar2 = [1, 5, 7, 8, 10, 15, 16, 19] \nm = len(ar1) \nn = len(ar2) \n  \n# Function call \nprint('Maximum sum path is', maxPathSum(ar1, ar2, m, n)) \n  \n# This code is contributed by __Devesh Agrawal__ \n"], "Given an array arr[], find the maximum j - i such that arr[i]": ["# Python3 program to find the maximum\n# j \u2013 i such that arr[j] > arr[i]\n \n# For a given array arr[], returns\n# the maximum j \u2013 i such that\n# arr[j] > arr[i]\n \n \ndef maxIndexDiff(arr, n):\n    maxDiff = -1\n    for i in range(0, n):\n        j = n - 1\n        while(j > i):\n            if arr[j] > arr[i] and maxDiff < (j - i):\n                maxDiff = j - i\n            j -= 1\n \n    return maxDiff\n \n \n# driver code\narr = [9, 2, 3, 4, 5, 6, 7, 8, 18, 0]\nn = len(arr)\nmaxDiff = maxIndexDiff(arr, n)\nprint(maxDiff)\n \n# This article is contributed by Smitha Dinesh Semwal\n", "# Python3 program to implement\n# the above approach\n \n# For a given array arr, \n# calculates the maximum j \u2013 i \n# such that arr[j] > arr[i] \n \n# Driver code\nif __name__ == '__main__':\n   \n    v = [34, 8, 10, 3, \n         2, 80, 30, 33, 1];\n    n = len(v);\n    maxFromEnd = [-38749432] * (n + 1);\n \n    # Create an array maxfromEnd\n    for i in range(n - 1, 0, -1):\n        maxFromEnd[i] = max(maxFromEnd[i + 1], \n                            v[i]);\n \n    result = 0;\n \n    for i in range(0, n):\n        low = i + 1; high = n - 1; ans = i;\n \n        while (low <= high):\n            mid = int((low + high) / 2);\n \n            if (v[i] <= maxFromEnd[mid]):\n               \n                # We store this as current\n                # answer and look for further\n                # larger number to the right side\n                ans = max(ans, mid);\n                low = mid + 1;\n            else:\n                high = mid - 1;        \n \n        # Keeping a track of the\n        # maximum difference in indices\n        result = max(result, ans - i);\n     \n    print(result, end = '');\n     \n# This code is contributed by Rajput-Ji\n", "# Python3 implementation of the above approach\nn = 9\na = [34, 8, 10, 3, 2, 80, 30, 33, 1]\n \n# To store the index of an element.\nindex = dict() \nfor i in range(n):\n    if a[i] in index:\n \n        # append to list (for duplicates)\n        index[a[i]].append(i)  \n    else:\n \n        # if first occurrence\n        index[a[i]] = [i]   \n \n# sort the input array\na.sort()     \nmaxDiff = 0\n \n# Temporary variable to keep track of minimum i\ntemp = n     \nfor i in range(n):\n    if temp > index[a[i]][0]:\n        temp = index[a[i]][0]\n    maxDiff = max(maxDiff, index[a[i]][-1]-temp)\n \nprint(maxDiff)\n", "# Utility Functions to get max\n# and minimum of two integers \ndef max(a, b):\n    if(a > b):\n        return a\n    else:\n        return b\n \ndef min(a, b):\n    if(a < b):\n        return a\n    else:\n        return b\n \n# For a given array arr[], \n# returns the maximum j - i\n# such that arr[j] > arr[i]\ndef maxIndexDiff(arr, n):\n    maxDiff = 0;\n    LMin = [0] * n\n    RMax = [0] * n\n \n    # Construct LMin[] such that \n    # LMin[i] stores the minimum \n    # value from (arr[0], arr[1], \n    # ... arr[i]) \n    LMin[0] = arr[0]\n    for i in range(1, n):\n        LMin[i] = min(arr[i], LMin[i - 1])\n \n    # Construct RMax[] such that \n    # RMax[j] stores the maximum \n    # value from (arr[j], arr[j + 1],\n    # ..arr[n-1]) \n    RMax[n - 1] = arr[n - 1]\n    for j in range(n - 2, -1, -1):\n        RMax[j] = max(arr[j], RMax[j + 1]);\n \n    # Traverse both arrays from left\n    # to right to find optimum j - i\n    # This process is similar to\n    # merge() of MergeSort\n    i, j = 0, 0\n    maxDiff = -1\n    while (j < n and i < n):\n        if (LMin[i] <= RMax[j]):\n            maxDiff = max(maxDiff, j - i)\n            j = j + 1\n        else:\n            i = i + 1\n \n    return maxDiff\n \n# Driver Code\nif(__name__ == '__main__'):\n    arr = [9, 2, 3, 4, 5, \n           6, 7, 8, 18, 0]\n    n = len(arr)\n    maxDiff = maxIndexDiff(arr, n)\n    print (maxDiff)\n \n# This code is contributed \n# by gautam karakoti\n", "# For a given array arr[], returns the \n# maximum j \u2013 i such that arr[j] > arr[i] \ndef maxIndexDiff(arr, n):\n     \n    rightMax = [0] * n\n    rightMax[n - 1] = arr[n - 1]\n    for i in range(n - 2, -1, -1):\n        rightMax[i] = max(rightMax[i + 1], arr[i])\n         \n    # rightMax[i] = max arr[i...(n-1] \n    maxDist = -2**31\n    i = 0\n    j = 0\n     \n    while (i < n and j < n):\n        if (rightMax[j] >= arr[i]):\n            maxDist = max(maxDist, j - i)\n            j += 1\n             \n        else:\n             \n            # if(rightMax[j] < leftMin[i]) \n            i += 1\n     \n    return maxDist\n \n# Driver Code\narr = [ 34, 8, 10, 3, 2, 80, 30, 33, 1 ]\nn = len(arr)\nmaxDiff = maxIndexDiff(arr, n)\n \nprint(maxDiff)\n \n# This code is contributed by Shubham Singh\n", "# For a given array arr[],  \n#   returns the maximum j \u2013 i such that\n#   arr[j] > arr[i] */\ndef maxIndexDiff(arr, n):\n     \n    leftMin = [0]*n\n    leftMin[0] = arr[0]\n    for i in range(1,n):\n        leftMin[i] = min(leftMin[i-1], arr[i])\n         \n    # leftMin[i] = min arr[0...i]  \n    maxDist = - 2**32\n    i = n-1\n    j = n-1\n     \n    while(i>=0  and  j>=0):\n         \n        if(arr[j] >= leftMin[i]):\n            maxDist = max(maxDist, j-i)\n            i-=1\n        else:\n            j-=1\n             \n    return maxDist\n \n# Driver Code\narr = [34,8,10,3,2,80,30,33,1]\nn = len(arr)\nmaxDiff = maxIndexDiff(arr, n)\nprint(maxDiff)\n \n# This code is contributed by Shubham Singh\n", "def maxIndexDiff( A, N) :\n    stkForIndex = list();\n     \n    # loop for storing index in stack whose value appears in decreasing order\n    for i in range(0, N):           \n        if(len(stkForIndex) == 0 or A[stkForIndex[-1]] > A[i]):\n            stkForIndex.append(i);\n \n    maxDiffSoFar = 0;\n    tempdiff=-1;\n     \n    # Now we traverse from right to left.\n    i = N-1;\n    while(i >= 0):\n         \n        # This will compare top value of array at index stack top.\n        # if it satisfy our condition we check the difference  and update out result.\n        # else we decrement our counter\n        if(len(stkForIndex) and A[stkForIndex[-1]] <= A[i]):\n            tempdiff = i - stkForIndex.pop();\n            if(tempdiff > maxDiffSoFar):\n                maxDiffSoFar  = tempdiff;\n            continue;\n        i -= 1;\n    return maxDiffSoFar; \n     \nA = [34,8,10,3,2,80,30,33,1];        \nN = len(A);\nprint('Max diff be :' , maxIndexDiff(A, N));\n \n# This code is contributed by ratiagrawal.\n"], "Implement two Stacks in an Array -  ": ["# Python Script to Implement two stacks in a list \nimport math \n  \n  \nclass twoStacks: \n  \n    def __init__(self, n):     # constructor \n        self.size = n \n        self.arr = [None] * n \n        self.top1 = math.floor(n/2) + 1\n        self.top2 = math.floor(n/2) \n  \n    # Method to push an element x to stack1 \n  \n    def push1(self, x): \n  \n        # There is at least one empty space for new element \n        if self.top1 > 0: \n            self.top1 = self.top1 - 1\n            self.arr[self.top1] = x \n        else: \n            print('Stack Overflow by element : ', x) \n  \n    # Method to push an element x to stack2 \n  \n    def push2(self, x): \n  \n        # There is at least one empty space for new element \n        if self.top2 < self.size - 1: \n            self.top2 = self.top2 + 1\n            self.arr[self.top2] = x \n        else: \n            print('Stack Overflow by element : ', x) \n  \n    # Method to pop an element from first stack \n  \n    def pop1(self): \n        if self.top1 <= self.size/2: \n            x = self.arr[self.top1] \n            self.top1 = self.top1 + 1\n            return x \n        else: \n            print('Stack Underflow') \n            exit(1) \n  \n    # Method to pop an element from second stack \n  \n    def pop2(self): \n        if self.top2 >= math.floor(self.size/2) + 1: \n            x = self.arr[self.top2] \n            self.top2 = self.top2 - 1\n            return x \n        else: \n            print('Stack Underflow') \n            exit(1) \n  \n  \n# Driver program to test twoStacks class \nif __name__ == '__main__': \n    ts = twoStacks(5) \n    ts.push1(5) \n    ts.push2(10) \n    ts.push2(15) \n    ts.push1(11) \n    ts.push2(7) \n      \n    print('Popped element from stack1 is : ' + str(ts.pop1())) \n    ts.push2(40) \n    print('Popped element from stack2 is : ' + str(ts.pop2())) \n  \n# This code is contributed by Gautam goel \n"], "Print a given matrix in spiral form -  ": ["# python3 program for the above approach\n \n \ndef spiralOrder(matrix):\n    ans = []\n \n    if (len(matrix) == 0):\n        return ans\n \n    m = len(matrix)\n    n = len(matrix[0])\n    seen = [[0 for i in range(n)] for j in range(m)]\n    dr = [0, 1, 0, -1]\n    dc = [1, 0, -1, 0]\n    x = 0\n    y = 0\n    di = 0\n \n    # Iterate from 0 to R * C - 1\n    for i in range(m * n):\n        ans.append(matrix[x][y])\n        seen[x][y] = True\n        cr = x + dr[di]\n        cc = y + dc[di]\n \n        if (0 <= cr and cr < m and 0 <= cc and cc < n and not(seen[cr][cc])):\n            x = cr\n            y = cc\n        else:\n            di = (di + 1) % 4\n            x += dr[di]\n            y += dc[di]\n    return ans\n \n \n# Driver code\nif __name__ == '__main__':\n    a = [[1, 2, 3, 4],\n         [5, 6, 7, 8],\n         [9, 10, 11, 12],\n         [13, 14, 15, 16]]\n \n    # Function call\n    for x in spiralOrder(a):\n        print(x, end=' ')\n    print()\n", "# Python3 program to print\n# given matrix in spiral form\n \n \ndef spiralPrint(m, n, a):\n    k = 0\n    l = 0\n \n    ''' k - starting row index\n        m - ending row index\n        l - starting column index\n        n - ending column index\n        i - iterator '''\n \n    while (k < m and l < n):\n \n        # Print the first row from\n        # the remaining rows\n        for i in range(l, n):\n            print(a[k][i], end=' ')\n \n        k += 1\n \n        # Print the last column from\n        # the remaining columns\n        for i in range(k, m):\n            print(a[i][n - 1], end=' ')\n \n        n -= 1\n \n        # Print the last row from\n        # the remaining rows\n        if (k < m):\n \n            for i in range(n - 1, (l - 1), -1):\n                print(a[m - 1][i], end=' ')\n \n            m -= 1\n \n        # Print the first column from\n        # the remaining columns\n        if (l < n):\n            for i in range(m - 1, k - 1, -1):\n                print(a[i][l], end=' ')\n \n            l += 1\n \n \n# Driver Code\na = [[1, 2, 3, 4],\n     [5, 6, 7, 8],\n     [9, 10, 11, 12],\n     [13, 14, 15, 16]]\n \nR = 4\nC = 4\n \n# Function Call\nspiralPrint(R, C, a)\n \n# This code is contributed by Nikita Tiwari.\n", "# Python3 program for the above approach\n \n# Function for printing matrix in spiral\n# form i, j: Start index of matrix, row\n# and column respectively m, n: End index\n# of matrix row and column respectively\n \n \ndef printdata(arr, i, j, m, n):\n \n    # If i or j lies outside the matrix\n    if (i >= m or j >= n):\n        return\n \n    # Print First Row\n    for p in range(i, n):\n        print(arr[i][p], end=' ')\n \n    # Print Last Column\n    for p in range(i + 1, m):\n        print(arr[p][n - 1], end=' ')\n \n    # Print Last Row, if Last and\n    # First Row are not same\n    if ((m - 1) != i):\n        for p in range(n - 2, j - 1, -1):\n            print(arr[m - 1][p], end=' ')\n \n    # Print First Column, if Last and\n    # First Column are not same\n    if ((n - 1) != j):\n        for p in range(m - 2, i, -1):\n            print(arr[p][j], end=' ')\n \n    printdata(arr, i + 1, j + 1, m - 1, n - 1)\n \n \n# Driver code\nif __name__ == '__main__':\n    R = 4\n    C = 4\n    arr = [[1, 2, 3, 4],\n           [5, 6, 7, 8],\n           [9, 10, 11, 12],\n           [13, 14, 15, 16]]\n \n    # Function Call\n    printdata(arr, 0, 0, R, C)\n \n# This code is contributed by avsadityavardhan\n", "# Python3 program for the above approach\n \nR = 4\nC = 4\n \n \ndef isInBounds(i, j):\n    global R\n    global C\n    if (i < 0 or i >= R or j < 0 or j >= C):\n        return False\n    return True\n \n# Check if the position is blocked\n \n \ndef isBlocked(matrix, i, j):\n    if (not isInBounds(i, j)):\n        return True\n    if (matrix[i][j] == -1):\n        return True\n \n    return False\n \n# DFS code to traverse spirally\n \n \ndef spirallyDFSTraverse(matrix, i, j, Dir, res):\n    if (isBlocked(matrix, i, j)):\n        return\n \n    allBlocked = True\n    for k in range(-1, 2, 2):\n        allBlocked = allBlocked and isBlocked(\n            matrix, k + i, j) and isBlocked(matrix, i, j + k)\n \n    res.append(matrix[i][j])\n    matrix[i][j] = -1\n    if (allBlocked):\n        return\n \n    # dir: 0 - right, 1 - down, 2 - left, 3 - up\n    nxt_i = i\n    nxt_j = j\n    nxt_dir = Dir\n    if (Dir == 0):\n        if (not isBlocked(matrix, i, j + 1)):\n            nxt_j += 1\n        else:\n            nxt_dir = 1\n            nxt_i += 1\n \n    elif(Dir == 1):\n        if (not isBlocked(matrix, i + 1, j)):\n            nxt_i += 1\n        else:\n            nxt_dir = 2\n            nxt_j -= 1\n \n    elif(Dir == 2):\n        if (not isBlocked(matrix, i, j - 1)):\n            nxt_j -= 1\n        else:\n            nxt_dir = 3\n            nxt_i -= 1\n \n    elif(Dir == 3):\n        if (not isBlocked(matrix, i - 1, j)):\n            nxt_i -= 1\n        else:\n            nxt_dir = 0\n            nxt_j += 1\n \n    spirallyDFSTravserse(matrix, nxt_i, nxt_j, nxt_dir, res)\n \n# To traverse spirally\n \n \ndef spirallyTraverse(matrix):\n    res = []\n    spirallyDFSTravserse(matrix, 0, 0, 0, res)\n    return res\n \n \n# Driver code\nif __name__ == '__main__':\n    a = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n \n    # Function Call\n    res = spirallyTraverse(a)\n    print(*res)\n \n# This code is contributed by rag2127\n"], "Find the smallest positive number missing from an unsorted array | Set 1 -  ": ["# Python3 Program to find the smallest\n# positive missing number\n \n \ndef solution(A):  # Our original array\n \n    m = max(A)  # Storing maximum value\n    if m < 1:\n \n        # In case all values in our array are negative\n        return 1\n    if len(A) == 1:\n \n        # If it contains only one element\n        return 2 if A[0] == 1 else 1\n    l = [0] * m\n    for i in range(len(A)):\n        if A[i] > 0:\n            if l[A[i] - 1] != 1:\n \n                # Changing the value status at the index of our list\n                l[A[i] - 1] = 1\n    for i in range(len(l)):\n \n        # Encountering first 0, i.e, the element with least value\n        if l[i] == 0:\n            return i + 1\n            # In case all values are filled between 1 and m\n    return i + 2\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [0, 10, 2, -10, -20]\n    print(solution(arr))\n", "# Python3 program for the above approach\n \n# Function for finding the first missing\n# positive number\ndef firstMissingPositive(arr, n):\n \n    ptr = 0\n \n    # Check if 1 is present in array or not\n    for i in range(n):\n        if arr[i] == 1:\n            ptr = 1\n            break\n \n    # If 1 is not present\n    if ptr == 0:\n        return(1)\n \n    # Changing values to 1\n    for i in range(n):\n        if arr[i] <= 0 or arr[i] > n:\n            arr[i] = 1\n \n    # Updating indices according to values\n    for i in range(n):\n        arr[(arr[i] - 1) % n] += n\n \n    # Finding which index has value less than n\n    for i in range(n):\n        if arr[i] <= n:\n            return(i + 1)\n \n    # If array has values from 1 to n\n    return(n + 1)\n \n# Driver Code\nif __name__ == '__main__':\n    # Given array\n    A = [0, 10, 2, -10, -20]\n     \n    # Size of the array\n    N = len(A)\n     \n    # Function call\n    print(firstMissingPositive(A, N))\n \n# This code is contributed by shailjapriya\n", "# Python program for the above approach\n \n \n# Function for finding the first\n# missing positive number\ndef firstMissingPositive(arr, n):\n \n    # Loop to traverse the whole array\n    for i in range(n):\n \n        # Loop to check boundary\n        # condition and for swapping\n        while (arr[i] >= 1 and arr[i] <= n\n               and arr[i] != arr[arr[i] - 1]):\n            temp = arr[i]\n            arr[i] = arr[arr[i] - 1]\n            arr[temp - 1] = temp\n \n    # Checking any element which\n    # is not equal to i + 1\n    for i in range(n):\n        if (arr[i] != i + 1):\n            return i + 1\n \n    # Nothing is present return last index\n    return n + 1\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [0, 10, 2, -10, -20]\n    n = len(arr)\n    ans = firstMissingPositive(arr, n)\n    print(ans)\n \n# This code is contributed by shivanisinghss2110\n", "# Python code for the same approach\nfrom functools import cmp_to_key\n \n \ndef cmp(a, b):\n    return (a - b)\n \n \ndef firstMissingPositive(nums):\n \n    nums.sort(key = cmp_to_key(cmp))\n    ans = 1\n    for i in range(len(nums)):\n \n        if(nums[i] == ans):\n            ans += 1\n \n    return ans\n \n \n# driver code\nif __name__ == '__main__':\n    arr = [0, 10, 2, -10, -20]\n    print(firstMissingPositive(arr))\n \n# This code is contributed by shinjanpatra\n"], "The Stock Span Problem -  ": ["# Python3 program for brute force method to calculate stock span values\n \n# Fills list S[] with span values\n \n \ndef calculateSpan(price, n, S):\n \n    # Span value of first day is always 1\n    S[0] = 1\n \n    # Calculate span value of remaining days by linearly\n    # checking previous days\n    for i in range(1, n, 1):\n        S[i] = 1   # Initialize span value\n \n        # Traverse left while the next element on left is\n        # smaller than price[i]\n        j = i - 1\n        while (j >= 0) and (price[i] >= price[j]):\n            S[i] += 1\n            j -= 1\n \n# A utility function to print elements of array\n \n \ndef printArray(arr, n):\n \n    for i in range(n):\n        print(arr[i], end=' ')\n \n \n# Driver program to test above function\nprice = [10, 4, 5, 90, 120, 80]\nn = len(price)\nS = [None] * n\n \n# Fill the span values in list S[]\ncalculateSpan(price, n, S)\n \n# print the calculated span values\nprintArray(S, n)\n \n \n# This code is contributed by Sunny Karira\n", "# Python linear time solution for stock span problem\n \n# A stack based efficient method to calculate s\n \n \ndef calculateSpan(price, S):\n \n    n = len(price)\n    # Create a stack and push index of first element to it\n    st = []\n    st.append(0)\n \n    # Span value of first element is always 1\n    S[0] = 1\n \n    # Calculate span values for rest of the elements\n    for i in range(1, n):\n \n        # Pop elements from stack while stack is not\n        # empty and top of stack is smaller than price[i]\n        while(len(st) > 0 and price[st[-1]] <= price[i]):\n            st.pop()\n \n        # If stack becomes empty, then price[i] is greater\n        # than all elements on left of it, i.e. price[0],\n        # price[1], ..price[i-1]. Else the price[i] is\n        # greater than elements after top of stack\n        S[i] = i + 1 if len(st) == 0 else (i - st[-1])\n \n        # Push this element to stack\n        st.append(i)\n \n \n# A utility function to print elements of array\ndef printArray(arr, n):\n    for i in range(0, n):\n        print(arr[i], end=' ')\n \n \n# Driver program to test above function\nprice = [10, 4, 5, 90, 120, 80]\nS = [0 for i in range(len(price)+1)]\n \n# Fill the span values in array S[]\ncalculateSpan(price, S)\n \n# Print the calculated span values\nprintArray(S, len(price))\n \n# This code is contributed by Nikhil Kumar Singh (nickzuck_007)\n", "# Python3 program for a linear time\n# solution for stock span problem\n# without using stack\n \n# An efficient method to calculate\n# stock span values implementing\n# the same idea without using stack\n \n \ndef calculateSpan(A, n, ans):\n \n    # Span value of first element\n    # is always 1\n    ans[0] = 1\n \n    # Calculate span values for rest\n    # of the elements\n    for i in range(1, n):\n        counter = 1\n \n        while ((i - counter) >= 0 and\n               A[i] >= A[i - counter]):\n            counter += ans[i - counter]\n        ans[i] = counter\n \n# A utility function to print elements\n# of array\n \n \ndef printArray(arr, n):\n \n    for i in range(n):\n        print(arr[i], end=' ')\n    print()\n \n \n# Driver code\nprice = [10, 4, 5, 90, 120, 80]\nn = len(price)\nS = [0] * (n)\n \n# Fill the span values in array S[]\ncalculateSpan(price, n, S)\n \n# Print the calculated span values\nprintArray(S, n)\n \n# This code is contributed by Prateek Gupta\n", "# Python3 program for a linear time\n# solution for stock span problem\n# using stack\n \n \ndef calculateSpan(a, n):\n    s = []\n    ans = []\n    for i in range(0, n):\n \n        while(s != [] and a[s[-1]] <= a[i]):\n            s.pop()\n \n        if(s == []):\n            ans.append(i+1)\n \n        else:\n            top = s[-1]\n            ans.append(i - top)\n \n        s.append(i)\n \n    return ans\n \n# A utility function to print elements\n# of array\n \n \ndef printArray(arr, n):\n \n    for i in range(n):\n        print(arr[i], end=' ')\n    print()\n \n \n# Driver code\nprice = [10, 4, 5, 90, 120, 80]\nn = len(price)\nans = calculateSpan(price, n)\n \n# Print the calculated span values\nprintArray(ans, n)\n \n# This code is contributed by Arpit Jain\n"], "Maximum sum of i*arr[i] among all rotations of a given array -  ": ["# A Naive Python3 program to find\n# maximum sum rotation\nimport sys\n \n# Returns maximum value of i * arr[i]\ndef maxSum(arr, n):\n \n    # Initialize result\n    res = -sys.maxsize\n \n    # Consider rotation beginning with i\n    # for all possible values of i.\n    for i in range(0, n):\n \n \n        # Initialize sum of current rotation\n        curr_sum = 0\n     \n        # Compute sum of all values. We don't\n        # actually rotation the array, but \n        # compute sum by finding indexes when \n        # arr[i] is first element\n        for j in range(0, n):\n         \n            index = int((i + j)% n) \n            curr_sum += j * arr[index] \n     \n \n        # Update result if required\n        res = max(res, curr_sum)\n    return res \n \n# Driver code\narr = [8, 3, 1, 2] \nn = len(arr)\n \nprint(maxSum(arr, n))\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# An efficient Python3 program to\n# compute maximum sum of i * arr[i]\n \ndef maxSum(arr, n):\n \n    # Compute sum of all array elements\n    cum_sum = 0\n     \n    for i in range(0, n):\n        cum_sum += arr[i] \n \n    # Compute sum of i * arr[i] for \n    # initial configuration.\n    curr_val = 0\n     \n    for i in range(0, n):\n        curr_val += i * arr[i] \n \n    # Initialize result\n    res = curr_val \n \n    # Compute values for other iterations\n    for i in range(1, n):\n     \n        # Compute next value using previous\n        # value in O(1) time\n        next_val = (curr_val - (cum_sum - arr[i-1]) +\n                                    arr[i-1] * (n-1))\n \n        # Update current value\n        curr_val = next_val \n \n        # Update result if required\n        res = max(res, next_val)\n     \n    return res \n \n \n# Driver code\narr = [8, 3, 1, 2] \nn = len(arr)\n \nprint(maxSum(arr, n))\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# Python3 program to find maximum sum of\n# all rotation of i*arr[i] using pivot.\n \n# function definition\n \n \ndef maxSum(arr, n):\n \n    sum = 0\n    pivot = findPivot(arr, n)\n \n    # difference in pivot and index\n    # of last element of array\n    diff = n - 1 - pivot\n    for i in range(n):\n        sum = sum + ((i + diff) % n) * arr[i]\n \n    return sum\n \n# function to find pivot\n \n \ndef findPivot(arr, n):\n    for i in range(n):\n \n        if(arr[i] > arr[(i + 1) % n]):\n            return i\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # rotated input array\n    arr = [8, 13, 1, 2]\n    n = len(arr)\n \n    max = maxSum(arr, n)\n    print(max)\n \n# This code is contributed by Ryuga\n"], "Find the Factorial of a large number -  ": ["# Python program to compute factorial\n# of big numbers\n \nimport sys\n \n# This function finds factorial of large\n# numbers and prints them\n \n \ndef factorial(n):\n    res = [None]*500\n    # Initialize result\n    res[0] = 1\n    res_size = 1\n \n    # Apply simple factorial formula\n    # n! = 1 * 2 * 3 * 4...*n\n    x = 2\n    while x <= n:\n        res_size = multiply(x, res, res_size)\n        x = x + 1\n \n    print('Factorial of given number is')\n    i = res_size-1\n    while i >= 0:\n        sys.stdout.write(str(res[i]))\n        sys.stdout.flush()\n        i = i - 1\n \n \n# This function multiplies x with the number\n# represented by res[]. res_size is size of res[]\n# or number of digits in the number represented\n# by res[]. This function uses simple school\n# mathematics for multiplication. This function\n# may value of res_size and returns the new value\n# of res_size\ndef multiply(x, res, res_size):\n \n    carry = 0  # Initialize carry\n \n    # One by one multiply n with individual\n    # digits of res[]\n    i = 0\n    while i < res_size:\n        prod = res[i] * x + carry\n        res[i] = prod % 10  # Store last digit of\n        # 'prod' in res[]\n        # make sure floor division is used\n        carry = prod//10  # Put rest in carry\n        i = i + 1\n \n    # Put carry in res and increase result size\n    while (carry):\n        res[res_size] = carry % 10\n        # make sure floor division is used\n        # to avoid floating value\n        carry = carry // 10\n        res_size = res_size + 1\n \n    return res_size\n \n \n# Driver program\nfactorial(100)\n \n# This code is contributed by Nikita Tiwari.\n", "# Python3 program to find large\n# factorials\n \n# Returns Factorial of N\ndef factorial(N):\n \n    # Initialize result\n    f =  1 \n     \n    # Multiply f with 2, 3, ...N\n    for i in range(2, N + 1):\n        f *= i\n     \n    return f;\n \n \n# Driver method\nN = 20;\nprint(factorial(N));\n \n \n# This code is contributed by phasing17\n"], "Subarray with 0 sum -  ": ["def subArrayExists(arr, n):\n    for i in range(n):\n        # Starting point of the subarray and\n        # sum is initialized with the first element of subarray\n        sum = arr[i]\n        if sum == 0:\n            return True\n        for j in range(i + 1, n):\n            # We are finding the sum till the jth index\n            # starting from the ith index\n            sum += arr[j]\n            if sum == 0:\n                return True\n    return False\n \n# Driver's code\nif __name__ == '__main__':\n    arr = [-3, 2, 3, 1, 6]\n    N = len(arr)\n \n    # Function call\n    if subArrayExists(arr, N):\n        print('Found a subarray with 0 sum')\n    else:\n        print('No Such Sub Array Exists!')\n", "# python3 program to find if\n# there is a zero sum subarray\n \n \ndef subArrayExists(arr, N):\n    # traverse through array\n    # and store prefix sums\n    n_sum = 0\n    s = set()\n \n    for i in range(N):\n        n_sum += arr[i]\n \n        # If prefix sum is 0 or\n        # it is already present\n        if n_sum == 0 or n_sum in s:\n            return True\n        s.add(n_sum)\n \n    return False\n \n \n# Driver's code\nif __name__ == '__main__':\n    arr = [-3, 2, 3, 1, 6]\n    N = len(arr)\n \n    # Function call\n    if subArrayExists(arr, N) == True:\n        print('Found a subarray with 0 sum')\n    else:\n        print('No Such sub array exits!')\n \n# This code is contributed by Shrikant13\n"], "Rearrange array in alternating positive & negative items with O(1) extra space | Set 1 -  ": [], "Count subarrays with equal number of 1's and 0's -  ": ["# Python3 implementation to count\n# subarrays with equal number\n# of 1's and 0's\n \n# function to count subarrays with\n# equal number of 1's and 0's\n \n \ndef countSubarrWithEqualZeroAndOne(arr, n):\n \n    # 'um' implemented as hash table\n    # to store frequency of values\n    # obtained through cumulative sum\n    um = dict()\n    curr_sum = 0\n \n    # Traverse original array and compute\n    # cumulative sum and increase count\n    # by 1 for this sum in 'um'.\n    # Adds '-1' when arr[i] == 0\n    for i in range(n):\n        curr_sum += (-1 if (arr[i] == 0) else arr[i])\n        if um.get(curr_sum):\n            um[curr_sum] += 1\n        else:\n            um[curr_sum] = 1\n \n    count = 0\n \n    # traverse the hash table 'um'\n    for itr in um:\n \n        # If there are more than one\n        # prefix subarrays with a\n        # particular sum\n        if um[itr] > 1:\n            count += ((um[itr] * int(um[itr] - 1)) / 2)\n \n    # add the subarrays starting from\n    # 1st element and have equal\n    # number of 1's and 0's\n    if um.get(0):\n        count += um[0]\n \n    # required count of subarrays\n    return int(count)\n \n \n# Driver code to test above\narr = [1, 0, 0, 1, 0, 1, 1]\nn = len(arr)\nprint('Count =',\n      countSubarrWithEqualZeroAndOne(arr, n))\n \n# This code is contributed by 'Sharad_Bhardwaj'.\n", "# Python3 implementation to count subarrays\n# with equal number of 1's and 0's\n \n \ndef countSubarrWithEqualZeroAndOne(arr, n):\n    mp = dict()\n    Sum = 0\n    count = 0\n \n    for i in range(n):\n \n        # Replacing 0's in array with -1\n        if (arr[i] == 0):\n            arr[i] = -1\n \n        Sum += arr[i]\n \n        # If Sum = 0, it implies number of\n        # 0's and 1's are equal from arr[0]..arr[i]\n        if (Sum == 0):\n            count += 1\n \n        if (Sum in mp.keys()):\n            count += mp[Sum]\n \n        mp[Sum] = mp.get(Sum, 0) + 1\n \n    return count\n \n \n# Driver Code\narr = [1, 0, 0, 1, 0, 1, 1]\n \nn = len(arr)\n \nprint('count =',\n      countSubarrWithEqualZeroAndOne(arr, n))\n \n# This code is contributed by mohit kumar\n"], "Find first non-repeating element in a given Array of integers -  ": ["# Python3 program to find first\n# non-repeating element.\n \n \ndef firstNonRepeating(arr, n):\n \n    # Loop for checking each element\n    for i in range(n):\n        j = 0\n        # Checking if ith element is present in array\n        while(j < n):\n            if (i != j and arr[i] == arr[j]):\n                break\n            j += 1\n        # if ith element is not present in array\n        # except at ith index then return element\n        if (j == n):\n            return arr[i]\n \n    return -1\n \n \n# Driver code\narr = [9, 4, 9, 6, 7, 4]\nn = len(arr)\nprint(firstNonRepeating(arr, n))\n \n# This code is contributed by Anant Agarwal.\n", "# Efficient Python3 program to find first\n# non-repeating element.\nfrom collections import defaultdict\n \n \ndef firstNonRepeating(arr, n):\n    mp = defaultdict(lambda: 0)\n \n    # Insert all array elements in hash table\n    for i in range(n):\n        mp[arr[i]] += 1\n \n    # Traverse array again and return\n    # first element with count 1.\n    for i in range(n):\n        if mp[arr[i]] == 1:\n            return arr[i]\n    return -1\n \n \n# Driver Code\narr = [9, 4, 9, 6, 7, 4]\nn = len(arr)\nprint(firstNonRepeating(arr, n))\n \n# This code is contributed by Shrikant13\n"], "Find the first repeating element in an array of integers -  ": ["# Python3 code for the approach\n \n# Function to find the index of first repeating element in an array\ndef firstRepeatingElement(arr, n):\n  # Nested loop to check for repeating elements\n  for i in range(n):\n    for j in range(i+1, n):\n      # If a repeating element is found, return its index\n      if arr[i] == arr[j]:\n        return i\n       \n  # If no repeating element is found, return -1\n  return -1\n \n# Driver code\nif __name__ == '__main__':\n  # Initializing an array and its size\n  arr = [10, 5, 3, 4, 3, 5, 6]\n  n = len(arr)\n   \n  # Finding the index of first repeating element\n  index = firstRepeatingElement(arr, n)\n   \n  # Checking if any repeating element is found or not\n  if index == -1:\n      print('No repeating element found!')\n  else:\n      # Printing the first repeating element and its index\n      print('First repeating element is', arr[index])\n", "# Python3 program to find first repeating\n# element in arr[]\n \n# This function prints the first repeating\n# element in arr[]\n \n \ndef printFirstRepeating(arr, n):\n \n    # Initialize index of first repeating element\n    Min = -1\n \n    # Creates an empty hashset\n    myset = dict()\n \n    # Traverse the input array from right to left\n    for i in range(n - 1, -1, -1):\n \n        # If element is already in hash set,\n        # update Min\n        if arr[i] in myset.keys():\n            Min = i\n \n        else:  # Else add element to hash set\n            myset[arr[i]] = 1\n \n    # Print the result\n    if (Min != -1):\n        print('The first repeating element is',\n              arr[Min])\n    else:\n        print('There are no repeating elements')\n \n \n# Driver Code\narr = [10, 5, 3, 4, 3, 5, 6]\n \nn = len(arr)\nprintFirstRepeating(arr, n)\n \n# This code is contributed by Mohit kumar 29\n", "# Python3 program to find first\n# repeating element in arr[]\n \n# This function prints the\n# first repeating element in arr[]\n \n \ndef printFirstRepeating(arr, n):\n \n    # This will set k=1, if any\n    # repeating element found\n    k = 0\n \n    # max = maximum from (all elements & n)\n    max = n\n \n    for i in range(n):\n        if (max < arr[i]):\n            max = arr[i]\n \n    # Array a is for storing\n    # 1st time occurrence of element\n    # initialized by 0\n    a = [0 for i in range(max + 1)]\n \n    # Store 1 in array b\n    # if element is duplicate\n    # initialized by 0\n    b = [0 for i in range(max + 1)]\n \n    for i in range(n):\n \n        # Duplicate element found\n        if (a[arr[i]]):\n            b[arr[i]] = 1\n            k = 1\n            continue\n        else:\n \n            # Storing 1st occurrence of arr[i]\n            a[arr[i]] = i+1\n \n    if (k == 0):\n        print('No repeating element found')\n    else:\n        min = max + 1\n \n        for i in range(max + 1):\n \n            # Trace array a & find repeating\n            # element with min index\n            if (a[i] and (min > (a[i])) and b[i]):\n                min = a[i]\n \n        print(arr[min-1])\n \n \n# Driver code\narr = [10, 5, 3, 4, 3, 5, 6]\nN = len(arr)\n \nprintFirstRepeating(arr, N)\n \n# This code is contributed by avanitrachhadiya2155\n", "# Python program to find first repeating element in arr[]\ndef firstRepeating(arr, n):\n    # Finding max\n    max_val = max(arr)\n     \n    # Creating array\n    hash = [0] * (max_val+1)\n     \n    # Mapping/counting\n    for i in range(n):\n        hash[arr[i]] += 1\n     \n    # Variable for storing ans\n    repeating = float('inf')\n     \n    # Checking repeating element\n    for i in range(n):\n        if hash[arr[i]] > 1:\n            repeating = arr[i]\n            break\n     \n    if repeating == float('inf'):\n        print('There are no repeating elements')\n    else:\n        print('The first repeating element is:', repeating)\n \n# Driver method to test above method\narr = [10, 5, 3, 4, 3, 5, 6]\nN = len(arr)\nfirstRepeating(arr, N)\n"], "Find common elements in three sorted arrays -  ": ["# Function to find the intersection of two arrays\ndef find_intersection(arr1, arr2, temp, m, n, k):\n    i = 0\n    j = 0\n    while i < m and j < n:\n        if arr1[i] < arr2[j]:\n            i += 1\n        elif arr2[j] < arr1[i]:\n            j += 1\n        else:\n            temp[k[0]] = arr1[i]\n            i += 1\n            j += 1\n            k[0] += 1\n \n# Main function\n \n \ndef main():\n    arr1 = [1, 5, 10, 20, 40, 80]\n    arr2 = [6, 7, 20, 80, 100]\n    arr3 = [3, 4, 15, 20, 30, 70, 80, 120]\n    n1 = len(arr1)\n    n2 = len(arr2)\n    n3 = len(arr3)\n \n    temp = [0] * 200000\n    ans = [0] * 200000\n \n    k = [0]  # Mutable list to simulate pass-by-reference\n \n    # Function call to find the temp array\n    find_intersection(arr1, arr2, temp, n1, n2, k)\n    temp_size = k[0]\n    k[0] = 0\n \n    # Function call to find the ans array\n    find_intersection(arr3, temp, ans, n3, temp_size, k)\n \n    print('Common elements present in arrays are:')\n \n    # Printing the common elements\n    for i in range(k[0]):\n        print(ans[i], end=' ')\n    print()\n \n \nif __name__ == '__main__':\n    main()\n"], "Find duplicates in O(n) time and O(1) extra space | Set 1 -  ": ["# Python3 code for above approach\ndef duplicates(arr, n):\n   \n    # Increment array elements by 1\n    for i in range(n):\n        arr[i] = arr[i] + 1\n         \n    # result vector\n    res = []\n     \n    # count variable for count of\n    # largest element\n    count = 0\n    for i in range(n):\n       \n        # Calculate index value\n        if(abs(arr[i]) > n):\n            index = abs(arr[i])//(n+1)\n        else:\n            index = abs(arr[i])\n             \n        # Check if index equals largest element value\n        if(index == n):\n            count += 1\n            continue\n             \n        # Get element value at index\n        val = arr[index]\n         \n        # Check if element value is negative, positive\n        # or greater than n\n        if(val < 0):\n            res.append(index-1)\n            arr[index] = abs(arr[index]) * (n + 1)\n        elif(val>n):\n            continue\n        else:\n            arr[index] = -arr[index]\n             \n    # If largest element occurs more than once\n    if(count > 1):\n        res.append(n - 1)\n    if(len(res) == 0):\n        res.append(-1)\n    else:\n        res.sort()\n    return res\n   \n# Driver Code\nnumRay = [ 0, 4, 3, 2, 7, 8, 2, 3, 1 ]\nn = len(numRay)\nans = duplicates(numRay,n)\nfor i in ans:\n    print(i)\n     \n # This code is contributed by Vibhu Karnwal\n", "def find_duplicates(arr):\n    duplicates = []\n    n = len(arr)\n \n    # First check all the values that are present in the array\n    # then go to those values as indices and increment by the size of the array\n    for i in range(n):\n        index = arr[i] % n\n        arr[index] += n\n \n    # Now check which value exists more than once by dividing with the size of the array\n    for i in range(n):\n        if arr[i] // n >= 2:\n            duplicates.append(i)\n \n    return duplicates\n \n \narr = [1, 6, 3, 1, 3, 6, 6]\nprint('The repeating elements are:')\nans = find_duplicates(arr)\nfor x in ans:\n    print(x, end=' ')\n"], "Find the Missing Number -  ": ["# Find Missing Element\ndef findMissing(arr, N):\n   \n    # create a list of zeroes\n    temp = [0] * (N+1)\n \n    for i in range(0, N):\n        temp[arr[i] - 1] = 1\n \n    for i in range(0, N+1):\n        if(temp[i] == 0):\n            ans = i + 1\n \n    print(ans)\n \n# Driver code\nif __name__ == '__main__':\n    arr = [1, 2, 3, 5]\n    N = len(arr)\n \n    # Function call\n    findMissing(arr, N)\n \n    # This code is contributed by nikhilm2302\n", "# Function to get the missing number\ndef getMissingNo(a, n):\n    i, total = 0, 1\n \n    for i in range(2, n + 2):\n        total += i\n        total -= a[i - 2]\n    return total\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [1, 2, 3, 5]\n    N = len(arr)\n \n    # Function call\n    print(getMissingNo(arr, N))\n \n# This code is contributed by Mohit kumar\n", "# Python3 program to find\n# the missing Number\n# getMissingNo takes list as argument\n \n \ndef getMissingNo(a, n):\n    x1 = a[0]\n    x2 = 1\n \n    for i in range(1, n):\n        x1 = x1 ^ a[i]\n \n    for i in range(2, n + 2):\n        x2 = x2 ^ i\n \n    return x1 ^ x2\n \n \n# Driver program to test above function\nif __name__ == '__main__':\n \n    arr = [1, 2, 3, 5]\n    N = len(arr)\n \n    # Driver code\n    miss = getMissingNo(arr, N)\n    print(miss)\n \n# This code is contributed by Yatin Gupta\n", "# Python3 program to check missingNo\n \n# Function to find the missing number\ndef getMissingNo(arr, n) :\n    i = 0;\n     \n    while (i < n) :\n        # as array is of 1 based indexing so the\n        # correct position or index number of each\n        # element is element-1 i.e. 1 will be at 0th\n        # index similarly 2 correct index will 1 so\n        # on...\n        correctpos = arr[i] - 1;\n        if (arr[i] < n and arr[i] != arr[correctpos]) :\n            # if array element should be lesser than\n            # size and array element should not be at\n            # its correct position then only swap with\n            # its correct position or index value\n            arr[i],arr[correctpos] = arr[correctpos], arr[i]\n \n        else :\n            # if element is at its correct position\n            # just increment i and check for remaining\n            # array elements\n            i += 1;\n             \n    # check for missing element by comparing elements with their index values \n    for index in range(n) : \n        if (arr[index] != index + 1) :\n            return index + 1;\n             \n    return n;\n \n# Driver code\nif __name__ == '__main__' :\n    arr = [ 1, 2, 3, 5 ];\n    N = len(arr);\n    print(getMissingNo(arr, N));\n \n \n    # This Code is Contributed by AnkThon\n", "# Function to get the missing number\ndef findMissing(a, size):\n \n    for i in range(0, n):\n        if (abs(arr[i]) - 1 == size):\n            continue\n \n        ind = abs(arr[i]) - 1\n        arr[ind] *= -1\n \n    ans = size + 1\n    for i in range(0, n):\n        if (arr[i] > 0):\n            ans = i + 1\n \n    print(ans)\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [1, 3, 7, 5, 6, 2]\n    n = len(arr)\n \n    # Function call\n    findMissing(arr, n)\n \n    # This code is contributed by aarohirai2616.\n"], "Union and Intersection of two sorted arrays -  ": ["# Python code to implement the approach\n \ndef Unionarray(arr1, arr2, n, m):\n    # Create a set to store unique elements from both arrays\n    set1 = set(arr1)\n    set2 = set(arr2)\n    # Merge both sets and convert back to list\n    result = list(set1.union(set2))\n    return result\n   \n# Driver code\nif __name__ == '__main__':\n    arr1 = [1, 2, 2, 2, 3]\n    arr2 = [2, 3, 3, 4, 5, 5]\n    n = len(arr1)\n    m = len(arr2)\n   \n    # Function call\n    uni = Unionarray(arr1, arr2, n, m)\n    for i in uni:\n        print(i, end=' ')\n", "# Python code to implement the approach\nfrom typing import List\n \ndef Unionarray(arr1: List[int], arr2: List[int], n: int, m: int) -> List[int]:\n    map = {}\n      \n    # Remove the duplicates from arr1[]\n    for i in range(n):\n        if arr1[i] in map:\n            map[arr1[i]] += 1\n        else:\n            map[arr1[i]] = 1\n            \n    # Remove duplicates from arr2[]\n    for i in range(m):\n        if arr2[i] in map:\n            map[arr2[i]] += 1\n        else:\n            map[arr2[i]] = 1\n            \n    # Loading set to list\n    uni = list(map.keys())\n  \n    return uni\n    \n# Driver code\narr1 = [1, 2, 2, 2, 3]\narr2 = [2, 3, 3, 4, 5, 5]\nn = len(arr1)\nm = len(arr2)\nprint('Union is :')\n \n# Function call\nuni = Unionarray(arr1, arr2, n, m)\nfor i in uni:\n    print(i, end=' ')\n", "# Python program to find union of\n# two sorted arrays\n# Function prints union of arr1[] and arr2[]\n# m is the number of elements in arr1[]\n# n is the number of elements in arr2[]\ndef printUnion(arr1, arr2, m, n):\n    i, j = 0, 0\n    while i < m and j < n:\n        if arr1[i] < arr2[j]:\n            print(arr1[i],end=' ')\n            i += 1\n        elif arr2[j] < arr1[i]:\n            print(arr2[j],end=' ')\n            j+= 1\n        else:\n            print(arr2[j],end=' ')\n            j += 1\n            i += 1\n \n    # Print remaining elements of the larger array\n    while i < m:\n        print(arr1[i],end=' ')\n        i += 1\n \n    while j < n:\n        print(arr2[j],end=' ')\n        j += 1\n \n# Driver program to test above function\narr1 = [1, 2, 4, 5, 6]\narr2 = [2, 3, 5, 7]\nm = len(arr1)\nn = len(arr2)\nprintUnion(arr1, arr2, m, n)\n \n# This code is contributed by Pratik Chhajer\n", "def next_distinct(arr, x):\n    '''\n    Helper function for printUnion(). This same function can also be implemented as a lambda function inside printUnion().\n    This function moves to the next distinct element in the array.\n    '''\n    while x < len(arr) - 1 and arr[x] == arr[x + 1]:\n        x += 1\n    return x + 1\n \n \ndef printUnion(arr1, arr2):\n    '''\n    This function prints the union of two arrays without duplicates.\n \n    '''\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            print(arr1[i], end=' ')\n            i = next_distinct(arr1, i)\n        elif arr1[i] > arr2[j]:\n            print(arr2[j], end=' ')\n            j = next_distinct(arr2, j)\n        else:\n            print(arr1[i], end=' ')\n            i = next_distinct(arr1, i)\n            j = next_distinct(arr2, j)\n \n    while i < len(arr1):\n        print(arr1[i], end=' ')\n        i = next_distinct(arr1, i)\n \n    while j < len(arr2):\n        print(arr2[j], end=' ')\n        j = next_distinct(arr2, j)\n \n \narr1 = [1, 2, 2, 2, 3]\narr2 = [2, 3, 3, 4, 5, 5]\nprintUnion(arr1, arr2)\n", "# Function to find the intersection of two arrays\ndef find_intersection(arr1, arr2):\n    set1 = set(arr1)\n \n    # Removing duplicates from the first array\n    result = []\n \n    # Avoiding duplicates and adding intersections\n    for num in arr2:\n        if num in set1:\n            result.append(num)\n            set1.remove(num)\n \n    return result\n \n# Driver code\nif __name__ == '__main__':\n    arr1 = [1, 2, 4, 5, 6]\n    arr2 = [2, 3, 5, 7]\n \n    # Function call\n    intersection = find_intersection(arr1, arr2)\n    for num in intersection:\n        print(num, end=' ')\n", "# Python program to find intersection of\n# two sorted arrays\n# Function prints Intersection of arr1[] and arr2[]\n# m is the number of elements in arr1[]\n# n is the number of elements in arr2[]\ndef printIntersection(arr1, arr2, m, n):\n    i, j = 0, 0\n    while i < m and j < n:\n        if arr1[i] < arr2[j]:\n            i += 1\n        elif arr2[j] < arr1[i]:\n            j+= 1\n        else:\n            print(arr2[j],end=' ')\n            j += 1\n            i += 1\n \n# Driver program to test above function\narr1 = [1, 2, 4, 5, 6]\narr2 = [2, 3, 5, 7]\nm = len(arr1)\nn = len(arr2)\nprintIntersection(arr1, arr2, m, n)\n \n# This code is contributed by Pratik Chhajer\n", "# Python program to find intersection of\n# two sorted arrays\n \n# function prints intersection of arr1[] and arr2[]\n# m is the number of elements in arr1[]\n# n is the number of elements in arr2[]\ndef printIntersection(arr1, arr2, m, n):\n    i = 0\n    j = 0\n    while(i < m and j < n):\n        if(i > 0 and arr1[i] == arr1[i-1]): # For Handling duplicates\n            i = i+1\n            continue\n        if(arr1[i] < arr2[j]):\n            i += 1\n        elif(arr2[j] < arr1[i]):\n            j += 1\n        else:\n            print(arr2[j], end=' ')\n            i+=1\n            j+=1\n \n \n# driver program\narr1 = [1,2,2,3,4]\narr2 = [2,2,4,6,7,8]\n \nm = len(arr1)\nn = len(arr2)\n \n# function calling\nprintIntersection(arr1, arr2, m, n)\n \n# This code is contributed by Kirti Agarwal(kirtiagarwal23121999)\n"], "Move all negative numbers to beginning and positive to end with constant extra space -  ": ["# Python code for the same approach \ndef move(arr): \n  arr.sort() \n  \n# driver code \narr = [ -1, 2, -3, 4, 5, 6, -7, 8, 9 ] \nmove(arr) \nfor e in arr: \n    print(e , end = ' ') \n  \n# This code is contributed by shinjanpatra\n", "# A Python 3 program to put \n# all negative numbers before \n# positive numbers \n  \ndef rearrange(arr, n ) : \n  \n    # Please refer partition() in  \n    # below post \n    # https://www. .org / quick-sort / j = 0 \n    j = 0 \n    for i in range(0, n) : \n        if (arr[i] < 0) : \n            temp = arr[i] \n            arr[i] = arr[j] \n            arr[j]= temp \n            j = j + 1\n    print(arr) \n  \n# Driver code \narr = [-1, 2, -3, 4, 5, 6, -7, 8, 9] \nn = len(arr) \nrearrange(arr, n) \n  \n  \n# This code is contributed by Nikita Tiwari. \n", "# Python3 program of the  \n# above approach \n  \n# Function to shift all the  \n# the negative elements to \n# the left of the array \ndef shiftall(arr,left,right): \n    \n  # Loop to iterate while the  \n  # left pointer is less than \n  # the right pointer \n  while left<=right: \n      \n    # Condition to check if the left \n    # and right pointer negative \n    if arr[left] < 0 and arr[right] < 0: \n      left+=1\n        \n    # Condition to check if the left  \n    # pointer element is positive and  \n    # the right pointer element is \n    # negative \n    else if arr[left]>0 and arr[right]<0: \n      arr[left], arr[right] = \\ \n              arr[right],arr[left] \n      left+=1\n      right-=1\n        \n    # Condition to check if the left \n    # pointer is positive and right  \n    # pointer as well \n    else if arr[left]>0 and arr[right]>0: \n      right-=1\n    else: \n      left+=1\n      right-=1\n        \n# Function to print the array \ndef display(arr): \n  for i in range(len(arr)): \n    print(arr[i], end=' ') \n  print() \n  \n# Driver Code \nif __name__ == '__main__': \n  arr=[-12, 11, -13, -5, \\ \n       6, -7, 5, -3, 11] \n  n=len(arr) \n  shiftall(arr,0,n-1) \n  display(arr) \n  \n# Sumit Singh\n", "# Python code for the approach \n  \n# Using Dutch National Flag Algorithm. \ndef reArrange(arr, n): \n    low,high = 0, n - 1\n    while(low<high): \n        if(arr[low] < 0): \n            low += 1\n        elif(arr[high] > 0): \n            high -= 1\n        else: \n            arr[low],arr[high] = arr[high],arr[low] \n  \ndef displayArray(arr, n): \n  \n    for i in range(n): \n        print(arr[i],end = ' ') \n    \n    print('') \n  \n# driver code \n# Data \narr = [1, 2,  -4, -5, 2, -7, 3, 2, -6, -8, -9, 3, 2,  1] \nn = len(arr) \nreArrange(arr,n) \ndisplayArray(arr,n) \n  \n# This code is contributed by shinjanpatra\n"], "Count number of occurrences (or frequency) in a sorted array -  ": ["# Python3 program to count \n# occurrences of an element\n \n# Returns number of times x \n# occurs in arr[0..n-1]\ndef countOccurrences(arr, n, x):\n    res = 0\n    for i in range(n):\n        if x == arr[i]:\n            res += 1\n    return res\n  \n# Driver code\narr = [1, 2, 2, 2, 2, 3, 4, 7 ,8 ,8]\nn = len(arr)\nx = 2\nprint (countOccurrences(arr, n, x))\n", "# Python 3 program to count \n# occurrences of an element\n \n# A recursive binary search \n# function. It returns location\n# of x in given array arr[l..r] \n# is present, otherwise -1\ndef binarySearch(arr, l, r, x):\n    if (r < l):\n        return -1\n \n    mid = int( l + (r - l) / 2)\n \n    # If the element is present \n    # at the middle itself\n    if arr[mid] == x:\n        return mid\n \n    # If element is smaller than \n    # mid, then it can only be\n    # present in left subarray\n    if arr[mid] > x:\n        return binarySearch(arr, l, \n                            mid - 1, x)\n \n    # Else the element \n    # can only be present\n    # in right subarray\n    return binarySearch(arr, mid + 1,\n                                r, x)\n \n# Returns number of times \n# x occurs in arr[0..n-1]\ndef countOccurrences(arr, n, x):\n    ind = binarySearch(arr, 0, n - 1, x)\n \n    # If element is not present\n    if ind == -1:\n        return 0\n \n    # Count elements \n    # on left side.\n    count = 1\n    left = ind - 1\n    while (left >= 0 and\n           arr[left] == x):\n        count += 1\n        left -= 1\n \n    # Count elements on\n    # right side.\n    right = ind + 1;\n    while (right < n and\n           arr[right] == x):\n        count += 1\n        right += 1\n \n    return count\n \n# Driver code\narr = [ 1, 2, 2, 2, 2, \n        3, 4, 7, 8, 8 ]\nn = len(arr)\nx = 2\nprint(countOccurrences(arr, n, x))\n \n# This code is contributed \n# by ChitraNayal\n", "# Python3 program to count\n# occurrences of an element\n \n# if x is present in arr[] then \n# returns the count of occurrences\n# of x, otherwise returns -1. \ndef count(arr, x, n):\n \n    # get the index of first\n    # occurrence of x \n    i = first(arr, 0, n-1, x, n)\n  \n    # If x doesn't exist in \n    # arr[] then return -1 \n    if i == -1:\n        return i\n     \n    # Else get the index of last occurrence\n    # of x. Note that we are only looking\n    # in the subarray after first occurrence   \n    j = last(arr, i, n-1, x, n);     \n     \n    # return count \n    return j-i+1;\n \n# if x is present in arr[] then return\n# the index of FIRST occurrence of x in\n# arr[0..n-1], otherwise returns -1 \ndef first(arr, low, high, x, n):\n    if high >= low:\n \n        # low + (high - low)/2\n        mid = (low + high)//2     \n         \n        if (mid == 0 or x > arr[mid-1]) and arr[mid] == x:\n            return mid\n        elif x > arr[mid]:\n            return first(arr, (mid + 1), high, x, n)\n        else:\n            return first(arr, low, (mid -1), x, n)\n    return -1;\n  \n# if x is present in arr[] then return\n# the index of LAST occurrence of x \n# in arr[0..n-1], otherwise returns -1 \ndef last(arr, low, high, x, n):\n    if high >= low:\n \n        # low + (high - low)/2\n        mid = (low + high)//2; \n  \n        if(mid == n-1 or x < arr[mid+1]) and arr[mid] == x :\n            return mid\n        elif x < arr[mid]:\n            return last(arr, low, (mid -1), x, n)\n        else:\n            return last(arr, (mid + 1), high, x, n)     \n    return -1\n \n# driver program to test above functions \narr = [1, 2, 2, 3, 3, 3, 3]\nx = 3  # Element to be counted in arr[]\nn = len(arr)\nc = count(arr, x, n)\nprint ('%d occurs %d times '%(x, c))\n", "# Python code to implement the approach\n \n# Function to count occurrences\ndef countOccurrences(arr, x) :\n \n    count = 0\n    n = len(arr)\n    for i in range(n) :\n        if (arr[i] == x):\n            count += 1\n             \n    return count\n    \n# Driver Code\nif __name__ == '__main__':\n         \n    arr = [ 1, 2, 2, 2, 2, 3, 4, 7, 8, 8 ]\n    x = 2\n   \n    # displaying the frequency of x in ArrayList\n    print(x , 'occurs'\n                        , countOccurrences(arr, x)\n                        , 'times')\n     \n    # This code is contributed by sanjoy_62.\n", "# Python program for the above approach\n \n# Function to count occurrences\ndef countOccurrences(arr, x, N):\n    mp = {}\n    for i in range(N):\n        if arr[i] in mp:\n            mp[arr[i]] += 1\n        else:\n            mp[arr[i]] = 1\n \n    if x not in mp:\n        return 0\n \n    return mp[x]\n \n# Driver Code\narr = [1, 2, 2, 2, 2, 3, 4, 7, 8, 8]\nx = 2\nN = len(arr)\n \n# displaying the frequency of x in Array\nprint(x, 'occurs', countOccurrences(arr, x, N), 'times')\n \n# This code is contributed by Susobhan Akhuli\n"], "C program to sort an array in ascending order -  ": [], "Program to find the minimum (or maximum) element of an array -  ": ["import sys\n \n# Define an array\na = [1, 423, 6, 46, 34, 23, 13, 53, 4]\n \n# Sort the array using the built-in sorted() function\na_sorted = sorted(a)\n \n# Find the minimum and maximum values\nmin_value = a_sorted[0]\nmax_value = a_sorted[-1]\n \n# Print the results\nprint(f'min-{min_value} max-{max_value}')\n", "# Python3 program to find minimum\n# (or maximum) element in an array\n \n# Minimum Function\ndef getMin(arr, n):\n    res = arr[0]\n    for i in range(1,n):\n        res = min(res, arr[i])\n    return res\n \n# Maximum Function\ndef getMax(arr, n):\n    res = arr[0]\n    for i in range(1,n):\n        res = max(res, arr[i])\n    return res\n \n# Driver Program\narr = [12, 1234, 45, 67, 1]\nn = len(arr)\nprint ('Minimum element of array:', getMin(arr, n))\nprint ('Maximum element of array:', getMax(arr, n))\n \n# This code is contributed \n# by Shreyanshi Arun.\n", "# Python3 program to find minimum \n# (or maximum) element in an array.\ndef getMin(arr, n):\n    if(n==1):\n        return arr[0]\n    # If there is single element, return it. \n    # Else return minimum of first element \n    # and minimum of remaining array. \n    else:\n        return min(getMin(arr[1:], n-1), arr[0])\ndef getMax(arr, n): \n    if(n==1):\n        return arr[0]\n    # If there is single element, return it. \n    # Else return maximum of first element \n    # and maximum of remaining array. \n    else:\n        return max(getMax(arr[1:], n-1), arr[0])\n \n# Driver code\narr = [12, 1234, 45, 67, 1]\nn = len(arr)\nprint('Minimum element of array: ', \n                   getMin(arr, n));\nprint('Maximum element of array: ',\n                   getMax(arr, n));\n \n# This code is contributed by \n# Mohit Kumar 29\n", "# Python3 program to find minimum \n# (or maximum) element \n# in an array. \ndef getMin(arr,n):\n    return min(arr)\n \ndef getMax(arr,n):\n    return max(arr)\n \n# Driver Code\nif __name__=='__main__':\n    arr = [12,1234,45,67,1]\n    n = len(arr)\n    print('Minimum element of array: '\n          ,getMin(arr, n))\n    print('Maximum element of array: '\n          ,getMax(arr, n))\n \n# This code is contributed by \n# Shrikant13\n"], "Smallest Difference Triplet from Three arrays -  ": ["# Python3 implementation of smallest\n# difference triplet\n \n# Function to find maximum number\ndef maximum(a, b, c):\n    return max(max(a, b), c)\n \n# Function to find minimum number\ndef minimum(a, b, c):\n    return min(min(a, b), c)\n \n# Finds and prints the smallest\n# Difference Triplet\ndef smallestDifferenceTriplet(arr1, arr2, arr3, n):\n \n    # sorting all the three arrays\n    arr1.sort()\n    arr2.sort()\n    arr3.sort()\n \n    # To store resultant three numbers\n    res_min = 0; res_max = 0; res_mid = 0\n \n    # pointers to arr1, arr2, \n    # arr3 respectively\n    i = 0; j = 0; k = 0\n \n    # Loop until one array reaches to its end\n    # Find the smallest difference.\n    diff = 2147483647\n    while (i < n and j < n and k < n):\n     \n        sum = arr1[i] + arr2[j] + arr3[k]\n \n        # maximum number\n        max = maximum(arr1[i], arr2[j], arr3[k])\n \n        # Find minimum and increment its index.\n        min = minimum(arr1[i], arr2[j], arr3[k])\n        if (min == arr1[i]):\n            i += 1\n        else if (min == arr2[j]):\n            j += 1\n        else:\n            k += 1\n \n        # Comparing new difference with the\n        # previous one and updating accordingly\n        if (diff > (max - min)):\n         \n            diff = max - min\n            res_max = max\n            res_mid = sum - (max + min)\n            res_min = min\n         \n    # Print result\n    print(res_max, ',', res_mid, ',', res_min)\n \n# Driver code\narr1 = [5, 2, 8]\narr2 = [10, 7, 12]\narr3 = [9, 14, 6]\nn = len(arr1)\nsmallestDifferenceTriplet(arr1, arr2, arr3, n)\n \n# This code is contributed by Anant Agarwal.\n"], "Maximum equilibrium sum in an array -  ": ["# Python 3 program to find maximum \n# equilibrium sum.\nimport sys\n \n# Function to find maximum equilibrium sum.\ndef findMaxSum(arr, n):\n    res = -sys.maxsize - 1\n    for i in range(n):\n        prefix_sum = arr[i]\n        for j in range(i):\n            prefix_sum += arr[j]\n \n        suffix_sum = arr[i]\n        j = n - 1\n        while(j > i):\n            suffix_sum += arr[j]\n            j -= 1\n        if (prefix_sum == suffix_sum):\n            res = max(res, prefix_sum)\n \n    return res\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [-2, 5, 3, 1, 2, 6, -4, 2]\n    n = len(arr)\n    print(findMaxSum(arr, n))\n \n# This code is contributed by\n# Surendra_Gangwar\n", "# Python3 program to find\n# maximum equilibrium sum.\n \n# Function to find maximum\n# equilibrium sum.\ndef findMaxSum(arr, n):\n \n    # Array to store prefix sum.\n    preSum = [0 for i in range(n)]\n \n    # Array to store suffix sum.\n    suffSum = [0 for i in range(n)]\n \n    # Variable to store maximum sum.\n    ans = -10000000\n \n    # Calculate prefix sum.\n    preSum[0] = arr[0]\n     \n    for i in range(1, n):\n     \n        preSum[i] = preSum[i - 1] + arr[i]\n \n    # Calculate suffix sum and compare\n    # it with prefix sum. Update ans\n    # accordingly.\n    suffSum[n - 1] = arr[n - 1]\n    if (preSum[n - 1] == suffSum[n - 1]):\n        ans = max(ans, preSum[n - 1])\n      \n    for i in range(n - 2, -1, -1):\n        suffSum[i] = suffSum[i + 1] + arr[i]\n        if (suffSum[i] == preSum[i]):\n            ans = max(ans, preSum[i])\n     \n    return ans\n \n# Driver Code\nif __name__=='__main__':\n \n    arr = [-2, 5, 3, 1,2, 6, -4, 2]\n    n = len(arr)\n    print(findMaxSum(arr, n))\n     \n# This code is contributed by pratham76\n", "# Python3 program to find\n# maximum equilibrium sum.\nimport sys\n \n# Function to find \n# maximum equilibrium sum. \ndef findMaxSum(arr,n):\n     \n    ss = sum(arr)\n    prefix_sum = 0\n    res = -sys.maxsize\n     \n    for i in range(n):\n        prefix_sum += arr[i]\n         \n        if prefix_sum == ss:\n            res = max(res, prefix_sum); \n             \n        ss -= arr[i];\n         \n    return res\n  \n# Driver code   \nif __name__=='__main__':\n     \n    arr = [ -2, 5, 3, 1, \n             2, 6, -4, 2 ]\n    n = len(arr)\n     \n    print(findMaxSum(arr, n))\n \n# This code is contributed by rutvik_56\n"], "Construct an array from its pair-sum array -  ": ["# Fills element in arr[] from its \n# pair sum array pair[]. \n# n is size of arr[] \n \ndef constructArr(arr,pair,n):\n    arr [0] = (pair[0]+pair[1]-pair[n-1])//2\n    for i in range(1,n):\n        arr[i] = pair[i-1]-arr[0]\n \n# Driver code\nif __name__=='__main__':\n    pair = [15, 13, 11, 10, 12, 10, 9, 8, 7, 5]\n    n =5\n    arr = [0]*n\n    constructArr(arr,pair,n)\n    for i in range(n):\n        print(arr[i],end =' ')\n \n# This code is contributed by \n# Shrikant13\n"], "Find maximum value of Sum( i*arr[i]) with only rotations on given array allowed -  ": ["def max_sum_rotation(arr, n):\n    # set the maximum sum to the\n    # minimum possible value\n    max_sum = float('-inf')\n     \n     \n    # loop through all possible rotations\n    for i in range(n):\n       \n        # set the current sum to zero\n        sum = 0\n         \n        # loop through all elements in the array\n        for j in range(n):\n            # calculate the index of the current element after rotation\n            index = (i + j) % n\n             \n            # add the product of the element with its index to the sum\n            sum += j * arr[index]\n         \n        # update the maximum sum if necessary\n        max_sum = max(max_sum, sum)\n     \n    # return the maximum sum obtained over all rotations\n    return max_sum\n# Test case\narr = [10, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nn = len(arr)\nprint(max_sum_rotation(arr, n))\n"], "Space optimization using bit manipulations -  ": ["# Python3 program to mark numbers\n# as multiple of 2 or 5\nimport math\n \n# Driver code\na = 2\nb = 10\nsize = abs(b - a) + 1\narray = [0] * size\n \n# Iterate through a to b, \n# If it is a multiple of 2 \n# or 5 Mark index in array as 1\nfor i in range(a, b + 1):\n    if (i % 2 == 0 or i % 5 == 0):\n            array[i - a] = 1\n \nprint('MULTIPLES of 2 and 5:')\nfor i in range(a, b + 1):\n    if (array[i - a] == 1):\n            print(i, end=' ')\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# Python3 code to for marking multiples\nimport math\n \n# index >> 5 corresponds to dividing index by 32\n# index & 31 corresponds to modulo operation of \n# index by 32\n \n# Function to check value of bit position whether \n# it is zero or one\ndef checkbit( array, index):\n    return array[index >> 5] & (1 << (index & 31))\n \n# Sets value of bit for corresponding index\ndef setbit( array, index):\n    array[index >> 5] |= (1 << (index & 31))\n \n# Driver code\na = 2\nb = 10\nsize = abs(b - a)\n \n# Size that will be used is actual_size/32\n# ceil is used to initialize the array with\n# positive number\nsize = math.ceil(size / 32)\n     \n# Array is dynamically initialized as\n# we are calculating size at run time\narray = [0 for i in range(size)]\n \n# Iterate through every index from a to b and\n# call setbit() if it is a multiple of 2 or 5\nfor i in range(a, b + 1):\n    if (i % 2 == 0 or i % 5 == 0):\n        setbit(array, i - a)\n \nprint('MULTIPLES of 2 and 5:')\nfor i in range(a, b + 1):\n    if (checkbit(array, i - a)):\n        print(i, end = ' ')\n \n# This code is contributed by rohitsingh07052\n"], "Range LCM Queries -  ": ["# LCM of given range queries using Segment Tree\nMAX = 1000\n \n# allocate space for tree\ntree = [0] * (4 * MAX)\n \n# declaring the array globally\narr = [0] * MAX\n \n# Function to return gcd of a and b\n \n \ndef gcd(a: int, b: int):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n \n# utility function to find lcm\n \n \ndef lcm(a: int, b: int):\n    return (a * b) // gcd(a, b)\n \n# Function to build the segment tree\n# Node starts beginning index of current subtree.\n# start and end are indexes in arr[] which is global\n \n \ndef build(node: int, start: int, end: int):\n \n    # If there is only one element\n    # in current subarray\n    if start == end:\n        tree[node] = arr[start]\n        return\n \n    mid = (start + end) // 2\n \n    # build left and right segments\n    build(2 * node, start, mid)\n    build(2 * node + 1, mid + 1, end)\n \n    # build the parent\n    left_lcm = tree[2 * node]\n    right_lcm = tree[2 * node + 1]\n \n    tree[node] = lcm(left_lcm, right_lcm)\n \n# Function to make queries for array range )l, r).\n# Node is index of root of current segment in segment\n# tree (Note that indexes in segment tree begin with 1\n# for simplicity).\n# start and end are indexes of subarray covered by root\n# of current segment.\n \n \ndef query(node: int, start: int,\n          end: int, l: int, r: int):\n \n    # Completely outside the segment,\n    # returning 1 will not affect the lcm;\n    if end < l or start > r:\n        return 1\n \n    # completely inside the segment\n    if l <= start and r >= end:\n        return tree[node]\n \n    # partially inside\n    mid = (start + end) // 2\n    left_lcm = query(2 * node, start, mid, l, r)\n    right_lcm = query(2 * node + 1,\n                      mid + 1, end, l, r)\n    return lcm(left_lcm, right_lcm)\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # initialize the array\n    arr[0] = 5\n    arr[1] = 7\n    arr[2] = 5\n    arr[3] = 2\n    arr[4] = 10\n    arr[5] = 12\n    arr[6] = 11\n    arr[7] = 17\n    arr[8] = 14\n    arr[9] = 1\n    arr[10] = 44\n \n    # build the segment tree\n    build(1, 0, 10)\n \n    # Now we can answer each query efficiently\n \n    # Print LCM of (2, 5)\n    print(query(1, 0, 10, 2, 5))\n \n    # Print LCM of (5, 10)\n    print(query(1, 0, 10, 5, 10))\n \n    # Print LCM of (0, 10)\n    print(query(1, 0, 10, 0, 10))\n \n# This code is contributed by\n# sanjeev2552\n", "from math import gcd\n \ndef lcm(a, b):\n    return a*b // gcd(a, b)\n \ndef range_lcm_queries(arr, queries):\n    results = []\n    for query in queries:\n        l, r = query\n        lcm_val = arr[l]\n        for i in range(l+1, r+1):\n            lcm_val = lcm(lcm_val, arr[i])\n        results.append(lcm_val)\n    return results\n \n# example usage\narr = [5, 7, 5, 2, 10, 12 ,11, 17, 14, 1, 44]\nqueries = [(2, 5), (5, 10), (0, 10)]\nprint(range_lcm_queries(arr, queries))  # output: [60, 15708, 78540]\n"], "Range sum query using Sparse Table -  ": ["# Python3 program to find the sum in a given\n# range in an array using sparse table.\n \n# Because 2^17 is larger than 10^5\nk = 16\n \n# Maximum value of array\nn = 100000\n \n# k + 1 because we need to access\n# table[r][k]\n \ntable = [[0 for j in range(k+1)] for i in range(n)]\n \n# it builds sparse table\ndef buildSparseTable(arr, n):\n    global table, k\n    for i in range(n):\n        table[i][0] = arr[i]\n \n    for j in range(1,k+1):\n        for i in range(0,n-(1<<j)+1):\n            table[i][j] = table[i][j-1] + \\\n                          table[i + (1 << (j - 1))][j - 1]\n \n# Returns the sum of the elements in the range\n# L and R.\ndef query(L, R):\n    global table, k\n \n    # boundaries of next query, 0 - indexed\n    answer = 0\n    for j in range(k,-1,-1):\n        if (L + (1 << j) - 1 <= R):\n            answer = answer + table[L][j]\n \n            # instead of having L ', we\n            # increment L directly\n            L+=1<<j\n \n    return answer\n \n# Driver program\nif __name__ == '__main__':\n    arr = [3, 7, 2, 5, 8, 9]\n    n = len(arr)\n \n    buildSparseTable(arr, n)\n    print(query(0,5))\n    print(query(3,5))\n    print(query(2,4))\n     \n# This code is contributed by \n# chaudhary_19 (Mayank Chaudhary)\n"], "Sparse Table -  ": ["# Python3 program to do range minimum \n# query using sparse table \nimport math\n \n# Fills lookup array lookup[][] in \n# bottom up manner. \ndef buildSparseTable(arr, n):\n \n    # Initialize M for the intervals\n    # with length 1 \n    for i in range(0, n): \n        lookup[i][0] = arr[i] \n     \n    j = 1\n     \n    # Compute values from smaller to \n    # bigger intervals \n    while (1 << j) <= n: \n \n        # Compute minimum value for all \n        # intervals with size 2^j\n        i = 0\n        while (i + (1 << j) - 1) < n: \n \n            # For arr[2][10], we compare arr[lookup[0][7]] \n            # and arr[lookup[3][10]] \n            if (lookup[i][j - 1] < \n                lookup[i + (1 << (j - 1))][j - 1]): \n                lookup[i][j] = lookup[i][j - 1] \n            else:\n                lookup[i][j] = \\\n                        lookup[i + (1 << (j - 1))][j - 1] \n             \n            i += 1\n        j += 1       \n \n# Returns minimum of arr[L..R] \ndef query(L, R): \n \n    # Find highest power of 2 that is smaller \n    # than or equal to count of elements in \n    # given range. For [2, 10], j = 3 \n    j = int(math.log2(R - L + 1)) \n \n    # Compute minimum of last 2^j elements \n    # with first 2^j elements in range. \n    # For [2, 10], we compare arr[lookup[0][3]] \n    # and arr[lookup[3][3]], \n    if lookup[L][j] <= lookup[R - (1 << j) + 1][j]: \n        return lookup[L][j] \n \n    else:\n        return lookup[R - (1 << j) + 1][j] \n \n# Driver Code\nif __name__ == '__main__':\n \n    a = [7, 2, 3, 0, 5, 10, 3, 12, 18] \n    n = len(a) \n    MAX = 500\n     \n    # lookup[i][j] is going to store minimum \n    # value in arr[i..j]. Ideally lookup table \n    # size should not be fixed and should be \n    # determined using n Log n. It is kept \n    # constant to keep code simple. \n    lookup = [[0 for i in range(MAX)]\n                 for j in range(MAX)]\n \n    buildSparseTable(a, n) \n    print(query(0, 4)) \n    print(query(4, 7)) \n    print(query(7, 8)) \n     \n# This code is contributed by Rituraj Jain\n", "# Python3 program to do range minimum \n# query using sparse table \nimport math\n \n# Fills lookup array lookup[][] in \n# bottom up manner. \ndef buildSparseTable(arr, n):\n \n    # GCD of single element is element itself \n    for i in range(0, n): \n        table[i][0] = arr[i] \n \n    # Build sparse table\n    j = 1\n    while (1 << j) <= n: \n        i = 0\n        while i <= n - (1 << j): \n            table[i][j] = math.gcd(table[i][j - 1], \n                                   table[i + (1 << (j - 1))][j - 1])\n             \n            i += 1\n        j += 1\n \n# Returns minimum of arr[L..R] \ndef query(L, R): \n \n    # Find highest power of 2 that is smaller \n    # than or equal to count of elements in \n    # given range. For [2, 10], j = 3 \n    j = int(math.log2(R - L + 1)) \n \n    # Compute GCD of last 2^j elements with \n    # first 2^j elements in range. \n    # For [2, 10], we find GCD of arr[lookup[0][3]] \n    # and arr[lookup[3][3]], \n    return math.gcd(table[L][j], \n                    table[R - (1 << j) + 1][j])\n     \n# Driver Code \nif __name__ == '__main__':\n \n    a = [7, 2, 3, 0, 5, 10, 3, 12, 18] \n    n = len(a) \n    MAX = 500\n     \n    # lookup[i][j] is going to store minimum \n    # value in arr[i..j]. Ideally lookup table \n    # size should not be fixed and should be \n    # determined using n Log n. It is kept \n    # constant to keep code simple. \n    table = [[0 for i in range(MAX)] \n                for j in range(MAX)]\n \n    buildSparseTable(a, n) \n    print(query(0, 2)) \n    print(query(1, 3)) \n    print(query(4, 5)) \n     \n# This code is contributed by Rituraj Jain\n"], "Square Root (Sqrt) Decomposition Algorithm -  ": ["arr = [0] * 10000  # original array\n \n# Time Complexity: O(r-l+1)\ndef query(l, r):\n    _sum = 0\n    for i in range(l, r + 1):\n        _sum += arr[i]\n    return _sum\n \n# Driver code\nif __name__ == '__main__':\n    # We have used separate list for input because\n    # the purpose of this code is to explain simple\n    # array query using iteration in competitive\n    # programming where we have multiple inputs.\n    input_arr = [1, 5, 2, 4, 6, 1, 3, 5, 7, 10]\n \n    # copying input_arr to arr\n    arr[:len(input_arr)] = input_arr\n \n    print('query(3,8) :', query(3, 8))\n    print('query(1,6) :', query(1, 6))\n    arr[8] = 0  # updating arr[8] to 0\n    print('query(8,8) :', query(8, 8))\n", "# Python 3 program to demonstrate working of Square Root\n# Decomposition.\nfrom math import sqrt\n \nMAXN = 10000\nSQRSIZE = 100\n \narr = [0]*(MAXN)         # original array\nblock = [0]*(SQRSIZE)     # decomposed array\nblk_sz = 0                 # block size\n \n# Time Complexity : O(1)\n \n \ndef update(idx, val):\n    blockNumber = idx // blk_sz\n    block[blockNumber] += val - arr[idx]\n    arr[idx] = val\n \n# Time Complexity : O(sqrt(n))\n \n \ndef query(l, r):\n    sum = 0\n    while (l < r and l % blk_sz != 0 and l != 0):\n \n        # traversing first block in range\n        sum += arr[l]\n        l += 1\n \n    while (l + blk_sz - 1 <= r):\n \n        # traversing completely overlapped blocks in range\n        sum += block[l//blk_sz]\n        l += blk_sz\n \n    while (l <= r):\n \n        # traversing last block in range\n        sum += arr[l]\n        l += 1\n \n    return sum\n \n# Fills values in input[]\n \n \ndef preprocess(input, n):\n \n    # initiating block pointer\n    blk_idx = -1\n \n    # calculating size of block\n    global blk_sz\n    blk_sz = int(sqrt(n))\n \n    # building the decomposed array\n    for i in range(n):\n        arr[i] = input[i]\n        if (i % blk_sz == 0):\n \n            # entering next block\n            # incrementing block pointer\n            blk_idx += 1\n \n        block[blk_idx] += arr[i]\n \n# Driver code\n \n \n# We have used separate array for input because\n# the purpose of this code is to explain SQRT\n# decomposition in competitive programming where\n# we have multiple inputs.\ninput = [1, 5, 2, 4, 6, 1, 3, 5, 7, 10]\nn = len(input)\n \npreprocess(input, n)\n \nprint('query(3,8) : ', query(3, 8))\nprint('query(1,6) : ', query(1, 6))\nupdate(8, 0)\nprint('query(8,8) : ', query(8, 8))\n \n# This code is contributed by Sanjit_Prasad\n"], "MO's Algorithm (Query Square Root Decomposition) | Set 1 (Introduction) -  ": ["# Python program to compute sum of ranges for different range queries.\n \n# Function that accepts array and list of queries and print sum of each query\ndef printQuerySum(arr,Q):\n     \n    for q in Q: # Traverse through each query\n        L,R = q # Extract left and right indices\n        s = 0\n        for i in range(L,R+1): # Compute sum of current query range\n            s += arr[i]\n             \n        print('Sum of',q,'is',s) # Print sum of current query range\n \n# Driver script\narr = [1, 1, 2, 1, 3, 4, 5, 2, 8]\nQ = [[0, 4], [1, 3], [2, 4]]\nprintQuerySum(arr,Q)\n#This code is contributed by Shivam Singh\n", "# Python program to compute sum of ranges for different range queries \n \nimport math\n \n# Function that accepts array and list of queries and print sum of each query\ndef queryResults(arr,Q):\n     \n    #Q.sort(): # Sort by L\n    #sort all queries so that all queries in the increasing order of R values .  \n    Q.sort(key=lambda x: x[1])\n     \n    # Initialize current L, current R and current sum\n    currL,currR,currSum = 0,0,0\n     \n    # Traverse through all queries\n    for i in range(len(Q)):\n        L,R = Q[i] # L and R values of current range\n         \n        # Remove extra elements from previous range\n        # if previous range is [0, 3] and current  \n        # range is [2, 5], then a[0] and a[1] are subtracted  \n        while currL<L:\n            currSum-=arr[currL]\n            currL+=1\n             \n        # Add elements of current range\n        while currL>L:\n            currSum+=arr[currL-1]\n            currL-=1\n        while currR<=R:\n            currSum+=arr[currR]\n            currR+=1\n             \n        # Remove elements of previous range\n        # when previous range is [0, 10] and current range  \n        # is [3, 8], then a[9] and a[10] are subtracted  \n        while currR>R+1:\n            currSum-=arr[currR-1]\n            currR-=1\n         \n        # Print the sum of current range\n        print('Sum of',Q[i],'is',currSum)\n \narr = [1, 1, 2, 1, 3, 4, 5, 2, 8]\nQ = [[0, 4], [1, 3], [2, 4]]\nqueryResults(arr,Q)\n#This code is contributed by Shivam Singh\n"], "Equilibrium index of an array -  ": ["# Python3 program to find equilibrium\n# index of an array\n \n# function to find the equilibrium index\n \n \ndef equilibrium(arr):\n    leftsum = 0\n    rightsum = 0\n    n = len(arr)\n \n    # Check for indexes one by one\n    # until an equilibrium index is found\n    for i in range(n):\n        leftsum = 0\n        rightsum = 0\n \n        # get left sum\n        for j in range(i):\n            leftsum += arr[j]\n \n        # get right sum\n        for j in range(i + 1, n):\n            rightsum += arr[j]\n \n        # if leftsum and rightsum are same,\n        # then we are done\n        if leftsum == rightsum:\n            return i\n \n    # return -1 if no equilibrium index is found\n    return -1\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [-7, 1, 5, 2, -4, 3, 0]\n \n    # Function call\n    print(equilibrium(arr))\n \n# This code is contributed by Abhishek Sharama\n", "# Python program to find the equilibrium\n# index of an array\n \n# Function to find the equilibrium index\n \n \ndef equilibrium(arr):\n \n    # finding the sum of whole array\n    total_sum = sum(arr)\n    leftsum = 0\n    for i, num in enumerate(arr):\n \n        # total_sum is now right sum\n        # for index i\n        total_sum -= num\n \n        if leftsum == total_sum:\n            return i\n        leftsum += num\n \n      # If no equilibrium index found,\n      # then return -1\n    return -1\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [-7, 1, 5, 2, -4, 3, 0]\n \n    # Function call\n    print('First equilibrium index is ',\n          equilibrium(arr))\n \n# This code is contributed by Abhishek Sharma\n", "# Python3 program to find the equilibrium\n# index of an array\n \n# Function to find the equilibrium index\n \n \ndef equilibrium(arr):\n    left_sum = []\n    right_sum = []\n \n    # Iterate from 0 to len(arr)\n    for i in range(len(arr)):\n \n        # If i is not 0\n        if(i):\n            left_sum.append(left_sum[i-1]+arr[i])\n            right_sum.append(right_sum[i-1]+arr[len(arr)-1-i])\n        else:\n            left_sum.append(arr[i])\n            right_sum.append(arr[len(arr)-1])\n \n    # Iterate from 0 to len(arr)\n    for i in range(len(arr)):\n        if(left_sum[i] == right_sum[len(arr) - 1 - i]):\n            return(i)\n \n    # If no equilibrium index found,then return -1\n    return -1\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [-7, 1, 5, 2, -4, 3, 0]\n \n    # Function call\n    print('First equilibrium index is ',\n          equilibrium(arr))\n \n# This code is contributed by Lokesh Sharma\n", "from typing import List\n \ndef pivotIndex(nums: List[int]) -> int:\n    left, pivot, right = 0, 0, sum(nums)-nums[0]\n    while pivot < len(nums)-1 and right != left:\n        pivot += 1\n        right -= nums[pivot]\n        left += nums[pivot-1]\n \n    return pivot if left == right else -1\n \ndef main():\n    # test the function with an example array\n    nums = [1, 7, 3, 6, 5, 6]\n    result = pivotIndex(nums)\n    print(result)\n \nif __name__ == '__main__':\n    main()\n"], "Two Pointers Technique -  ": ["# Python Program Illustrating Naive Approach to\n# Find if There is a Pair in A[0..N-1] with Given Sum\n \n# Method\n \n \ndef isPairSum(A, N, X):\n \n    for i in range(N):\n        for j in range(N):\n \n            # as equal i and j means same element\n            if(i == j):\n                continue\n \n            # pair exists\n            if (A[i] + A[j] == X):\n                return True\n \n            # as the array is sorted\n            if (A[i] + A[j] > X):\n                break\n \n    # No pair found with given sum\n    return 0\n \n \n# Driver code\narr = [2, 3, 5, 8, 9, 10, 11]\nval = 17\n \nprint(isPairSum(arr, len(arr), val))\n \n# This code is contributed by maheshwaripiyush9\n", "from typing import List\n \n \ndef isPairSum(A: List[int], N: int, X: int) -> bool:\n    # represents first pointer\n    i = 0\n \n    # represents second pointer\n    j = N - 1\n \n    while i < j:\n        # If we find a pair\n        if A[i] + A[j] == X:\n            return True\n \n        # If sum of elements at current\n        # pointers is less, we move towards\n        # higher values by doing i++\n        elif A[i] + A[j] < X:\n            i += 1\n \n        # If sum of elements at current\n        # pointers is more, we move towards\n        # lower values by doing j--\n        else:\n            j -= 1\n \n    return False\n \n \n# Driver code\nif __name__ == '__main__':\n    # array declaration\n    arr = [2, 3, 5, 8, 9, 10, 11]\n \n    # value to search\n    val = 17\n \n    # size of the array\n    arrSize = len(arr)\n \n    # array should be sorted before using the two-pointer technique\n    arr.sort()\n \n    # Function call\n    print(isPairSum(arr, arrSize, val))\n"], "Merge two sorted arrays with O(1) extra space -  ": ["# Python program to merge\n# two sorted arrays\n# with O(1) extra space.\n \n# Merge ar1[] and ar2[]\n# with O(1) extra space\n \n \ndef merge(ar1, ar2, m, n):\n \n    # Iterate through all\n    # elements of ar2[] starting from\n    # the last element\n    for i in range(n-1, -1, -1):\n \n        # Find the smallest element\n        # greater than ar2[i]. Move all\n        # elements one position ahead\n        # till the smallest greater\n        # element is not found\n        last = ar1[m-1]\n        j = m-2\n        while(j >= 0 and ar1[j] > ar2[i]):\n            ar1[j+1] = ar1[j]\n            j -= 1\n \n        # If there was a greater element\n        if (last > ar2[i]):\n \n            ar1[j+1] = ar2[i]\n            ar2[i] = last\n \n# Driver code\nar1 = [1, 5, 9, 10, 15, 20]\nar2 = [2, 3, 8, 13]\nm = len(ar1)\nn = len(ar2)\n \nmerge(ar1, ar2, m, n)\n \nprint('After Merging \\nFirst Array:', end='')\nfor i in range(m):\n    print(ar1[i], ' ', end='')\n \nprint('\\nSecond Array: ', end='')\nfor i in range(n):\n    print(ar2[i], ' ', end='')\n \n# This code is contributed\n# by Anant Agarwal.\n", "# Python program for the above approach\narr1 = [1, 5, 9, 10, 15, 20]\narr2 = [2, 3, 8, 13]\n \n# Function to merge two arrays\n \n \ndef merge(n, m):\n    i = 0\n    j = 0\n    k = n - 1\n    while (i <= k and j < m):\n        if (arr1[i] < arr2[j]):\n            i += 1\n        else:\n            temp = arr2[j]\n            arr2[j] = arr1[k]\n            arr1[k] = temp\n            j += 1\n            k -= 1\n \n    arr1.sort()\n    arr2.sort()\n \n \n# Driver code\nif __name__ == '__main__':\n    merge(len(arr1), len(arr2))\n    print('After Merging \\nFirst Array: ', ','.join(str(x) for x in arr1))\n    print('Second Array: ', ','.join(str(x) for x in arr2))\n # This code is contributed by gauravrajput1\n", "# Python3 program for the above approach\n \narr1 = [1, 5, 9, 10, 15, 20]\narr2 = [2, 3, 8, 13]\n \n \ndef merge(n, m):\n    i = 0\n    temp = 0\n \n    # While loop till last element\n    # of array 1(sorted)\n    # is greater than first element\n    # of array 2(sorted)\n    while (arr1[n - 1] > arr2[0]):\n        if (arr1[i] > arr2[0]):\n \n            # Swap arr1[i] with first element\n            # of arr2 and sorting the updated\n            # arr2(arr1 is already sorted)\n            # swap(arr1[i],arr2[0]);\n            temp = arr1[i]\n            arr1[i] = arr2[0]\n            arr2[0] = temp\n            arr2.sort()\n \n        i += 1\n \n \n# Driver code\nif __name__ == '__main__':\n    merge(len(arr1), len(arr2))\n \n    print('After Merging \\nFirst Array: ', arr1)\n \n    print('Second Array: ', arr2)\n \n \n# This code contributed by gauravrajput1\n", "# Python program to merge\n# two sorted arrays\n# with O(1) extra space.\n \n# Merge ar1[] and ar2[]\n# with O(1) extra space\n \n \ndef rotate(a, n, idx):\n    for i in range((int)(idx/2)):\n        a[i], a[idx-1-i] = a[idx-1-i], a[i]\n    for i in range(idx, (int)((n+idx)/2)):\n        a[i], a[n-1-(i-idx)] = a[n-1-(i-idx)], a[i]\n    for i in range((int)(n/2)):\n        a[i], a[n-1-i] = a[n-1-i], a[i]\n \n \ndef sol(a1, a2, n, m):\n    l = 0\n    h = n-1\n    idx = 0\n    while (l <= h):\n        c1 = (int)((l+h)/2)\n        c2 = n-c1-1\n        l1 = a1[c1]\n        l2 = a2[c2-1]\n        r1 = sys.maxint if c1 == n-1 else a1[c1+1]\n        r2 = sys.maxint if c2 == m else a2[c2]\n        if l1 > r2:\n            h = c1-1\n            if h == -1:\n                idx = 0\n        elif l2 > r1:\n            l = c1+1\n            if l == n-1:\n                idx = n\n        else:\n            idx = c1+1\n            break\n    for i in range(idx, n):\n        a1[i], a2[i-idx] = a2[i-idx], a1[i]\n \n    a1.sort()\n    a2.sort()\n \n \ndef merge(a1, a2, n, m):\n    if n > m:\n        sol(a2, a1, m, n)\n        rotate(a1, n, n-m)\n        for i in range(m):\n            a1[i], a2[i] = a2[i], a1[i]\n    else:\n        sol(a1, a2, n, m)\n# Driver program\n \n \nar1 = [1, 5, 9, 10, 15, 20]\nar2 = [2, 3, 8, 13]\nm = len(ar1)\nn = len(ar2)\n \nmerge(ar1, ar2, m, n)\n \nprint('After Merging \\nFirst Array:', end='')\nfor i in range(m):\n    print(ar1[i], ' ', end='')\nprint('\\nSecond Array: ', end='')\nfor i in range(n):\n    print(ar2[i], ' ', end='')\n# This code is contributed\n# by Aditya Anand.\n", "# code contributed by mahee96\n \n# 'Insertion sort of list 2 with swaps from list 1'\n#\n# swap elements to get list 1 correctly, meanwhile\n# place the swapped item in correct position of list 2\n# eventually list 2 is also sorted\n# Time = O(m*n) or O(n*m)\n# AUX = O(1)\n \n \ndef merge(arr1, arr2):\n    x = arr1\n    y = arr2\n    end = len(arr1)\n    i = 0\n    while(i < end):                 # O(m) or O(n)\n        if(x[i] > y[0]):\n            swap(x, y, i, 0)\n            insert(y, 0)             # O(n) or O(m) number of shifts\n        i += 1\n \n# O(n):\n \n \ndef insert(y, i):\n    orig = y[i]\n    i += 1\n    while (i < len(y) and y[i] < orig):\n        y[i-1] = y[i]\n        i += 1\n    y[i-1] = orig\n \n \ndef swap(x, y, i, j):\n    temp = x[i]\n    x[i] = y[j]\n    y[j] = temp\n \n \ndef test():\n    c1 = [2, 3, 8, 13]\n    c2 = [1, 5, 9, 10, 15, 20]\n    c1, c2 = c2, c1\n    merge(c1, c2)\n    print(c1, c2)\n         \n \n \ntest()\n", "# Python3 program to merge two sorted arrays without using extra space\n \n \ndef merge(arr1, arr2, n, m):\n    # three pointers to iterate\n    i = 0\n    j = 0\n    k = 0\n    # for euclid's division lemma\n    x = 10e7 + 1\n    # in this loop we are rearranging the elements of arr1\n    while i < n and (j < n and k < m):\n        # if both arr1 and arr2 elements are modified\n        if arr1[j] >= x and arr2[k] >= x:\n            if arr1[j] % x <= arr2[k] % x:\n                arr1[i] += (arr1[j] % x) * x\n                j += 1\n            else:\n                arr1[i] += (arr2[k] % x) * x\n                k += 1\n        # if only arr1 elements are modified\n        elif arr1[j] >= x:\n            if arr1[j] % x <= arr2[k]:\n                arr1[i] += (arr1[j] % x) * x\n                j += 1\n            else:\n                arr1[i] += (arr2[k] % x) * x\n                k += 1\n        # if only arr2 elements are modified\n        elif arr2[k] >= x:\n            if arr1[j] <= arr2[k] % x:\n                arr1[i] += (arr1[j] % x) * x\n                j += 1\n            else:\n                arr1[i] += (arr2[k] % x) * x\n                k += 1\n        # if none elements are modified\n        else:\n            if arr1[j] <= arr2[k]:\n                arr1[i] += (arr1[j] % x) * x\n                j += 1\n            else:\n                arr1[i] += (arr2[k] % x) * x\n                k += 1\n        i += 1\n \n    #  we can copy the elements directly as the other array\n    #  is exchausted\n    while j < n and i < n:\n        arr1[i] += (arr1[j] % x) * x\n        i += 1\n        j += 1\n    while k < m and i < n:\n        arr1[i] += (arr2[k] % x) * x\n        i += 1\n        k += 1\n    #  we need to reset i\n    i = 0\n \n    # in this loop we are rearranging the elements of arr2\n    while i < m and (j < n and k < m):\n        # if both arr1 and arr2 elements are modified\n        if arr1[j] >= x and arr2[k] >= x:\n            if arr1[j] % x <= arr2[k] % x:\n                arr2[i] += (arr1[j] % x) * x\n                j += 1\n \n            else:\n                arr2[i] += (arr2[k] % x) * x\n                k += 1\n \n        # if only arr1 elements are modified\n        elif arr1[j] >= x:\n            if arr1[j] % x <= arr2[k]:\n                arr2[i] += (arr1[j] % x) * x\n                j += 1\n \n            else:\n                arr2[i] += (arr2[k] % x) * x\n                k += 1\n \n        # if only arr2 elements are modified\n        elif arr2[k] >= x:\n            if arr1[j] <= arr2[k] % x:\n                arr2[i] += (arr1[j] % x) * x\n                j += 1\n \n            else:\n                arr2[i] += (arr2[k] % x) * x\n                k += 1\n \n        else:\n            # if none elements are modified\n            if arr1[j] <= arr2[k]:\n                arr2[i] += (arr1[j] % x) * x\n                j += 1\n \n            else:\n                arr2[i] += (arr2[k] % x) * x\n                k += 1\n \n        i += 1\n    # we can copy the elements directly as the other array\n    # is exhausted\n    while j < n and i < m:\n        arr2[i] += (arr1[j] % x) * x\n        i += 1\n        j += 1\n \n    while k < m and i < m:\n        arr2[i] += (arr2[k] % x) * x\n        i += 1\n        k += 1\n \n    # we need to reset i\n    i = 0\n    # we need to divide the whole arr1 by x\n    while i < n:\n        arr1[i] /= x\n        i += 1\n \n    # we need to reset i\n    i = 0\n    # we need to divide the whole arr2 by x\n    while i < m:\n        arr2[i] /= x\n        i += 1\n \n# Driver program\n \n \nar1 = [1, 5, 9, 10, 15, 20]\nar2 = [2, 3, 8, 13]\nm = len(ar1)\nn = len(ar2)\n \nmerge(ar1, ar2, m, n)\n \nprint('After Merging \\nFirst Array:', end=' ')\nfor i in range(m):\n    print(int(ar1[i]), end=' ')\nprint('\\nSecond Array:', end=' ')\nfor i in range(n):\n    print(int(ar2[i]), end=' ')\n \n# This code is contributed by Tapesh(tapeshdua420)\n", "# Python code\n \n#swap function\ndef swapIfGreater(ar1, ar2, i, j):\n    if ar1[i] > ar2[j]:\n        ar1[i], ar2[j] = ar2[j], ar1[i]\n \ndef merge(ar1, ar2, m, n):\n    len_arr = m + n\n    gap = len_arr // 2 + (len_arr % 2)\n \n    while gap > 0:\n        left, right = 0, gap\n        while right < len_arr:\n            # If left pointer is in ar1[] and right in ar2[]\n            if left < m and right < m:\n                swapIfGreater(ar1, ar1, left, right)\n \n            # If left pointer is in ar1[] and right in ar2[]\n            elif left < m and right >= m:\n                swapIfGreater(ar1, ar2, left, right - m)\n \n            # If both left and right pointers are in ar2[]\n            else:\n                swapIfGreater(ar2, ar2, left - m, right - m)\n \n            left += 1\n            right += 1\n \n        if gap == 1:\n            break\n \n        # Decrement the gap value if right reaches the end i.e len_arr\n        gap = (gap // 2) + (gap % 2)\n \nif __name__ == '__main__':\n    ar1 = [1, 5, 9, 10, 15, 20]\n    ar2 = [2, 3, 8, 13]\n    m = len(ar1)\n    n = len(ar2)\n    merge(ar1, ar2, m, n)\n \n    print('After Merging')\n    print('First Array:', *ar1)\n    print('Second Array:', *ar2)\n        \n# This code is contributed by guptapratik\n"], "Smallest subarray with sum greater than a given value -  ": ["# Python3 program to find Smallest \n# subarray with sum greater \n# than a given value\n \n# Returns length of smallest subarray\n# with sum greater than x. If there\n# is no subarray with given sum, \n# then returns n+1\ndef smallestSubWithSum(arr, n, x):\n \n    # Initialize length of smallest\n    # subarray as n+1\n    min_len = n + 1\n \n    # Pick every element as starting point\n    for start in range(0,n):\n     \n        # Initialize sum starting \n        # with current start\n        curr_sum = arr[start]\n \n        # If first element itself is greater\n        if (curr_sum > x):\n            return 1\n \n        # Try different ending points\n        # for current start\n        for end in range(start+1,n):\n         \n            # add last element to current sum\n            curr_sum += arr[end]\n \n            # If sum becomes more than x \n            # and length of this subarray\n            # is smaller than current smallest\n            # length, update the smallest \n            # length (or result)\n            if curr_sum > x and (end - start + 1) < min_len:\n                min_len = (end - start + 1)\n         \n    return min_len;\n \n \n# Driver program to test above function */\narr1 = [1, 4, 45, 6, 10, 19]\nx = 51\nn1 = len(arr1)\nres1 = smallestSubWithSum(arr1, n1, x);\nif res1 == n1+1:\n    print('Not possible')\nelse:\n    print(res1)\n \narr2 = [1, 10, 5, 2, 7]\nn2 = len(arr2)\nx = 9\nres2 = smallestSubWithSum(arr2, n2, x);\nif res2 == n2+1:\n    print('Not possible')\nelse:\n    print(res2)\n \narr3 = [1, 11, 100, 1, 0, 200, 3, 2, 1, 250]\nn3 = len(arr3)\nx = 280\nres3 = smallestSubWithSum(arr3, n3, x)\nif res3 == n3+1:\n    print('Not possible') \nelse:\n    print(res3)\n     \n# This code is contributed by Smitha Dinesh Semwal\n", "# O(n) solution for finding smallest\n# subarray with sum greater than x\n \n# Returns length of smallest subarray\n# with sum greater than x. If there\n# is no subarray with given sum, then\n# returns n + 1\n \n \ndef smallestSubWithSum(arr, n, x):\n \n    # Initialize current sum and minimum length\n    curr_sum = 0\n    min_len = n + 1\n \n    # Initialize starting and ending indexes\n    start = 0\n    end = 0\n    while (end < n):\n \n        # Keep adding array elements while current\n        # sum is smaller than or equal to x\n        while (curr_sum <= x and end < n):\n            curr_sum += arr[end]\n            end += 1\n \n        # If current sum becomes greater than x.\n        while (curr_sum > x and start < n):\n \n            # Update minimum length if needed\n            if (end - start < min_len):\n                min_len = end - start\n \n            # remove starting elements\n            curr_sum -= arr[start]\n            start += 1\n \n    return min_len\n \n \n# Driver program\narr1 = [1, 4, 45, 6, 10, 19]\nx = 51\nn1 = len(arr1)\nres1 = smallestSubWithSum(arr1, n1, x)\nprint('Not possible') if (res1 == n1 + 1) else print(res1)\n \narr2 = [1, 10, 5, 2, 7]\nn2 = len(arr2)\nx = 9\nres2 = smallestSubWithSum(arr2, n2, x)\nprint('Not possible') if (res2 == n2 + 1) else print(res2)\n \narr3 = [1, 11, 100, 1, 0, 200, 3, 2, 1, 250]\nn3 = len(arr3)\nx = 280\nres3 = smallestSubWithSum(arr3, n3, x)\nprint('Not possible') if (res3 == n3 + 1) else print(res3)\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# O(n log(n) solution for finding smallest subarray with\n# sum greater than \nfrom bisect import bisect_left\n# Function to find the smallest subarray length with a \n# sum greater than a target value\ndef smallestSubArrayLen(target, nums):\n    # Get the length of the input list\n    n = len(nums)\n    # If the list is empty, return 0\n    if n == 0:\n        return 0\n    # Initialize the minimum subarray length to a large value\n    ans = float('inf')\n    # Create a new list 'sums' with size n+1, initialized to all zeros\n    sums = [0] * (n + 1)\n    # Compute the running sum of nums and store it in 'sums'\n    for i in range(1, n + 1):\n        sums[i] = sums[i - 1] + nums[i - 1]\n    # Iterate through each starting index i\n    for i in range(1, n + 1):\n        # Calculate the target sum for the subarray starting at index i\n        to_find = target + sums[i - 1]\n        # Find the first element in 'sums' that is >= to_find\n        bound = bisect_left(sums, to_find)\n        # If such an element is found and it is not equal to to_find itself\n        if bound != len(sums) and sums[bound] != to_find:\n            # Compute the length of the subarray and update ans if necessary\n            length = bound - (i - 1)\n            ans = min(ans, length)\n    # Return ans if it was updated, otherwise return 0\n    return ans if ans != float('inf') else 0\n \n# Driver code to test the function\narr1 = [1, 4, 45, 6, 10, 19]\ntarget1 = 51\nprint('Length of Smallest Subarray:', smallestSubArrayLen(target1, arr1))\n \narr2 = [1, 10, 5, 2, 7]\ntarget2 = 9\nprint('Length of Smallest Subarray:', smallestSubArrayLen(target2, arr2))\n \narr3 = [1, 1, 1, 1, 1, 1, 1, 1]\ntarget3 = 11\nprint('Length of Smallest Subarray:', smallestSubArrayLen(target3, arr3))\n \narr4 = [1, 11, 100, 1, 0, 200, 3, 2, 1, 250]\ntarget4 = 280\nprint('Length of Smallest Subarray:', smallestSubArrayLen(target4, arr4))\n"], "Maximum profit by buying and selling a share at most twice -  ": ["# Returns maximum profit with\n# two transactions on a given\n# list of stock prices price[0..n-1]\n \n \ndef maxProfit(price, n):\n \n    # Create profit array and initialize it as 0\n    profit = [0]*n\n \n    # Get the maximum profit\n    # with only one transaction\n    # allowed. After this loop,\n    # profit[i] contains maximum\n    # profit from price[i..n-1]\n    # using at most one trans.\n    max_price = price[n-1]\n \n    for i in range(n-2, 0, -1):\n \n        if price[i] > max_price:\n            max_price = price[i]\n \n        # we can get profit[i] by\n        # taking maximum of:\n        # a) previous maximum,\n        # i.e., profit[i+1]\n        # b) profit by buying at\n        # price[i] and selling at\n        #    max_price\n        profit[i] = max(profit[i+1], max_price - price[i])\n \n    # Get the maximum profit\n    # with two transactions allowed\n    # After this loop, profit[n-1]\n    # contains the result\n    min_price = price[0]\n \n    for i in range(1, n):\n \n        if price[i] < min_price:\n            min_price = price[i]\n \n        # Maximum profit is maximum of:\n        # a) previous maximum,\n        # i.e., profit[i-1]\n        # b) (Buy, Sell) at\n        # (min_price, A[i]) and add\n        #  profit of other trans.\n        # stored in profit[i]\n        profit[i] = max(profit[i-1], profit[i]+(price[i]-min_price))\n \n    result = profit[n-1]\n \n    return result\n \n \n# Driver function\nprice = [2, 30, 15, 10, 8, 25, 80]\nprint ('Maximum profit is', maxProfit(price, len(price)))\n \n# This code is contributed by __Devesh Agrawal__\n", "import sys\n \ndef maxtwobuysell(arr, size):\n    first_buy = -sys.maxsize; \n    first_sell = 0;\n    second_buy = -sys.maxsize; \n    second_sell = 0;\n \n    for i in range(size):\n \n        first_buy = max(first_buy, -arr[i]);\n        first_sell = max(first_sell, first_buy + arr[i]);\n        second_buy = max(second_buy, first_sell - arr[i]);\n        second_sell = max(second_sell, second_buy + arr[i]);\n \n     \n    return second_sell;\n \nif __name__ == '__main__':\n    arr = [ 2, 30, 15, 10, 8, 25, 80 ];\n    size = len(arr);\n    print(maxtwobuysell(arr, size));\n \n# This code is contributed by gauravrajput1 \n", "def f(idx, buy, prices, cap, n):\n    if cap == 0:\n        return 0\n \n    if idx == n:\n        return 0\n \n    profit = 0\n    # you can either buy or not buy\n    if buy == 0:\n        profit = max(-prices[idx] + f(idx + 1, 1, prices, cap, n),\n                     f(idx + 1, 0, prices, cap, n))\n    # you can either sell or not sell\n    else:\n        profit = max(prices[idx] + f(idx + 1, 0, prices, cap - 1, n),\n                     f(idx + 1, 1, prices, cap, n))\n \n    return profit\n \ndef maxtwobuysell(prices, n):\n    return f(0, 0, prices, 2, n)\n \n \nif __name__ == '__main__':\n    arr = [2, 30, 15, 10, 8, 25, 80]\n    size = len(arr)\n    print(maxtwobuysell(arr, size))\n \n    # This code is contributed by prajwalkandekar123.\n", "# Python program for the above approach\nimport sys\n \ndef f(idx, buy, prices, dp, cap, n):\n    if cap == 0:\n        return 0\n    if idx == n:\n        return 0\n    if dp[idx][buy][cap] != -1:\n        return dp[idx][buy][cap]\n \n    profit = 0\n     \n    # you can either buy or not buy\n    if buy == 0:\n        dp[idx][buy][cap] = profit = max(-prices[idx] +\n                                         f(idx + 1, 1, prices, dp, cap, n), \n                                         f(idx + 1, 0, prices, dp, cap, n))\n     \n    # you can either sell or not sell\n    else:\n        dp[idx][buy][cap] = profit = max(prices[idx] +\n                                         f(idx + 1, 0, prices, dp, cap - 1, n),\n                                         f(idx + 1, 1, prices, dp, cap, n))\n \n    return profit\n \ndef maxtwobuysell(prices, n):\n    dp = [[[-1 for _ in range(3)] for _ in range(2)] for _ in range(n)]\n    return f(0, 0, prices, dp, 2, n)\n \nif __name__ == '__main__':\n    arr = [2, 30, 15, 10, 8, 25, 80]\n    size = len(arr)\n    print(maxtwobuysell(arr, size))\n \n \n# This code is contributed by rishabmalhdjio\n"], "Difference Array | Range update query in O(1) -  ": ["# Python3 code to demonstrate Difference Array\n \n# Creates a diff array D[] for A[] and returns\n# it after filling initial values.\ndef initializeDiffArray( A):\n    n = len(A)\n \n    # We use one extra space because\n    # update(l, r, x) updates D[r+1]\n    D = [0 for i in range(0 , n + 1)]\n \n    D[0] = A[0]; D[n] = 0\n     \n    for i in range(1, n ):\n        D[i] = A[i] - A[i - 1]\n    return D\n \n \n# Does range update\ndef update(D, l, r, x):\n \n    D[l] += x\n    D[r + 1] -= x\n \n \n# Prints updated Array\ndef printArray(A, D):\n \n    for i in range(0 , len(A)):\n        if (i == 0):\n            A[i] = D[i]\n \n        # Note that A[0] or D[0] decides\n        # values of rest of the elements.\n        else:\n            A[i] = D[i] + A[i - 1]\n \n        print(A[i], end = ' ')\n     \n    print ('')\n \n \n# Driver Code\nA = [ 10, 5, 20, 40 ]\n \n# Create and fill difference Array\nD = initializeDiffArray(A)\n \n# After below update(l, r, x), the\n# elements should become 20, 15, 20, 40\nupdate(D, 0, 1, 10)\nprintArray(A, D)\n \n# After below updates, the\n# array should become 30, 35, 70, 60\nupdate(D, 1, 3, 20)\nupdate(D, 2, 2, 30)\nprintArray(A, D)\n \n# This code is contributed by Gitanjali.\n"], "Find the smallest missing number -  ": ["# Python3 program to find the smallest \n# elements missing in a sorted array. \n  \ndef findFirstMissing(array, start, end): \n  \n    if (start > end): \n        return end + 1\n  \n    if (start != array[start]): \n        return start; \n  \n    mid = int((start + end) / 2) \n  \n    # Left half has all elements \n    # from 0 to mid \n    if (array[mid] == mid): \n        return findFirstMissing(array, \n                          mid+1, end) \n  \n    return findFirstMissing(array,  \n                          start, mid) \n  \n  \n# driver program to test above function \narr = [0, 1, 2, 3, 4, 5, 6, 7, 10] \nn = len(arr) \nprint('Smallest missing element is', \n      findFirstMissing(arr, 0, n-1)) \n  \n# This code is contributed by Smitha Dinesh Semwal  \n", "# Python3 program for above approach  \n  \n# Function to find Smallest   \n# Missing in Sorted Array \ndef findSmallestMissinginSortedArray(arr): \n      \n    # Check if 0 is missing   \n    # in the array  \n    if (arr[0] != 0): \n        return 0\n      \n    # Check is all numbers 0 to n - 1   \n    # are present in array  \n    if (arr[-1] == len(arr) - 1): \n        return len(arr) \n      \n    first = arr[0] \n      \n    return findFirstMissing(arr, 0,  \n            len(arr) - 1, first) \n  \n# Function to find missing element   \ndef findFirstMissing(arr, start, end, first): \n      \n    if (start < end): \n        mid = int((start + end) / 2) \n          \n        # Index matches with value   \n        # at that index, means missing  \n        # element cannot be upto that point  \n        if (arr[mid] != mid + first): \n            return findFirstMissing(arr, start, \n                                    mid, first) \n        else: \n            return findFirstMissing(arr, mid + 1,   \n                                    end, first) \n      \n    return start + first \n  \n# Driver code \narr = [ 0, 1, 2, 3, 4, 5, 7 ] \nn = len(arr) \n  \n# Function Call  \nprint('First Missing element is :', \n      findSmallestMissinginSortedArray(arr)) \n  \n# This code is contributed by rag2127\n", "# Python program to find the smallest element missing in a sorted array. \n  \ndef findFirstMissing(arr, n, m): \n    vec = [0] * m \n  \n    for i in range(n): \n        vec[arr[i]] = 1\n          \n    for i in range(m): \n        if vec[i] == 0: \n            return i \n              \n    return m \n  \n# Driver code \narr = [0, 1, 2, 3, 4, 5, 6, 7, 10] \nn = len(arr) \nm = 11\nprint('Smallest missing element is', findFirstMissing(arr, n, m)) \n"], "Reorder an array according to given indexes -  ": ["# Python3 program to sort\n# an array according to given\n# indexes\n \n# Function to reorder\n# elements of arr[] according\n# to index[]\ndef reorder(arr,index, n):\n \n    temp = [0] * n;\n \n    # arr[i] should be\n        # present at index[i] index\n    for i in range(0,n):\n        temp[index[i]] = arr[i]\n \n    # Copy temp[] to arr[]\n    for i in range(0,n):\n        arr[i] = temp[i]\n        index[i] = i\n     \n# Driver program\narr = [50, 40, 70, 60, 90]\nindex = [3, 0, 4, 1, 2]\nn = len(arr)\n \nreorder(arr, index, n)\n \nprint('Reordered array is:')\nfor i in range(0,n):\n    print(arr[i],end = ' ')\n \nprint('\\nModified Index array is:')\nfor i in range(0,n):\n    print(index[i],end = ' ')\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# A O(n) time and O(1) extra space Python3 program to\n# sort an array according to given indexes\n \n# Function to reorder elements of arr[] according\n# to index[]\ndef reorder(arr, index, n):\n \n    # Fix all elements one by one\n    for i in range(0,n):\n \n           #  While index[i] and arr[i] are not fixed\n           while (index[i] != i):\n         \n               # Store values of the target (or correct) \n               # position before placing arr[i] there\n               oldTargetI = index[index[i]]\n               oldTargetE = arr[index[i]]\n \n               # Place arr[i] at its target (or correct)\n               # position. Also copy corrected index for\n               # new position\n               arr[index[i]] = arr[i]\n               index[index[i]] = index[i]\n \n               # Copy old target values to arr[i] and\n               # index[i]\n               index[i] = oldTargetI\n               arr[i] = oldTargetE\n \n \n# Driver program\narr = [50, 40, 70, 60, 90]\nindex= [3, 0, 4, 1, 2]\nn = len(arr)\n \nreorder(arr, index, n)\n \nprint('Reordered array is:')\nfor  i in range(0, n):\n    print(arr[i],end=' ')\n \nprint('\\nModified Index array is:')\nfor i in range(0, n):\n    print(index[i] ,end=' ')\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# Python implementation for the above approach\ndef printArray(arr):\n    for i in range(len(arr)):\n        print(arr[i], end=' ')\n \n# result = (original + update%z*z) ..\ndef rearrange(arr, index):\n    z = findMax(arr) + 1\n    for i in range(len(arr)):\n        arr[index[i]] = arr[index[i]] % z + arr[i] % z * z\n \n    for i in range(len(arr)):\n        arr[i] = arr[i]//z\n \n \ndef findMax(arr):\n    Max = float('-inf')\n    for i in range(len(arr)):\n        if(Max < arr[i]):\n            Max = arr[i]\n \n    return Max\n \narr = [23, 12, 20, 10, 23]\nindex = [4, 0, 1, 2, 3]\n \nrearrange(arr, index)\nprintArray(arr)\n \n# This code is contributed by lokesh\n"], "Rearrange positive and negative numbers in O(n) time and O(1) extra space -  ": ["#  Python program to put positive numbers at even indexes (0,  // 2, 4,..) and\n#  negative numbers at odd indexes (1, 3, 5, ..)\n \n# The main function that rearranges elements of given array. \n# It puts  positive elements at even indexes (0, 2, ..) and \n# negative numbers at odd indexes (1, 3, ..).\ndef rearrange(arr, n):\n    # The following few lines are similar to partition process\n    # of QuickSort.  The idea is to consider 0 as pivot and\n    # divide the array around it.\n    i = -1\n    for j in range(n):\n        if (arr[j] < 0):\n            i += 1\n            # swapping of arr\n            arr[i], arr[j] = arr[j], arr[i]\n  \n    # Now all positive numbers are at end and negative numbers\n    # at the beginning of array. Initialize indexes for starting\n    # point of positive and negative numbers to be swapped\n    pos, neg = i+1, 0\n  \n    # Increment the negative index by 2 and positive index by 1,\n    # i.e., swap every alternate negative number with next \n    # positive number\n    while (pos < n and neg < pos and arr[neg] < 0):\n \n        # swapping of arr\n        arr[neg], arr[pos] = arr[pos], arr[neg]\n        pos += 1\n        neg += 2\n \n# A utility function to print an array\ndef printArray(arr, n):\n     \n    for i in range(n):\n        print (arr[i],end=' ')\n  \n# Driver program to test above functions\narr = [-1, 2, -3, 4, 5, 6, -7, 8, 9]\nn = len(arr)\nrearrange(arr, n)\nprintArray(arr, n)\n \n# Contributed by Afzal\n"], "Rearrange an array such that arr[i] = i -  ": ["# Python3 program for above approach\n \n# Function to transform the array\ndef fixArray(ar, n):\n     \n    # Iterate over the array\n    for i in range(n):\n        for j in range(n):\n \n            # Check is any ar[j]\n            # exists such that\n            # ar[j] is equal to i\n            if (ar[j] == i):\n                ar[j], ar[i] = ar[i], ar[j]\n \n    # Iterate over array\n    for i in range(n):\n         \n        # If not present\n        if (ar[i] != i):\n            ar[i] = -1\n \n    # Print the output\n    print('Array after Rearranging')\n \n    for i in range(n):\n        print(ar[i], end = ' ')\n \n# Driver Code\nar = [ -1, -1, 6, 1, 9, 3, 2, -1, 4, -1 ]\nn = len(ar)\n \n# Function Call\nfixArray(ar, n);\n \n# This code is contributed by rag2127\n", "# Python3 program for rearrange an\n# array such that arr[i] = i.\n \n# Function to rearrange an array\n# such that arr[i] = i.\n \n \ndef fix(A, len):\n \n    for i in range(0, len):\n \n        if (A[i] != -1 and A[i] != i):\n            x = A[i]\n \n            # check if desired place\n            # is not vacate\n            while (A[x] != -1 and A[x] != x):\n                 \n                # store the value from\n                # desired place\n                y = A[x]\n \n                # place the x to its correct\n                # position\n                A[x] = x\n \n                # now y will become x, now\n                # search the place for x\n                x = y\n \n            # place the x to its correct\n            # position\n            A[x] = x\n \n            # check if while loop hasn't\n            # set the correct value at A[i]\n            if (A[i] != i):\n \n                # if not then put -1 at\n                # the vacated place\n                A[i] = -1\n \n \n# Driver code\nA = [-1, -1, 6, 1, 9, 3, 2, -1, 4, -1]\n \nfix(A, len(A))\n \nfor i in range(0, len(A)):\n    print(A[i], end=' ')\n \n# This code is contributed by Saloni1297\n", "# Python3 program for rearrange an \n# array such that arr[i] = i.\n \n# Function to rearrange an array\n# such that arr[i] = i.\ndef fix(A):\n    s = set()\n     \n    # Storing all the values in the Set\n    for i in range(len(A)):\n        s.add(A[i])\n \n    for i in range(len(A)):\n       \n        # check for item if present in set\n        if i in s:\n            A[i] = i\n        else:\n            A[i] = -1\n    return A\n     \n# Driver code\nif __name__ == '__main__':\n    A = [-1, -1, 6, 1, 9,\n          3, 2, -1, 4,-1]\n    print(fix(A))\n \n# This code is contributed by Chitranayal\n", "# Python3 program for rearrange an\n# array such that arr[i] = i.\nif __name__ == '__main__':\n \n    arr = [-1, -1, 6, 1, 9,\n           3, 2, -1, 4, -1]\n    n = len(arr)\n    i = 0\n    while i < n:\n \n        if (arr[i] >= 0 and arr[i] != i):\n            (arr[arr[i]],\n             arr[i]) = (arr[i],\n                        arr[arr[i]])\n        else:\n            i += 1\n \n    for i in range(n):\n        print(arr[i], end=' ')\n \n# This code is contributed by Chitranayal\n", "# Python program for rearranging\n# an array such that arr[i] = i.\n   \ndef fixArray(arr, n):\n    vec = [-1]*n\n   \n    # Traverse the array\n    for i in range(0, n):\n   \n        # If arr[i] is not -1 then arr[i]\n        # is at its correct position.\n        if (arr[i] != -1):\n            vec[arr[i]] = arr[i]\n   \n    # Copy vec[] to arr[]\n    for i in range(0, n):\n        arr[i] = vec[i]\n    return arr\n   \n# Driver code\narr = [-1, -1, 6, 1, 9, 3, 2, -1, 4, -1]\nn = len(arr)\n   \n# Function call\nfixArray(arr, n)\n   \n# Print output\nfor i in range(0, n):\n    print(arr[i], end=' ')\n"], "Leaders in an array -  ": ["# Python Function to print leaders in array \n \ndef printLeaders(arr,size): \n     \n    for i in range(0, size): \n        for j in range(i+1, size): \n            if arr[i]<=arr[j]: \n                break\n        if j == size-1: # If loop didn't break \n            print (arr[i],end=' ') \n \n# Driver function \narr=[16, 17, 4, 3, 5, 2] \nprintLeaders(arr, len(arr)) \n \n# This code is contributed by _Devesh Agrawal__ \n", "# Python function to print leaders in array\ndef printLeaders(arr, size):\n    \n    max_from_right = arr[size-1]   \n    print (max_from_right,end=' ')    \n    for i in range( size-2, -1, -1):        \n        if max_from_right < arr[i]:        \n            print (arr[i],end=' ')\n            max_from_right = arr[i]\n         \n# Driver function\narr = [16, 17, 4, 3, 5, 2]\nprintLeaders(arr, len(arr))\n \n# This code contributed by _Devesh Agrawal__\n", "# Python Function to print leaders in an array\ndef printLaders(arr, size):\n    # create stack to store leaders\n    sk = []\n    sk.append(arr[size - 1])\n    for i in range(size - 2, -1, -1):\n        if(arr[i] >= sk[len(sk) - 1]):\n            sk.append(arr[i])\n \n    # print stack elements\n    # run loop till stack is not empty\n    while(len(sk) != 0):\n        print(sk[len(sk)-1],end = ' ')\n        sk.pop()\n \n# Driver program to test above function\nif __name__ == '__main__':\n    arr = [16,17,4,3,5,2]\n    n = len(arr)\n    printLaders(arr,n)\n     \n    # This code is contributed by ajaymakvana\n"], "Find the element that appears once in an array where every other element appears twice -  ": ["# Python code to find the array element that appears only once \n  \n# Function to find the array \n# element that appears only once \ndef findSingle(A, ar_size): \n    \n    # iterate over every element \n    for i in range(ar_size): \n        \n        # Initialize count to 0 \n        count = 0\n        for j in range(ar_size): \n            \n            # Count the frequency \n            # of the element \n            if(A[i] == A[j]): \n                count += 1\n  \n        # If the frequency of \n        # the element is one \n        if(count == 1): \n            return A[i] \n            \n    # If no element exist \n    # at most once \n    return -1\n  \nar = [2, 3, 5, 4, 5, 3, 4] \nn = len(ar) \n# Function call \nprint('Element occurring once is', findSingle(ar, n)) \n  \n# This code is contributed by lokesh \n", "# Python3 program to find  \n# element that appears once \n  \n# function which find number \ndef singleNumber(nums): \n  \n# applying the formula. \n    return 2 * sum(set(nums)) - sum(nums) \n  \n# driver code \na = [2, 3, 5, 4, 5, 3, 4] \nprint (int(singleNumber(a))) \n  \na = [15, 18, 16, 18, 16, 15, 89] \nprint (int(singleNumber(a))) \n  \n# This code is contributed by 'Abhishek Sharma 44' \n", "def singleelement(arr, n): \n    low = 0\n    high = n - 2\n    mid = 0\n    while (low <= high): \n        mid = (low + high) // 2\n        if (arr[mid] == arr[mid ^ 1]): \n            low = mid + 1\n        else: \n            high = mid - 1\n      \n    return arr[low] \n      \n# Driver code \narr = [2, 3, 5, 4, 5, 3, 4] \nsize = len(arr) \narr.sort() \nprint(singleelement(arr, size)) \n  \n# This code is contributed by shivanisingh\n", "def singleelement(arr, n): \n    #dictionary to store frequency \n    mm = {} \n    for i in range(n): \n        #storing frequency \n        if arr[i] in mm: \n            mm[arr[i]] += 1\n        else: \n            mm[arr[i]] = 1\n      \n    #iterating over dictionary \n    for key, value in mm.items(): \n        #returning element with frequency 1 \n        if value == 1: \n            return key \n  \n#driver code \narr = [2, 3, 5, 4, 5, 3, 4] \nsize = len(arr) \narr.sort() \nprint(singleelement(arr, size)) \n"], "Print all Distinct ( Unique ) Elements in given Array -  ": ["# python program to print all distinct\n# elements in a given array\n \ndef printDistinct(arr, n):\n \n    # Pick all elements one by one\n    for i in range(0, n):\n \n        # Check if the picked element \n        # is already printed\n        d = 0\n        for j in range(0, i):\n            if (arr[i] == arr[j]):\n                d = 1\n                break\n \n        # If not printed earlier,\n        # then print it\n        if (d == 0):\n            print(arr[i])\n     \n# Driver program to test above function\narr = [6, 10, 5, 4, 9, 120, 4, 6, 10]\nn = len(arr)\nprintDistinct(arr, n)\n \n# This code is contributed by Sam007.\n", "# Python program to print all distinct \n# elements in a given array\n \ndef printDistinct(arr, n):\n     \n    # First sort the array so that \n    # all occurrences become consecutive\n    arr.sort();\n \n    # Traverse the sorted array\n    for i in range(n):\n         \n        # Move the index ahead while there are duplicates\n        if(i < n-1 and arr[i] == arr[i+1]):\n            while (i < n-1 and (arr[i] == arr[i+1])):\n                i+=1;\n             \n \n        # print last occurrence of the current element\n        else:\n            print(arr[i], end=' ');\n \n# Driver code\narr = [6, 10, 5, 4, 9, 120, 4, 6, 10];\nn = len(arr);\nprintDistinct(arr, n);\n \n# This code has been contributed by 29AjayKumar\n", "from sortedcontainers import SortedList, SortedSet, SortedDict\n \nv=[10, 5, 3, 4, 3, 5, 6];\ns=SortedSet();\nfor i in range (0,len(v)):\n    s.add(v[i]);\nprint('All the distinct element in given vector in sorted order are: ');\nfor it in s:\n    print(it,' ');\n", "# Python3 program to print all distinct elements \n# of a given array \n \n# This function prints all distinct elements\ndef printDistinct(arr, n):\n     \n    # Creates an empty hashset\n    s = dict();\n \n    # Traverse the input array\n    for i in range(n):\n         \n        # If not present, then put it in\n        # hashtable and print it\n        if (arr[i] not in s.keys()):\n            s[arr[i]] = arr[i];\n            print(arr[i], end = ' ');\n  \n# Driver Code\narr = [10, 5, 3, 4, 3, 5, 6];\nn = 7;\nprintDistinct(arr, n);\n \n# This code is contributed by Princi Singh\n"], "Sort an array which contain 1 to n values -  ": ["# Function to sort the array\ndef sort(arr, n):\n    i = 0\n    while(i < n):\n        # finding the corrent index\n        correct = arr[i]-1\n \n        # Element index and value not match\n        # then swapping\n        if arr[correct] != arr[i]:\n            # calling swap function\n            swap(arr, i, correct)\n        else:\n            i = i + 1\n \n# function to swap values\ndef swap(arr, first, second):\n    temp = arr[first]\n    arr[first] = arr[second]\n    arr[second] = temp\n \n# Driver Code\narr = [3, 2, 5, 6, 1, 4]\nn = len(arr)\n \n# function call\nsort(arr, n)\n \n# printing the answer\nfor i in range(0, n):\n    print(arr[i], end=' ')\n \n# This code is contributed by Yash Agarwal(yashagarwal2852002)\n"], "Print left rotation of array in O(n) time and O(1) space -  ": ["# Python3 implementation to print left \n# rotation of any array K times\nfrom collections import deque \n \n# Function For The k Times Left Rotation\ndef leftRotate(arr, k, n):\n     \n    # The collections module has deque class \n    # which provides the rotate(), which is \n    # inbuilt function to allow rotation\n    arr = deque(arr) \n     \n    # using rotate() to left rotate by k \n    arr.rotate(-k) \n    arr = list(arr) \n     \n    # Print the rotated array from\n    # start position\n    for i in range(n):\n        print(arr[i], end = ' ')\n \n# Driver Code\nif __name__ == '__main__':\n       \n    arr = [ 1, 3, 5, 7, 9 ]\n    n = len(arr)\n    k = 2\n   \n    # Function Call\n    leftRotate(arr, k, n)\n \n# This code is contributed by math_lover\n", "# Function for k times left rotation\ndef leftRotate(arr, k):\n    # if k>len(arr) , k%=len(arr) bring k back to range \n    k%len(arr)\n    # Reverse the first k elements\n    arr = reverseArray(arr, 0, k - 1)\n    # Reverse the remaining n-k elements\n    arr = reverseArray(arr, k, len(arr) - 1)\n    # Reverse the entire array\n    arr = reverseArray(arr, 0, len(arr) - 1)\n \n    # Print the rotated array from start position\n    print(' '.join(map(str,arr)))\n \n# Helper function to reverse a section of an array from start to end (inclusive)\ndef reverseArray(arr, start, end):\n    while start < end:\n        temp = arr[start]\n        arr[start] = arr[end]\n        arr[end] = temp\n        start += 1\n        end -= 1\n    return arr\n \n# Driver code\narr = [1, 3, 5, 7, 9]\nk = 2\n   \n# Function Call\nleftRotate(arr, k)\n"], "Reversal algorithm for Array rotation -  ": ["# Python program for reversal algorithm of array rotation\n \n# Function to reverse arr[] from index start to end\n \n \ndef reverseArray(arr, start, end):\n    while (start < end):\n        temp = arr[start]\n        arr[start] = arr[end]\n        arr[end] = temp\n        start += 1\n        end = end-1\n \n# Function to left rotate arr[] of size n by d\n \n \ndef leftRotate(arr, d):\n \n    if d == 0:\n        return\n    n = len(arr)\n    # in case the rotating factor is\n    # greater than array length\n    d = d % n\n    reverseArray(arr, 0, d-1)\n    reverseArray(arr, d, n-1)\n    reverseArray(arr, 0, n-1)\n \n# Function to print an array\n \n \ndef printArray(arr):\n    for i in range(0, len(arr)):\n        print (arr[i],end=' ')\n \n \n# Driver function to test above functions\narr = [1, 2, 3, 4, 5, 6, 7]\nn = len(arr)\nd = 2\n \nleftRotate(arr, d)  # Rotate array by 2\nprintArray(arr)\n \n# This code is contributed by Devesh Agrawal\n", "# Function to rotate an array by k elements to the right\ndef rotateArray(arr, k):\n    # Find the size of the array\n    n = len(arr);\n \n    # Mod k with the size of the array\n    # To handle the case where k is greater than the size of the array\n    k %= n;\n \n    # Reverse the entire array\n    arr[0:n] = arr[0:n][::-1]\n \n    # Reverse the first k elements\n    arr[0:k] = arr[0:k][::-1]\n \n    # Reverse the remaining n-k elements\n    arr[k:n] = arr[k:n][::-1]\n \n# Initialize the array\narr = [ 1, 2, 3, 4, 5 ];\n \n# Number of elements to rotate to the right\nk = 2;\n \n# Call the rotateArray function to rotate the array\nrotateArray(arr, k);\n \n# Print the rotated array\nfor i in range(0,len(arr)):\n    print(arr[i], end= ' ');\n"], "Rearrange an array in maximum minimum form using Two Pointer Technique -  ": ["# Python program to rearrange an array in minimum \n# maximum form \n  \n# Prints max at first position, min at second position \n# second max at third position, second min at fourth \n# position and so on. \n  \n  \ndef rearrange(arr, n): \n    # Auxiliary array to hold modified array \n    temp = n*[None] \n  \n    # Indexes of smallest and largest elements \n    # from remaining array. \n    small, large = 0, n-1\n  \n    # To indicate whether we need to copy remaining \n    # largest or remaining smallest at next position \n    flag = True\n  \n    # Store result in temp[] \n    for i in range(n): \n        if flag is True: \n            temp[i] = arr[large] \n            large -= 1\n        else: \n            temp[i] = arr[small] \n            small += 1\n  \n        flag = bool(1-flag) \n  \n    # Copy temp[] to arr[] \n    for i in range(n): \n        arr[i] = temp[i] \n    return arr \n  \n  \n# Driver code \narr = [1, 2, 3, 4, 5, 6] \nn = len(arr) \nprint('Original Array') \nprint(arr) \nprint('Modified Array') \nprint(rearrange(arr, n)) \n  \n# This code is contributed by Pratik Chhajer \n"], "Rearrange array such that even positioned are greater than odd -  ": ["# Python3 code to rearrange the\n# elements in array such that\n# even positioned are greater\n# than odd positioned elements\n \ndef assign(a, n):\n     \n    # Sort the array\n    a.sort()\n     \n    ans = [0] * n\n    p = 0\n    q = n - 1\n    for i in range(n):\n         \n        # Assign even indexes with\n        # maximum elements\n        if (i + 1) % 2 == 0:\n            ans[i] = a[q]\n            q = q - 1\n         \n        # Assign odd indexes with\n        # remaining elements\n        else:\n            ans[i] = a[p]\n            p = p + 1\n             \n    # Print result\n    for i in range(n):\n        print(ans[i], end = ' ')\n \n# Driver Code\nA = [ 1, 3, 2, 2, 5 ]\nn = len(A)\nassign(A, n)\n \n# This code is contributed by 'Sharad_Bhardwaj'.\n", "# Python3 program to rearrange \n# the elements in the array \n# such that even positioned are\n# greater than odd positioned elements\ndef rearrange(arr, n):\n \n    for i in range (1, n):\n       \n        # if index is even\n        if (i % 2 == 0):\n            if (arr[i] < arr[i - 1]):\n                arr[i - 1], arr[i] = arr[i], arr[i - 1]\n         \n        # if index is odd\n        else:\n            if (arr[i] > arr[i - 1]):\n                arr[i - 1], arr[i] = arr[i] , arr[i - 1]\n \nif __name__ == '__main__':          \n    n = 5\n    arr = [1, 3, 2, 2, 5]\n    rearrange(arr, n);\n    for i in range (n):\n        print (arr[i], end = ' ')\n    print ()\n    \n# This code is contributed by Chitranayal\n"], "Given a linked list A, remove the B-th node from the end of the list and return its head. For example, Given linked list: 1->2->3->4->5, and B = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. NOTE: If B is greater than the size of the list, remove the first node of the list. NOTE: Try doing it using constant additional space. Problem Constraints 1 <= |A| <= 106 Input Format The first argument of input contains a pointer to the head of the linked list. The second argument of input contains the integer B. Output Format Return the head of the linked list after deleting the B-th element from the end. Example Input Input 1: A = [1, 2, 3, 4, 5] B = 2 Input 2: A = [1] B = 1 Example Output Output 1: [1, 2, 3, 5] Output 2: [] Example Explanation Explanation 1: In the first example, 4 is the second last element. Explanation 2: In the second example, 1 is the first and the last element.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @param B : integer\n    # @return the head node in the linked list\n    def removeNthFromEnd(self, A, B):\n        length = 0\n        cur = A\n        while cur:     ##calculating the length of the list\n            length += 1\n            cur = cur.next\n        if B >= length:    ## if this is the case deleting the head node of the list\n            return A.next\n        n = length - B    ## calucalting the node to be removed from listhead (node index starts with 'zero')\n        count = 0\n        prev = None\n        cur = A\n        while count < n:\n            prev = cur\n            cur = cur.next\n            count += 1\n        if cur.next is not None:    ## cur is the node required to be removed\n            prev.next = cur.next    ## removing the cur node from list by linking the prev node directly to next of the cur node\n        else:\n            prev.next = None\n        return A \n        \n\n\n\n", "Find the sum of last n nodes of the given Linked List -  ": ["# Python3 implementation to find the sum of\n# last 'n' nodes of the Linked List\n \n# Linked List node \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n \nhead = None\nn = 0\nsum = 0\n \n# function to insert a node at the\n# beginning of the linked list\ndef push(head_ref, new_data):\n    global head\n     \n    # allocate node \n    new_node = Node(0)\n     \n    # put in the data \n    new_node.data = new_data\n     \n    # link the old list to the new node \n    new_node.next = head_ref\n     \n    # move the head to point to the new node \n    head_ref = new_node\n    head = head_ref\n \n# function to recursively find the sum of last\n# 'n' nodes of the given linked list\ndef sumOfLastN_Nodes(head):\n \n    global sum\n    global n\n \n    # if head = None\n    if (head == None):\n        return\n \n    # recursively traverse the remaining nodes\n    sumOfLastN_Nodes(head.next)\n \n    # if node count 'n' is greater than 0\n    if (n > 0) :\n     \n        # accumulate sum\n        sum = sum + head.data\n \n        # reduce node count 'n' by 1\n        n = n - 1\n     \n# utility function to find the sum of last 'n' nodes\ndef sumOfLastN_NodesUtil(head, n):\n     \n    global sum\n     \n    # if n == 0\n    if (n <= 0):\n        return 0\n \n    sum = 0\n \n    # find the sum of last 'n' nodes\n    sumOfLastN_Nodes(head)\n \n    # required sum\n    return sum\n \n# Driver Code\nhead = None\n \n# create linked list 10.6.8.4.12\npush(head, 12)\npush(head, 4)\npush(head, 8)\npush(head, 6)\npush(head, 10)\n \nn = 2\nprint('Sum of last ' , n , \n    ' nodes = ', sumOfLastN_NodesUtil(head, n))\n \n# This code is contributed by Arnab Kundu\n", "# Python3 implementation to find the sum of \n# last 'n' nodes of the Linked List \n \n# Linked List node \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n \nhead = None\nn = 0\nsum = 0\n \n# function to insert a node at the \n# beginning of the linked list \ndef push(head_ref, new_data): \n    global head \n     \n    # allocate node \n    new_node = Node(0) \n     \n    # put in the data \n    new_node.data = new_data \n     \n    # link the old list to the new node \n    new_node.next = head_ref \n     \n    # move the head to point to the new node \n    head_ref = new_node \n    head = head_ref \n     \n# utility function to find the sum of last 'n' nodes \ndef sumOfLastN_NodesUtil(head, n):\n     \n    global sum\n     \n    # if n == 0 \n    if (n <= 0):\n        return 0\n     \n    st = []\n    sum = 0\n     \n    # traverses the list from left to right \n    while (head != None):\n         \n        # push the node's data onto the stack 'st' \n        st.append(head.data) \n         \n        # move to next node \n        head = head.next\n     \n    # pop 'n' nodes from 'st' and \n    # add them \n    while (n):\n        n -= 1\n        sum += st[0]\n        st.pop(0) \n         \n    # required sum \n    return sum\n \n# Driver Code \nhead = None\n \n# create linked list 10.6.8.4.12 \npush(head, 12) \npush(head, 4) \npush(head, 8) \npush(head, 6) \npush(head, 10) \n \nn = 2\nprint('Sum of last' , n , \n    'nodes =', sumOfLastN_NodesUtil(head, n)) \n \n# This code is contributed by shubhamsingh10 \n", "# Python implementation to find the sum of last\n# 'n' Nodes of the Linked List\n''' A Linked list Node '''\n \n# A Linked list Node\nclass Node:\n \n    def __init__(self, x):\n        self.data = x\n        self.next = None\n \nhead = None\n \n# Function to insert a Node at the\n# beginning of the linked list\ndef push(head_ref, new_data):\n   \n    # Allocate Node\n    new_Node = Node(new_data)\n \n    # Put in the data\n    new_Node.data = new_data\n \n    # Link the old list to the new Node\n    new_Node.next = head_ref\n \n    # Move the head to point to the new Node\n    head_ref = new_Node\n    head = head_ref\n    return head\n \ndef reverseList():\n    global head;\n    current, prev, next = None, None, None;\n    current = head;\n    prev = None;\n \n    while (current != None):\n        next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n \n    head = prev;\n \n# utility function to find the sum of last 'n' Nodes\ndef sumOfLastN_NodesUtil(n):\n   \n    # if n == 0\n    if (n <= 0):\n        return 0;\n \n    # reverse the linked list\n    reverseList();\n \n    sum = 0;\n    current = head;\n \n    # traverse the 1st 'n' Nodes of the reversed\n    # linked list and add them\n    while (current != None and n > 0):\n       \n        # accumulate Node's data to 'sum'\n        sum += current.data;\n \n        # move to next Node\n        current = current.next;\n        n -= 1;\n \n    # reverse back the linked list\n    reverseList();\n \n    # required sum\n    return sum;\n \n# Driver code\nif __name__ == '__main__':\n    # create linked list 10.6.8.4.12\n \n    # create linked list 10.6.8.4.12\n    head = push(head, 12)\n    head = push(head, 4)\n    head = push(head, 8)\n    head = push(head, 6)\n    head = push(head, 10)\n \n    n = 2;\n    print('Sum of last ' , n , ' Nodes = ' , sumOfLastN_NodesUtil(n));\n \n# This code contributed by Princi Singh\n", "# Python3 implementation to find the sum \n# of last 'n' Nodes of the Linked List\n \n# A Linked list Node \nclass Node:\n     \n    def __init__(self, x):\n         \n        self.data = x\n        self.next = None\n         \nhead = None\n \n# Function to insert a Node at the\n# beginning of the linked list\ndef push(head_ref, new_data):\n     \n    # Allocate Node \n    new_Node = Node(new_data)\n \n    # Put in the data \n    new_Node.data = new_data\n \n    # Link the old list to the new Node\n    new_Node.next = head_ref\n \n    # Move the head to point to the new Node \n    head_ref = new_Node\n    head = head_ref\n    return head\n \n# Utility function to find the sum of \n# last 'n' Nodes\ndef sumOfLastN_NodesUtil(head, n):\n     \n    # If n == 0\n    if (n <= 0):\n        return 0\n \n    sum = 0\n    len = 0\n    temp = head\n     \n    # Calculate the length of the linked list\n    while (temp != None):\n        len += 1\n        temp = temp.next\n \n    # Count of first (len - n) Nodes\n    c = len - n\n    temp = head\n \n    # Just traverse the 1st 'c' Nodes\n    while (temp != None and c > 0):\n         \n        # Move to next Node\n        temp = temp.next\n        c -= 1\n \n    # Now traverse the last 'n' Nodes \n    # and add them\n    while (temp != None):\n         \n        # Accumulate Node's data to sum\n        sum += temp.data\n \n        # Move to next Node\n        temp = temp.next\n \n    # Required sum\n    return sum\n \n# Driver code\nif __name__ == '__main__':\n     \n    # Create linked list 10->6->8->4->12\n    head = push(head, 12)\n    head = push(head, 4)\n    head = push(head, 8)\n    head = push(head, 6)\n    head = push(head, 10)\n \n    n = 2\n     \n    print('Sum of last ', n, ' Nodes = ', \n          sumOfLastN_NodesUtil(head, n))\n \n# This code is contributed by Princi Singh\n", "# Python3 implementation to find the sum of last\n# 'n' nodes of the Linked List\n# include\n \nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n \n# function to insert a node at the\n# beginning of the linked list\ndef push(head_ref,new_data):\n   \n    # /* allocate node */\n    new_node = Node(new_data)\n \n    #/* link the old list to the new node */\n    new_node.next = head_ref\n \n    #/* move the head to point to the new node */\n    head_ref = new_node\n \n    return head_ref\n \n# utility function to find the sum of last 'n' nodes\ndef sumOfLastN_NodesUtil(head, n):\n   \n    # if n == 0\n    if (n <= 0):\n        return 0\n \n    sum = 0\n    temp = 0\n    ref_ptr  = None\n    main_ptr = None\n    ref_ptr = main_ptr = head\n \n    # traverse 1st 'n' nodes through 'ref_ptr' and\n    # accumulate all node's data to 'sum'\n    while (ref_ptr != None and  n):\n        sum += ref_ptr.data\n \n        # move to next node\n        ref_ptr = ref_ptr.next\n        n -= 1\n \n    # traverse to the end of the linked list\n    while (ref_ptr != None):\n \n        # accumulate all node's data to 'temp' pointed\n        # by the 'main_ptr'\n        temp += main_ptr.data\n \n        # accumulate all node's data to 'sum' pointed by\n        # the 'ref_ptr'\n        sum += ref_ptr.data\n \n        # move both the pointers to their respective\n        # next nodes\n        main_ptr = main_ptr.next\n        ref_ptr = ref_ptr.next\n \n    # required sum\n    return (sum - temp)\n \n# Driver program to test above\nif __name__ == '__main__':\n    head = None\n \n    # create linked list 10.6.8.4.12\n    head = push(head, 12)\n    head = push(head, 4)\n    head = push(head, 8)\n    head = push(head, 6)\n    head = push(head, 10)\n \n    n = 2\n    print('Sum of last ',n,' nodes = ',sumOfLastN_NodesUtil(head, n))\n \n# This code is contributed by mohit kumar 29\n"], "Subtract Two Numbers represented as Linked Lists -  ": ["# Python program to subtract smaller valued list from\n# larger valued list and return result as a list.\n \n# A linked List Node\nclass Node: \n    def __init__(self, new_data): \n        self.data = new_data \n        self.next = None\n \n# A utility which creates Node.\ndef newNode(data):\n \n    temp = Node(0)\n    temp.data = data\n    temp.next = None\n    return temp\n \n# A utility function to get length of linked list \ndef getLength(Node):\n \n    size = 0\n    while (Node != None):\n     \n        Node = Node.next\n        size = size + 1\n     \n    return size\n \n# A Utility that padds zeros in front of the\n# Node, with the given diff \ndef paddZeros( sNode, diff):\n \n    if (sNode == None):\n        return None\n \n    zHead = newNode(0)\n    diff = diff - 1\n    temp = zHead\n    while (diff > 0):\n        diff = diff - 1\n        temp.next = newNode(0)\n        temp = temp.next\n     \n    temp.next = sNode\n    return zHead\n \nborrow = True\n \n# Subtract LinkedList Helper is a recursive function,\n# move till the last Node, and subtract the digits and\n# create the Node and return the Node. If d1 < d2, we\n# borrow the number from previous digit. \ndef subtractLinkedListHelper(l1, l2):\n \n    global borrow\n     \n    if (l1 == None and l2 == None and not borrow ):\n        return None\n \n    l3 = None\n    l4 = None\n    if(l1 != None):\n        l3 = l1.next\n    if(l2 != None):\n        l4 = l2.next\n    previous = subtractLinkedListHelper(l3, l4)\n \n    d1 = l1.data\n    d2 = l2.data\n    sub = 0\n \n    # if you have given the value to next digit then\n    # reduce the d1 by 1 \n    if (borrow):\n        d1 = d1 - 1\n        borrow = False\n     \n    # If d1 < d2, then borrow the number from previous digit.\n    # Add 10 to d1 and set borrow = True \n    if (d1 < d2):\n        borrow = True\n        d1 = d1 + 10\n \n    # subtract the digits \n    sub = d1 - d2\n \n    # Create a Node with sub value \n    current = newNode(sub)\n \n    # Set the Next pointer as Previous \n    current.next = previous\n \n    return current\n \n# This API subtracts two linked lists and returns the\n# linked list which shall have the subtracted result. \ndef subtractLinkedList(l1, l2):\n \n    # Base Case.\n    if (l1 == None and l2 == None):\n        return None\n \n    # In either of the case, get the lengths of both\n    # Linked list.\n    len1 = getLength(l1)\n    len2 = getLength(l2)\n \n    lNode = None\n    sNode = None\n \n    temp1 = l1\n    temp2 = l2\n \n    # If lengths differ, calculate the smaller Node\n    # and padd zeros for smaller Node and ensure both\n    # larger Node and smaller Node has equal length.\n    if (len1 != len2):\n        if(len1 > len2):\n            lNode = l1\n        else:\n            lNode = l2\n         \n        if(len1 > len2):\n            sNode = l2\n        else:\n            sNode = l1\n        sNode = paddZeros(sNode, abs(len1 - len2))\n     \n    else:\n     \n        # If both list lengths are equal, then calculate\n        # the larger and smaller list. If 5-6-7 & 5-6-8\n        # are linked list, then walk through linked list\n        # at last Node as 7 < 8, larger Node is 5-6-8\n        # and smaller Node is 5-6-7.\n        while (l1 != None and l2 != None):\n         \n            if (l1.data != l2.data):\n                if(l1.data > l2.data ):\n                    lNode = temp1 \n                else:\n                    lNode = temp2\n                 \n                if(l1.data > l2.data ):\n                    sNode = temp2 \n                else:\n                    sNode = temp1\n                break\n             \n            l1 = l1.next\n            l2 = l2.next\n         \n    global borrow\n     \n    # After calculating larger and smaller Node, call\n    # subtractLinkedListHelper which returns the subtracted\n    # linked list.\n    borrow = False\n    return subtractLinkedListHelper(lNode, sNode)\n \n# A utility function to print linked list \ndef printList(Node):\n \n    while (Node != None):\n     \n        print (Node.data, end =' ')\n        Node = Node.next\n     \n    print(' ')\n \n \n# Driver program to test above functions\n \nhead1 = newNode(1)\nhead1.next = newNode(0)\nhead1.next.next = newNode(0)\n \nhead2 = newNode(1)\n \nresult = subtractLinkedList(head1, head2)\n \nprintList(result)\n \n# This code is contributed by Arnab Kundu\n", "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \ndef newNode(data):\n    temp = Node(data)\n    temp.next = None\n    return temp\n \ndef getLength(head):\n    size = 0\n    while head is not None:\n        head = head.next\n        size += 1\n    return size\n \ndef reverse(head):\n    prev = None\n    while head is not None:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n    return prev\n \ndef subtractLinkedListHelper(l1, l2):\n    l1 = reverse(l1)\n    l2 = reverse(l2)\n    carry = 1\n    res = None\n    temp = None\n \n    while l1 is not None or l2 is not None:\n        sum = carry\n        if l1 is not None:\n            sum += l1.data\n            l1 = l1.next\n \n        if l2 is not None:\n            sum += (9 - l2.data)\n            l2 = l2.next\n        else:\n            sum += 9\n \n        carry = sum // 10\n        sum = sum % 10\n \n        if res is None:\n            res = newNode(sum)\n            temp = res\n        else:\n            temp.next = newNode(sum)\n            temp = temp.next\n \n    res = reverse(res)\n \n    while res is not None and res.data == 0:\n        res = res.next\n \n    return res\n \ndef subtractLinkedList(l1, l2):\n    if l1 is None and l2 is None:\n        return None\n \n    while l1 is not None and l1.data == 0:\n        l1 = l1.next\n    while l2 is not None and l2.data == 0:\n        l2 = l2.next\n \n    len1 = getLength(l1)\n    len2 = getLength(l2)\n \n    if len1 == len2:\n        a, b = l1, l2\n        while a is not None and b is not None and a.data == b.data:\n            a = a.next\n            b = b.next\n \n        if a is not None and b is not None and a.data < b.data:\n            l1, l2 = l2, l1\n    elif len2 > len1:\n        l1, l2 = l2, l1\n \n    res = subtractLinkedListHelper(l1, l2)\n \n    if res is None:\n        return newNode(0)\n \n    return res\n \ndef printList(head):\n    while head is not None:\n        print(head.data, end=' ')\n        head = head.next\n    print()\n \nhead1 = newNode(1)\nhead1.next = newNode(0)\nhead1.next.next = newNode(0)\n \nhead2 = newNode(1)\n \nresult = subtractLinkedList(head1, head2)\n \nprintList(result)\n"], "Add two numbers represented by Linked List -  ": ["class Solution:\n    # Function to reverse a list\n    def reverse(self, head):\n        if head is None or head.next is None:\n            return head\n        prev = None\n        next = None\n        curr = head\n        while curr is not None:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        head = prev\n        return head\n \n    # Function to add two numbers represented by linked list.\n \n    def addTwoLists(self, first, second):\n \n        # reverse the two lists\n        curr1 = self.reverse(first)\n        curr2 = self.reverse(second)\n \n        # res is head node of the resultant list\n        sum = 0\n        carry = 0\n        res = None\n        prev = None\n \n        # while both lists have atleast one node\n        while curr1 is not None or curr2 is not None:\n \n            # Calculating the sum of the last digits\n            sum = carry + (curr1.data if curr1 else 0) + \\\n                (curr2.data if curr2 else 0)\n \n            # update carry for next calculation\n            carry = (1 if sum >= 10 else 0)\n \n            # update sum if it is greater than 10\n            sum = sum % 10\n \n            # Create a new node with sum as data\n            temp = Node(sum)\n \n            # if this is the first node then set it as head of the resultant list\n            if res is None:\n                res = temp\n \n            # If this is not the first node then connect it to the rest.\n            else:\n                prev.next = temp\n \n            # Set prev for next insertion\n            prev = temp\n \n            # Move first and second pointers to next nodes\n            if curr1:\n                curr1 = curr1.next\n            if curr2:\n                curr2 = curr2.next\n \n        # if carry from previous sums is remaining\n        if carry > 0:\n            temp.next = Node(carry)\n \n        # Reverse the resultant answer\n        ans = self.reverse(res)\n        return ans\n \n \nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n \n    def insert(self, val):\n        if self.head is None:\n            self.head = Node(val)\n            self.tail = self.head\n        else:\n            self.tail.next = Node(val)\n            self.tail = self.tail.next\n \n# Utility function to print the list\n \n \ndef printList(n):\n    while n:\n        print(n.data, end = ' ')\n        n = n.next\n    print()\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    arr1 = [7, 5, 9, 4, 6]\n    LL1 = LinkedList()\n    for i in arr1:\n        LL1.insert(i)\n    print('First list is', end = ' ')\n    printList(LL1.head)\n \n    arr2 = [8, 4]\n    LL2 = LinkedList()\n    for i in arr2:\n        LL2.insert(i)\n    print('Second list is', end = ' ')\n    printList(LL2.head)\n \n    # Function Call\n    res = Solution().addTwoLists(LL1.head, LL2.head)\n    print('Resultant list is', end = ' ')\n    printList(res)\n \n# This code Contributed by Vaidehi Agarwal\n", "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n         \nclass LinkedList:\n    def __init__(self):\n        self.head = None\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n         \n    def printList(self):\n        n = self.head\n        while n:\n            print(n.data, end=' ')\n            n = n.next\n        print()\n \ndef addTwoLists(first, second):\n    num1, num2 = 0, 0\n    while first.head:\n        num1 = num1*10 + first.head.data\n        first.head = first.head.next\n    while second.head:\n        num2 = num2*10 + second.head.data\n        second.head = second.head.next\n    num3 = num1 + num2\n    temp = LinkedList()\n    while num3:\n        last = num3 % 10\n        temp.push(last)\n        num3 = num3 // 10\n    return temp\n \nif __name__ == '__main__':\n    first = LinkedList()\n    second = LinkedList()\n    first.push(6)\n    first.push(4)\n    first.push(9)\n    first.push(5)\n    first.push(7)\n \n    second.push(4)\n    second.push(8)\n \n    ans = addTwoLists(first, second)\n \n    print('Sum is : ', end=' ')\n    ans.printList()\n", "# Python program to add two numbers represented by Linked Lists\n# using Stack\n \nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \ndef addTwoLists(l1, l2):\n    prev = None\n    # Create 3 stacks\n    s1 = []\n    s2 = []\n    s3 = []\n    # Fill first stack with first List Elements\n    while l1 is not None:\n        s1.append(l1)\n        l1 = l1.next\n    # Fill second stack with second List Elements\n    while l2 is not None:\n        s2.append(l2)\n        l2 = l2.next\n    carry = 0\n    # Fill the third stack with the sum of first and second stack\n    while len(s1) > 0 and len(s2) > 0:\n        sum = s1[-1].data + s2[-1].data + carry\n        temp = Node(sum % 10)\n        s3.append(temp)\n        if sum > 9:\n            carry = 1\n        else:\n            carry = 0\n        s1.pop()\n        s2.pop()\n    while len(s1) > 0:\n        sum = carry + s1[-1].data\n        temp = Node(sum % 10)\n        s3.append(temp)\n        if sum > 9:\n            carry = 1\n        else:\n            carry = 0\n        s1.pop()\n    while len(s2) > 0:\n        sum = carry + s2[-1].data\n        temp = Node(sum % 10)\n        s3.append(temp)\n        if sum > 9:\n            carry = 1\n        else:\n            carry = 0\n        s2.pop()\n    # If carry is still present create a new node with value 1 \n    # and push it to the third stack\n    if carry == 1:\n        temp = Node(1)\n        s3.append(temp)\n    # Link all the elements inside third stack with each other\n    if len(s3) != 0:\n        prev = s3[-1]\n    while len(s3) > 0:\n        temp = s3[-1]\n        s3.pop()\n        if len(s3) == 0:\n            temp.next = None\n        else:\n            temp.next = s3[-1]\n    printList(prev)\n \n# Utility function to print a linked list\ndef printList(head):\n    while head.next is not None:\n        print(str(head.data) + ' -> ', end='')\n        head = head.next\n    print(str(head.data))\n \n \n# creating first list\nhead1 = Node(7)\nhead1.next = Node(5)\nhead1.next.next = Node(9)\nhead1.next.next.next = Node(4)\nhead1.next.next.next.next = Node(6)\nprint('First List : ', end='')\nprintList(head1)\n \n# creating second list\nhead2 = Node(8)\nhead2.next = Node(4)\nprint('Second List : ', end='')\nprintList(head2)\n \nprint('Sum List : ', end='')\n# add the two lists and see the result\naddTwoLists(head1, head2)\n \n# This code is contributed by lokesh.\n", "# Python code for the above approach\nclass Node:\n    def __init__(self):\n        self.data = None\n        self.next = None\n \n# recursive function\ndef addition(temp1, temp2, size1, size2):\n \n    # creating a new Node\n    newNode = Node()\n \n    # base case\n    if temp1 is not None and temp2 is not None and temp1.next is None and temp2.next is None:\n \n        # addition of current nodes which is the last\n        # nodes of both linked lists\n        newNode.data = (temp1.data + temp2.data)\n \n        # set this current node's link null\n        newNode.next = None\n \n        # return the current node\n        return newNode\n \n    # creating a node that contains sum of previously\n    # added number\n    returnedNode = Node()\n \n    # if sizes are same then we move in both linked\n    # list\n    if temp1 is not None and temp2 is not None and size2 == size1:\n \n        # recursively call the function\n        # move ahead in both linked list\n        returnedNode = addition(temp1.next, temp2.next, size1 - 1, size2 - 1)\n \n        # add the current nodes and append the carry\n        newNode.data = (temp1.data + temp2.data) + ((returnedNode.data) // 10)\n \n    # or else we just move in big linked list\n    elif temp1 is not None and temp2 is not None:\n \n        # recursively call the function\n        # move ahead in big linked list\n        returnedNode = addition(temp1, temp2.next, size1, size2 - 1)\n \n        # add the current node and carry\n        newNode.data = (temp2.data) + ((returnedNode.data) // 10)\n \n    # this node contains previously added numbers\n    # so we need to set only rightmost digit of it\n    returnedNode.data = (returnedNode.data) % 10\n \n    # set the returned node to the current node\n    newNode.next = returnedNode\n \n    # return the current node\n    return newNode\n \n# Function to add two numbers represented by nexted\n# list.\ndef addTwoLists(head1, head2):\n    temp1 = head1\n    temp2 = head2\n    size1 = 0\n    size2 = 0\n \n    # calculating the size of first linked list\n    while temp1 is not None:\n        temp1 = temp1.next\n        size1 += 1\n \n    # calculating the size of second linked list\n    while temp2 is not None:\n        temp2 = temp2.next\n        size2 += 1\n    returnedNode = Node()\n \n    # traverse the bigger linked list\n    if size2 > size1:\n        returnedNode = addition(head1, head2, size1, size2)\n    else:\n        returnedNode = addition(head2, head1, size2, size1)\n \n    # creating new node if head node is >10\n    if returnedNode.data >= 10:\n        ans = Node()\n        ans.data = (returnedNode.data) // 10\n        returnedNode.data = returnedNode.data % 10\n        ans.next = returnedNode\n    else:\n        ans = returnedNode\n \n    # return the head node of linked list that contains\n    # answer\n    return ans\n \n \ndef Display(head):\n    if head is None:\n        return\n    while head.next is not None:\n        print(str(head.data) + ' -> ', end='')\n        head = head.next\n    print(str(head.data))\n \n# Function that adds element at the end of the Linked\n# List\ndef push(head_ref, d):\n    new_node = Node()\n    new_node.data = d\n    new_node.next = None\n    if head_ref is None:\n        new_node.next = head_ref\n        head_ref = new_node\n        return head_ref\n    last = head_ref\n    while last.next is not None and last is not None:\n        last = last.next\n    last.next = new_node\n    return head_ref\n \n \n# Creating two lists\nfirst = None\nsecond = None\nsum = None\nfirst = push(first, 7)\nfirst = push(first, 5)\nfirst = push(first, 9)\nfirst = push(first, 4)\nfirst = push(first, 6)\nsecond = push(second, 8)\nsecond = push(second, 4)\nprint('First List : ', end='')\nDisplay(first)\nprint('Second List : ', end='')\nDisplay(second)\nsum = addTwoLists(first, second)\nprint('Sum List : ', end='')\nDisplay(sum)\n \n# This code contributed by Prasad Kandekar(prasad264)\n", "# Python code to add two nodes by reversing the two lists\n \n# Node class for linked list\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# LinkedList class\nclass LinkedList:\n    # Function to reverse the linked list and \n    # return the head of the reversed list\n    def reverse_list(self, list):\n        prev = None\n        curr = list\n        next = None\n        while curr is not None:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        return prev\n \n    # Function that calculates and prints the sum \n    # of two numbers represented by linked lists\n    def add_two_lists(self, first, second):\n        # Reverse both lists\n        first = self.reverse_list(first)\n        second = self.reverse_list(second)\n \n        carry = 0\n        head = None\n        prev = None\n        sum_list = None\n \n        # Add the two lists and carry over if necessary\n        while first is not None or second is not None or carry == 1:\n            new_val = carry\n            if first is not None:\n                new_val += first.data\n            if second is not None:\n                new_val += second.data\n            carry = new_val // 10\n            new_val = new_val % 10\n \n            # Create a new node for the sum and append it \n            # to the beginning of the final ans list\n            new_node = Node(new_val)\n            new_node.next = sum_list\n            sum_list = new_node\n \n            # Initialize nodes for the next iteration\n            if first is not None:\n                first = first.next\n            if second is not None:\n                second = second.next\n \n        self.print_list(sum_list)\n \n    # Utility function to print a linked list\n    def print_list(self, head):\n        while head.next is not None:\n            print(head.data, end=' ')\n            head = head.next\n        print(head.data)\n \n \n# Test the LinkedList class\nlinked_list = LinkedList()\n \n# Create first list\nlinked_list.head1 = Node(7)\nlinked_list.head1.next = Node(5)\nlinked_list.head1.next.next = Node(9)\nlinked_list.head1.next.next.next = Node(4)\nlinked_list.head1.next.next.next.next = Node(6)\n \n# Create second list\nlinked_list.head2 = Node(8)\nlinked_list.head2.next = Node(4)\n \nprint('Sum is:', end = ' ')\n# Add the two lists and see the result\nlinked_list.add_two_lists(linked_list.head1, linked_list.head2)\n \n# This code is contributed by lokeshmvs21.\n"], "Add 1 to a number represented as linked list -  ": ["# Python3 program to add 1 to a linked list\nimport sys\nimport math\n \n# Linked list node\n \n \nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# Function to create a new node with given data */\n \n \ndef newNode(data):\n    return Node(data)\n \n# Function to reverse the linked list */\n \n \ndef reverseList(head):\n    if not head:\n        return\n    curNode = head\n    prevNode = head\n    nextNode = head.next\n    curNode.next = None\n \n    while(nextNode):\n        curNode = nextNode\n        nextNode = nextNode.next\n        curNode.next = prevNode\n        prevNode = curNode\n \n    return curNode\n \n# Adds one to a linked lists and return the head\n# node of resultant list\n \n \ndef addOne(head):\n \n    # Reverse linked list and add one to head\n    head = reverseList(head)\n    k = head\n    carry = 0\n    prev = None\n    head.data += 1\n \n    # update carry for next calculation\n    while(head != None) and (head.data > 9 or carry > 0):\n        prev = head\n        head.data += carry\n        carry = head.data // 10\n        head.data = head.data % 10\n        head = head.next\n \n    if carry > 0:\n        prev.next = Node(carry)\n    # Reverse the modified list\n    return reverseList(k)\n \n# A utility function to print a linked list\n \n \ndef printList(head):\n    if not head:\n        return\n    while(head):\n        print('{}'.format(head.data), end='')\n        head = head.next\n \n \n# Driver code\nif __name__ == '__main__':\n    head = newNode(1)\n    head.next = newNode(9)\n    head.next.next = newNode(9)\n    head.next.next.next = newNode(9)\n \n    print('List is: ', end='')\n    printList(head)\n \n    head = addOne(head)\n \n    print('\\nResultant list is: ', end='')\n    printList(head)\n \n \n# This code is contributed by Rohit\n", "# Recursive Python program to add 1 to a linked list\n \n# Node class \nclass Node: \n \n    # Constructor to initialize the node object \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n \n# Function to create a new node with given data \ndef newNode(data):\n \n    new_node = Node(0)\n    new_node.data = data\n    new_node.next = None\n    return new_node\n \n# Recursively add 1 from end to beginning and returns\n# carry after all nodes are processed.\ndef addWithCarry(head):\n \n    # If linked list is empty, then\n    # return carry\n    if (head == None):\n        return 1\n \n    # Add carry returned be next node call\n    res = head.data + addWithCarry(head.next)\n \n    # Update data and return new carry\n    head.data = int((res) % 10)\n    return int((res) / 10)\n \n# This function mainly uses addWithCarry().\ndef addOne(head):\n \n    # Add 1 to linked list from end to beginning\n    carry = addWithCarry(head)\n \n    # If there is carry after processing all nodes,\n    # then we need to add a new node to linked list\n    if (carry != 0):\n     \n        newNode = Node(0)\n        newNode.data = carry\n        newNode.next = head\n        return newNode # New node becomes head now\n     \n    return head\n \n# A utility function to print a linked list\ndef printList(node):\n \n    while (node != None):\n     \n        print( node.data,end = '')\n        node = node.next\n     \n    print('\\n')\n \n# Driver program to test above function \n \nhead = newNode(1)\nhead.next = newNode(9)\nhead.next.next = newNode(9)\nhead.next.next.next = newNode(9)\n \nprint('List is ')\nprintList(head)\n \nhead = addOne(head)\n \nprint('\\nResultant list is ')\nprintList(head)\n \n \n# This code is contributed by Arnab Kundu\n", "# Recursive Python 3 program to add 1 to a linked list\nclass GFG :\n    # Linked list node\n    class Node :\n        data = 0\n        next = None\n    # Function to create a new node with given data\n    @staticmethod\n    def  newNode( data) :\n        new_node = GFG.Node()\n        new_node.data = data\n        new_node.next = None\n        return new_node\n    @staticmethod\n    def  addOne( head) :\n        # Return head of list after adding one\n        ln = head\n        if (head.next == None) :\n            head.data += 1\n            return head\n        t = head\n        prev = 0\n        while (t.next != None) :\n            if (t.data != 9) :\n                ln = t\n            t = t.next\n        if (t.data == 9 and ln != None) :\n            t = ln\n            t.data += 1\n            t = t.next\n            while (t != None) :\n                t.data = 0\n                t = t.next\n        else :\n            t.data += 1\n        return head\n    # A utility function to print a linked list\n    @staticmethod\n    def printList( node) :\n        while (node != None) :\n            print(node.data, end ='')\n            node = node.next\n        print()\n    # Driver code\n    @staticmethod\n    def main( args) :\n        head = GFG.newNode(1)\n        head.next = GFG.newNode(9)\n        head.next.next = GFG.newNode(9)\n        head.next.next.next = GFG.newNode(9)\n        print('List is ', end ='')\n        GFG.printList(head)\n        head = GFG.addOne(head)\n        print()\n        print('Resultant list is ', end ='')\n        GFG.printList(head)\n     \nif __name__=='__main__':\n    GFG.main([])\n     \n    # This code is contributed by mukulsomukesh.\n", "# Linked list Node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# Function to insert a node at the beginning of the Singly Linked List\ndef push(head_ref, new_data):\n   \n    # Allocate new node\n    new_node = Node(new_data)\n     \n    # Link the old list of the new node\n    new_node.next = head_ref\n     \n    # Move the head to point to the new node\n    head_ref = new_node\n    return head_ref\n \ndef printList(n):\n    while n:\n        print(n.data, end=' ')\n        n = n.next\n    print()\n \n# Function working on addition.\ndef addTwoLists(first):\n    num1 = 0\n    # Get the number\n    while first.next != None:\n        num1 += first.data\n        num1 *= 10\n        first = first.next\n    num1 += first.data\n     \n    # Add one to it\n    num2 = num1 + 1\n    temp = None\n     \n    # Made the linked list form it\n    while num2 != 0:\n        last = num2 % 10\n        temp = push(temp, last)\n        num2 //= 10\n         \n    # Return the list\n    return temp\n \n# Driver code\nif __name__ == '__main__':\n    first = None\n    first = push(first, 6)\n    first = push(first, 4)\n    first = push(first, 9)\n    first = push(first, 5)\n    first = push(first, 7)\n \n    ans = addTwoLists(first)\n    print('Sum is of first: ', end='')\n    printList(ans)\n \n    second = None\n    second = push(second, 9)\n    second = push(second, 9)\n    second = push(second, 9)\n    second = push(second, 1)\n \n    res = addTwoLists(second)\n    print('Sum is of second: ', end='')\n    printList(res)\n"], "Delete alternate nodes of a Linked List -  ": ["# Python3 program to remove alternate  \n# nodes of a linked list  \nimport math  \n  \n# A linked list node  \nclass Node:  \n    def __init__(self, data):  \n        self.data = data  \n        self.next = None\n          \n# deletes alternate nodes  \n# of a list starting with head  \ndef deleteAlt(head):  \n    if (head == None): \n        return\n  \n    # Initialize prev and node to be deleted  \n    prev = head  \n    now = head.next\n  \n    while (prev != None and now != None):  \n          \n        # Change next link of previous node  \n        prev.next = now.next\n  \n        # Free memory  \n        now = None\n  \n        # Update prev and node  \n        prev = prev.next\n        if (prev != None):  \n            now = prev.next\n      \n# UTILITY FUNCTIONS TO TEST fun1() and fun2()  \n# Given a reference (pointer to pointer) to the head  \n# of a list and an , push a new node on the front  \n# of the list.  \ndef push(head_ref, new_data):  \n      \n    # allocate node  \n    new_node = Node(new_data) \n  \n    # put in the data  \n    new_node.data = new_data  \n  \n    # link the old list of the new node  \n    new_node.next = head_ref  \n  \n    # move the head to point to the new node  \n    head_ref = new_node  \n    return head_ref \n  \n# Function to print nodes in a given linked list  \ndef printList(node):  \n    while (node != None):  \n        print(node.data, end = ' ')  \n        node = node.next\n      \n# Driver code  \nif __name__=='__main__':  \n      \n    # Start with the empty list  \n    head = None\n  \n    # Using head=push() to construct below list  \n    # 1.2.3.4.5  \n    head = push(head, 5)  \n    head = push(head, 4)  \n    head = push(head, 3)  \n    head = push(head, 2)  \n    head = push(head, 1)  \n  \n    print('List before calling deleteAlt() ') \n    printList(head)  \n  \n    deleteAlt(head)  \n  \n    print('\\nList after calling deleteAlt() ')  \n    printList(head)  \n  \n# This code is contributed by Srathore \n", "# deletes alternate nodes of a list starting with head  \ndef deleteAlt(head):  \n    if (head == None):  \n        return\n  \n    node = head.next\n  \n    if (node == None):  \n        return\n  \n    # Change the next link of head  \n    head.next = node.next\n  \n    # free memory allocated for node  \n    #free(node)  \n  \n    # Recursively call for the new next of head  \n    deleteAlt(head.next)  \n  \n# This code is contributed by Srathore \n"], "Make middle node head in a linked list -  ": ["# Python3 program to make middle node\n# as head of Linked list\n \n# Linked List node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# function to get the middle node\n# set it as the beginning of the \n# linked list\ndef setMiddleHead(head):\n    if(head == None):\n        return None\n \n    # to traverse nodes \n    # one by one\n    one_node = head\n \n    # to traverse nodes by \n    # skipping one\n    two_node = head\n \n    # to keep track of previous middle\n    prev = None\n \n    while(two_node != None and\n          two_node.next != None):\n \n        # for previous node of middle node\n        prev = one_node\n \n        # move one node each time\n        one_node = one_node.next\n \n        # move two nodes each time\n        two_node = two_node.next.next\n \n    # set middle node at head\n    prev.next = prev.next.next\n    one_node.next = head\n    head = one_node\n \n    # return the modified head\n    return head\n \ndef push(head, new_data):\n \n    # allocate new node\n    new_node = Node(new_data)\n \n    #link the old list to new node\n    new_node.next = head\n \n    # move the head to point the new node\n    head = new_node\n \n    # return the modified head\n    return head\n \n# A function to print a given linked list\ndef printList(head):\n    temp = head\n    while (temp!=None):\n         \n        print(str(temp.data), end = ' ')\n        temp = temp.next\n    print('')\n \n# Create a list of 5 nodes\nhead = None\nfor i in range(5, 0, -1):\n    head = push(head, i)\n \nprint(' list before: ', end = '')\nprintList(head)\n \nhead = setMiddleHead(head)\n \nprint(' list After: ', end = '')\nprintList(head)\n \n# This code is contributed\n# by Pranav Devarakonda\n"], "Move last element to front of a given Linked List -  ": ["# Python3 code to move the last item to front \n  \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n  \n  \nclass LinkedList: \n    def __init__(self): \n        self.head = None\n  \n    # Function to add a node \n    # at the beginning of Linked List \n    def push(self, data): \n        new_node = Node(data) \n        new_node.next = self.head \n        self.head = new_node \n  \n    # Function to print nodes in a \n    # given linked list \n    def printList(self): \n        tmp = self.head \n        while tmp is not None: \n            print(tmp.data, end=', ') \n            tmp = tmp.next\n        print() \n  \n    # Function to bring the last node to the front \n    def moveToFront(self): \n        tmp = self.head \n        sec_last = None  # To maintain the track of \n        # the second last node \n  \n    # To check whether we have not received \n    # the empty list or list with a single node \n        if not tmp or not tmp.next: \n            return\n  \n        # Iterate till the end to get \n        # the last and second last node \n        while tmp and tmp.next: \n            sec_last = tmp \n            tmp = tmp.next\n  \n        # point the next of the second \n        # last node to None \n        sec_last.next = None\n  \n        # Make the last node as the first Node \n        tmp.next = self.head \n        self.head = tmp \n  \n  \n# Driver's Code \nif __name__ == '__main__': \n    llist = LinkedList() \n  \n    # swap the 2 nodes \n    llist.push(5) \n    llist.push(4) \n    llist.push(3) \n    llist.push(2) \n    llist.push(1) \n    print('Linked List before moving last to front ') \n    llist.printList() \n      \n    # Function call \n    llist.moveToFront() \n    print('Linked List after moving last to front ') \n    llist.printList() \n"], "Write a function to get Nth node in a Linked List -  ": ["# A complete working Python program to find n'th node \n# in a linked list \n  \n# Node class \n  \n  \nclass Node: \n    # Function to initialise the node object \n    def __init__(self, data): \n        self.data = data  # Assign data \n        self.next = None  # Initialize next as null \n  \n  \n# Linked List class contains a Node object \nclass LinkedList: \n  \n    # Function to initialize head \n    def __init__(self): \n        self.head = None\n  \n    # This function is in LinkedList class. It inserts \n    # a new node at the beginning of Linked List. \n  \n    def push(self, new_data): \n  \n        # 1 & 2: Allocate the Node & \n        #     Put in the data \n        new_node = Node(new_data) \n  \n        # 3. Make next of new Node as head \n        new_node.next = self.head \n  \n        # 4. Move the head to point to new Node \n        self.head = new_node \n  \n    # Returns data at given index in linked list \n    def getNth(self, index): \n        current = self.head  # Initialise temp \n        count = 0  # Index of current node \n  \n        # Loop while end of linked list is not reached \n        while (current): \n            if (count == index): \n                return current.data \n            count += 1\n            current = current.next\n  \n        # if we get to this line, the caller was asking \n        # for a non-existent element so we assert fail \n        assert(false) \n        return 0\n  \n  \n# Driver Code \nif __name__ == '__main__': \n  \n    llist = LinkedList() \n  \n    # Use push() to construct below list \n    # 1->12->1->4->1 \n    llist.push(1) \n    llist.push(4) \n    llist.push(1) \n    llist.push(12) \n    llist.push(1) \n  \n    n = 3\n    print('Element at index 3 is :', llist.getNth(n)) \n", "# Python3 program to find n'th node in \n# linked list using recursion \n  \n  \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n  \n  \nclass LinkedList: \n    def __init__(self): \n        self.head = None\n  \n    ''' Given a reference (pointer to pointer) to the \n        head of a list and an int, push a new node on \n        the front of the list. '''\n  \n    def push(self, new_data):  # make new node and add \n                              # into LinkedList \n        new_node = Node(new_data) \n        new_node.next = self.head \n        self.head = new_node \n  \n    def getNth(self, llist, position): \n  \n        # call recursive method \n        llist.getNthNode(self.head, position, llist) \n  \n    # recursive method to find Nth Node \n    def getNthNode(self, head, position, llist): \n        count = 0  # initialize count \n        if(head): \n            if count == position:  # if count is equal to position, \n                                  # it means we have found the position \n                print(head.data) \n            else: \n                llist.getNthNode(head.next, position - 1, llist) \n        else:  # if head doesn't exist we have \n              # traversed the LinkedList \n            print('Index Doesn\\'t exist') \n  \n  \n# Driver Code \nif __name__ == '__main__': \n    llist = LinkedList() \n    llist.push(1) \n    llist.push(4) \n    llist.push(1) \n    llist.push(12) \n    llist.push(1) \n    # llist.getNth(llist,int(input())) \n    # Enter the node position here \n    # first argument is instance of LinkedList \n  \n    print('Element at Index 3 is', end=' ') \n    llist.getNth(llist, 3) \n  \n# This code is contributed by Yogesh Joshi \n"], "Find the middle of a given linked list -  ": ["class Node:\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\n \nclass NodeOperation:\n    def pushNode(self, head_ref, data_val):\n        new_node = Node(data=data_val)\n        new_node.next = head_ref[0]\n        head_ref[0] = new_node\n \nif __name__ == '__main__':\n    head = [None]\n    temp = NodeOperation()\n    for i in range(5, 0, -1):\n        temp.pushNode(head, i)\n    v = []\n    while head[0]:\n        v.append(head[0].data)\n        head[0] = head[0].next\n    print('Middle Value Of Linked List is :', v[len(v)//2])\n", "# Python program for the above approach\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass NodeOperation:\n    # Function to add a new node\n    def pushNode(self, head_ref, data_val):\n \n        # Allocate node and put in the data\n        new_node = Node(data_val)\n \n        # Link the old list of the new node\n        new_node.next = head_ref\n \n        # move the head to point to the new node\n        head_ref = new_node\n        return head_ref\n \n    # A utility function to print a given linked list\n    def printNode(self, head):\n        while (head != None):\n            print('%d->' % head.data, end='')\n            head = head.next\n        print('NULL')\n \n    ''' Utility Function to find length of linked list '''\n \n    def getLen(self, head):\n        temp = head\n        len = 0\n \n        while (temp != None):\n            len += 1\n            temp = temp.next\n \n        return len\n \n    def printMiddle(self, head):\n        if head != None:\n            # find length\n            len = self.getLen(head)\n            temp = head\n \n            # traverse till we reached half of length\n            midIdx = len // 2\n            while midIdx != 0:\n                temp = temp.next\n                midIdx -= 1\n \n            # temp will be storing middle element\n            print('The middle element is [ %d ]' % temp.data)\n \n \n# Driver Code\nhead = None\ntemp = NodeOperation()\nfor i in range(5, 0, -1):\n    head = temp.pushNode(head, i)\n    temp.printNode(head)\n    temp.printMiddle(head)\n \n# This code is contributed by Tapesh(tapeshdua420)\n", "# Python3 program to find middle of linked list\n# Node class \nclass Node: \n   \n    # Function to initialise the node object \n    def __init__(self, data): \n        self.data = data  # Assign data \n        self.next = None  # Initialize next as null \n   \n   \n# Linked List class contains a Node object \nclass LinkedList: \n   \n    # Function to initialize head \n    def __init__(self): \n        self.head = None\n \n    # Function to insert a new node at the beginning  \n    def push(self, new_data):  \n        new_node = Node(new_data)  \n        new_node.next = self.head  \n        self.head = new_node\n \n    # Print the linked list\n    def printList(self):\n        node = self.head\n        while node:\n            print(str(node.data) + '->', end='')\n            node = node.next\n        print('NULL')\n \n    # Function that returns middle.\n    def printMiddle(self):\n        # Initialize two pointers, one will go one step a time (slow), another two at a time (fast)\n        slow = self.head\n        fast = self.head\n \n        # Iterate till fast's next is null (fast reaches end)\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n         \n        # return the slow's data, which would be the middle element.\n        print('The middle element is ', slow.data)\n \n# Code execution starts here \nif __name__=='__main__': \n   \n    # Start with the empty list \n    llist = LinkedList() \n   \n    for i in range(5, 0, -1):\n        llist.push(i)\n        llist.printList()\n        llist.printMiddle()\n \n # Code is contributed by Kumar Shivam (kshivi99)\n", "# Node class \nclass Node: \n    \n    # Function to initialise the node object \n    def __init__(self, data): \n        self.data = data  # Assign data \n        self.next = None  # Initialize next as null \n    \n# Linked List class contains a Node object \nclass LinkedList: \n    \n    # Function to initialize head \n    def __init__(self): \n        self.head = None\n  \n    # Function to insert a new node at the beginning  \n    def push(self, new_data):  \n        new_node = Node(new_data)  \n        new_node.next = self.head  \n        self.head = new_node\n  \n    # Print the linked list\n    def printList(self):\n        node = self.head\n        while node:\n            print(str(node.data) + '->', end = '')\n            node = node.next\n        print('NULL')\n  \n    # Function to get the middle of\n    #  the linked list\n    def printMiddle(self):\n        count = 0\n        mid = self.head\n        heads = self.head\n   \n        while(heads != None):\n       \n        # Update mid, when 'count'\n        # is odd number \n            if count&1:\n                mid = mid.next\n            count += 1\n            heads = heads.next\n             \n        # If empty list is provided \n        if mid!=None:\n            print('The middle element is ', mid.data)\n  \n# Code execution starts here \nif __name__=='__main__': \n    \n    # Start with the empty list \n    llist = LinkedList() \n    \n    for i in range(5, 0, -1):\n        llist.push(i)\n        llist.printList()\n        llist.printMiddle()\n  \n # This Code is contributed by Manisha_Ediga\n"], "Identical Linked Lists -  ": ["# An iterative Java program to check if \n# two linked lists are identical or not \n  \n# Linked list Node \n  \n  \nclass Node: \n    def __init__(self, d): \n        self.data = d \n        self.next = None\n  \n  \nclass LinkedList: \n    def __init__(self): \n        self.head = None  # head of list \n  \n    # Returns true if linked lists a and b \n    # are identical, otherwise false \n    def areIdentical(self, listb): \n        a = self.head \n        b = listb.head \n        while (a != None and b != None): \n            if (a.data != b.data): \n                return False\n  \n            # If we reach here, then a and b \n            # are not null and their data is \n            # same, so move to next nodes \n            # in both lists \n            a = a.next\n            b = b.next\n  \n        # If linked lists are identical, \n        # then 'a' and 'b' must be null \n        # at this point. \n        return (a == None and b == None) \n  \n    # UTILITY FUNCTIONS TO TEST fun1() and fun2() \n    # Given a reference (pointer to pointer) to the \n    # head of a list and an int, push a new node on \n    # the front of the list. \n  \n    def push(self, new_data): \n  \n        # 1 & 2: Allocate the Node & \n        # Put in the data \n        new_node = Node(new_data) \n  \n        # 3. Make next of new Node as head \n        new_node.next = self.head \n  \n        # 4. Move the head to point to new Node \n        self.head = new_node \n  \n  \n# Driver Code \nif __name__ == '__main__': \n  llist1 = LinkedList() \n  llist2 = LinkedList() \n  \n  # The constructed linked lists are : \n  # llist1: 3->2->1 \n  # llist2: 3->2->1 \n  llist1.push(1) \n  llist1.push(2) \n  llist1.push(3) \n  llist2.push(1) \n  llist2.push(2) \n  llist2.push(3) \n  \n  # Function call \n  if (llist1.areIdentical(llist2) == True): \n      print('Identical ') \n  else: \n      print('Not identical ') \n  \n# This code is contributed by Prerna Saini \n", "# Python program for the above approach. \n  \n# Structure for a linked list node  \nclass Node: \n    def __init__(self,data): \n        self.data = data \n        self.next = None\n          \ndef push(head,new_data): \n    # allocate node and put data in it  \n    new_node = Node(new_data) \n      \n    # link the old list of the new node  \n    new_node.next = head \n    # move the head to point to the new node \n    head = new_node \n    return head \n  \ndef areIdentical(a,b): \n    # If both lists are empty \n    if a == None and b == None:  \n        return True\n    # If both lists are not empty, then data of \n    # current nodes must match, and same should \n    # be recursively true for rest of the nodes \n    if a != None and b != None: \n        return a.data == b.data and areIdentical(a.next,b.next) \n      \n    # If we reach here, then one of the lists \n    # is empty and other is not \n    return False\n      \n# Driver Code \n# The constructed linked lists are : \n# a: 3->2->1 \n# b: 3->2->1 \na = None\nb = None\na = push(a, 1) \na = push(a, 2) \na = push(a, 3) \nb = push(b, 1) \nb = push(b, 2) \nb = push(b, 3) \n  \n# Function call \nif areIdentical(a, b): \n    print('Identical') \nelse: \n    print('Not identical') \n      \n    # This code is contributed by hardikkushwaha.\n"], "Write a function to delete a Linked List -  ": ["# Delete linkedlist from beginning\nX = head\nhead = head.next\nX = None\n", "# Delete linkedlist from end\ntemp = head\nwhile (temp.next and temp.next.next != None):\n  temp = temp.next\ntemp.next = None\n", "# Delete linkedlist from middle\nfor i in range(2,position):\n  if temp.next != None:\n    temp = temp.next;\ntemp.next = temp.next.next;\n", "# Python3 program to delete all\n# the nodes of singly linked list\n \n# Node class\n \n \nclass Node:\n \n    # Function to initialise the node object\n    def __init__(self, data):\n        self.data = data  # Assign data\n        self.next = None  # Initialize next as null\n \n \n# Constructor to initialize the node object\nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    def deleteList(self):\n \n        # initialize the current node\n        current = self.head\n        while current:\n            next_to_current = current.next  # move next node\n \n            # delete the current node\n            del current.data\n \n            # set current equals prev node\n            current = next_to_current\n \n        # In python garbage collection happens\n        # therefore, only\n        # self.head = None\n        # would also delete the link list \n \n    # push function to add node in front of llist\n    def push(self, new_data):\n \n        # Allocate the Node &\n        # Put in the data\n        new_node = Node(new_data)\n \n        # Make next of new Node as head\n        new_node.next = self.head\n \n        # Move the head to point to new Node\n        self.head = new_node\n \n \n# Use push() to construct below\n# list 1-> 12-> 1-> 4-> 1\nif __name__ == '__main__':\n \n    llist = LinkedList()\n    llist.push(1)\n    llist.push(4)\n    llist.push(1)\n    llist.push(12)\n    llist.push(1)\n \n    print('Deleting linked list')\n    llist.deleteList()\n \n    print('Linked list deleted')\n \n \n# This article is provided by Shrikant13\n"], "Delete a Linked List node at a given position -  ": ["# Python program to delete a node in a linked list\n# at a given position\n \n# Node class\n \n \nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    # Constructor to initialize head\n    def __init__(self):\n        self.head = None\n \n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Given a reference to the head of a list\n    # and a position, delete the node at a given position\n    # This delete function code is contributed by Arabin Islam\n    def deleteNodeAtGivenPosition(self, position):\n        if self.head is None:\n            return\n        index = 0\n        current = self.head\n        while current.next and index < position:\n            previous = current\n            current = current.next\n            index += 1\n        if index < position:\n            print('\\nIndex is out of range.')\n        elif index == 0:\n            self.head = self.head.next\n        else:\n            previous.next = current.next\n            # current = None #Optional statement\n \n    # Utility function to print the LinkedList\n \n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(' %d ' % (temp.data), end=' ')\n            temp = temp.next\n \n \n# Driver program to test above function\nllist = LinkedList()\nllist.push(7)\nllist.push(1)\nllist.push(3)\nllist.push(2)\nllist.push(8)\n \nprint('Created Linked List: ')\nllist.printList()\nllist.deleteNodeAtGivenPosition(4)\nprint('\\nLinked List after Deletion at position 4: ')\nllist.printList()\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"], "Deletion in Linked List -  ": ["# Python program to implement the above approach\nclass Node:\n    # constructor to initialize the node object\n    def __init__(self, data):\n        self.number = data\n        self.next = None\n \n \ndef push(head, A):\n    n = Node(A)\n    n.number = A\n    n.next = head\n    head = n\n    return head\n \n \ndef deleteN(head, position):\n    temp = head\n    prev = head\n    for i in range(0, position):\n        if i == 0 and position == 1:\n            head = head.next\n \n        else:\n            if i == position-1 and temp is not None:\n                prev.next = temp.next\n            else:\n                prev = temp\n \n                # Position was greater than\n                # number of nodes in the list\n                if prev is None:\n                    break\n                temp = temp.next\n    return head\n \n \ndef printList(head):\n    while(head):\n        if head.next == None:\n            print('[', head.number, '] ', '[', hex(id(head)), ']->', 'nil')\n        else:\n            print('[', head.number, '] ', '[', hex(\n                id(head)), ']->', hex(id(head.next)))\n        head = head.next\n    print('')\n    print('')\n \n \nhead = Node(0)\nhead = push(head, 1)\nhead = push(head, 2)\nhead = push(head, 3)\n \nprintList(head)\n \n# Delete any position from list\nhead = deleteN(head, 1)\nprintList(head)\n \n# This code is contributed by Yash Agawral(yashagawral2852002)\n", "# Python program to delete a node in\n# singly linked list recursively\n \nclass Node:\n    def __init__(self,data):\n        self.data = data\n        self.next = None\n \n# Deletes the node containing 'data'\n# part as val and alter the head of\n# the linked list (recursive method)\ndef deleteNode(head, val):\n    # Check if list is empty or we\n    # reach at the end of the\n    # list.\n    if (head == None):\n        print('Element not present in the list')\n        return -1\n    # If current node is the\n    # node to be deleted\n    if (head.data == val):\n        # If it's start of the node head\n        # node points to second node\n        if head.next: \n            head.data = head.next.data\n            head.next = head.next.next\n            return 1\n        else: return 0\n    if deleteNode(head.next, val) == 0:\n        head.next = None\n        return 1\n \n# Utility function to add a\n# node in the linked list\n# Here we are passing head by\n# reference thus no need to\n# return it to the main function\ndef push(head, data):\n    newNode = Node(data) \n    newNode.next = head \n    head = newNode \n    return head\n \n# Utility function to print\n# the linked list (recursive\n# method)\ndef printLL(head):\n    if (head == None):\n        return\n    temp = head\n    while temp:\n        print(temp.data,end=' ')\n        temp = temp.next\n    print()\n \n# Driver Code\n \n# Starting with an empty linked list\nhead = None\n# Adds new element at the\n# beginning of the list\nhead = push(head, 10) \nhead = push(head, 12) \nhead = push(head, 14) \nhead = push(head, 15)\n# original list\nprintLL(head) \n# Call to delete function\ndeleteNode(head, 20) \n# 20 is not present thus no change\n# in the list\nprintLL(head) \ndeleteNode(head, 10) \nprintLL(head) \ndeleteNode(head, 14) \nprintLL(head)\n"], "Find Length of a Linked List (Iterative and Recursive) -  ": ["# A complete working Python program to find length of a\n# Linked List iteratively\n \n# Node class\n \n \nclass Node:\n    # Function to initialise the node object\n    def __init__(self, data):\n        self.data = data  # Assign data\n        self.next = None  # Initialize next as null\n \n \n# Linked List class contains a Node object\nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # This function is in LinkedList class. It inserts\n    # a new node at the beginning of Linked List.\n \n    def push(self, new_data):\n \n        # 1 & 2: Allocate the Node &\n        #     Put in the data\n        new_node = Node(new_data)\n \n        # 3. Make next of new Node as head\n        new_node.next = self.head\n \n        # 4. Move the head to point to new Node\n        self.head = new_node\n \n    # This function counts number of nodes in Linked List\n    # iteratively, given 'node' as starting node.\n \n    def getCount(self):\n        temp = self.head  # Initialise temp\n        count = 0  # Initialise count\n \n        # Loop while end of linked list is not reached\n        while (temp):\n            count += 1\n            temp = temp.next\n        return count\n \n \n# Driver code\nif __name__ == '__main__':\n    llist = LinkedList()\n    llist.push(1)\n    llist.push(3)\n    llist.push(1)\n    llist.push(2)\n    llist.push(1)\n     \n    # Function call\n    print('Count of nodes is :', llist.getCount())\n", "# A complete working Python program to find length of a\n# Linked List recursively\n \n# Node class\n \n \nclass Node:\n    # Function to initialise the node object\n    def __init__(self, data):\n        self.data = data  # Assign data\n        self.next = None  # Initialize next as null\n \n \n# Linked List class contains a Node object\nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # This function is in LinkedList class. It inserts\n    # a new node at the beginning of Linked List.\n \n    def push(self, new_data):\n \n        # 1 & 2: Allocate the Node &\n        #        Put in the data\n        new_node = Node(new_data)\n \n        # 3. Make next of new Node as head\n        new_node.next = self.head\n \n        # 4. Move the head to point to new Node\n        self.head = new_node\n \n    # This function counts number of nodes in Linked List\n    # recursively, given 'node' as starting node.\n    def getCountRec(self, node):\n        if (not node):  # Base case\n            return 0\n        else:\n            return 1 + self.getCountRec(node.next)\n \n    # A wrapper over getCountRec()\n    def getCount(self):\n        return self.getCountRec(self.head)\n \n \n# Code execution starts here\nif __name__ == '__main__':\n    llist = LinkedList()\n    llist.push(1)\n    llist.push(3)\n    llist.push(1)\n    llist.push(2)\n    llist.push(1)\n    print('Count of nodes is :', llist.getCount())\n", "# A complete working Python3 program to find length of a\n# Linked List using Tail recursion.\n \n# Node class\n \n \nclass Node:\n    # Function to initialise the node object\n    def __init__(self, data):\n        self.data = data  # Assign data\n        self.next = None  # Initialize next as null\n \n \n# Linked List class contains a Node object\nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # This function is in LinkedList class. It inserts\n    # a new node at the beginning of Linked List.\n \n    def push(self, new_data):\n \n        # 1 & 2: Allocate the Node &\n        #     Put in the data\n        new_node = Node(new_data)\n \n        # 3. Make next of new Node as head\n        new_node.next = self.head\n \n        # 4. Move the head to point to new Node\n        self.head = new_node\n \n    # This function counts number of nodes in Linked List\n    # recursively, given 'node' as starting node using Tail Recursion.\n    def getCountRec(self, node, count=0):\n        if (not node):  # Base case\n            return count\n        else:\n            return self.getCountRec(node.next, count+1)\n \n    # A wrapper over getCountRec()\n    def getCount(self):\n        return self.getCountRec(self.head)\n \n \n# Driver code\nif __name__ == '__main__':\n    llist = LinkedList()\n    llist.push(1)\n    llist.push(3)\n    llist.push(1)\n    llist.push(2)\n    llist.push(1)\n     \n    # Function call\n    print('Count of nodes is :', llist.getCount())\n \n    # This code is contributed by garinesrija.\n"], "Search an element in a Linked List (Iterative and Recursive) -  ": ["# Class definition for Node\nclass Node:\n    # Initialize the node with a key\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n   \n# Class definition for Linked List\nclass LinkedList:\n    # Initialize the linked list with a head node\n    def __init__(self):\n        self.head = None\n   \n    # Add a new node with key 'new_key' at the beginning of the linked list\n    def push(self, new_key):\n        new_node = Node(new_key)\n        new_node.next = self.head\n        self.head = new_node\n   \n# Create a linked list object\nllist = LinkedList()\n \n# Add new nodes to the linked list\nllist.push(10)\nllist.push(30)\nllist.push(11)\nllist.push(21)\nllist.push(14)\n   \n# Key to search for in the linked list\nx = 21\n \n# Create a temp variable to traverse the linked list\ntemp = llist.head\n \n# List to store the keys in the linked list\nv = []\n \n# Traverse the linked list and store the keys in the list 'v'\nwhile(temp):\n    v.append(temp.key)\n    temp = temp.next\n   \n# Check if 'x' is in the list 'v'\nif x in v:\n    print('YES')\nelse:\n    print('NO')\n", "# Iterative Python3 program to search an element\n# in linked list\n \n# Node class\n \n \nclass Node:\n \n    # Function to initialise the node object\n    def __init__(self, data):\n        self.data = data  # Assign data\n        self.next = None  # Initialize next as null\n \n# Linked List class\n \n \nclass LinkedList:\n    def __init__(self):\n        self.head = None  # Initialize head as None\n \n    # This function insert a new node at the\n    # beginning of the linked list\n    def push(self, new_data):\n \n        # Create a new Node\n        new_node = Node(new_data)\n \n        # 3. Make next of new Node as head\n        new_node.next = self.head\n \n        # 4. Move the head to point to new Node\n        self.head = new_node\n \n    # This Function checks whether the value\n    # x present in the linked list\n    def search(self, x):\n \n        # Initialize current to head\n        current = self.head\n \n        # loop till current not equal to None\n        while current != None:\n            if current.data == x:\n                return True  # data found\n \n            current = current.next\n \n        return False  # Data Not found\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Start with the empty list\n    llist = LinkedList()\n    x = 21\n     \n    ''' Use push() to construct below list\n        14->21->11->30->10 '''\n    llist.push(10)\n    llist.push(30)\n    llist.push(11)\n    llist.push(21)\n    llist.push(14)\n \n       # Function call\n    if llist.search(x):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed by Ravi Shankar\n", "# Recursive Python program to\n# search an element in linked list\n \n# Node class\n \n \nclass Node:\n \n    # Function to initialise\n    # the node object\n    def __init__(self, data):\n        self.data = data  # Assign data\n        self.next = None  # Initialize next as null\n \n \nclass LinkedList:\n \n    def __init__(self):\n        self.head = None  # Initialize head as None\n \n    # This function insert a new node at\n    # the beginning of the linked list\n    def push(self, new_data):\n \n        # Create a new Node\n        new_node = Node(new_data)\n \n        # Make next of new Node as head\n        new_node.next = self.head\n \n        # Move the head to\n        # point to new Node\n        self.head = new_node\n \n    # Checks whether the value key\n    # is present in linked list\n \n    def search(self, li, key):\n \n        # Base case\n        if(not li):\n            return False\n \n        # If key is present in\n        # current node, return true\n        if(li.data == key):\n            return True\n \n        # Recur for remaining list\n        return self.search(li.next, key)\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    li = LinkedList()\n \n    li.push(10)\n    li.push(30)\n    li.push(11)\n    li.push(21)\n    li.push(14)\n \n    x = 21\n \n    # Function call\n    if li.search(li.head, x):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed\n# by Manoj Sharma\n"], "Insertion in Linked List -  ": ["# This function is in LinkedList class\n# Function to insert a new node at the beginning\ndef push(self, new_data):\n \n    # 1 & 2: Allocate the Node &\n    # Put in the data\n    new_node = Node(new_data)\n \n    # 3. Make next of new Node as head\n    new_node.next = self.head\n \n    # 4. Move the head to point to new Node\n    self.head = new_node\n", "# This function is in LinkedList class.\n# Inserts a new node after the given prev_node. This method is\n# defined inside LinkedList class shown above */\ndef insertAfter(self, prev_node, new_data):\n \n    # 1. check if the given prev_node exists\n    if prev_node is None:\n        print('The given previous node must inLinkedList.')\n        return\n \n    # 2. Create new node &\n    # 3. Put in the data\n    new_node = Node(new_data)\n \n    # 4. Make next of new Node as next of prev_node\n    new_node.next = prev_node.next\n \n    # 5. make next of prev_node as new_node\n    prev_node.next = new_node\n", "# This function is defined in Linked List class\n# Appends a new node at the end. This method is\n# defined inside LinkedList class shown above\ndef append(self, new_data):\n \n        # 1. Create a new node\n        # 2. Put in the data\n        # 3. Set next as None\n        new_node = Node(new_data)\n \n        # 4. If the Linked List is empty, then make the\n        # new node as head\n        if self.head is None:\n            self.head = new_node\n            return\n \n        # 5. Else traverse till the last node\n        last = self.head\n        while (last.next):\n            last = last.next\n \n        # 6. Change the next of last node\n        last.next = new_node\n"], "Prim\u2019s Algorithm for Minimum Spanning Tree (MST) -  ": ["# A Python3 program for \n# Prim's Minimum Spanning Tree (MST) algorithm.\n# The program is for adjacency matrix \n# representation of the graph\n \n# Library for INT_MAX\nimport sys\n \n \nclass Graph():\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)]\n                      for row in range(vertices)]\n \n    # A utility function to print \n    # the constructed MST stored in parent[]\n    def printMST(self, parent):\n        print('Edge \\tWeight')\n        for i in range(1, self.V):\n            print(parent[i], '-', i, '\\t', self.graph[i][parent[i]])\n \n    # A utility function to find the vertex with\n    # minimum distance value, from the set of vertices\n    # not yet included in shortest path tree\n    def minKey(self, key, mstSet):\n \n        # Initialize min value\n        min = sys.maxsize\n \n        for v in range(self.V):\n            if key[v] < min and mstSet[v] == False:\n                min = key[v]\n                min_index = v\n \n        return min_index\n \n    # Function to construct and print MST for a graph\n    # represented using adjacency matrix representation\n    def primMST(self):\n \n        # Key values used to pick minimum weight edge in cut\n        key = [sys.maxsize] * self.V\n        parent = [None] * self.V  # Array to store constructed MST\n        # Make key 0 so that this vertex is picked as first vertex\n        key[0] = 0\n        mstSet = [False] * self.V\n \n        parent[0] = -1  # First node is always the root of\n \n        for cout in range(self.V):\n \n            # Pick the minimum distance vertex from\n            # the set of vertices not yet processed.\n            # u is always equal to src in first iteration\n            u = self.minKey(key, mstSet)\n \n            # Put the minimum distance vertex in\n            # the shortest path tree\n            mstSet[u] = True\n \n            # Update dist value of the adjacent vertices\n            # of the picked vertex only if the current\n            # distance is greater than new distance and\n            # the vertex in not in the shortest path tree\n            for v in range(self.V):\n \n                # graph[u][v] is non zero only for adjacent vertices of m\n                # mstSet[v] is false for vertices not yet included in MST\n                # Update the key only if graph[u][v] is smaller than key[v]\n                if self.graph[u][v] > 0 and mstSet[v] == False \\\n                and key[v] > self.graph[u][v]:\n                    key[v] = self.graph[u][v]\n                    parent[v] = u\n \n        self.printMST(parent)\n \n \n# Driver's code\nif __name__ == '__main__':\n    g = Graph(5)\n    g.graph = [[0, 2, 0, 6, 0],\n               [2, 0, 3, 8, 5],\n               [0, 3, 0, 0, 7],\n               [6, 8, 0, 0, 9],\n               [0, 5, 7, 9, 0]]\n \n    g.primMST()\n \n \n# Contributed by Divyanshu Mehta\n", "import heapq\n \ndef tree(V, E, edges):\n    # Create an adjacency list representation of the graph\n    adj = [[] for _ in range(V)]\n    # Fill the adjacency list with edges and their weights\n    for i in range(E):\n        u, v, wt = edges[i]\n        adj[u].append((v, wt))\n        adj[v].append((u, wt))\n    # Create a priority queue to store edges with their weights\n    pq = []\n    # Create a visited array to keep track of visited vertices\n    visited = [False] * V\n    # Variable to store the result (sum of edge weights)\n    res = 0\n    # Start with vertex 0\n    heapq.heappush(pq, (0, 0))\n    # Perform Prim's algorithm to find the Minimum Spanning Tree\n    while pq:\n        wt, u = heapq.heappop(pq)\n        if visited[u]:\n            continue \n            # Skip if the vertex is already visited\n        res += wt  \n        # Add the edge weight to the result\n        visited[u] = True \n        # Mark the vertex as visited\n        # Explore the adjacent vertices\n        for v, weight in adj[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (weight, v))  \n                # Add the adjacent edge to the priority queue\n    return res  \n  # Return the sum of edge weights of the Minimum Spanning Tree\nif __name__ == '__main__':\n    graph = [[0, 1, 5],\n             [1, 2, 3],\n             [0, 2, 1]]\n    # Function call\n    print(tree(3, 3, graph))\n"], "Bellman\u2013Ford Algorithm -  ": ["# Python3 program for Bellman-Ford's single source\n# shortest path algorithm.\n \n# Class to represent a graph\n \nclass Graph:\n \n    def __init__(self, vertices):\n        self.V = vertices  # No. of vertices\n        self.graph = []\n \n    # function to add an edge to graph\n    def addEdge(self, u, v, w):\n        self.graph.append([u, v, w])\n \n    # utility function used to print the solution\n    def printArr(self, dist):\n        print('Vertex Distance from Source')\n        for i in range(self.V):\n            print('{0}\\t\\t{1}'.format(i, dist[i]))\n \n    # The main function that finds shortest distances from src to\n    # all other vertices using Bellman-Ford algorithm. The function\n    # also detects negative weight cycle\n    def BellmanFord(self, src):\n \n        # Step 1: Initialize distances from src to all other vertices\n        # as INFINITE\n        dist = [float('Inf')] * self.V\n        dist[src] = 0\n \n        # Step 2: Relax all edges |V| - 1 times. A simple shortest\n        # path from src to any other vertex can have at-most |V| - 1\n        # edges\n        for _ in range(self.V - 1):\n            # Update dist value and parent index of the adjacent vertices of\n            # the picked vertex. Consider only those vertices which are still in\n            # queue\n            for u, v, w in self.graph:\n                if dist[u] != float('Inf') and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n \n        # Step 3: check for negative-weight cycles. The above step\n        # guarantees shortest distances if graph doesn't contain\n        # negative weight cycle. If we get a shorter path, then there\n        # is a cycle.\n \n        for u, v, w in self.graph:\n            if dist[u] != float('Inf') and dist[u] + w < dist[v]:\n                print('Graph contains negative weight cycle')\n                return\n \n        # print all distance\n        self.printArr(dist)\n \n \n# Driver's code\nif __name__ == '__main__':\n    g = Graph(5)\n    g.addEdge(0, 1, -1)\n    g.addEdge(0, 2, 4)\n    g.addEdge(1, 2, 3)\n    g.addEdge(1, 3, 2)\n    g.addEdge(1, 4, 2)\n    g.addEdge(3, 2, 5)\n    g.addEdge(3, 1, 1)\n    g.addEdge(4, 3, -3)\n \n    # function call\n    g.BellmanFord(0)\n \n# Initially, Contributed by Neelam Yadav\n# Later On, Edited by Himanshu Garg\n"], "What is Dijkstra\u2019s Algorithm? | Introduction to Dijkstra's Shortest Path Algorithm -  ": ["# Python implementation of Dijkstra Algorithm\n \nimport heapq\n \nclass Node:\n    def __init__(self, v, distance):\n        self.v = v\n        self.distance = distance\n \n    def __lt__(self, other):\n        return self.distance < other.distance\n \ndef dijkstra(V, adj, S):\n    visited = [False] * V\n    map = {}\n    q = []\n \n    map[S] = Node(S, 0)\n    heapq.heappush(q, Node(S, 0))\n \n    while q:\n        n = heapq.heappop(q)\n        v = n.v\n        distance = n.distance\n        visited[v] = True\n \n        adjList = adj[v]\n        for adjLink in adjList:\n            if not visited[adjLink[0]]:\n                if adjLink[0] not in map:\n                    map[adjLink[0]] = Node(v, distance + adjLink[1])\n                else:\n                    sn = map[adjLink[0]]\n                    if distance + adjLink[1] < sn.distance:\n                        sn.v = v\n                        sn.distance = distance + adjLink[1]\n                heapq.heappush(q, Node(adjLink[0], distance + adjLink[1]))\n \n    result = [0] * V\n    for i in range(V):\n        result[i] = map[i].distance\n \n    return result\n \ndef main():\n    adj = [[] for _ in range(6)]\n \n    V = 6\n    E = 5\n    u = [0, 0, 1, 2, 4]\n    v = [3, 5, 4, 5, 5]\n    w = [9, 4, 4, 10, 3]\n \n    for i in range(E):\n        edge = [v[i], w[i]]\n        adj[u[i]].append(edge)\n \n        edge2 = [u[i], w[i]]\n        adj[v[i]].append(edge2)\n \n    S = 1\n \n    result = dijkstra(V, adj, S)\n    print(result)\n \nif __name__ == '__main__':\n    main()\n \n# This code is contributed by ragul21\n"], "Print all subsets of a given Set or Array -  ": ["#Function to find the subsets of the given array\ndef findSubsets(nums, n):\n    # Loop through all possible subsets using bit manipulation\n    for i in range(1 << n):\n        # Loop through all elements of the input array\n        for j in range(n):\n            #Check if the jth bit is set in the current subset\n            if (i & (1 << j)) != 0:\n                #If the jth bit is set, add the jth element to the subset\n                print(nums[j], end=' ')\n        print()\n#Driver Code\narr = [1, 2, 3]\nn = len(arr)\nfindSubsets(arr, n)\n"], "Permutations of given String -  ": ["# Python3 program to print all permutations with \n# duplicates allowed \n  \n  \ndef toString(List): \n    return ''.join(List) \n  \n# Function to print permutations of string \n# This function takes three parameters: \n# 1. String \n# 2. Starting index of the string \n# 3. Ending index of the string. \n  \n  \ndef permute(a, l, r): \n    if l == r: \n        print(toString(a)) \n    else: \n        for i in range(l, r): \n            a[l], a[i] = a[i], a[l] \n            permute(a, l+1, r) \n            a[l], a[i] = a[i], a[l]  # backtrack \n  \n  \n# Driver code \nstring = 'ABC'\nn = len(string) \na = list(string) \n  \n# Function call \npermute(a, 0, n) \n  \n# This code is contributed by Bhavya Jain \n"], "Write program to calculate pow(x, n) -  ": ["# Python3 program for the above approach\ndef power(x, n):\n \n    # If x^0 return 1\n    if (n == 0):\n        return 1\n \n    # If we need to find of 0^y\n    if (x == 0):\n        return 0\n \n    # For all other cases\n    return x * power(x, n - 1)\n \n \n# Driver Code\nif __name__ == '__main__':\n    x = 2\n    n = 3\n \n    # Function call\n    print(power(x, n))\n \n# This code is contributed by shivani.\n", "# Function to calculate x raised to the power y in O(logn)\ndef power(x, y):\n    temp = 0\n    if(y == 0):\n        return 1\n    temp = power(x, int(y / 2))\n    if (y % 2 == 0)\n    return temp * temp\n    else\n    return x * temp * temp\n \n# This code is contributed by avanitrachhadiya2155\n", "# Python3 code for extended version\n# of power function that can work\n# for float x and negative y\n \n \ndef power(x, y):\n \n    if(y == 0):\n        return 1\n    temp = power(x, int(y / 2))\n \n    if (y % 2 == 0):\n        return temp * temp\n    else:\n        if(y > 0):\n            return x * temp * temp\n        else:\n            return (temp * temp) / x\n \n \n# Driver Code\nif __name__ == '__main__':\n    x, y = 2, -3\n \n    # Function call\n    print('%.6f' % (power(x, y)))\n \n# This code is contributed by Smitha Dinesh Semwal.\n", "# Python3 program for the above approach\ndef power(x, n):\n \n    # Return type of pow()\n    # function is double\n    return pow(x, n)\n \n \n# Driver Code\nif __name__ == '__main__':\n    x = 2\n    n = 3\n \n    # Function call\n    print(power(x, n))\n \n# This code is contributed by susmitakundugoaldanga\n", "# Python3 program for the above approach\ndef power(x, n):\n \n    result = 1\n    while (n > 0):\n        if (n % 2 == 0):\n            # y is even\n \n            x = x * x\n            n = n / 2\n \n        else:\n            # y isn't even\n \n            result = result * x\n            n = n - 1\n \n    return result\n \n \n# Driver Code\nif __name__ == '__main__':\n    x = 2\n    n = 3\n \n    # Function call\n    print((power(x, n)))\n \n# This code is contributed by shivanisinghss2110\n", "# Python program to illustrate use of ** operator\n# to calculate power of a number\ndef power(x, n):\n \n    # Calculate the power\n    return x**n\n \n \n# Driver Code\nif __name__ == '__main__':\n    x = 2\n    n = 3\n \n    # Function call\n    print(power(x, n))\n \n# This code is contributed by Susobhan Akhuli\n", "import numpy as np\n \nN = 2\nX = 3\nresult = np.power(N, X)\nprint(result) # Output: 8\n \n#This code is contributed by Susobhan Akhuli\n", "import math\n \ndef calculatePower(a, n):\n    return round(2 ** (math.log2(a) * n))\n \n# Driver code\nif __name__ == '__main__':\n    a = 2\n    n = 3\n    print(calculatePower(a, n)) # Output: a^n\n \n# This code is contributed by Susobhan Akhuli\n", "import math\n \ndef calculatePower(x, n):\n      ans = math.exp(math.log(x) * n)\n      ans = round(ans)\n      return ans\n \n# Driver code\nif __name__ == '__main__':\n    x = 2\n    n = 3\n    print(calculatePower(x, n)) # Output: x^n\n \n# This code is contributed by Susobhan Akhuli\n"], "Queue Operations -  ": ["# Python Program to implement above approach\nimport collections\n \n# Helper class Geeks to implement\n# insert() and findFrequency()\nclass Geeks:\n \n    # Function to insert\n    # element into the queue\n    def insert(self, q, k):\n       \n        # adding N integers into the Queue\n        q.append(k)\n \n    # Function to find frequency of an element\n    # return the frequency of k\n    def findFrequency(self, q, k):\n       \n        # to count frequency of elements\n        cntFrequency = 0\n \n        # storing size of queue in a variable\n        size = len(q)\n \n        # running loop until size becomes zero\n        while (size):\n            size = size - 1\n             \n            # storing and deleting\n            # first element from queue\n            x = q.popleft()\n \n            # comparing if it's equal to integer K\n            # that belongs to M\n            if (x == k):\n               \n                # increment count\n                cntFrequency += 1\n                 \n            # add element back to queue because\n            # we also want N integers\n            q.append(x)\n \n        # return the count\n        return cntFrequency\n \n# Declaring Queue\nq = collections.deque()\nN = 8\na = [1, 2, 3, 4, 5, 2, 3, 1]\nM = 5\nb = [1, 3, 2, 9, 10]\n \n# Invoking object of Geeks class\nobj = Geeks()\n \nfor i in range(N):\n \n    # calling insert()\n    # to add elements in queue\n    obj.insert(q, a[i])\n \nfor i in range(M):\n \n    # calling findFrequency()\n    f = obj.findFrequency(q, b[i])\n    if (f != 0):\n       \n        # variable f\n        # will have final frequency\n        print(f, end=' ')\n    else:\n        print('-1', end=' ')\nprint(' ')\n \n# This code is contributed by gfgking.\n"], "Basic Operations in Stack Data Structure with Implementations -  ": ["# Python Code:\nstack = []\n \nstack.append(1) # This pushes 1 to the stack top\n \nstack.append(2) # This pushes 2 to the stack top\n \nstack.append(3) # This pushes 3 to the stack top\n \nstack.append(4) # This pushes 4 to the stack top\n \nstack.append(5) # This pushes 5 to the stack top\n \n# printing the stack\n \nwhile stack:\n    print(stack[-1], end=' ')\n    stack.pop()\n \n# The above loop prints '5 4 3 2 1'\n \n# This code is contributed by Sakshi\n", "# Python Code:\nstack = []\n \nstack.append(1) # This pushes 1 to the stack top\n \nstack.append(2) # This pushes 2 to the stack top\n \nstack.append(3) # This pushes 3 to the stack top\n \nstack.append(4) # This pushes 4 to the stack top\n \nstack.append(5) # This pushes 5 to the stack top\n \n \n# Now, let us remove elements from the stack using pop\n# function\nprint(stack[-1], end=' ')\nstack.pop() # removes 5 from the stack since 5 was present\n            # at the top. Now, the new stack top\n            # becomes 4.\nprint(stack[-1], end=' ')\nstack.pop() # removes 4 from the stack since 4 was present\n            # at the top. Now, the new stack top\n            # becomes 3.\n     \nprint(stack[-1], end=' ')\nstack.pop() # removes 3 from the stack since 3 was present\n            # at the top. Now, the new stack top\n            # becomes 2.\n     \nprint(stack[-1], end=' ')\nstack.pop() # removes 2 from the stack since 2 was present\n            # at the top. Now, the new stack top\n            # becomes 1.\n     \nprint(stack[-1], end=' ')\nstack.pop() # removes 1 from the stack since 1 was present\n            # at the top. Now, the stack becomes empty.\n   \n# This code is contributed by Sakshi\n", "# Python code:\n \ndef topElement(s):\n    return s[-1]\n \ns = [] # creating a stack of integers\n \ns.append(1) # This pushes 1 to the stack top\nprint(topElement(s)) # Prints 1 since 1 is present at the stack top\n \ns.append(2) # This pushes 2 to the stack top\nprint(topElement(s)) # Prints 2 since 2 is present at the stack top\n \ns.append(3) # This pushes 3 to the stack top\nprint(topElement(s)) # Prints 3 since 3 is present at the stack top\n \n# This code is contributed by Sakshi\n", "# Python Code:\ndef isEmpty(s):\n    isStackEmpty = len(s) == 0 # checking whether stack is empty or \n                               # not and storing it into isStackEmpty variable\n    return isStackEmpty # returning bool value stored in isStackEmpty\n \ns = []\n \n# The if - else conditional statements below prints 'Stack is empty.'\nif isEmpty(s):\n    print('Stack is empty.')\nelse:\n    print('Stack is not empty.')\n \ns.append(1) # Inserting value 1 to the stack top\n \n# The if - else conditional statements below prints 'Stack is not empty.'\nif isEmpty(s):\n    print('Stack is empty.')\nelse:\n    print('Stack is not empty.')\n     \n# This code is contributed by Sakshi\n", "# PYthon Code:\nstack = [] # creating an empty list as a stack\n \nprint(len(stack)) # Prints 0 since the stack is empty\n \nstack.append(1) # This appends 1 to the stack\nstack.append(2) # This appends 2 to the stack\nprint(len(stack)) # Prints 2 since the stack contains two elements\n \nstack.append(3) # This appends 3 to the stack\nprint(len(stack)) # Prints 3 since the stack contains three element\n \n# This code is contributed by Sakshi\n"], "Applications, Advantages and Disadvantages of Linked List -  ": [], "Types of Linked List -  ": ["# Node of a singly linked list\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n", "# structure of Node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n    def __init__(self):\n        self.head = None\n        self.last_node = None\n \n    # function to add elements to linked list\n    def append(self, data):\n        # if linked list is empty then last_node will be none so in if condition head will be created\n        if self.last_node is None:\n            self.head = Node(data)\n            self.last_node = self.head\n        # adding node to the tail of linked list\n        else:\n            self.last_node.next = Node(data)\n            self.last_node = self.last_node.next\n \n# function to print the content of linked list\n    def display(self):\n        current = self.head\n      # traversing the linked list\n        while current is not None:\n          # at each node printing its data\n            print(current.data, end=' ')\n           # giving current next node\n            current = current.next\n        print()\n \n# Driver code\nif __name__ == '__main__':\n    L = LinkedList()\n    # adding elements to the linked list\n    L.append(1)\n    L.append(2)\n    L.append(3)\n    # displaying elements of linked list\n    L.display()\n", "# structure of Node\nclass Node:\n    def __init__(self, data):\n        self.previous = None\n        self.data = data\n        self.next = None\n", "# Python3 program to illustrate\n# creation and traversal of\n# Doubly Linked List\n \n# structure of Node\nclass Node:\n    def __init__(self, data):\n        self.previous = None\n        self.data = data\n        self.next = None\n \n \nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.start_node = None\n        self.last_node = None\n \n    # function to add elements to doubly linked list\n    def append(self, data):\n        # is doubly linked list is empty then last_node will be none so in if condition head will be created\n        if self.last_node is None:\n            self.head = Node(data)\n            self.last_node = self.head\n        # adding node to the tail of doubly linked list\n        else:\n            new_node = Node(data)\n            self.last_node.next = new_node\n            new_node.previous = self.last_node\n            new_node.next = None\n            self.last_node = new_node\n \n    # function to printing and traversing the content of doubly linked list from left to right and right to left\n    def display(self, Type):\n        if Type == 'Left_To_Right':\n            current = self.head\n            while current is not None:\n                print(current.data, end=' ')\n                current = current.next\n            print()\n        else:\n            current = self.last_node\n            while current is not None:\n                print(current.data, end=' ')\n                current = current.previous\n            print()\n \n# Driver code\nif __name__ == '__main__':\n    L = DoublyLinkedList()\n    L.append(1)\n    L.append(2)\n    L.append(3)\n    L.append(4)\n    L.display('Left_To_Right')\n    L.display('Right_To_Left')\n", "# structure of Node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n", "# Python3 program to illustrate\n# creation and traversal of\n# Circular LL\n \n# structure of Node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n        self.last_node = None\n \n    # function to add elements to circular linked list\n    def append(self, data):\n        # is circular linked list is empty then last_node will be none so in if condition head will be created\n        if self.last_node is None:\n            self.head = Node(data)\n            self.last_node = self.head\n        # adding node to the tail of circular linked list\n        else:\n            self.last_node.next = Node(data)\n            self.last_node = self.last_node.next\n            self.last_node.next = self.head\n \n    # function to print the content of circular linked list\n    def display(self):\n        current = self.head\n        while current is not None:\n            print(current.data, end=' ')\n            current = current.next\n            if current == self.head:\n                break\n        print()\n \n# Driver code\nif __name__ == '__main__':\n    L = CircularLinkedList()\n    L.append(12)\n    L.append(56)\n    L.append(2)\n    L.append(11)\n         \n    # Function call\n    L.display()\n", "# structure of Node\nclass Node:\n    def __init__(self, data):\n        self.previous = None\n        self.data = data\n        self.next = None\n", "# Python3 program to illustrate creation\n# & traversal of Doubly Circular LL\n \n# structure of Node\nclass Node:\n    def __init__(self, data):\n        self.previous = None\n        self.data = data\n        self.next = None\n \n \nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.start_node = None\n        self.last_node = None\n \n    # function to add elements to doubly linked list\n    def append(self, data):\n        # is doubly linked list is empty then last_node will be none so in if condition head will be created\n        if self.last_node is None:\n            self.head = Node(data)\n            self.last_node = self.head\n        # adding node to the tail of doubly linked list\n        else:\n            new_node = Node(data)\n            self.last_node.next = new_node\n            new_node.previous = self.last_node\n            new_node.next = self.head\n            self.head.previous = new_node\n            self.last_node = new_node\n \n    # function to print the content of doubly linked list\n    def display(self, Type='Left_To_Right'):\n        if Type == 'Left_To_Right':\n            current = self.head\n            while current.next is not None:\n                print(current.data, end=' ')\n                current = current.next\n                if current == self.head:\n                    break\n            print()\n        else:\n            current = self.last_node\n            while current.previous is not None:\n                print(current.data, end=' ')\n                current = current.previous\n                if current == self.last_node.next:\n                    print(self.last_node.next.data, end=' ')\n                    break\n            print()\n \n \nif __name__ == '__main__':\n    L = DoublyLinkedList()\n    L.append(1)\n    L.append(2)\n    L.append(3)\n    L.append(4)\n    L.display('Left_To_Right')\n    L.display('Right_To_Left')\n", "# structure of Node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n", "# Python3 program to illustrate creation\n# and traversal of Header Linked List\n \n# structure of Node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n    def __init__(self):\n        self.head = Node(0)\n        self.last_node = self.head\n \n    # function to add elements to header linked list\n    def append(self, data):\n        self.last_node.next = Node(data)\n        self.last_node = self.last_node.next\n \n    # function to print the content of header linked list\n    def display(self):\n        current = self.head.next\n        # traversing the header linked list\n        while current is not None:\n            # at each node printing its data\n            print(current.data, end=' ')\n            # giving current next node\n            current = current.next\n        # print(self.head.data)\n        print()\n \n# Driver code\nif __name__ == '__main__':\n    L = LinkedList()\n    # adding elements to the header linked list\n    L.append(1)\n    L.append(2)\n    L.append(3)\n    L.append(4)\n    # displaying elements of header linked list\n    L.display()\n"], "Program to print all substrings of a given string -  ": ["# Python3 program to print all possible\n# substrings of a given string\n \n \n# Function to print all sub strings\ndef subString(Str,n):\n     \n    # Pick starting point\n    for Len in range(1,n + 1):\n         \n        # Pick ending point\n        for i in range(n - Len + 1):\n             \n            # Print characters from current\n            # starting point to current ending\n            # point. \n            j = i + Len - 1\n \n            for k in range(i,j + 1):\n                print(Str[k],end='')\n            print()\n             \n# Driver program to test above function\nStr = 'abc'\nsubString(Str,len(Str))\n \n# This code is contributed by mohit kumar\n", "     \n# Python program to print all possible\n# substrings of a given string\n  \n# Function to print all sub strings\ndef subString(s, n):\n    # Pick starting point in outer loop\n    # and lengths of different strings for\n    # a given starting point\n    for i in range(n):\n        for len in range(i+1,n+1):\n            print(s[i: len]);\n \n# Driver program to test above function\ns = 'abcd';\nsubString(s,len(s));\n \n# This code is contributed by princiraj1992\n", "'''\n* Python3 program to print all possible\n* substrings of a given string\n* without checking for duplication.\n'''\n \n \n'''\n* Function to print all (n * (n + 1)) / 2\n* substrings of a given string s of length n.\n'''\ndef printAllSubstrings(s, n):\n \n    # Fix start index in outer loop.\n    # Reveal new character in inner loop till end of string.\n    # Print till-now-formed string.\n    for i in range(n):\n        temp=''\n        for j in range(i,n):\n            temp+=s[j]\n            print(temp)\n \n# Driver program to test above function\n \ns = 'Geeky'\nprintAllSubstrings(s, len(s))\n \n# This code is contributed by shubhamsingh10\n", "# Python program for the above approach\ndef printSubstrings(string, n):\n \n  # this is for the selection\n    # of starting point\n    for i in range(n):\n       \n        # 2nd for loop is for selection\n        # of ending point\n        for j in range(i, n):\n           \n            # 3rd loop is for printing from\n            # starting point to ending point\n            for k in range(i, (j + 1)):\n                print(string[k], end='')\n                 \n            # changing the line after printing\n            # from starting point to ending point\n            print()\n \n# Driver Code\nstring = 'abcd'\n# calling the method to print the substring\nprintSubstrings(string, len(string))\n", "# Python program for the above approach\ndef printSubStrings(str):\n \n    # First loop for starting index\n    for i in range(len(str)):\n        subStr = ''\n \n        # Second loop is generating sub-String\n        for j in range(i,len(str)):\n            subStr += str[j]\n            print(subStr + '')\n         \n# Driver Code\nif __name__ == '__main__':\n    str = 'abcd'\n    printSubStrings(str)\n     \n# This code is contributed by umadevi9616 \n"], "Basic String Operations with Implementation -  ": [], "QuickSort on Singly Linked List -  ": ["''' \n  \nsort a linked list using quick sort \n  \n'''\n  \n  \nclass Node: \n    def __init__(self, val): \n        self.data = val \n        self.next = None\n  \n  \nclass QuickSortLinkedList: \n  \n    def __init__(self): \n        self.head = None\n  \n    def addNode(self, data): \n        if (self.head == None): \n            self.head = Node(data) \n            return\n  \n        curr = self.head \n        while (curr.next != None): \n            curr = curr.next\n  \n        newNode = Node(data) \n        curr.next = newNode \n  \n    def printList(self, n): \n        while (n != None): \n            print(n.data, end=' ') \n            n = n.next\n  \n    ''' takes first and last node,but do not \n    break any links in    the whole linked list'''\n  \n    def partitionLast(self, start, end): \n        if (start == end or start == None or end == None): \n            return start \n  \n        pivot_prev = start \n        curr = start \n        pivot = end.data \n  \n        '''iterate till one before the end,  \n        no need to iterate till the end because end is pivot'''\n  \n        while (start != end): \n            if (start.data < pivot): \n  \n                # keep tracks of last modified item \n                pivot_prev = curr \n                temp = curr.data \n                curr.data = start.data \n                start.data = temp \n                curr = curr.next\n            start = start.next\n  \n        '''swap the position of curr i.e.  \n        next suitable index and pivot'''\n  \n        temp = curr.data \n        curr.data = pivot \n        end.data = temp \n  \n        ''' return one previous to current because  \n        current is now pointing to pivot '''\n        return pivot_prev \n  \n    def sort(self, start, end): \n        if(start == None or start == end or start == end.next): \n            return\n  \n        # split list and partition recurse \n        pivot_prev = self.partitionLast(start, end) \n        self.sort(start, pivot_prev) \n  \n        ''' \n        if pivot is picked and moved to the start, \n        that means start and pivot is same  \n        so pick from next of pivot \n        '''\n        if(pivot_prev != None and pivot_prev == start): \n            self.sort(pivot_prev.next, end) \n  \n        # if pivot is in between of the list,start from next of pivot, \n        # since we have pivot_prev, so we move two nodes \n        elif (pivot_prev != None and pivot_prev.next != None): \n            self.sort(pivot_prev.next.next, end) \n  \n  \nif __name__ == '__main__': \n    ll = QuickSortLinkedList() \n    ll.addNode(30) \n    ll.addNode(3) \n    ll.addNode(4) \n    ll.addNode(20) \n    ll.addNode(5) \n  \n    N = ll.head \n    while (N.next != None): \n        N = N.next\n  \n    print('\\nLinked List before sorting') \n    ll.printList(ll.head) \n  \n    # Function call \n    ll.sort(ll.head, N) \n  \n    print('\\nLinked List after sorting') \n    ll.printList(ll.head) \n  \n    # This code is contributed by humpheykibet. \n"], "Given only a pointer to a node to be deleted in a singly linked list, how do you delete it? -  ": ["# A python3 program to delete\n# the node in which only a single pointer\n# is known pointing to that node\n \n# Linked list node\n \n \nclass Node():\n    def __init__(self):\n        self.data = None\n        self.next = None\n \n# Given a reference (pointer to pointer)\n# to the head of a list and an int,\n# push a new node on the front of the list\n \n \ndef push(head_ref, new_data):\n \n    # allocate node\n    new_node = Node()\n \n    # put in the data\n    new_node.data = new_data\n \n    # link the old list of the new node\n    new_node.next = head_ref\n \n    # move the head to point to the new node\n    head_ref = new_node\n \n    return head_ref\n \n \ndef printList(head):\n    temp = head\n    while(temp != None):\n        print(temp.data, end=' ')\n        temp = temp.next\n \n \ndef deleteNode(node_ptr):\n    temp = node_ptr.next\n    node_ptr.data = temp.data\n    node_ptr.next = temp.next\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Start with the empty list\n    head = None\n \n    # Use push() to construct below list\n    # 1->12->1->4->1\n    head = push(head, 1)\n    head = push(head, 4)\n    head = push(head, 1)\n    head = push(head, 12)\n    head = push(head, 1)\n \n    print('Before deleting ')\n    printList(head)\n \n    # I'm deleting the head itself.\n    # You can check for more cases\n    deleteNode(head)\n \n    print('\\nAfter deleting')\n    printList(head)\n \n# This code is contributed by Yashyasvi Agarwal\n"], "Convert singly linked list into circular linked list -  ": ["# Python3 program for converting \n# singly linked list into \n# circular linked list. \nimport sys\n \n# Linked list node \nclass Node:\n    def __init__(self,data):\n        self.data = data\n        self.next = None\n \ndef push(head, data):\n    if not head:\n        return Node(data)\n \n    # Allocate dynamic memory \n    # for newNode. \n    # Assign the data into newNode. \n    newNode = Node(data)\n \n    # newNode.next assign the \n    # address of head node. \n    newNode.next = head\n \n    # newNode become the headNode. \n    head = newNode\n    return head\n \n# Function that convert \n# singly linked list into \n# circular linked list. \ndef circular(head):\n \n    # declare a node variable \n    # start and assign head \n    # node into start node. \n    start = head\n \n    # check that while head.next \n    # not equal to null then head \n    # points to next node. \n    while(head.next is not None):\n        head = head.next\n \n    # if head.next points to null \n    # then start assign to the \n    # head.next node.     \n    head.next = start\n    return start\n \n# Function that display the elements \n# of circular linked list. \ndef displayList(node):\n    start = node\n    while(node.next is not start):\n        print('{} '.format(node.data),end='')\n        node=node.next\n \n    # Display the last node of \n    # circular linked list. \n    print('{} '.format(node.data),end='')\n \n# Driver Code\nif __name__=='__main__':\n     \n    # Start with empty list \n    head=None\n \n    # Using push() function to \n    # convert singly linked list \n    # 17.22.13.14.15 \n    head=push(head,15)\n    head=push(head,14)\n    head=push(head,13)\n    head=push(head,22)\n    head=push(head,17)\n \n    # Call the circular_list function \n    # that convert singly linked \n    # list to circular linked list. \n    circular(head)\n    print('Display List:')\n    displayList(head)\n \n# This Code is Contributed By Vikash Kumar 37\n", "# Define a class Node\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n \n# Define a method to convert a linked list to a\n# circular linked list\n \n \ndef convertToCircular(head):\n    current = head\n    while current.next != None:\n        current = current.next\n    current.next = head\n \n# Define a method to print the circular linked list\n \n \ndef printList(head):\n    current = head\n    while True:\n        print(current.data, end=' ')\n        current = current.next\n        if current == head:\n            break\n \n \n# Main method\nif __name__ == '__main__':\n    # Create a new linked list\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n \n    # Convert the linked list to a circular linked list\n    convertToCircular(head)\n \n    # Print the circular linked list\n    print('The circular linked list is:')\n    printList(head)\n"], "Convert Singly Linked List to XOR Linked List -  ": ["# Python3 program to Convert a Singly Linked\n# List to XOR Linked List\n \n# Linked List node\nclass Node:\n    def __init__(self,d):\n        self.data = d\n        self.next = None\n \n# Print singly linked list before conversion\ndef printt(head):\n    while (head):\n \n        # print current node\n        print(head.data, end=' ')\n        head = head.next\n    print()\n \n# Function to find XORed value of\n# the node addresses\ndef XOR(a, b):\n    return b\n \n# Function to convert singly linked\n# list to XOR linked list\ndef convert(head):\n    curr = head\n    prev = None\n    next = curr.next\n \n    while (curr):\n \n        # store curr.next in next\n        next = curr.next\n \n        # change curr.next to XOR of prev and next\n        curr.next = XOR(prev, next)\n \n        # prev will change to curr for next iteration\n        prev = curr\n \n        # curr is now pointing to next for next iteration\n        curr = next\n \n# Function to print XORed linked list\ndef printXOR(head):\n    curr = head\n    prev = None\n \n    while (curr):\n \n        # print current node\n        print(curr.data, end=' ')\n \n        temp = curr\n \n        # /* compute curr as prev^curr.next as\n        #    it is previously set as prev^curr.next so\n        #    this time curr would be prev^prev^curr.next\n        #    which is curr.next */\n        curr = XOR(prev, curr.next)\n \n        prev = temp\n \n    print()\n \n# Driver Code\nif __name__ == '__main__':\n     \n    # Create following singly linked list\n    # 1.2.3.4\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n \n    print('Before Conversion : ')\n    printt(head)\n \n    convert(head)\n    print('After Conversion : ')\n    printXOR(head)\n \n# This code is contributed by mohitkumar29\n"], "Count rotations in sorted and rotated linked list -  ": ["# Program for count number of rotations in\n# sorted linked list.\n \n# Linked list node \nclass Node:\n     \n    def __init__(self, data):\n         \n        self.data = data\n        self.next = None\n \n# Function that count number of\n# rotation in singly linked list.\ndef countRotation(head):\n \n    # Declare count variable and assign it 1.\n    count = 0\n  \n    # Declare a min variable and assign to\n    # data of head node.\n    min = head.data\n  \n    # Check that while head not equal to None.\n    while (head != None):\n  \n        # If min value is greater then head->data\n        # then it breaks the while loop and\n        # return the value of count.\n        if (min > head.data):\n            break\n  \n        count += 1\n  \n        # head assign the next value of head.\n        head = head.next\n     \n    return count\n \n# Function to push element in linked list.\ndef push(head, data):\n \n    # Allocate dynamic memory for newNode.\n    newNode = Node(data)\n  \n    # Assign the data into newNode.\n    newNode.data = data\n  \n    # newNode->next assign the address of\n    # head node.\n    newNode.next = (head)\n  \n    # newNode become the headNode.\n    (head) = newNode\n    return head\n \n# Display linked list.\ndef printList(node):\n \n    while (node != None):\n        print(node.data, end = ' ')\n        node = node.next\n     \n# Driver code\nif __name__=='__main__':\n     \n    # Create a node and initialize with None\n    head = None\n  \n    # push() insert node in linked list.\n    # 15 -> 18 -> 5 -> 8 -> 11 -> 12\n    head = push(head, 12)\n    head = push(head, 11)\n    head = push(head, 8)\n    head = push(head, 5)\n    head = push(head, 18)\n    head = push(head, 15)\n  \n    printList(head);\n    print()\n    print('Linked list rotated elements: ', \n          end = '')\n  \n    # Function call countRotation()\n    print(countRotation(head))\n \n# This code is contributed by rutvik_56\n"], "Rotate Linked List block wise -  ": ["# Python3 program to rotate a linked\n# list block wise \n \n# Link list node \nclass Node:    \n    def __init__(self, data):      \n        self.data = data\n        self.next = None\n \n# Recursive function to rotate one block \ndef rotateHelper(blockHead, blockTail,\n                 d, tail, k):    \n    if (d == 0):\n        return blockHead, tail \n  \n    # Rotate Clockwise \n    if (d > 0):\n        temp = blockHead \n        i = 1       \n        while temp.next.next != None and i < k - 1:\n            temp = temp.next\n            i += 1           \n        blockTail.next = blockHead\n        tail = temp\n        return rotateHelper(blockTail, temp, \n                            d - 1, tail, k)\n \n    # Rotate anti-Clockwise \n    if (d < 0):\n        blockTail.next = blockHead \n        tail = blockHead\n        return rotateHelper(blockHead.next, \n                            blockHead, d + 1, \n                            tail, k) \n     \n# Function to rotate the linked list block wise \ndef rotateByBlocks(head, k, d):\n \n    # If length is 0 or 1 return head \n    if (head == None or head.next == None):\n        return head\n  \n    # If degree of rotation is 0, return head \n    if (d == 0):\n        return head \n    temp = head\n    tail = None\n  \n    # Traverse upto last element of this block \n    i = 1   \n    while temp.next != None and i < k:\n        temp = temp.next\n        i += 1\n  \n    # Storing the first node of next block \n    nextBlock = temp.next\n  \n    # If nodes of this block are less than k. \n    # Rotate this block also \n    if (i < k):\n        head, tail = rotateHelper(head, temp, d % k, \n                                  tail, i) \n    else:\n        head, tail = rotateHelper(head, temp, d % k, \n                                  tail, k) \n  \n    # Append the new head of next block to \n    # the tail of this block \n    tail.next = rotateByBlocks(nextBlock, k, \n                               d % k);\n  \n    # Return head of updated Linked List \n    return head; \n \n# UTILITY FUNCTIONS \n# Function to push a node \ndef push(head_ref, new_data):\n \n    new_node = Node(new_data)\n    new_node.data = new_data \n    new_node.next = (head_ref) \n    (head_ref) = new_node\n    return head_ref\n \n# Function to print linked list \ndef printList(node):\n    while (node != None):\n        print(node.data, end = ' ')\n        node = node.next\n     \n# Driver code\nif __name__=='__main__':\n     \n    # Start with the empty list\n    head = None\n  \n    # Create a list 1.2.3.4.5. \n    # 6.7.8.9.None \n    for  i in range(9, 0, -1):\n        head = push(head, i) \n    print('Given linked list ')\n    printList(head)\n  \n    # k is block size and d is number of \n    # rotations in every block. \n    k = 3\n    d = 2\n    head = rotateByBlocks(head, k, d)\n  \n    print('\\nRotated by blocks Linked list ')\n    printList(head)\n  \n# This code is contributed by rutvik_56\n"], "Length of longest palindrome list in a linked list using O(1) extra space -  ": ["# Python program to find longest palindrome \n# sublist in a list in O(1) time. \n \n# Linked List node \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n \n# function for counting the common elements \ndef countCommon(a, b) :\n \n    count = 0\n \n    # loop to count common in the list starting \n    # from node a and b \n    while ( a != None and b != None ) :\n \n        # increment the count for same values \n        if (a.data == b.data) :\n            count = count + 1\n        else:\n            break\n         \n        a = a.next\n        b = b.next\n \n    return count \n \n# Returns length of the longest palindrome \n# sublist in given list \ndef maxPalindrome(head) :\n \n    result = 0\n    prev = None\n    curr = head \n \n    # loop till the end of the linked list \n    while (curr != None) :\n     \n        # The sublist from head to current \n        # reversed. \n        next = curr.next\n        curr.next = prev \n \n        # check for odd length \n        # palindrome by finding \n        # longest common list elements \n        # beginning from prev and \n        # from next (We exclude curr) \n        result = max(result, \n                    2 * countCommon(prev, next) + 1) \n \n        # check for even length palindrome \n        # by finding longest common list elements \n        # beginning from curr and from next \n        result = max(result, \n                    2 * countCommon(curr, next)) \n \n        # update prev and curr for next iteration \n        prev = curr \n        curr = next\n     \n    return result \n \n# Utility function to create a new list node \ndef newNode(key) :\n \n    temp = Node(0) \n    temp.data = key \n    temp.next = None\n    return temp \n \n# Driver code\n \n# Let us create a linked lists to test \n# the functions \n# Created list is a: 2->4->3->4->2->15 \nhead = newNode(2) \nhead.next = newNode(4) \nhead.next.next = newNode(3) \nhead.next.next.next = newNode(4) \nhead.next.next.next.next = newNode(2) \nhead.next.next.next.next.next = newNode(15) \n \nprint(maxPalindrome(head)) \n \n# This code is contributed by Arnab Kundu\n"], "In-place Merge two linked lists without changing links of first list -  ": ["# Python3 program to merge two sorted linked \n# lists without using any extra space and \n# without changing links of first list\n \n# Structure for a linked list node \nclass Node:\n     \n    def __init__(self):\n         \n        self.data = 0\n        self.next = None\n     \n# Given a reference (pointer to pointer) to \n# the head of a list and an int, push a new\n# node on the front of the list. \ndef push(head_ref, new_data):\n \n    # Allocate node \n    new_node = Node()\n  \n    # Put in the data  \n    new_node.data  = new_data\n  \n    # Link the old list off the new node \n    new_node.next = (head_ref)\n  \n    # Move the head to point to the new node \n    (head_ref) = new_node\n    return head_ref\n \n# Function to merge two sorted linked lists\n# LL1 and LL2 without using any extra space.\ndef mergeLists(a, b):\n \n    # Run till either one of a \n    # or b runs out\n    while (a and b):\n \n        # For each element of LL1, compare\n        # it with first element of LL2.\n        if (a.data > b.data):\n     \n            # Swap the two elements involved\n            # if LL1 has a greater element\n            a.data, b.data = b.data, a.data\n  \n            temp = b\n  \n            # To keep LL2 sorted, place first\n            # element of LL2 at its correct place\n            if (b.next and b.data > b.next.data):\n                b = b.next\n                ptr = b\n                prev = None\n                 \n                # Find mismatch by traversing the\n                # second linked list once\n                while (ptr and ptr.data < temp.data):\n                    prev = ptr\n                    ptr = ptr.next\n         \n                # Correct the pointers\n                prev.next = temp\n                temp.next = ptr\n         \n        # Move LL1 pointer to next element\n        a = a.next\n     \n# Function to print the linked link\ndef printList(head):\n \n    while (head):\n        print(head.data, end = '->')\n        head = head.next\n     \n    print('NULL')\n     \n# Driver code\nif __name__=='__main__':\n     \n    a = None\n    a = push(a, 10)\n    a = push(a, 8)\n    a = push(a, 7)\n    a = push(a, 4)\n    a = push(a, 2)\n  \n    b = None\n    b = push(b, 12)\n    b = push(b, 3)\n    b = push(b, 1)\n  \n    mergeLists(a, b)\n  \n    print('First List: ', end = '')\n    printList(a)\n  \n    print('Second List: ', end = '')\n    printList(b)\n \n# This code is contributed by rutvik_56\n"], "Select a Random Node from a Singly Linked List -  ": ["# Python program to randomly select a node from singly\n# linked list \n \nimport random\n \n# Node class \nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data= data\n        self.next = None\n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # A reservoir sampling based function to print a\n    # random node from a linked list\n    def printRandom(self):\n \n        # If list is empty \n        if self.head is None:\n            return\n        if self.head and not self.head.next:\n           print('Randomly selected key is %d' %(self.head.data))\n \n        # Use a different seed value so that we don't get \n        # same result each time we run this program\n        random.seed()\n \n        # Initialize result as first node\n        result = self.head.data\n \n        # Iterate from the (k+1)th element nth element\n        # because we iterate from (k+1)th element, or \n        # the first node will be picked more easily \n        current = self.head.next\n        n = 2\n        while(current is not None):\n             \n            # change result with probability 1/n\n            if (random.randrange(n) == 0 ):\n                result = current.data \n \n            # Move to next node\n            current = current.next\n            n += 1\n \n        print('Randomly selected key is %d' %(result))\n         \n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Utility function to print the LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(temp.data,end=' ')\n            temp = temp.next\n \n \n# Driver program to test above function\nllist = LinkedList()\nllist.push(5)\nllist.push(20)\nllist.push(4)\nllist.push(3)\nllist.push(30)\nllist.printRandom()\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "import random\n \n# Link list node\nclass Node:\n    def __init__(self):\n        self.key = 0\n        self.next = None\n \n    def push(self, head_ref, new_key):\n        # allocate node\n        new_node = Node()\n \n        # put in the key\n        new_node.key = new_key\n \n        # link the old list of the new node\n        new_node.next = head_ref\n \n        # move the head to point to the new node\n        head_ref = new_node\n        return head_ref\n \n    @staticmethod\n    def printRandom(head):\n        temp = head\n        v = []\n        while temp != None:\n            v.append(temp.key)\n            temp = temp.next\n        n = len(v)\n        randIndex = random.randint(0, n-1)\n        print(v[randIndex])\n \n# Driver's code\nif __name__ == '__main__':\n    n1 = Node()\n    head = None\n    head = n1.push(head, 5)\n    head = n1.push(head, 20)\n    head = n1.push(head, 4)\n    head = n1.push(head, 3)\n    head = n1.push(head, 30)\n    # function call\n    Node.printRandom(head)\n"], "Rearrange a given linked list in-place. -  ": ["# Python program to rearrange link list in place\n \n# Node Class\nclass Node:\n   \n    # Constructor to create a new node\n    def __init__(self, d):\n        self.data = d\n        self.next = None\n         \ndef printlist(node):\n    if(node == None):\n        return\n    while(node != None):\n        print(node.data,' -> ', end = '')\n        node = node.next\n \ndef reverselist(node):\n    prev = None\n    curr = node\n    next=None\n    while (curr != None):\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n    node = prev\n    return node\n \ndef rearrange(node):\n   \n    # 1) Find the middle point using tortoise and hare\n    # method\n    slow = node\n    fast = slow.next\n    while (fast != None and fast.next != None):\n        slow = slow.next\n        fast = fast.next.next\n     \n    # 2) Split the linked list in two halves\n    # node1, head of first half    1 -> 2 -> 3\n    # node2, head of second half   4 -> 5    \n    node1 = node\n    node2 = slow.next\n    slow.next = None\n     \n    # 3) Reverse the second half, i.e., 5 -> 4\n    node2 = reverselist(node2)\n     \n    # 4) Merge alternate nodes\n    node = Node(0)  #Assign dummy Node\n     \n    # curr is the pointer to this dummy Node, which\n    # will be used to form the new list\n    curr = node\n     \n    while (node1 != None or node2 != None):\n         \n        # First add the element from first list\n        if (node1 != None):\n            curr.next = node1\n            curr = curr.next\n            node1 = node1.next\n         \n        # Then add the element from second list\n        if(node2 != None):\n            curr.next = node2\n            curr = curr.next\n            node2 = node2.next\n     \n    # Assign the head of the new list to head pointer\n    node = node.next\n \nhead = None\nhead = Node(1)\nhead.next = Node(2)\nhead.next.next = Node(3)\nhead.next.next.next = Node(4)\nhead.next.next.next.next = Node(5)\n \nprintlist(head) #print original list\nrearrange(head) #rearrange list as per ques\nprint()\nprintlist(head) #print modified list\n \n# This code is contributed by ab2127\n", "# Python3 implementation\nclass Node:\n     \n    def __init__(self, key):\n         \n        self.data = key\n        self.next = None\n \nleft = None\n \n# Function to print the list\ndef printlist(head):\n     \n    while (head != None):\n        print(head.data, end = ' ')\n        if (head.next != None):\n            print('->', end = '')\n             \n        head = head.next\n         \n    print()\n \n# Function to rearrange\ndef rearrange(head):\n     \n    global left\n    if (head != None):\n        left = head\n        reorderListUtil(left)\n \ndef reorderListUtil(right):\n     \n    global left\n    if (right == None):\n        return\n     \n    reorderListUtil(right.next)\n     \n    # We set left = null, when we reach stop \n    # condition, so no processing required \n    # after that\n    if (left == None):\n        return\n     \n    # Stop condition: odd case : left = right, even\n    # case : left.next = right\n    if (left != right and left.next != right):\n        temp = left.next\n        left.next = right\n        right.next = temp\n        left = temp\n    else:\n         \n        # Stop condition , set null to left nodes\n        if (left.next == right):\n             \n            # Even case\n            left.next.next = None\n            left = None\n        else:\n             \n            # Odd case\n            left.next = None\n            left = None\n \n# Driver code\nhead = Node(1)\nhead.next = Node(2)\nhead.next.next = Node(3)\nhead.next.next.next = Node(4)\nhead.next.next.next.next = Node(5)\n \n# Print original list\nprintlist(head)\n \n#  Modify the list\nrearrange(head)\n \n# Print modified list\nprintlist(head)\n \n# This code is contributed by patel2127\n"], "Clone a Linked List with next and Random Pointer -  ": ["# Structure of a node of linked list\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n        self.arbit = None\n \n# Function to clone the linked list\ndef cloneLinkedList(head):\n    # Map to store the mapping of\n    # old nodes with new ones\n    mp = {}\n    temp = head\n    nhead = Node(temp.val)\n    mp[temp] = nhead\n \n    # Loop to create duplicates of nodes\n    # with only next pointer\n    while temp.next:\n        nhead.next = Node(temp.next.val)\n        temp = temp.next\n        nhead = nhead.next\n        mp[temp] = nhead\n \n    temp = head\n \n    # Loop to clone the arbit pointers\n    while temp:\n        mp[temp].arbit = mp[temp.arbit]\n        temp = temp.next\n \n    # Return the head of the clone\n    return mp[head]\n \n# Function to print the linked list\ndef printList(head):\n    result = []\n    while head:\n        result.append(f'{head.val}({head.arbit.val})')\n        head = head.next\n    print(' -> '.join(result))\n \n# Creating a linked list with random pointer\nhead = Node(1)\nhead.next = Node(2)\nhead.next.next = Node(3)\nhead.next.next.next = Node(4)\nhead.next.next.next.next = Node(5)\nhead.arbit = head.next.next\nhead.next.arbit = head\nhead.next.next.arbit = head.next.next.next.next\nhead.next.next.next.arbit = head.next.next\nhead.next.next.next.next.arbit = head.next\n \n# Print the original list\nprint('The original linked list:')\nprintList(head)\n \n# Function call\nsol = cloneLinkedList(head)\n \nprint('The cloned linked list:')\nprintList(sol)\n", "class Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n        self.random = None\n \n \ndef cloneLinkedList(head):\n    if head == None:\n        return None\n    # Step 1: Create new nodes and insert them next to the original nodes\n    curr = head\n    while curr != None:\n        newNode = Node(curr.data)\n        newNode.next = curr.next\n        curr.next = newNode\n        curr = newNode.next\n    # Step 2: Set the random pointers of the new nodes\n    curr = head\n    while curr != None:\n        if curr.random != None:\n            curr.next.random = curr.random.next\n        curr = curr.next.next\n    # Step 3: Separate the new nodes from the original nodes\n    curr = head\n    clonedHead = head.next\n    clonedCurr = clonedHead\n    while clonedCurr.next != None:\n        curr.next = curr.next.next\n        clonedCurr.next = clonedCurr.next.next\n        curr = curr.next\n        clonedCurr = clonedCurr.next\n    curr.next = None\n    clonedCurr.next = None\n    return clonedHead\n \n# Function to print the linked list\n \n \ndef printList(head):\n    print(head.data, '(', head.random.data, ')', end='')\n    head = head.next\n    while head != None:\n        print('->', head.data, '(', head.random.data, ')', end='')\n        head = head.next\n    print()\n \n \n# Driver code\nif __name__ == '__main__':\n    # Creating a linked list with random pointer\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head.random = head.next.next\n    head.next.random = head\n    head.next.next.random = head.next.next.next.next\n    head.next.next.next.random = head.next.next\n    head.next.next.next.next.random = head.next\n \n    # Print the original list\n    print('The original linked list:')\n    printList(head)\n \n    # Function call\n    sol = cloneLinkedList(head)\n    print('The cloned linked list:')\n    printList(sol)\n"], "Given a linked list of line segments, remove middle points -  ": ["# Python program to remove middle points in a linked list of\n# line segments,\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n \n    # Linked list Node\n    class Node(object):\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n            self.next = None\n \n    # This function deletes middle nodes in a sequence of\n    # horizontal and vertical line segments represented\n    # by linked list.\n    def deleteMiddle(self):\n        # If only one node or no node...Return back\n        if self.head == None or self.head.next == None or self.head.next.next == None:\n            return self.head\n        Next = self.head.next\n        NextNext = Next.next\n        # check if this is vertical or horizontal line\n        if self.head.x == Next.x:\n            # Find middle nodes with same value as x and\n            # delete them.\n            while NextNext != None and Next.x == NextNext.x:\n                self.head.next = Next.next\n                Next.next = None\n                # Update NextNext for the next iteration\n                Next = NextNext\n                NextNext = NextNext.next\n        elif self.head.y == Next.y:\n            # find middle nodes with same value as y and\n            # delete them\n            while NextNext != None and Next.y == NextNext.y:\n                self.head.next = Next.next\n                Next.next = None\n                # Update NextNext for the next iteration\n                Next = NextNext\n                NextNext = NextNext.next\n        else:\n            # Adjacent points should have same x or same y\n            print ('Given list is not valid')\n            return None\n        # recur for other segment\n        # temporarily store the head and move head forward.\n        temp = self.head\n        self.head = self.head.next\n        # call deleteMiddle() for next segment\n        self.deleteMiddle()\n        # restore head\n        self.head = temp\n        # return the head\n        return self.head\n \n    # Given a reference (pointer to pointer) to the head\n    # of a list and an int, push a new node on the front\n    # of the list.\n    def push(self, x, y):\n        # 1 & 2: Allocate the Node &\n        # Put in the data\n        new_node = self.Node(x, y)\n        # 3. Make next of new Node as head\n        new_node.next = self.head\n        # 4. Move the head to point to new Node\n        self.head = new_node\n \n    def printList(self):\n        temp = self.head\n        while temp != None:\n            print ('(' + str(temp.x) + ',' + str(temp.y) + ')->',end=' ')\n            temp = temp.next\n        print ()\n \n# Driver program\nllist = LinkedList()\nllist.push(40,5)\nllist.push(20,5)\nllist.push(10,5)\nllist.push(10,8)\nllist.push(10,10)\nllist.push(3,10)\nllist.push(1,10)\nllist.push(0,10)\n \nprint ('Given list')\nllist.printList()\n \nif llist.deleteMiddle() != None:\n    print ('Modified Linked List is')\n    llist.printList()\n \n# This code is contributed by BHAVYA JAIN\n"], "Delete nodes which have a greater value on right side -  ": ["# Python program to delete nodes which have a\n# greater value on right side\nclass Node:\n \n    # constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # Function to insert a new node at beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Utility function to print a linked list\n    def printList(self):\n        temp = self.head\n        while(temp is not None):\n            print(temp.data, end=' ')\n            temp = temp.next\n        print('\\n')\n \n    def delLesserNodes(self):\n        # Reverse the linked list\n        self.reverseList()\n \n        # In the reversed list, delete nodes which have a node with greater\n        # value node on left side. Note that head node is never deleted because\n        # it is the leftmost node.\n        self._delLesserNodes()\n \n        # Reverse the linked list again to retain the original order\n        self.reverseList()\n \n    # Deletes nodes which have greater value node(s) on left side\n    def _delLesserNodes(self):\n        current = self.head\n        # Initialize max\n        maxnode = self.head\n \n        while(current is not None and current.next is not None):\n            # If current is smaller than max, then delete current\n            if(current.next.data < maxnode.data):\n                temp = current.next\n                current.next = temp.next\n \n            # If current is greater than max, then update max and move current\n            else:\n                current = current.next\n                maxnode = current\n \n    # Utility function to reverse a linked list\n    def reverseList(self):\n        current = self.head\n        prev = None\n        while(current is not None):\n            next = current.next\n            current.next = prev\n            prev = current\n            current = next\n        self.head = prev\n \n \n# Create following linked list\n# 12->15->10->11->5->6->2->3\nllist = LinkedList()\nllist.push(3)\nllist.push(2)\nllist.push(6)\nllist.push(5)\nllist.push(11)\nllist.push(10)\nllist.push(15)\nllist.push(12)\n \nprint('Given linked list')\nllist.printList()\n \nllist.delLesserNodes()\n \nprint('Modified Linked List')\nllist.printList()\n \n# This code is contributed by Yash Agarwal(yashagarwal2852002)\n", "#Python program for above approach\n \n# This class represents a single node \n# in a linked list\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n#This is a utility class for linked list\nclass LLUtil:\n     \n      # This function creates a linked list from a \n    # given array and returns head\n    def createLL(self,arr):\n         \n        head = Node(arr[0])\n        temp = head\n \n        newNode = None\n        for i in range(1, len(arr)):\n            newNode = Node(arr[i])\n            temp.next = newNode\n            temp = temp.next\n        return head\n \n      #This function prints given linked list\n    def printLL(self, head):\n         \n        while head != None:\n            print(head.data, end=' ')\n            head = head.next\n        print()\n \n#Main function\ndef deleteNodesOnRightSide(head):\n    if head == None or head.next == None: \n        return head\n     \n    nextNode = deleteNodesOnRightSide(head.next)\n \n    if nextNode.data > head.data: \n        return nextNode\n     \n    head.next = nextNode\n \n    return head\n \nif __name__ == '__main__':\n    arr = [12,15,10,11,5,6,2,3]\n    llu = LLUtil()\n    head = llu.createLL(arr)\n    print('Given Linked List')\n    llu.printLL(head)\n    head = deleteNodesOnRightSide(head)\n    print('Modified Linked List')\n    llu.printLL(head)\n"], "Alternating split of a given Singly Linked List | Set 1 -  ": ["def AlternatingSplit(source, aRef,  bRef):\n   \n  aDummy = Node();\n  aTail = aDummy; ''' points to the last Node in 'a' '''\n  bDummy = Node();\n  bTail = bDummy; ''' points to the last Node in 'b' '''\n  current = source;\n  aDummy.next = None;\n  bDummy.next = None;\n  while (current != None):\n    MoveNode((aTail.next), current); ''' add at 'a' tail '''\n    aTail = aTail.next; ''' advance the 'a' tail '''\n    if (current != None):\n      MoveNode((bTail.next), current);\n      bTail = bTail.next;\n     \n  aRef = aDummy.next;\n  bRef = bDummy.next;\n \n# This code is contributed by umadevi9616 \n"], "Reverse alternate K nodes in a Singly Linked List -  ": ["# Python3 program to reverse alternate\n# k nodes in a linked list\nimport math\n \n# Link list node \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n \n# Reverses alternate k nodes and \n#returns the pointer to the new head node \ndef kAltReverse(head, k) : \n    current = head \n    next = None\n    prev = None\n    count = 0\n \n    #1) reverse first k nodes of the linked list \n    while (current != None and count < k) : \n        next = current.next\n        current.next = prev \n        prev = current \n        current = next\n        count = count + 1;\n     \n    # 2) Now head pos to the kth node. \n    # So change next of head to (k+1)th node\n    if(head != None): \n        head.next = current \n \n    # 3) We do not want to reverse next k \n    # nodes. So move the current \n    # pointer to skip next k nodes \n    count = 0\n    while(count < k - 1 and current != None ): \n        current = current.next\n        count = count + 1\n     \n    # 4) Recursively call for the list \n    # starting from current.next. And make\n    # rest of the list as next of first node \n    if(current != None): \n        current.next = kAltReverse(current.next, k) \n \n    # 5) prev is new head of the input list \n    return prev \n \n# UTILITY FUNCTIONS \n# Function to push a node \ndef push(head_ref, new_data): \n     \n    # allocate node \n    new_node = Node(new_data)\n \n    # put in the data \n    # new_node.data = new_data \n \n    # link the old list of the new node \n    new_node.next = head_ref \n \n    # move the head to po to the new node \n    head_ref = new_node\n     \n    return head_ref\n \n# Function to print linked list \ndef printList(node): \n    count = 0\n    while(node != None): \n        print(node.data, end = ' ') \n        node = node.next\n        count = count + 1\n     \n# Driver code\nif __name__=='__main__':\n     \n    # Start with the empty list \n    head = None\n \n    # create a list 1.2.3.4.5...... .20 \n    for i in range(20, 0, -1):\n        head = push(head, i) \n         \n    print('Given linked list ') \n    printList(head) \n    head = kAltReverse(head, 3) \n \n    print('\\nModified Linked list') \n    printList(head) \n     \n# This code is contributed by Srathore\n", "# Python code for above algorithm\n \n# Link list node \nclass node: \n     \n    def __init__(self, data): \n        self.data = data \n        self.next = next\n         \n# function to insert a node at the\n# beginning of the linked list\ndef push(head_ref, new_data):\n \n    # allocate node \n    new_node = node(0)\n \n    # put in the data \n    new_node.data = new_data\n \n    # link the old list to the new node \n    new_node.next = (head_ref)\n \n    # move the head to point to the new node \n    (head_ref) = new_node\n     \n    return head_ref\n     \n''' Alternatively reverses the given linked list \nin groups of given size k. '''\ndef kAltReverse(head, k) :\n \n    return _kAltReverse(head, k, True) \n \n''' Helper function for kAltReverse(). \nIt reverses k nodes of the list only if \nthe third parameter b is passed as True, \notherwise moves the pointer k nodes ahead\nand recursively calls itself '''\ndef _kAltReverse(Node, k, b) :\n \n    if(Node == None) :\n        return None\n     \n    count = 1\n    prev = None\n    current = Node \n    next = None\n     \n    ''' The loop serves two purposes \n        1) If b is True, \n        then it reverses the k nodes \n        2) If b is false, \n        then it moves the current pointer '''\n    while(current != None and count <= k) :\n     \n        next = current.next\n     \n        ''' Reverse the nodes only if b is True'''\n        if(b == True) :\n            current.next = prev \n                 \n        prev = current \n        current = next\n        count = count + 1\n     \n         \n    ''' 3) If b is True, then node is the kth node. \n        So attach rest of the list after node. \n        4) After attaching, return the new head '''\n    if(b == True) :\n     \n        Node.next = _kAltReverse(current, k, not b) \n        return prev         \n     \n    else :\n        ''' If b is not True, then attach \n        rest of the list after prev. \n        So attach rest of the list after prev '''\n        prev.next = _kAltReverse(current, k, not b) \n        return Node     \n     \n''' Function to print linked list '''\ndef printList(node) :\n \n    count = 0\n    while(node != None) :\n     \n        print( node.data, end = ' ') \n        node = node.next\n        count = count + 1\n \n# Driver Code\n \n''' Start with the empty list '''\nhead = None\ni = 20\n \n# create a list 1->2->3->4->5...... ->20 \nwhile(i > 0 ): \n    head = push(head, i) \n    i = i - 1\n \nprint( 'Given linked list ') \nprintList(head) \nhead = kAltReverse(head, 3) \n \nprint( '\\nModified Linked list ') \nprintList(head) \n \n# This code is contributed by Arnab Kundu\n"], "Flattening a Linked List -  ": ["# Python3 program for flattening a Linked List\n \n \nclass Node():\n    def __init__(self, data):\n        self.data = data\n        self.right = None\n        self.down = None\n \n \nclass LinkedList():\n    def __init__(self):\n \n        # head of list\n        self.head = None\n \n    # Utility function to insert a node at beginning of the\n    #   linked list\n    def push(self, head_ref, data):\n \n        # 1 & 2: Allocate the Node &\n        # Put in the data\n        new_node = Node(data)\n \n        # Make next of new Node as head\n        new_node.down = head_ref\n \n        # 4. Move the head to point to new Node\n        head_ref = new_node\n \n        # 5. return to link it back\n        return head_ref\n \n    def printList(self):\n \n        temp = self.head\n        while(temp != None):\n            print(temp.data, end=' ')\n            temp = temp.down\n \n        print()\n \n    # An utility function to merge two sorted linked lists\n    def merge(self, a, b):\n        # if first linked list is empty then second\n        # is the answer\n        if(a == None):\n            return b\n \n        # if second linked list is empty then first\n        # is the result\n        if(b == None):\n            return a\n \n        # compare the data members of the two linked lists\n        # and put the larger one in the result\n        result = None\n \n        if (a.data < b.data):\n            result = a\n            result.down = self.merge(a.down, b)\n        else:\n            result = b\n            result.down = self.merge(a, b.down)\n \n        result.right = None\n        return result\n \n    def flatten(self, root):\n \n        # Base Case\n        if(root == None or root.right == None):\n            return root\n        # recur for list on right\n \n        root.right = self.flatten(root.right)\n \n        # now merge\n        root = self.merge(root, root.right)\n \n        # return the root\n        # it will be in turn merged with its left\n        return root\n \n \n# Driver's code\nif __name__ == '__main__':\n    L = LinkedList()\n \n    ''' \n    Let us create the following linked list\n            5 -> 10 -> 19 -> 28\n            |    |     |     |\n            V    V     V     V\n            7    20    22    35\n            |          |     |\n            V          V     V\n            8          50    40\n            |                |\n            V                V\n            30               45\n    '''\n    L.head = L.push(L.head, 30)\n    L.head = L.push(L.head, 8)\n    L.head = L.push(L.head, 7)\n    L.head = L.push(L.head, 5)\n \n    L.head.right = L.push(L.head.right, 20)\n    L.head.right = L.push(L.head.right, 10)\n \n    L.head.right.right = L.push(L.head.right.right, 50)\n    L.head.right.right = L.push(L.head.right.right, 22)\n    L.head.right.right = L.push(L.head.right.right, 19)\n \n    L.head.right.right.right = L.push(L.head.right.right.right, 45)\n    L.head.right.right.right = L.push(L.head.right.right.right, 40)\n    L.head.right.right.right = L.push(L.head.right.right.right, 35)\n    L.head.right.right.right = L.push(L.head.right.right.right, 20)\n \n    # Function call\n    L.head = L.flatten(L.head)\n \n    L.printList()\n    # This code is contributed by maheshwaripiyush9\n", "from heapq import heappush, heappop\nclass Node:\n    def __init__(self, d):\n        self.data = d\n        self.right = self.down = None\n \n \nclass LinkedList():\n    def __init__(self):\n \n        # head of list\n        self.head = None\n \n    # Utility function to insert a node at beginning of the\n    #   linked list\n    def push(self, head_ref, data):\n \n        # 1 & 2: Allocate the Node &\n        # Put in the data\n        new_node = Node(data)\n \n        # Make next of new Node as head\n        new_node.down = head_ref\n \n        # 4. Move the head to point to new Node\n        head_ref = new_node\n \n        # 5. return to link it back\n        return head_ref\n \n    def printList(self):\n \n        temp = self.head\n        while(temp != None):\n            print(temp.data, end=' ')\n            temp = temp.down\n \n        print()\n \n \n# class to compare two node objects\nclass Cmp:\n    def __init__(self, node):\n        self.node = node\n \n    def __lt__(self, other):\n        return self.node.data < other.node.data\n \n \ndef flatten(root):\n    pq = []\n    # push main linked list nodes to priority queue\n    while root:\n        heappush(pq, Cmp(root))\n        root = root.right\n    dummy = Node(0)\n    temp = dummy\n     \n    # keep popping out the min node until there are no nodes left in priority queue\n    while pq:\n        node = heappop(pq).node\n        temp.down = node\n        temp = node\n        # if bottom child exist add it to priority queue\n        if node.down:\n            heappush(pq, Cmp(node.down))\n \n    return dummy.down\n \n \nif __name__ == '__main__':\n    L = LinkedList()\n \n    '''\n    Let us create the following linked list\n            5 -> 10 -> 19 -> 28\n            |    |     |     |\n            V    V     V     V\n            7    20    22    35\n            |          |     |\n            V          V     V\n            8          50    40\n            |                |\n            V                V\n            30               45\n    '''\n    L.head = L.push(L.head, 30)\n    L.head = L.push(L.head, 8)\n    L.head = L.push(L.head, 7)\n    L.head = L.push(L.head, 5)\n \n    L.head.right = L.push(L.head.right, 20)\n    L.head.right = L.push(L.head.right, 10)\n \n    L.head.right.right = L.push(L.head.right.right, 50)\n    L.head.right.right = L.push(L.head.right.right, 22)\n    L.head.right.right = L.push(L.head.right.right, 19)\n \n    L.head.right.right.right = L.push(L.head.right.right.right, 45)\n    L.head.right.right.right = L.push(L.head.right.right.right, 40)\n    L.head.right.right.right = L.push(L.head.right.right.right, 35)\n    L.head.right.right.right = L.push(L.head.right.right.right, 20)\n \nflatten(L.head)\nL.printList()\n"], "Reverse a Linked List in groups of given size -  ": ["# Python program to reverse a  \n# linked list in group of given size \n  \n# Node class \n  \n  \nclass Node: \n  \n    # Constructor to initialize the node object \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n  \n  \nclass LinkedList: \n  \n    # Function to initialize head \n    def __init__(self): \n        self.head = None\n  \n    def reverse(self, head, k): \n        \n        if head == None: \n          return None\n        current = head \n        next = None\n        prev = None\n        count = 0\n  \n        # Reverse first k nodes of the linked list \n        while(current is not None and count < k): \n            next = current.next\n            current.next = prev \n            prev = current \n            current = next\n            count += 1\n  \n        # next is now a pointer to (k+1)th node \n        # recursively call for the list starting \n        # from current. And make rest of the list as \n        # next of first node \n        if next is not None: \n            head.next = self.reverse(next, k) \n  \n        # prev is new head of the input list \n        return prev \n  \n    # Function to insert a new node at the beginning \n    def push(self, new_data): \n        new_node = Node(new_data) \n        new_node.next = self.head \n        self.head = new_node \n  \n    # Utility function to print the linked LinkedList \n    def printList(self): \n        temp = self.head \n        while(temp): \n            print(temp.data,end=' ') \n            temp = temp.next\n  \n  \n# Driver program \nllist = LinkedList() \nllist.push(9) \nllist.push(8) \nllist.push(7) \nllist.push(6) \nllist.push(5) \nllist.push(4) \nllist.push(3) \nllist.push(2) \nllist.push(1) \n  \nprint('Given linked list') \nllist.printList() \nllist.head = llist.reverse(llist.head, 3) \n  \nprint ('\\nReversed Linked list') \nllist.printList() \n  \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007) \n", "# Python program to reverse a linked list in groups of given size \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n  \n# Reverses the linked list in groups \n# of size k and returns the pointer \n# to the new head node. \n  \n  \ndef reverse(head, k): \n  # If head is NULL or K is 1 then return head \n    if not head or k == 1: \n        return head \n    dummy = Node(-1)  # creating dummy node \n    dummy.next = head \n    # Initializing three points prev, curr, next \n    prev = dummy \n    curr = dummy \n    next = dummy \n    count = 0\n    toLoop = 0\n    i = 0\n  \n    # Calculating the length of linked list \n    while curr: \n        curr = curr.next\n        count += 1\n  \n    # Iterating till next is not none \n    while next: \n        curr = prev.next  # Curr position after every reversed group \n        next = curr.next  # Next will always next to curr \n        # toLoop will set to count - 1 in case of remaining element \n        toLoop = count > k and k or count - 1\n        for i in range(1, toLoop): \n                # 4 steps as discussed above \n            curr.next = next.next\n            next.next = prev.next\n            prev.next = next\n            next = curr.next\n        # Setting prev to curr \n        prev = curr \n        # Update count \n        count -= k \n  \n     # dummy -> next will be our new head for output linked list \n    return dummy.next\n  \n# Function to print linked list \n  \n  \ndef printList(node): \n    while node is not None: \n        print(node.data, end=' ') \n        node = node.next\n  \n  \n# Created Linked list is 1->2->3->4->5->6->7->8->9 \nhead = Node(1) \nhead.next = Node(2) \nhead.next.next = Node(3) \nhead.next.next.next = Node(4) \nhead.next.next.next.next = Node(5) \nhead.next.next.next.next.next = Node(6) \nhead.next.next.next.next.next.next = Node(7) \nhead.next.next.next.next.next.next.next = Node(8) \nhead.next.next.next.next.next.next.next.next = Node(9) \n  \nprint('Given linked list') \nprintList(head) \nhead = reverse(head, 3) \n  \nprint('\\nReversed Linked list') \nprintList(head) \n  \n# This code is contributed by Tapesh(tapeshdua420) \n"], "Sort linked list which is already sorted on absolute values -  ": ["# Python3 program to sort a linked list, \n# already sorted by absolute values \n     \n# Linked list Node\nclass Node:\n    def __init__(self, d):\n        self.data = d \n        self.next = None\n \nclass SortList:\n    def __init__(self):\n        self.head = None\n         \n    # To sort a linked list by actual values. \n    # The list is assumed to be sorted by \n    # absolute values. \n    def sortedList(self, head):\n         \n        # Initialize previous and \n        # current nodes \n        prev = self.head \n        curr = self.head.next\n         \n        # Traverse list \n        while(curr != None): \n             \n            # If curr is smaller than prev, \n            # then it must be moved to head \n            if(curr.data < prev.data):\n                 \n                # Detach curr from linked list \n                prev.next = curr.next\n                 \n                # Move current node to beginning \n                curr.next = self.head \n                self.head = curr\n                 \n                # Update current \n                curr = prev \n             \n            # Nothing to do if current element \n            # is at right place \n            else:\n                prev = curr\n         \n            # Move current \n            curr = curr.next\n        return self.head \n     \n    # Inserts a new Node at front of the list\n    def push(self, new_data):\n         \n        # 1 & 2: Allocate the Node & \n        #        Put in the data\n        new_node = Node(new_data) \n     \n        # 3. Make next of new Node as head \n        new_node.next = self.head \n     \n        # 4. Move the head to point to new Node \n        self.head = new_node\n     \n    # Function to print linked list \n    def printList(self, head):\n        temp = head\n        while (temp != None): \n            print(temp.data, end = ' ')\n            temp = temp.next\n        print() \n     \n# Driver Code\nllist = SortList()\n \n# Constructed Linked List is  \n# 1->2->3->4->5->6->7->8->8->9->null \nllist.push(-5) \nllist.push(5) \nllist.push(4) \nllist.push(3) \nllist.push(-2) \nllist.push(1) \nllist.push(0) \n         \nprint('Original List :') \nllist.printList(llist.head)\n         \nstart = llist.sortedList(llist.head)\n \nprint('Sorted list :') \nllist.printList(start)\n \n# This code is contributed by\n# Prerna Saini\n"], "Union and Intersection of two Linked Lists -  ": ["# Python program to find union and\n# intersection of two unsorted\n# linked lists\n \n# Linked list Node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \nclass LinkedList:\n    def __init__(self):\n        self.head = None\n \n    # Function to get Union of 2 Linked Lists\n    def getUnion(self, head1, head2):\n        t1 = head1\n        t2 = head2\n \n        # insert all elements of list1 in the result\n        while t1 is not None:\n            self.push(t1.data)\n            t1 = t1.next\n \n        # insert those elements of list2\n        # that are not present\n        while t2 is not None:\n            if not self.isPresent(self.head, t2.data):\n                self.push(t2.data)\n            t2 = t2.next\n \n    def getIntersection(self, head1, head2):\n        t1 = head1\n \n        # Traverse list1 and search each\n        # element of it in list2.\n        # If the element is present in\n        # list 2, then insert the\n        # element to result\n        while t1 is not None:\n            if self.isPresent(head2, t1.data):\n                self.push(t1.data)\n            t1 = t1.next\n \n    # Utility function to print list\n    def printList(self):\n        temp = self.head\n        while temp is not None:\n            print(temp.data, end=' ')\n            temp = temp.next\n        print('')\n \n    # Inserts a node at start of linked list\n    def push(self, new_data):\n        new_node = Node(new_data)\n \n        # Make next of new Node as head\n        new_node.next = self.head\n \n        # Move the head to point to new Node\n        self.head = new_node\n \n    # A utility function that returns true\n    # if data is present in linked list\n    # else return false\n    def isPresent(self, head, data):\n        t = head\n        while t is not None:\n            if t.data == data:\n                return True\n            t = t.next\n        return False\n \n# Driver program to test above functions\nif __name__ == '__main__':\n    llist1 = LinkedList()\n    llist2 = LinkedList()\n    unin = LinkedList()\n    intersecn = LinkedList()\n \n    # create a linked lists 10->15->4->20\n    llist1.push(20)\n    llist1.push(4)\n    llist1.push(15)\n    llist1.push(10)\n \n    # create a linked lists 8->4->2->10\n    llist2.push(10)\n    llist2.push(2)\n    llist2.push(4)\n    llist2.push(8)\n \n    intersecn.getIntersection(llist1.head, llist2.head)\n    unin.getUnion(llist1.head, llist2.head)\n \n    print('First List is')\n    llist1.printList()\n     \n    print('Second List is')\n    llist2.printList()\n     \n    print('Intersection List is ')\n    intersecn.printList()\n     \n    print('Union List is ')\n    unin.printList()\n     \n# This code is contributed by lokesh.\n", "def merge(ll1,ll2):\n    if ll1 is None:\n        return ll2\n    if ll2 is None:\n        return ll1\n    if ll1.data==ll2.data:\n        head=ll1\n        tail=ll1\n        ll1=ll1.next\n        ll2=ll2.next\n    elif ll1.data>ll2.data:\n        head=ll2\n        tail=ll2\n        ll2=ll2.next\n    else:\n        head=ll1\n        tail=ll1\n        ll1=ll1.next\n    while ll1 is not None and ll2 is not None:\n        if ll1.data==ll2.data:\n            tail.next=ll1\n            tail=ll1\n            ll1=ll1.next\n            ll2=ll2.next\n        elif ll1.data>ll2.data:\n            tail.next=ll2\n            tail=ll2\n            ll2=ll2.next\n        else:\n            tail.next=ll1\n            tail=ll1\n            ll1=ll1.next\n    if ll1 is not None:\n        tail.next=ll1\n         \n     \n    if ll2 is not None:\n        tail.next=ll2\n         \n \n    return head\n \ndef mid_point_2(head):\n    if head is None:\n        return None\n    slow=head\n    fast=head\n    while fast.next is not None and fast.next.next is not None:\n        slow=slow.next\n        fast=fast.next.next\n    return slow \n     \ndef merge_sort(head):\n    if head is None or head.next is None:\n        return head\n    mid=mid_point_2(head)\n    head2=merge_sort(mid.next)\n    mid.next=None\n    head1=merge_sort(head)\n    final_head=merge(head1,head2)\n    return final_head\n     \n \n \ndef union(head1,head2):\n    # code here\n    # return head of resultant linkedlist\n     \n    head1=merge_sort(head1)\n    head2=merge_sort(head2)\n    return merge(head1,head2)\n     \n     \n     \n \n \n # Driver Code Starts\n#Initial Template for Python 3\n \nclass Node:\n    def __init__(self,data):\n        self.data=data\n        self.next=None\n         \ndef print_ll(head):\n    while head is not None:\n        print(head.data,end='-->')\n        head=head.next\n    print('None')\n     \ndef take_input(l):\n     \n    if len(l)==0 or l[0]==-1:\n        return\n    head,tail=None,None\n    for i in l:\n        if i ==-1:\n            break\n        new_node=Node(i)\n        if head is None:\n            head=new_node\n            tail=new_node\n        else:\n            tail.next=new_node\n            tail=new_node\n    return head\n \nhead1=take_input([10,20,30,40,50,60,70])\nhead2=take_input([10,30,50,80,90])\nprint_ll(union(head1,head2))\n \n \n \n      \n \n# This code is contributed by Shubham Setia\n", "class LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.next = None\n     \n    def __init__(self):\n        self.head = None # head of list\n     \n    # Utility function to print list\n    def printList(self):\n        temp = self.head\n        while temp:\n            print(temp.data, end=' ')\n            temp = temp.next\n        print()\n     \n    # Inserts a node at start of linked list\n    def push(self, new_data):\n        new_node = self.Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n     \n    def append(self, new_data):\n        if not self.head:\n            n = self.Node(new_data)\n            self.head = n\n            return\n        n1 = self.head\n        n2 = self.Node(new_data)\n        while n1.next:\n            n1 = n1.next\n        n1.next = n2\n        n2.next = None\n     \n    # A utility function that returns true if data is\n    # present in linked list else return false\n    def isPresent(self, head, data):\n        t = head\n        while t:\n            if t.data == data:\n                return True\n            t = t.next\n        return False\n     \n    def getIntersection(self, head1, head2):\n        hset = set()\n        n1 = head1\n        n2 = head2\n        result = LinkedList()\n         \n        # loop stores all the elements of list1 in hset\n        while n1:\n            if n1.data not in hset:\n                hset.add(n1.data)\n            n1 = n1.next\n         \n        while n2:\n            if n2.data in hset:\n                result.push(n2.data)\n            n2 = n2.next\n        return result\n     \n    def getUnion(self, head1, head2):\n        hmap = {}\n        n1 = head1\n        n2 = head2\n        result = LinkedList()\n         \n        # loop inserts the elements and the count of\n        # that element of list1 into the hmap\n        while n1:\n            if n1.data in hmap:\n                hmap[n1.data] += 1\n            else:\n                hmap[n1.data] = 1\n            n1 = n1.next\n         \n        # loop further adds the elements of list2 with\n        # their counts into the hmap\n        while n2:\n            if n2.data in hmap:\n                hmap[n2.data] += 1\n            else:\n                hmap[n2.data] = 1\n            n2 = n2.next\n         \n        list1 = []\n        for key, value in hmap.items():\n            # for _ in range(value):\n            list1.append(key)\n        list1 = set(list1)\n        for i in list1:\n            result.append(i)\n        return result\n \n# Driver program to test above functions\nllist1 = LinkedList()\nllist2 = LinkedList()\nintersection = LinkedList()\nunion_list = LinkedList()\n \n# create a linked list 10->15->4->20\nllist1.push(20)\nllist1.push(4)\nllist1.push(15)\nllist1.push(10)\n \n# create a linked list 8->4->2->10 \nllist2.push(10)\nllist2.push(2)\nllist2.push(4)\nllist2.push(8)\n \nintersection = intersection.getIntersection(\n               llist1.head, llist2.head)\nunion_list = union_list.getUnion(\n             llist1.head, llist2.head)\n \nprint('First List is')\nllist1.printList()\n \nprint('Second List is')\nllist2.printList()\n \nprint('Intersection List is')\nintersection.printList()\n \nprint('Union List is')\nunion_list.printList()\n"], "Adding two polynomials using Linked List -  ": ["# Python3 program to implement the approach \n  \n# Utilities for Linked List Nodes \nclass Node: \n      \n    # Constructor to initialize a node \n    def __init__(self, a, b): \n        self.coeff = a; \n        self.pow = b; \n        self.next = None; \n  \n# Polynomial Class definition \nclass Polynomial: \n      \n    # Method to add two polynomials \n    def addPolynomial(self, p1, p2): \n  \n        a = p1 \n        b = p2 \n        newHead = Node(0, 0) \n        c = newHead; \n  \n        while (a != None or b != None): \n  \n            if (a == None): \n                c.next = b; \n                break\n              \n            elif (b == None): \n                c.next = a; \n                break; \n              \n  \n            elif (a.pow == b.pow): \n                c.next = Node(a.coeff + b.coeff, a.pow); \n  \n                a = a.next; \n                b = b.next; \n              \n  \n            elif (a.pow > b.pow): \n                c.next = Node(a.coeff, a.pow); \n  \n                a = a.next; \n              \n  \n            elif (a.pow < b.pow): \n                c.next = Node(b.coeff, b.pow); \n  \n                b = b.next; \n              \n  \n            c = c.next; \n  \n        return newHead.next; \n      \n# Driver Code \nstart1 = None\ncur1 = None\nstart2 = None\ncur2 = None; \n  \nlist1_coeff = [ 5, 4, 2 ]; \nlist1_pow = [ 2, 1, 0 ]; \nn = len(list1_coeff); \n  \ni = 0; \nwhile (n > 0): \n    a = list1_coeff[i]; \n    b = list1_pow[i]; \n  \n    ptr =  Node(a, b); \n  \n    if (start1 == None): \n        start1 = ptr; \n        cur1 = ptr; \n      \n    else: \n        cur1.next = ptr; \n        cur1 = ptr; \n  \n    i += 1\n    n -= 1\n  \nlist2_coeff = [ -5, -5 ]; \nlist2_pow = [ 1, 0 ]; \nn = len(list2_coeff); \n  \ni = 0; \nwhile (n > 0): \n    a = list2_coeff[i]; \n    b = list2_pow[i]; \n  \n    ptr = Node(a, b); \n  \n    if (start2 == None): \n        start2 = ptr; \n        cur2 = ptr; \n  \n    else : \n        cur2.next = ptr; \n        cur2 = ptr; \n      \n    n -= 1\n    i += 1\n  \n  \nobj = Polynomial(); \n  \nsum = obj.addPolynomial(start1, start2); \n  \ntrav = sum; \n  \n# Displaying the result \nwhile (trav != None): \n    print(trav.coeff, 'x^', trav.pow, sep = '', end = ''); \n    if (trav.next != None): \n        print(' + ', end = ''); \n    trav = trav.next; \n  \nprint() \n  \n# This code is contributed by phasing17\n", "# 1st Number: 5x^2+4x^1+2x^0 \n# 2nd Number: -5x^1-5x^0 \n  \n# Link list Node \nclass Node: \n    def __init__(self, c, p): \n        self.coeff = c \n        self.pow = p \n        self.next = None\n  \n# insert in linked list \ndef append(head, coeff, power): \n    new_node = Node(coeff, power) \n  \n    while head.next != None: \n        head = head.next\n    head.next = new_node \n  \n# The below method print the required sum of polynomial p1 and p2 as specified in output \ndef addPolynomial(p1, p2): \n    res = Node(0, 0)  # dummy node ...head of resultant list \n    prev = res  # pointer to last node of resultant list \n  \n    while p1 != None and p2 != None: \n        if p1.pow < p2.pow: \n            prev.next = p2 \n            prev = p2 \n            p2 = p2.next\n        elif p1.pow > p2.pow: \n            prev.next = p1 \n            prev = p1 \n            p1 = p1.next\n        else: \n            p1.coeff += p2.coeff \n            prev.next = p1 \n            prev = p1 \n            p1 = p1.next\n            p2 = p2.next\n  \n    if (p1 != None): \n        prev.next = p1 \n  \n    if (p2 != None): \n        prev.next = p2 \n  \n    return res.next\n  \n  \n# Driver code \nif __name__ == '__main__': \n  \n    # 1st Number: 5x^2+4x^1+2x^0 \n    poly1 = Node(5, 2) \n    append(poly1, 4, 1) \n    append(poly1, 2, 0) \n  \n    # 2nd Number: -5x^1-5x^0 \n    poly2 = Node(-5, 1) \n    append(poly2, -5, 0) \n  \n    sum = addPolynomial(poly1, poly2) \n  \n    ptr = sum\n    while ptr != None: \n        # printing polynomial \n        print(ptr.coeff, 'x^', ptr.pow, end='') \n        if ptr.next != None: \n            print(' + ', end='') \n        ptr = ptr.next\n    print() \n  \n# This code is contributed by Tapesh(tapeshdua420) \n", "# Python3 Program to add two polynomials \n# represented in linkedlist using recursion \nclass Node: \n    def __init__(self, coeff, power): \n        self.coeff = coeff \n        self.power = power \n        self.next = None\n  \ndef addPolynomials(head1, head2): \n    if(head1 == None and head2 == None): \n        return\n    elif(head1.power == head2.power): \n        print(f'{head1.coeff + head2.coeff}x^{head1.power}', end=' ') \n        addPolynomials(head1.next, head2.next) \n  \n    elif(head1.power > head2.power): \n        print(f'{head1.coeff}x^{head1.power}', end=' ') \n        addPolynomials(head1.next, head2) \n  \n    else: \n        print(f'{head2.coeff}x^{head2.power} ', end=' ') \n        addPolynomials(head1, head2.next) \n  \n  \ndef insert(head, coeff, power): \n    new_node = Node(coeff, power) \n    while(head.next != None): \n        head = head.next\n  \n    head.next = new_node \n  \n  \ndef printList(head): \n    print('Linked List') \n    while(head != None): \n        print(f'{head.coeff}x^{head.power}', end=' ') \n        head = head.next\n  \n# Driver code \nhead = Node(5, 2) \ninsert(head, 4, 1) \nhead2 = Node(6, 2) \ninsert(head2, 4, 1) \nprintList(head) \nprint() \nprintList(head2) \nprint() \nprint('Addition:') \naddPolynomials(head, head2) \n  \n# This code is contributed by phasing17 \n"], "Rearrange a Linked List in Zig-Zag fashion -  ": ["# Python code to rearrange linked list in zig zag fashion\n \n# Node class \nclass Node: \n \n    # Constructor to initialize the node object \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n \n \n# This function distributes the Node in zigzag fashion\ndef zigZagList(head):\n \n    # If flag is true, then next node should be greater\n    # in the desired output.\n    flag = True\n \n    # Traverse linked list starting from head.\n    current = head\n    while (current.next != None):\n     \n        if (flag): # '<' relation expected\n         \n            # If we have a situation like A > B > C\n            # where A, B and C are consecutive Nodes\n            # in list we get A > B < C by swapping B\n            # and C \n            if (current.data > current.next.data):\n                t = current.data\n                current.data = current.next.data\n                current.next.data = t\n             \n         \n        else :# '>' relation expected\n         \n            # If we have a situation like A < B < C where\n            # A, B and C are consecutive Nodes in list we\n            # get A < C > B by swapping B and C \n            if (current.data < current.next.data):\n                t = current.data\n                current.data = current.next.data\n                current.next.data = t\n             \n        current = current.next\n        if(flag):\n            flag = False # flip flag for reverse checking \n        else:\n            flag = True\n    return head\n \n# function to insert a Node in \n# the linked list at the beginning.\ndef push(head, k):\n \n    tem = Node(0)\n    tem.data = k\n    tem.next = head\n    head = tem\n    return head\n \n# function to display Node of linked list.\ndef display( head):\n \n    curr = head\n    while (curr != None): \n        print( curr.data, '->', end =' ')\n        curr = curr.next\n     \n    print('None')\n \n# Driver code\n \nhead = None\n \n# create a list 4 -> 3 -> 7 -> 8 -> 6 -> 2 -> 1\n# answer should be -> 3 7 4 8 2 6 1\nhead = push(head, 1)\nhead = push(head, 2)\nhead = push(head, 6)\nhead = push(head, 8)\nhead = push(head, 7)\nhead = push(head, 3)\nhead = push(head, 4)\n \nprint('Given linked list \\n')\ndisplay(head)\n \nhead = zigZagList(head)\n \nprint('\\nZig Zag Linked list \\n')\ndisplay(head)\n \n# This code is contributed by Arnab Kundu\n", "# Python program for the above approach// Node class\nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nhead = None\n \n# Print Linked List\n \n \ndef printLL():\n    t = head\n    while (t != None):\n        print(t.data, end=' ->')\n        t = t.next\n    print()\n \n# Swap both nodes\n \n \ndef swap(a, b):\n    if(a == None or b == None):\n        return\n    temp = a.data\n    a.data = b.data\n    b.data = temp\n \n# Rearrange the linked list\n# in zig zag way\n \n \ndef zigZag(node, flag):\n    if(node == None or node.next == None):\n        return node\n    if (flag == 0):\n        if (node.data > node.next.data):\n            swap(node, node.next)\n        return zigZag(node.next, 1)\n \n    else:\n        if (node.data < node.next.data):\n            swap(node, node.next)\n        return zigZag(node.next, 0)\n \n \n# Driver Code\nhead = Node(11)\nhead.next = Node(15)\nhead.next.next = Node(20)\nhead.next.next.next = Node(5)\nhead.next.next.next.next = Node(10)\nprintLL()\n \n# 0 means the current element\n# should be smaller than the next\nflag = 0\nzigZag(head, flag)\nprint('LL in zig zag fashion : ')\nprintLL()\n \n# This code is contributed by avanitrachhadiya2155.\n"], "Alternate Odd and Even Nodes in a Singly Linked List -  ": ["# Python program to rearrange nodes \n# as alternate odd even nodes in \n# a Singly Linked List \n  \n# Link list node  \nclass Node:  \n      \n    def __init__(self, data):  \n        self.data = data  \n        self.next = next\n          \n# A utility function to print \n# linked list \ndef printList( node): \n  \n    while (node != None) : \n        print(node.data , end=' ') \n        node = node.next\n      \n    print('\\n') \n  \n# Function to create newNode \n# in a linkedlist \ndef newNode(key): \n  \n    temp = Node(0) \n    temp.data = key \n    temp.next = None\n    return temp \n  \n# Function to insert at beginning \ndef insertBeg(head, val): \n  \n    temp = newNode(val) \n    temp.next = head \n    head = temp \n    return head \n  \n# Function to rearrange the \n# odd and even nodes \ndef rearrangeOddEven( head): \n  \n    odd = [] \n    even = [] \n    i = 1\n  \n    while (head != None):  \n  \n        if (head.data % 2 != 0 and i % 2 == 0):  \n  \n            # Odd Value in Even Position \n            # Add pointer to current node \n            # in odd stack \n            odd.append(head) \n          \n        elif (head.data % 2 == 0 and i % 2 != 0):  \n  \n            # Even Value in Odd Position \n            # Add pointer to current node \n            # in even stack \n            even.append(head) \n  \n        head = head.next\n        i = i + 1\n  \n    while (len(odd) != 0 and len(even) != 0) : \n  \n        # Swap Data at the top of two stacks \n        odd[-1].data, even[-1].data = even[-1].data, odd[-1].data \n        odd.pop() \n        even.pop() \n      \n    return head \n  \n# Driver code \n  \nhead = newNode(8) \nhead = insertBeg(head, 7) \nhead = insertBeg(head, 6) \nhead = insertBeg(head, 5) \nhead = insertBeg(head, 3) \nhead = insertBeg(head, 2) \nhead = insertBeg(head, 1) \n  \nprint( 'Linked List:' ) \nprintList(head) \nrearrangeOddEven(head) \n  \nprint( 'Linked List after ', 'Rearranging:' ) \nprintList(head) \n  \n# This code is contributed by Arnab Kundu \n", "# Python3 program to rearrange nodes  \n# as alternate odd even nodes in  \n# a Singly Linked List  \n  \n# Structure node  \nclass Node : \n  \n    def __init__(self): \n        self.data = 0\n        self.next = None\n  \n# A utility function to print  \n# linked list  \ndef printList(node) : \n    while (node != None) : \n        print(node.data, end = ' ')  \n        node = node.next\n      \n    print(' ') \n  \n# Function to create newNode  \n# in a linkedlist  \ndef newNode( key) : \n    temp = Node()  \n    temp.data = key  \n    temp.next = None\n    return temp  \n  \n# Function to insert at beginning  \ndef insertBeg( head, val) : \n    temp = newNode(val)  \n    temp.next = head  \n    head = temp  \n    return head  \n  \n# Function to rearrange the  \n# odd and even nodes  \ndef rearrange(head) : \n  \n    # Step 1: Segregate even and odd nodes  \n    # Step 2: Split odd and even lists  \n    # Step 3: Merge even list into odd list  \n    even = None\n    temp = None\n    prev_temp = None\n    i = None\n    j = None\n    k = None\n    l = None\n    ptr = None\n  \n    # Step 1: Segregate Odd and Even Nodes  \n    temp = (head).next\n    prev_temp = head  \n  \n    while (temp != None) : \n      \n        # Backup next pointer of temp  \n        x = temp.next\n  \n        # If temp is odd move the node  \n        # to beginning of list  \n        if (temp.data % 2 != 0) : \n          \n            prev_temp.next = x  \n            temp.next = (head)  \n            (head) = temp  \n          \n        else: \n          \n            prev_temp = temp  \n          \n        # Advance Temp Pointer  \n        temp = x  \n      \n    # Step 2  \n    # Split the List into Odd and even  \n    temp = (head).next\n    prev_temp = (head)  \n  \n    while (temp != None and temp.data % 2 != 0) : \n        prev_temp = temp  \n        temp = temp.next\n      \n    even = temp  \n  \n    # End the odd List (Make last node None)  \n    prev_temp.next = None\n  \n    # Step 3:  \n    # Merge Even List into odd  \n    i = head  \n    j = even  \n  \n    while (j != None and i != None): \n      \n        # While both lists are not  \n        # exhausted Backup next  \n        # pointers of i and j  \n        k = i.next\n        l = j.next\n  \n        i.next = j  \n        j.next = k  \n  \n        # ptr points to the latest node added  \n        ptr = j  \n  \n        # Advance i and j pointers  \n        i = k  \n        j = l  \n  \n    if (i == None): \n      \n        # Odd list exhausts before even,  \n        # append remainder of even list to odd.  \n        ptr.next = j  \n          \n    # The case where even list exhausts before  \n    # odd list is automatically handled since we  \n    # merge the even list into the odd list  \n    return head \n  \n# Driver Code  \nhead = newNode(8)  \nhead = insertBeg(head, 7)  \nhead = insertBeg(head, 6)  \nhead = insertBeg(head, 3)  \nhead = insertBeg(head, 5)  \nhead = insertBeg(head, 1)  \nhead = insertBeg(head, 2)  \nhead = insertBeg(head, 10)  \n  \nprint('Linked List:' )  \nprintList(head)  \nprint('Rearranged List' )  \nhead = rearrange(head)  \nprintList(head)  \n  \n# This code is contributed by Arnab Kundu \n"], "Segregate even and odd nodes in a Linked List -  ": ["# Python program to segregate even and odd nodes in a \n# Linked List \nhead = None # head of list \n  \n# Node class  \nclass Node:  \n      \n    # Function to initialise the node object  \n    def __init__(self, data):  \n        self.data = data # Assign data  \n        self.next =None\n  \ndef segregateEvenOdd(): \n  \n    global head \n    end = head \n    prev = None\n    curr = head \n  \n    # Get pointer to last Node  \n    while (end.next != None): \n        end = end.next\n  \n    new_end = end \n  \n    # Consider all odd nodes before getting first even node \n    while (curr.data % 2 !=0 and curr != end): \n          \n        new_end.next = curr \n        curr = curr.next\n        new_end.next.next = None\n        new_end = new_end.next\n          \n    # do following steps only if there is an even node \n    if (curr.data % 2 == 0): \n          \n        head = curr \n  \n        # now curr points to first even node \n        while (curr != end): \n              \n            if (curr.data % 2 == 0): \n                  \n                prev = curr \n                curr = curr.next\n                  \n            else: \n                  \n                # Break the link between prev and curr \n                prev.next = curr.next\n  \n                # Make next of curr as None  \n                curr.next = None\n  \n                # Move curr to end  \n                new_end.next = curr \n  \n                # Make curr as new end of list  \n                new_end = curr \n  \n                # Update curr pointer  \n                curr = prev.next\n              \n    # We have to set prev before executing rest of this code  \n    else: \n        prev = curr \n  \n    if (new_end != end and end.data % 2 != 0): \n          \n        prev.next = end.next\n        end.next = None\n        new_end.next = end \n          \n# Given a reference (pointer to pointer) to the head \n# of a list and an int, push a new node on the front \n# of the list.  \ndef push(new_data): \n    global head \n  \n    # 1 & 2: Allocate the Node & \n    #         Put in the data \n    new_node = Node(new_data) \n  \n    # 3. Make next of new Node as head  \n    new_node.next = head \n  \n    # 4. Move the head to point to new Node  \n    head = new_node \n  \n# Utility function to print a linked list \ndef printList(): \n    global head \n    temp = head \n    while(temp != None): \n          \n        print(temp.data, end = ' ') \n        temp = temp.next\n          \n    print(' ') \n  \n# Driver program to test above functions  \n  \npush(11) \npush(10) \npush(8) \npush(6) \npush(4) \npush(2) \npush(0) \nprint('Original Linked List') \nprintList() \n  \nsegregateEvenOdd() \n  \nprint('Modified Linked List') \nprintList() \n  \n# This code is contributed by Arnab Kundu  \n", "# Python3 program to segregate even and odd nodes in a \n# Linked List \nhead = None # head of list  \n  \n# Node class   \nclass Node:   \n        \n    # Function to initialise the node object   \n    def __init__(self, data):   \n        self.data = data # Assign data   \n        self.next =None\n  \n# Function to segregate even and odd nodes. \ndef segregateEvenOdd(): \n    global head  \n      \n    # Starting node of list having  \n    # even values. \n    evenStart = None\n      \n    # Ending node of even values list. \n    evenEnd = None\n      \n    # Starting node of odd values list. \n    oddStart = None\n      \n    # Ending node of odd values list. \n    oddEnd = None\n      \n    # Node to traverse the list. \n    currNode = head \n      \n    while(currNode != None): \n        val = currNode.data \n          \n        # If current value is even, add \n        # it to even values list. \n        if(val % 2 == 0): \n            if(evenStart == None): \n                evenStart = currNode \n                evenEnd = evenStart \n            else: \n                evenEnd . next = currNode \n                evenEnd = evenEnd . next\n          \n        # If current value is odd, add  \n        # it to odd values list. \n        else: \n            if(oddStart == None): \n                oddStart = currNode \n                oddEnd = oddStart \n            else: \n                oddEnd . next = currNode \n                oddEnd = oddEnd . next\n                  \n        # Move head pointer one step in  \n        # forward direction \n        currNode = currNode . next \n      \n    # If either odd list or even list is empty, \n    # no change is required as all elements  \n    # are either even or odd. \n    if(oddStart == None or evenStart == None): \n        return\n      \n    # Add odd list after even list.      \n    evenEnd . next = oddStart \n    oddEnd . next = None\n      \n    # Modify head pointer to  \n    # starting of even list. \n    head = evenStart \n  \n''' UTILITY FUNCTIONS '''\n''' Function to insert a node at the beginning '''\ndef push(new_data): \n      \n    global head  \n    # 1 & 2: Allocate the Node &  \n    #         Put in the data  \n    new_node = Node(new_data)  \n      \n    # 3. Make next of new Node as head   \n    new_node.next = head  \n      \n    # 4. Move the head to point to new Node   \n    head = new_node  \n  \n''' Function to print nodes in a given linked list '''\ndef printList(): \n    global head \n    node = head \n    while (node != None): \n        print(node.data, end = ' ') \n        node = node.next\n    print() \n      \n''' Driver program to test above functions'''\n  \n''' Let us create a sample linked list as following \n0.1.4.6.9.10.11 '''\n  \npush(11) \npush(10) \npush(9) \npush(6) \npush(4) \npush(1) \npush(0) \n  \nprint('Original Linked list') \nprintList() \n  \nsegregateEvenOdd() \n  \nprint('Modified Linked list') \nprintList() \n  \n# This code is contributed by shubhamsingh10. \n", "# Python program to segregate even and odd nodes \n# in a Linked List \n  \n# A node structure \nclass Node: \n    def __init__(self, x): \n        self.data = x \n        self.next = None\n  \ndef p(node): \n    while(node is not None): \n        print(node.data, end=' ') \n        node = node.next\n  \ndef divide(head): \n    q = [] \n    qe = [] \n    qo = [] \n    cur = head \n    while(cur is not None): \n        if(cur.data % 2 == 0): \n            qe.append(cur) \n        else: \n            qo.append(cur) \n        cur = cur.next\n  \n    node = Node(-100) \n    ans = node \n  \n    while(len(qe) > 0): \n        q.append(qe.pop(0)) \n  \n    while(len(qo) > 0): \n        q.append(qo.pop(0)) \n  \n    while(len(q) > 0): \n        node.next = q.pop(0) \n        node = node.next\n  \n    node.next = None\n    return ans.next\n  \nhead = Node(9) \nhead.next = Node(1) \nhead.next.next = Node(6) \nhead.next.next.next = Node(7) \nhead.next.next.next.next = Node(3) \nhead.next.next.next.next.next = Node(4) \ntemp = divide(head) \np(temp) \n  \n# This code is contributed by Yash Agarwal(yashagrwal2852002)\n"], "Iteratively Reverse a linked list using only 2 pointers (An Interesting Method) -  ": ["# Iteratively Reverse a linked list using only 2 pointers (An Interesting Method) \n# Python program to reverse a linked list \n# Link list node \n# node class \n  \n  \nclass node: \n  \n    # Constructor to initialize the node object \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n  \n  \nclass LinkedList: \n  \n    # Function to initialize head \n    def __init__(self): \n        self.head = None\n  \n    # Function to reverse the linked list \n    def reverse(self): \n        prev = None\n        current = self.head \n    # Described here https://www. .org/ \n    # how-to-swap-two-variables-in-one-line / \n        while(current is not None): \n            # This expression evaluates from left to right \n            # current->next = prev, changes the link from \n            # next to prev node \n            # prev = current, moves prev to current node for \n            # next reversal of node \n            # This example of list will clear it more 1->2 \n            # initially prev = 1, current = 2 \n            # Final expression will be current = 1, prev = 2 \n            next, current.next = current.next, prev \n            prev, current = current, next\n        self.head = prev \n  \n    # Function to push a new node \n    def push(self, new_data): \n        # allocate node and put in the data \n        new_node = node(new_data) \n        # link the old list of the new node \n        new_node.next = self.head \n        # move the head to point to the new node \n        self.head = new_node \n  \n    # Function to print the linked list \n    def printList(self): \n        temp = self.head \n        while(temp): \n            print(temp.data, end=' ') \n            temp = temp.next\n  \n  \n# Driver program to test above functions \nllist = LinkedList() \nllist.push(20) \nllist.push(4) \nllist.push(15) \nllist.push(85) \n  \nprint('Given Linked List') \nllist.printList() \nllist.reverse() \nprint('\\nReversed Linked List') \nllist.printList() \n  \n# This code is contributed by Afzal Ansari \n", "# Python3 program to reverse a linked list using two pointers. \n  \n# A linked list node  \nclass Node : \n    def __init__(self): \n        self.data = 0\n        self.next = None\n  \n# Function to reverse the linked list using 2 pointers  \ndef reverse(head_ref): \n  \n    current = head_ref \n    next= None\n    while (current.next != None) : \n        next = current.next\n        current.next = next.next\n        next.next = (head_ref) \n        head_ref = next\n      \n    return head_ref \n  \n# Function to push a node  \ndef push( head_ref, new_data): \n  \n    new_node = Node() \n    new_node.data = new_data \n    new_node.next = (head_ref) \n    (head_ref) = new_node \n    return head_ref \n  \n# Function to print linked list  \ndef printList( head): \n  \n    temp = head \n    while (temp != None) : \n        print( temp.data, end=' ') \n        temp = temp.next\n      \n# Driver code \n  \n# Start with the empty list  \nhead = None\n  \nhead = push(head, 20) \nhead = push(head, 4) \nhead = push(head, 15) \nhead = push(head, 85) \n  \nprint('Given linked list') \nprintList(head) \nhead = reverse(head) \nprint('\\nReversed Linked list ') \nprintList(head) \n  \n# This code is contributed by Arnab Kundu \n"], "Write a function to get the intersection point of two Linked Lists -  ": ["# Python program to get intersection point of two linked list\n \n# Link list node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# function to get the intersection point of two linked lists head1 and head\ndef getIntersectionNode(head1, head2):\n    while head2:\n        temp = head1\n        while temp:\n            # if both Nodes are same\n            if temp == head2:\n                return head2\n            temp = temp.next\n        head2 = head2.next\n    # intersection is not present between the lists\n    return None\n \n \n# Driver Code\nif __name__ == '__main__':\n    '''\n    Create two linked lists\n \n    1st 3->6->9->15->30\n    2nd 10->15->30\n \n    15 is the intersection point \n    '''\n \n    newNode = Node(10)\n    head1 = newNode\n    newNode = Node(3)\n    head2 = newNode\n    newNode = Node(6)\n    head2.next = newNode\n    newNode = Node(9)\n    head2.next.next = newNode\n    newNode = Node(15)\n    head1.next = newNode\n    head2.next.next.next = newNode\n    newNode = Node(30)\n    head1.next.next = newNode\n \n    intersectionPoint = getIntersectionNode(head1, head2)\n \n    if not intersectionPoint:\n        print(' No Intersection Point ')\n    else:\n        print('Intersection Point:', intersectionPoint.data)\n \n# This code is contributed by Tapesh(tapeshdua420)\n", "# defining a node for LinkedList\nclass Node:\n  def __init__(self,data):\n    self.data=data\n    self.next=None\n     \n \n \ndef getIntersectionNode(head1,head2):\n   \n  #finding the total number of elements in head1 LinkedList\n    c1=getCount(head1)\n   \n  #finding the total number of elements in head2 LinkedList\n    c2=getCount(head2)\n   \n  #Traverse the bigger node by 'd' so that from that node onwards, both LinkedList\n  #would be having same number of nodes and we can traverse them together.\n    if c1 > c2:\n        d=c1-c2\n        return _getIntersectionNode(d,head1,head2)\n    else:\n        d=c2-c1\n        return _getIntersectionNode(d,head2,head1) \n   \n   \ndef _getIntersectionNode(d,head1,head2):\n     \n     \n    current1=head1\n    current2=head2\n     \n     \n    for i in range(d):\n        if current1 is None:\n            return -1\n        current1=current1.next\n     \n    while current1 is not None and current2 is not None:\n     \n    # Instead of values, we need to check if there addresses are same\n    # because there can be a case where value is same but that value is\n    #not an intersecting point.\n        if current1 is current2:\n            return current1.data # or current2.data ( the value would be same)\n     \n        current1=current1.next\n        current2=current2.next\n   \n  # Incase, we are not able to find our intersecting point.\n    return -1\n   \n#Function to get the count of a LinkedList\ndef getCount(node):\n    cur=node\n    count=0\n    while cur is not None:\n        count+=1\n        cur=cur.next\n    return count\n     \n \nif __name__ == '__main__':\n  # Creating two LinkedList\n  # 1st one: 3->6->9->15->30\n  # 2nd one: 10->15->30\n  # We can see that 15 would be our intersection point\n   \n  # Defining the common node\n   \n  common=Node(15)\n   \n  #Defining first LinkedList\n   \n  head1=Node(3)\n  head1.next=Node(6)\n  head1.next.next=Node(9)\n  head1.next.next.next=common\n  head1.next.next.next.next=Node(30)\n   \n  # Defining second LinkedList\n   \n  head2=Node(10)\n  head2.next=common\n  head2.next.next=Node(30)\n   \n  print('The node of intersection is ',getIntersectionNode(head1,head2))\n   \n  # The code is contributed by Ansh Gupta.\n", "# Python program to get intersection \n# point of two linked list\nclass Node :\n    def __init__(self, d):\n        self.data = d;\n        self.next = None;\n \n# Function to print the list\ndef Print(n):\n    cur = n;\n    while (cur != None) :\n        print(cur.data, end=' ');\n        cur = cur.next;\n    print('');\n \n# Function to find the intersection of two node\ndef MegeNode(n1, n2):\n     \n    # Define hashset\n    hs = set();\n \n    while (n1 != None):\n        hs.add(n1);\n        n1 = n1.next;\n    while (n2 != None):\n        if (n2 in hs):\n            return n2;\n        n2 = n2.next;\n     \n    return None;\n \n \n# Driver code\n \n# list 1\nn1 = Node(1);\nn1.next = Node(2);\nn1.next.next = Node(3);\nn1.next.next.next = Node(4);\nn1.next.next.next.next = Node(5);\nn1.next.next.next.next.next = Node(6);\nn1.next.next.next.next.next.next = Node(7);\n \n# list 2\nn2 = Node(10);\nn2.next = Node(9);\nn2.next.next = Node(8);\nn2.next.next.next = n1.next.next.next;\n \nPrint(n1);\nPrint(n2);\n \nprint(MegeNode(n1, n2).data);\n \n# This code is contributed by _saurabh_jaiswal\n", "# Python3 program to print intersection of lists\n \n#  Link list node \nclass Node:\n    def __init__(self, data = 0, next = None):\n        self.data = data\n        self.next = next\n \n# A utility function to return  intersection node\ndef intersectPoint(head1, head2):\n \n    # Maintaining two pointers ptr1 and ptr2\n    # at the head of A and B,\n    ptr1 = head1\n    ptr2 = head2\n \n    # If any one of head is None i.e\n    # no Intersection Point\n    if (ptr1 == None or ptr2 == None):\n        return None\n \n    # Traverse through the lists until they\n    # reach Intersection node\n    while (ptr1 != ptr2):\n \n        ptr1 = ptr1.next\n        ptr2 = ptr2.next\n \n      # If at any node ptr1 meets ptr2, then it is\n      # intersection node.Return intersection node.\n        if (ptr1 == ptr2):\n            return ptr1\n \n        # Once both of them go through reassigning,\n        # they will be equidistant from the collision point.\n \n        # When ptr1 reaches the end of a list, then\n        # reassign it to the head2.\n        if (ptr1 == None):\n            ptr1 = head2\n \n        # When ptr2 reaches the end of a list, then\n        # redirect it to the head1.\n        if (ptr2 == None):\n            ptr2 = head1\n \n    return ptr1\n \n# Function to print intersection nodes\n# in  a given linked list\ndef Print(node):\n \n    if (node == None):\n        print('None')\n    while (node.next != None):\n        print(node.data,end='->')\n        node = node.next\n    print(node.data)\n \n# Driver code\n \n# Create two linked lists\n \n# 1st Linked list is 3->6->9->15->30\n# 2nd Linked list is 10->15->30\n \n# 15 30 are elements in the intersection list\n \nhead1 = Node()\nhead1.data = 10\nhead2 = Node()\nhead2.data = 3\nnewNode = Node()\nnewNode.data = 6\nhead2.next = newNode\nnewNode = Node()\nnewNode.data = 9\nhead2.next.next = newNode\nnewNode = Node()\nnewNode.data = 15\nhead1.next = newNode\nhead2.next.next.next = newNode\nnewNode = Node()\nnewNode.data = 30\nhead1.next.next = newNode\nhead1.next.next.next = None\nintersect_node = None\n \n  # Find the intersection node of two linked lists\nintersect_node = intersectPoint(head1, head2)\n \nprint('INTERSEPOINT LIST :',end='')\n \nPrint(intersect_node)\n \n# This code is contributed by shinjanpatra\n", "# Python program to print intersection of lists\n \n# Link list node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# A utility function to return  intersection node\ndef intersectPoint(headA, headB):\n    stackA = []\n    stackB = []\n    intersectNode = None\n \n    while headB != None:\n        stackB.append(headB)\n        headB = headB.next\n \n    while headA != None:\n        stackA.append(headA)\n        headA = headA.next\n \n    if not stackA[-1].data == stackB[-1].data:\n        return None\n \n    while stackA and stackB and stackA[-1].data == stackB[-1].data:\n        intersectNode = stackA[-1]\n        stackA.pop()\n        stackB.pop()\n \n    return intersectNode\n \n \n# Driver code\nif __name__ == '__main__':\n    # Create two linked lists\n \n    # 1st Linked list is 3.6.9.15.30\n    # 2nd Linked list is 10.15.30\n \n    # 15 30 are elements in the intersection list\n \n    head1 = Node(10)\n    head2 = Node(3)\n    newNode = Node(6)\n    head2.next = newNode\n    newNode = Node(9)\n    head2.next.next = newNode\n    newNode = Node(15)\n    head1.next = newNode\n    head2.next.next.next = newNode\n    newNode = Node(30)\n    head1.next.next = newNode\n    head1.next.next.next = None\n \n    # Find the intersection node of two linked lists\n    intersect_node = intersectPoint(head1, head2)\n    print('INTERSECTION POINT:', intersect_node.data)\n \n# This code is contributed by Tapesh(tapeshdua420)\n"], "Swap nodes in a linked list without swapping data -  ": ["# Python3 program to swap two given\n# nodes of a linked list\n \n# A linked list node class\n \n \nclass Node:\n \n    # constructor\n    def __init__(self, val=None, next1=None):\n        self.data = val\n        self.next = next1\n \n    # print list from this\n    # to last till None\n    def printList(self):\n \n        node = self\n \n        while (node != None):\n            print(node.data, end=' ')\n            node = node.next\n        print(' ')\n \n# Function to add a node\n# at the beginning of List\n \n \ndef push(head_ref, new_data):\n \n    # allocate node\n    (head_ref) = Node(new_data, head_ref)\n    return head_ref\n \n \ndef swapNodes(head_ref, x, y):\n    head = head_ref\n \n    # Nothing to do if x and y are same\n    if (x == y):\n        return None\n \n    a = None\n    b = None\n \n    # search for x and y in the linked list\n    # and store their pointer in a and b\n    while (head_ref.next != None):\n \n        if ((head_ref.next).data == x):\n            a = head_ref\n \n        elif ((head_ref.next).data == y):\n            b = head_ref\n \n        head_ref = ((head_ref).next)\n \n    # if we have found both a and b\n    # in the linked list swap current\n    # pointer and next pointer of these\n    if (a != None and b != None):\n        temp = a.next\n        a.next = b.next\n        b.next = temp\n        temp = a.next.next\n        a.next.next = b.next.next\n        b.next.next = temp\n \n    return head\n \n# Driver code\n \n \nstart = None\n \n# The constructed linked list is:\n# 1.2.3.4.5.6.7\nstart = push(start, 7)\nstart = push(start, 6)\nstart = push(start, 5)\nstart = push(start, 4)\nstart = push(start, 3)\nstart = push(start, 2)\nstart = push(start, 1)\n \nprint('Linked list before calling swapNodes() ')\nstart.printList()\n \nstart = swapNodes(start, 6, 1)\n \nprint('Linked list after calling swapNodes() ')\nstart.printList()\n \n# This code is contributed by Arnab Kundu\n"], "Remove all occurrences of duplicates from a sorted Linked List -  ": ["# Python3 implementation for the above approach \n  \n# Creating node \nclass Node: \n    def __init__(self, val): \n        self.val = val \n        self.next = None\nclass LinkedList: \n    def __init__(self): \n        self.head = None\n          \n    # add node into beginning of linked list \n    def push(self, new_data): \n        new_node = Node(new_data) \n        new_node.next = self.head \n        self.head = new_node \n        return new_node \n          \n    # Function to remove all occurrences \n    # of duplicate elements \n    def removeAllDuplicates(self, temp): \n          \n        # temp is head node of linkedlist \n        curr = temp \n        # print(' print something') \n        head = prev = Node(None) \n        head.next = curr \n  \n        # Here we use same as we do in removing  \n        # duplicates and only extra thing is that \n        # we need to remove all elements  \n        # having duplicates that we did in 30-31 \n        while curr and curr.next: \n              \n            # until the current value and next  \n            # value are same keep updating the current value \n            if curr.val == curr.next.val: \n                while(curr and curr.next and \n                      curr.val == curr.next.val): \n                    curr = curr.next\n                      \n                    # still one of duplicate values left \n                    # so point prev to curr \n                curr = curr.next\n                prev.next = curr \n            else: \n                prev = prev.next\n                curr = curr.next\n        return head.next\n          \n    # for print the linkedlist \n    def printList(self): \n        temp1 = self.head \n        while temp1 is not None: \n            print(temp1.val, end = ' ') \n            temp1 = temp1.next\n              \n    # For getting head of linkedlist \n    def get_head(self): \n        return self.head \n  \n# Driver Code \nif __name__=='__main__': \n    llist = LinkedList() \n    llist.push(53) \n    llist.push(53) \n    llist.push(49) \n    llist.push(49) \n    llist.push(35) \n    llist.push(28) \n    llist.push(28) \n    llist.push(23) \n      \n    print('Created linked list is:') \n    llist.printList() \n    print('\\nLinked list after deletion of duplicates:') \n    head1 = llist.get_head() \n    #print(head1) \n    llist.removeAllDuplicates(head1) \n    llist.printList() \n          \n# This code is contributed  \n# by PRAVEEN KUMAR(IIIT KALYANI) \n"], "Remove Duplicates from an Unsorted Linked List -  ": ["# Python3 program to remove duplicates\n# from unsorted linked list\n \n \nclass Node():\n \n    def __init__(self, data):\n \n        self.data = data\n        self.next = None\n \n \nclass LinkedList():\n \n    def __init__(self):\n \n        # Head of list\n        self.head = None\n \n    def remove_duplicates(self):\n \n        ptr1 = None\n        ptr2 = None\n        dup = None\n        ptr1 = self.head\n \n        # Pick elements one by one\n        while (ptr1 != None and ptr1.next != None):\n \n            ptr2 = ptr1\n \n            # Compare the picked element with rest\n            # of the elements\n            while (ptr2.next != None):\n \n                # If duplicate then delete it\n                if (ptr1.data == ptr2.next.data):\n \n                    # Sequence of steps is important here\n                    dup = ptr2.next\n                    ptr2.next = ptr2.next.next\n                else:\n                    ptr2 = ptr2.next\n \n            ptr1 = ptr1.next\n \n    # Function to print nodes in a\n    # given linked list\n    def printList(self):\n        temp = self.head\n \n        while(temp != None):\n            print(temp.data, end=' ')\n            temp = temp.next\n \n        print()\n \n \n# Driver code\nlist = LinkedList()\nlist.head = Node(10)\nlist.head.next = Node(12)\nlist.head.next.next = Node(11)\nlist.head.next.next.next = Node(11)\nlist.head.next.next.next.next = Node(12)\nlist.head.next.next.next.next.next = Node(11)\nlist.head.next.next.next.next.next.next = Node(10)\n \nprint('Linked List before removing duplicates :')\nlist.printList()\nlist.remove_duplicates()\nprint()\nprint('Linked List after removing duplicates :')\nlist.printList()\n \n# This code is contributed by maheshwaripiyush9\n", "# Python3 program to remove duplicates\n# from unsorted linkedlist\n \n \nclass Node:\n \n    def __init__(self, data):\n \n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    def __init__(self):\n \n        self.head = None\n \n    # Function to print nodes in a\n    # given linked list\n    def printlist(self):\n \n        temp = self.head\n \n        while (temp):\n            print(temp.data, end=' ')\n            temp = temp.next\n \n    # Function to remove duplicates from a\n    # unsorted linked list\n    def removeDuplicates(self, head):\n \n        # Base case of empty list or\n        # list with only one element\n        if self.head is None or self.head.next is None:\n            return head\n \n        # Hash to store seen values\n        hash = set()\n \n        current = head\n        hash.add(self.head.data)\n \n        while current.next is not None:\n \n            if current.next.data in hash:\n                current.next = current.next.next\n            else:\n                hash.add(current.next.data)\n                current = current.next\n \n        return head\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Creating Empty list\n    llist = LinkedList()\n    llist.head = Node(10)\n    second = Node(12)\n    third = Node(11)\n    fourth = Node(11)\n    fifth = Node(12)\n    sixth = Node(11)\n    seventh = Node(10)\n \n    # Connecting second and third\n    llist.head.next = second\n    second.next = third\n    third.next = fourth\n    fourth.next = fifth\n    fifth.next = sixth\n    sixth.next = seventh\n \n    # Printing data\n    print('Linked List before removing Duplicates.')\n    llist.printlist()\n    llist.removeDuplicates(llist.head)\n    print('\\nLinked List after removing duplicates.')\n    llist.printlist()\n \n# This code is contributed by rajataro0\n"], "Function to check if a singly linked list is palindrome -  ": ["# Python3 program to check if linked\n# list is palindrome using stack\n \n \nclass Node:\n    def __init__(self, data):\n \n        self.data = data\n        self.ptr = None\n \n# Function to check if the linked list\n# is palindrome or not\n \n \ndef ispalindrome(head):\n \n    # Temp pointer\n    slow = head\n \n    # Declare a stack\n    stack = []\n \n    ispalin = True\n \n    # Push all elements of the list\n    # to the stack\n    while slow != None:\n        stack.append(slow.data)\n \n        # Move ahead\n        slow = slow.ptr\n \n    # Iterate in the list again and\n    # check by popping from the stack\n    while head != None:\n \n        # Get the top most element\n        i = stack.pop()\n \n        # Check if data is not\n        # same as popped element\n        if head.data == i:\n            ispalin = True\n        else:\n            ispalin = False\n            break\n \n        # Move ahead\n        head = head.ptr\n \n    return ispalin\n \n# Driver Code\n \n \n# Addition of linked list\none = Node(1)\ntwo = Node(2)\nthree = Node(3)\nfour = Node(4)\nfive = Node(3)\nsix = Node(2)\nseven = Node(1)\n \n# Initialize the next pointer\n# of every current pointer\none.ptr = two\ntwo.ptr = three\nthree.ptr = four\nfour.ptr = five\nfive.ptr = six\nsix.ptr = seven\nseven.ptr = None\n \n# Call function to check palindrome or not\nresult = ispalindrome(one)\n \nprint('isPalindrome:', result)\n \n# This code is contributed by Nishtha Goel\n", "# Python3 program to check if\n# linked list is palindrome\n \n# Node class\n \n \nclass Node:\n \n    # Constructor to initialize\n    # the node object\n    def __init__(self, data):\n \n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n \n        self.head = None\n \n    # Function to check if given\n    # linked list is palindrome or not\n    def isPalindrome(self, head):\n \n        slow_ptr = head\n        fast_ptr = head\n        prev_of_slow_ptr = head\n \n        # To handle odd size list\n        midnode = None\n \n        # Initialize result\n        res = True\n \n        if (head != None and head.next != None):\n \n            # Get the middle of the list.\n            # Move slow_ptr by 1 and\n            # fast_ptr by 2, slow_ptr\n            # will have the middle node\n            while (fast_ptr != None and\n                   fast_ptr.next != None):\n \n                # We need previous of the slow_ptr\n                # for linked lists  with odd\n                # elements\n                fast_ptr = fast_ptr.next.next\n                prev_of_slow_ptr = slow_ptr\n                slow_ptr = slow_ptr.next\n \n            # fast_ptr would become NULL when\n            # there are even elements in the\n            # list and not NULL for odd elements.\n            # We need to skip the middle node for\n            # odd case and store it somewhere so\n            # that we can restore the original list\n            if (fast_ptr != None):\n                midnode = slow_ptr\n                slow_ptr = slow_ptr.next\n \n            # Now reverse the second half\n            # and compare it with first half\n            second_half = slow_ptr\n \n            # NULL terminate first half\n            prev_of_slow_ptr.next = None\n \n            # Reverse the second half\n            second_half = self.reverse(second_half)\n \n            # Compare\n            res = self.compareLists(head, second_half)\n \n            # Construct the original list back\n            # Reverse the second half again\n            second_half = self.reverse(second_half)\n \n            if (midnode != None):\n \n                # If there was a mid node (odd size\n                # case) which was not part of either\n                # first half or second half.\n                prev_of_slow_ptr.next = midnode\n                midnode.next = second_half\n            else:\n                prev_of_slow_ptr.next = second_half\n        return res\n \n    # Function to reverse the linked list\n    # Note that this function may change\n    # the head\n    def reverse(self, second_half):\n \n        prev = None\n        current = second_half\n        next = None\n \n        while current != None:\n            next = current.next\n            current.next = prev\n            prev = current\n            current = next\n \n        second_half = prev\n        return second_half\n \n    # Function to check if two input\n    # lists have same data\n    def compareLists(self, head1, head2):\n \n        temp1 = head1\n        temp2 = head2\n \n        while (temp1 and temp2):\n            if (temp1.data == temp2.data):\n                temp1 = temp1.next\n                temp2 = temp2.next\n            else:\n                return 0\n \n        # Both are empty return 1\n        if (temp1 == None and temp2 == None):\n            return 1\n \n        # Will reach here when one is NULL\n        # and other is not\n        return 0\n \n    # Function to insert a new node\n    # at the beginning\n    def push(self, new_data):\n \n        # Allocate the Node &\n        # Put in the data\n        new_node = Node(new_data)\n \n        # Link the old list of the new one\n        new_node.next = self.head\n \n        # Move the head to point to new Node\n        self.head = new_node\n \n    # A utility function to print\n    # a given linked list\n    def printList(self):\n \n        temp = self.head\n \n        while(temp):\n            print(temp.data, end='->')\n            temp = temp.next\n \n        print('NULL')\n \n \n# Driver code\nif __name__ == '__main__':\n \n    l = LinkedList()\n    s = ['a', 'b', 'a', 'c', 'a', 'b', 'a']\n \n    for i in range(7):\n        l.push(s[i])\n    if (l.isPalindrome(l.head) != False):\n        print('Is Palindrome\\n')\n    else:\n        print('Not Palindrome\\n')\n \n# This code is contributed by MuskanKalra1\n", "# Python program for the above approach\n \n# Head of the list\nhead = None\nleft = None\n \n \nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.next = None\n \n# Initial parameters to this function are\n# &head and head\n \n \ndef isPalindromeUtil(right):\n    global head, left\n \n    left = head\n \n    # Stop recursion when right becomes null\n    if (right == None):\n        return True\n \n    # If sub-list is not palindrome then no need to\n    # check for the current left and right, return\n    # false\n    isp = isPalindromeUtil(right.next)\n    if (isp == False):\n        return False\n \n    # Check values at current left and right\n    isp1 = (right.data == left.data)\n \n    left = left.next\n \n    # Move left to next node;\n    return isp1\n \n# A wrapper over isPalindrome(Node head)\n \n \ndef isPalindrome(head):\n    result = isPalindromeUtil(head)\n    return result\n \n# Push a node to linked list. Note that\n# this function changes the head\n \n \ndef push(new_data):\n    global head\n \n    # Allocate the node and put in the data\n    new_node = Node(new_data)\n \n    # Link the old list of the new one\n    new_node.next = head\n \n    # Move the head to point to new node\n    head = new_node\n \n# A utility function to print a\n# given linked list\n \n \ndef printList(ptr):\n    while (ptr != None):\n        print(ptr.data, end='->')\n        ptr = ptr.next\n \n    print('Null ')\n \n \n# Driver Code\nstr = ['a', 'b', 'a', 'c', 'a', 'b', 'a']\n \nfor i in range(0, 7):\n    push(str[i])\n \nif (isPalindrome(head) and i != 0):\n    print('Is Palindrome\\n')\nelse:\n    print('Not Palindrome\\n')\n \n# This code is contributed by saurabh_jaiswal.\n"], "Remove duplicates from a sorted linked list -  ": ["# Python3 program to remove duplicate\n# nodes from a sorted linked list\n \n# Node class\n \n \nclass Node:\n \n    # Constructor to initialize\n    # the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # Function to insert a new node\n    # at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Given a reference to the head of a\n    # list and a key, delete the first\n    # occurrence of key in linked list\n    def deleteNode(self, key):\n \n        # Store head node\n        temp = self.head\n \n        # If head node itself holds the\n        # key to be deleted\n        if (temp is not None):\n            if (temp.data == key):\n                self.head = temp.next\n                temp = None\n                return\n \n        # Search for the key to be deleted,\n        # keep track of the previous node as\n        # we need to change 'prev.next'\n        while(temp is not None):\n            if temp.data == key:\n                break\n            prev = temp\n            temp = temp.next\n \n        # if key was not present in\n        # linked list\n        if(temp == None):\n            return\n \n        # Unlink the node from linked list\n        prev.next = temp.next\n \n        temp = None\n \n    # Utility function to print the\n    # linked LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(temp.data, end=' ')\n            temp = temp.next\n \n    # This function removes duplicates\n    # from a sorted list\n    def removeDuplicates(self):\n        temp = self.head\n        if temp is None:\n            return\n        while temp.next is not None:\n            if temp.data == temp.next.data:\n                new = temp.next.next\n                temp.next = None\n                temp.next = new\n            else:\n                temp = temp.next\n        return self.head\n \n \n# Driver Code\nllist = LinkedList()\n \nllist.push(20)\nllist.push(13)\nllist.push(13)\nllist.push(11)\nllist.push(11)\nllist.push(11)\nprint('Created Linked List: ')\nllist.printList()\nprint()\nprint('Linked List after removing',\n      'duplicate elements:')\nllist.removeDuplicates()\nllist.printList()\n \n# This code is contributed by\n# Dushyant Pathak.\n", "# Python3 Program to remove duplicates\n# from a sorted linked list\nimport math\n \n# Link list node\n \n \nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# The function removes duplicates\n# from a sorted list\n \n \ndef removeDuplicates(head):\n \n    # Pointer to store the pointer of a node\n    # to be deleted to_free\n \n    # do nothing if the list is empty\n    if (head == None):\n        return\n \n    # Traverse the list till last node\n    if (head.next != None):\n \n        # Compare head node with next node\n        if (head.data == head.next.data):\n \n            # The sequence of steps is important.\n            # to_free pointer stores the next of head\n            # pointer which is to be deleted.\n            to_free = head.next\n            head.next = head.next.next\n \n            # free(to_free)\n            removeDuplicates(head)\n \n        # This is tricky: only advance if no deletion\n        else:\n            removeDuplicates(head.next)\n \n    return head\n \n# UTILITY FUNCTIONS\n# Function to insert a node at the\n# beginning of the linked list\n \n \ndef push(head_ref, new_data):\n \n    # allocate node\n    new_node = Node(new_data)\n \n    # put in the data\n    new_node.data = new_data\n \n    # link the old list of the new node\n    new_node.next = head_ref\n \n    # move the head to point to the new node\n    head_ref = new_node\n    return head_ref\n \n# Function to print nodes in a given linked list\n \n \ndef printList(node):\n    while (node != None):\n        print(node.data, end=' ')\n        node = node.next\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Start with the empty list\n    head = None\n \n    # Let us create a sorted linked list\n    # to test the functions\n    # Created linked list will be 11.11.11.13.13.20\n    head = push(head, 20)\n    head = push(head, 13)\n    head = push(head, 13)\n    head = push(head, 11)\n    head = push(head, 11)\n    head = push(head, 11)\n \n    print('Linked list before duplicate removal ',\n          end='')\n    printList(head)\n \n    # Remove duplicates from linked list\n    removeDuplicates(head)\n \n    print('\\nLinked list after duplicate removal ',\n          end='')\n    printList(head)\n \n# This code is contributed by Srathore\n", "# Python3 program to remove duplicates\n# from a sorted linked list\nimport math\n \n# Link list node\n \n \nclass Node:\n \n    def __init__(self, data):\n \n        self.data = data\n        self.next = None\n \n# The function removes duplicates\n# from the given linked list\n \n \ndef removeDuplicates(head):\n \n    # Do nothing if the list consist of\n    # only one element or empty\n    if (head == None and\n            head.next == None):\n        return\n \n    # Construct a pointer\n    # pointing towards head\n    current = head\n \n    # Initialise a while loop till the\n    # second last node of the linkedlist\n    while (current.next):\n \n        # If the data of current and next\n        # node is equal we will skip the\n        # node between them\n        if current.data == current.next.data:\n            current.next = current.next.next\n \n        # If the data of current and\n        # next node is different move\n        # the pointer to the next node\n        else:\n            current = current.next\n \n    return\n \n# UTILITY FUNCTIONS\n# Function to insert a node at the\n# beginning of the linked list\n \n \ndef push(head_ref, new_data):\n \n    # Allocate node\n    new_node = Node(new_data)\n \n    # Put in the data\n    new_node.data = new_data\n \n    # Link the old list of\n    # the new node\n    new_node.next = head_ref\n \n    # Move the head to point\n    # to the new node\n    head_ref = new_node\n \n    return head_ref\n \n# Function to print nodes\n# in a given linked list\n \n \ndef printList(node):\n \n    while (node != None):\n        print(node.data, end=' ')\n        node = node.next\n \n \n# Driver code\nif __name__ == '__main__':\n \n    head = None\n \n    head = push(head, 20)\n    head = push(head, 13)\n    head = push(head, 13)\n    head = push(head, 11)\n    head = push(head, 11)\n    head = push(head, 11)\n \n    print('List before removal of '\n          'duplicates ', end='')\n    printList(head)\n \n    removeDuplicates(head)\n \n    print('\\nList after removal of '\n          'elements ', end='')\n \n    printList(head)\n \n# This code is contributed by MukulTomar\n", "# Python program for the above approach\nclass Node:\n    def __init__(self):\n        self.data = 0\n        self.next = None\n \n# Function to insert a node at\n# the beginning of the linked list\n \n \ndef push(head_ref, new_data):\n \n    # allocate node\n    new_node = Node()\n \n    # put in the data\n    new_node.data = new_data\n \n    # link the old list of the new node\n    new_node.next = (head_ref)\n \n    # move the head to point to the new node\n    head_ref = new_node\n    return head_ref\n \n# Function to print nodes in a given linked list\n \n \ndef printList(node):\n    while (node != None):\n        print(node.data, end=' ')\n        node = node.next\n \n \n# Function to remove duplicates\ndef removeDuplicates(head):\n    track = {}\n    temp = head\n \n    while(temp != None):\n        if (not temp.data in track):\n            print(temp.data, end=' ')\n \n        track[temp.data] = True\n        temp = temp.next\n \n \n# Driver Code\nhead = None\n \n# Created linked list will be 11->11->11->13->13->20\nhead = push(head, 20)\nhead = push(head, 13)\nhead = push(head, 13)\nhead = push(head, 11)\nhead = push(head, 11)\nhead = push(head, 11)\nprint('Linked list before duplicate removal ', end=' ')\nprintList(head)\nprint('\\nLinked list after duplicate removal  ', end=' ')\nremoveDuplicates(head)\n \n# This code is contributed by _Saurabh_jaiswal\n", "# Define a node in a linked list\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n \n \nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        # Return head if it's empty\n        if not head:\n            return head\n \n        # Use set to store unique values in linked list\n        unique_vals = set()\n        curr = head  # Pointer to traverse the linked list\n        prev = None  # Pointer to keep track of the previous node\n \n        # Iterate through the linked list\n        while curr:\n            # If the current value already exists in set, remove the node\n            if curr.val in unique_vals:\n                prev.next = curr.next\n            else:\n                # Otherwise, add the value to set and move on to the next node\n                unique_vals.add(curr.val)\n                prev = curr\n            curr = curr.next\n \n        # Return the head of the linked list\n        return head\n \n \n# Initialize linked list with values 1, 2, 2, 3\nhead = ListNode(1)\nhead.next = ListNode(2)\nhead.next.next = ListNode(2)\nhead.next.next.next = ListNode(2)\nhead.next.next.next.next = ListNode(3)\nhead.next.next.next.next.next = ListNode(3)\nhead.next.next.next.next.next.next = ListNode(3)\n \nBeforePrinter = head\nprint('Before removing duplicates linked list is:')\nwhile BeforePrinter:\n    print(BeforePrinter.val, end=' ')\n    BeforePrinter = BeforePrinter.next\nprint()\n \nsolution = Solution()\n# Remove duplicates from the linked list using the deleteDuplicates function\nhead = solution.deleteDuplicates(head)\n \n# Print the linked list after removing duplicates\nprint('After removing duplicates linked list is:')\ncurr = head\nwhile curr:\n    print(curr.val, end=' ')\n    curr = curr.next\nprint()\n", "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n \n \nclass Solution:\n    def delete_duplicates(self, head: ListNode) -> ListNode:\n \n        # Return head if it's null\n        if not head:\n            return head\n \n        # Use a set to store unique values in the linked list\n        s = set()\n        prev = head  # Keep track of the previous node\n        curr = head.next  # Pointer to traverse the linked list\n \n        # Add the first node to the set\n        s.add(head.val)\n \n        # Iterate through the linked list\n        while curr:\n            # If the current value already exists in set, remove the node\n            if curr.val in s:\n                prev.next = curr.next\n            else:\n                # Otherwise, add the value to set and move on to the next node\n                s.add(curr.val)\n                prev = curr\n \n            curr = curr.next\n \n        # Return the head of the linked list\n        return head\n \n \nif __name__ == '__main__':\n    # Initialize linked list with values 1, 2, 2, 3\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(2)\n    head.next.next.next = ListNode(2)\n    head.next.next.next.next = ListNode(3)\n    head.next.next.next.next.next = ListNode(3)\n    head.next.next.next.next.next.next = ListNode(3)\n \n    solution = Solution()\n \n    Beforeprinter = head\n    print('before removing the duplicates linked list is:', end=' ')\n    while Beforeprinter:\n        print(Beforeprinter.val, end=' ')\n        Beforeprinter = Beforeprinter.next\n    print()\n \n    # Remove duplicates from the linked list using the delete_duplicates function\n    head = solution.delete_duplicates(head)\n \n    # Print the linked list after removing duplicates\n    print('after removing the duplicates linked list is:', end=' ')\n    curr = head\n    while curr:\n        print(curr.val, end=' ')\n        curr = curr.next\n    print()\n"], "Remove every k-th node of the linked list -  ": ["# Python3 program to delete every k-th Node  \n# of a singly linked list. \nimport math \n  \n# Linked list Node  \nclass Node:  \n    def __init__(self, data):  \n        self.data = data  \n        self.next = None\n  \n# To remove complete list (Needed for \n# case when k is 1) \ndef freeList(node): \n    while (node != None): \n        next = node.next\n        node = next\n    return node \n  \n# Deletes every k-th node and  \n# returns head of modified list. \ndef deleteKthNode(head, k): \n      \n    # If linked list is empty \n    if (head == None): \n        return None\n  \n    if (k == 1): \n        freeList(head) \n        return None\n      \n    # Initialize ptr and prev before  \n    # starting traversal. \n    ptr = head \n    prev = None\n  \n    # Traverse list and delete every k-th node \n    count = 0\n    while (ptr != None): \n          \n        # increment Node count \n        count = count + 1\n  \n        # check if count is equal to k \n        # if yes, then delete current Node \n        if (k == count): \n              \n            # put the next of current Node in \n            # the next of previous Node \n            # delete(prev.next) \n            prev.next = ptr.next\n  \n            # set count = 0 to reach further \n            # k-th Node \n            count = 0\n          \n        # update prev if count is not 0 \n        if (count != 0): \n            prev = ptr \n  \n        ptr = prev.next\n      \n    return head \n  \n# Function to print linked list  \ndef displayList(head): \n    temp = head \n    while (temp != None): \n        print(temp.data, end = ' ') \n        temp = temp.next\n      \n# Utility function to create a new node. \ndef newNode( x): \n    temp = Node(x) \n    temp.data = x \n    temp.next = None\n    return temp \n  \n# Driver Code \nif __name__=='__main__':  \n      \n    # Start with the empty list  \n    head = newNode(1) \n    head.next = newNode(2) \n    head.next.next = newNode(3) \n    head.next.next.next = newNode(4) \n    head.next.next.next.next = newNode(5) \n    head.next.next.next.next.next = newNode(6) \n    head.next.next.next.next.next.next = newNode(7) \n    head.next.next.next.next.next.next.next = newNode(8) \n  \n    k = 3\n    head = deleteKthNode(head, k) \n  \n    displayList(head) \n  \n# This code is contributed by Srathore \n"], "Sort a linked list using insertion sort. We have explained Insertion Sort at Slide 7 of Arrays ( http://www.interviewbit.com/courses/programming/topics/arrays/ ) Insertion Sort Wiki ( http://en.wikipedia.org/wiki/Insertion_sort#Algorithm ) has some details on Insertion Sort as well. Example : Input : 1 -> 3 -> 2 Return 1 -> 2 -> 3": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    \n    def insert(self, a, b):\n        pb, cb = b, b\n        while cb and cb.val < a.val:\n            pb = cb\n            cb = cb.next\n        pb.next = a\n        pb.next.next = cb\n    \n    def insertionSortList(self, A):\n        a, b = A, ListNode(0)\n        \n        while a:\n            temp = a.next\n            self.insert(a, b)\n            a = temp\n        return b.next\n        \n\n\n", "Given a linked list A and a value B, partition it such that all nodes less than B come before nodes greater than or equal to B. You should preserve the original relative order of the nodes in each of the two partitions. Problem Constraints 1 <= |A| <= 106 1 <= A[i], B <= 109 Input Format The first argument of input contains a pointer to the head to the given linked list. The second argument of input contains an integer, B. Output Format Return a pointer to the head of the modified linked list. Example Input Input 1: A = [1, 4, 3, 2, 5, 2] B = 3 Input 2: A = [1, 2, 3, 1, 3] B = 2 Example Output Output 1: [1, 2, 2, 4, 3, 5] Output 2: [1, 1, 2, 3, 3] Example Explanation Explanation 1: [1, 2, 2] are less than B wheread [4, 3, 5] are greater than or equal to B. Explanation 2: [1, 1] are less than B wheread [2, 3, 3] are greater than or equal to B.": "class Solution:\n    # @param {ListNode} head\n    # @param {integer} x\n    # @return {ListNode}\n    def partition(self, head, x):\n        if not head:\n            return None\n\n        less, greaterEqual = ListNode(0), ListNode(0)\n        tempLess, tempGreaterEqual, temp = less, greaterEqual, head\n        while temp:\n            if temp.val < x:\n                tempLess.next = temp\n                tempLess = tempLess.next\n            else:\n                tempGreaterEqual.next = temp\n                tempGreaterEqual = tempGreaterEqual.next\n\n            cur = temp\n            temp = temp.next\n            cur.next = None\n\n        tempLess.next = greaterEqual.next\n        return less.next", "Fast I/O for Competitive Programming -  ": [], "Implementing Generic Graph in Java -  ": [], "Generic Implementation of QuickSort Algorithm in C -  ": [], "Generic Linked List in C -  ": [], "LCA for general or n-ary trees (Sparse Matrix DP approach ) -  ": ["# Python3 program to find LCA of n1 and \n# n2 using one DFS on the Tree \n \n# Maximum number of nodes is 100000 and\n# nodes are numbered from 1 to 100000\nMAXN = 100001\n \ntree = [0] * MAXN\nfor i in range(MAXN):\n    tree[i] = []\n \n# Storing root to node path\npath = [0] * 3\nfor i in range(3):\n    path[i] = [0] * MAXN\n \nflag = False\n \n# Storing the path from root to node\ndef dfs(cur: int, prev: int, pathNumber: int,\n        ptr: int, node: int) -> None:\n             \n    global tree, path, flag\n \n    for i in range(len(tree[cur])):\n        if (tree[cur][i] != prev and not flag):\n \n            # Pushing current node into the path\n            path[pathNumber][ptr] = tree[cur][i]\n             \n            if (tree[cur][i] == node):\n \n                # Node found\n                flag = True\n \n                # Terminating the path\n                path[pathNumber][ptr + 1] = -1\n                return\n \n            dfs(tree[cur][i], cur, pathNumber,\n                ptr + 1, node)\n \n# This Function compares the path from root \n# to 'a' & root to 'b' and returns LCA of \n# a and b. Time Complexity : O(n)\ndef LCA(a: int, b: int) -> int:\n     \n    global flag\n     \n    # Trivial case\n    if (a == b):\n        return a\n \n    # Setting root to be first element \n    # in path\n    path[1][0] = path[2][0] = 1\n \n    # Calculating path from root to a\n    flag = False\n    dfs(1, 0, 1, 1, a)\n \n    # Calculating path from root to b\n    flag = False\n    dfs(1, 0, 2, 1, b)\n \n    # Runs till path 1 & path 2 matches\n    i = 0\n    while (path[1][i] == path[2][i]):\n        i += 1\n \n    # Returns the last matching \n    # node in the paths\n    return path[1][i - 1]\n \ndef addEdge(a: int, b: int) -> None:\n \n    tree[a].append(b)\n    tree[b].append(a)\n \n# Driver code\nif __name__ == '__main__':\n \n    n = 8\n     \n    # Number of nodes\n    addEdge(1, 2)\n    addEdge(1, 3)\n    addEdge(2, 4)\n    addEdge(2, 5)\n    addEdge(2, 6)\n    addEdge(3, 7)\n    addEdge(3, 8)\n \n    print('LCA(4, 7) = {}'.format(LCA(4, 7)))\n    print('LCA(4, 6) = {}'.format(LCA(4, 6)))\n \n# This code is contributed by sanjeev2552\n", "# Sparse Matrix DP approach to find LCA of two nodes\nMAXN = 100000\nlevel = 18\ntree = [[] for _ in range(MAXN)]\ndepth = [0 for _ in range(MAXN)]\nparent = [[-1 for _ in range(level)] for _ in range(MAXN)]\n \n# pre-compute the depth for each node and their\n# first parent(2^0th parent)\n# time complexity : O(n)\n \n \ndef dfs(cur, prev):\n    depth[cur] = depth[prev] + 1\n    parent[cur][0] = prev\n    for i in range(len(tree[cur])):\n        if tree[cur][i] != prev:\n            dfs(tree[cur][i], cur)\n \n# Dynamic Programming Sparse Matrix Approach\n# populating 2^i parent for each node\n# Time complexity : O(nlogn)\n \n \ndef precompute_sparse_matrix(n):\n    for i in range(1, level):\n        for node in range(1, n+1):\n            if parent[node][i-1] != -1:\n                parent[node][i] = parent[parent[node][i-1]][i-1]\n \n# Returning the LCA of u and v\n# Time complexity : O(log n)\n \n \ndef lca(u, v):\n    if depth[v] < depth[u]:\n        u, v = v, u\n    diff = depth[v] - depth[u]\n    # Step 1 of the pseudocode\n    for i in range(level):\n        if (diff >> i) & 1 == 1:\n            v = parent[v][i]\n    # now depth[u] == depth[v]\n    if u == v:\n        return u\n    # Step 2 of the pseudocode\n    for i in range(level-1, -1, -1):\n        if parent[u][i] != parent[v][i]:\n            u = parent[u][i]\n            v = parent[v][i]\n    return parent[u][0]\n \n \ndef add_edge(u, v):\n    tree[u].append(v)\n    tree[v].append(u)\n \n \ndef memset(value):\n    for i in range(MAXN):\n        for j in range(level):\n            parent[i][j] = -1\n \n \n# Driver function\n \nn = 8\nadd_edge(1, 2)\nadd_edge(1, 3)\nadd_edge(2, 4)\nadd_edge(2, 5)\nadd_edge(2, 6)\nadd_edge(3, 7)\nadd_edge(3, 8)\ndepth[0] = 0\n# running dfs and precalculating depth\n# of each node.\ndfs(1, 0)\n# Precomputing the 2^i th ancestor for every node\nprecompute_sparse_matrix(n)\n# calling the LCA function\nprint('LCA(4, 7) = ', lca(4, 7))\nprint('LCA(4, 6) = ', lca(4, 6))\n"], "Isomorphism in N-ary Trees -  ": ["# Python3 program for the above approach\n \n# To create N-ary tree\ntree=dict()\n \n# Function which will accept the root\n# of the tree and its parent (which\n# is initially '-1') and will return\n# the canonical form of the tree\ndef ConvertCanonical(vertex, parent):\n    # In this string vector we will\n    # store canonical form of out\n    # current node and its subtree\n    child=[]\n \n    # Loop to the neighbours of\n    # current vertex\n    for neighbour in tree[vertex] :\n \n        # This is to prevent us from\n        # visiting the parent again\n        if (neighbour == parent):\n            continue\n \n        # DFS call neighbour of our\n        # current vertex & it will\n        # pushback the subtree-structure\n        # of this neighbour into our\n        # child vector.\n        child.append(ConvertCanonical(\n            neighbour, vertex))\n     \n \n    # These opening and closing\n    # brackets are for the\n    # current node\n    s = '('\n \n    # Sorting function will re-order\n    # the structure of subtree of\n    # the current vertex in a\n    # shortest-subtree-first manner.\n    # Hence we can\n    # now compare the two tree\n    # structures effectively\n    child.sort()\n \n    for j in child:\n        s += j\n \n    # Append the subtree structure\n    # and enclose it with '(' <subtree>\n    # ')' the opening and closing\n    # brackets of current vertex\n    s += ')'\n \n    # return the subtree-structure\n    # of our Current vertex\n    return s\n \n \n# Function to add edges\ndef addedge(a, b):\n    if a in tree:\n        tree[a].append(b)\n    else:\n        tree[a]=[b,]\n    if b in tree:\n        tree[b].append(a)\n    else:\n        tree[b]=[a,]\n \n \n# Driver code\nif __name__=='__main__':\n    # Given N-ary Tree 1\n    addedge(1, 3)\n    addedge(1, 2)\n    addedge(1, 5)\n    addedge(3, 4)\n    addedge(4, 8)\n    addedge(4, 9)\n    addedge(3, 6)\n    addedge(6, 7)\n \n    # Function Call to convert Tree 1\n    # into canonical with 3 is the root\n    # and the parent of root be '-1'\n    tree1 = ConvertCanonical(3, -1)\n \n    # Clearing our current tree\n    # before taking input of\n    # next tree\n    tree.clear()\n \n    # Given N-ary Tree 2\n    addedge(1, 3)\n    addedge(3, 4)\n    addedge(3, 5)\n    addedge(1, 8)\n    addedge(8, 9)\n    addedge(1, 2)\n    addedge(2, 6)\n    addedge(2, 7)\n \n    # Function Call to convert Tree 2\n    # into canonical\n    tree2 = ConvertCanonical(1, -1)\n \n    # Check if canonical form of both\n    # tree are equal or not\n    if (tree1 == tree2):\n        print('YES')\n    else:\n        print('NO')\n"], "DP on Trees | Set-3 ( Diameter of N-ary Tree ) -  ": ["# Python3 program to find diameter \n# of a tree using DFS. \n \n# Function to find the diameter of the \n# tree using Dynamic Programming \ndef dfs(node, parent, dp1, dp2, adj): \n \n    # Store the first maximum and secondmax \n    firstmax, secondmax = -1, -1\n \n    # Traverse for all children of node \n    for i in adj[node]: \n        if i == parent: \n            continue\n \n        # Call DFS function again \n        dfs(i, node, dp1, dp2, adj) \n \n        # Find first max \n        if firstmax == -1: \n            firstmax = dp1[i] \n         \n        elif dp1[i] >= firstmax: # Secondmaximum \n            secondmax = firstmax \n            firstmax = dp1[i] \n         \n        elif dp1[i] > secondmax: # Find secondmaximum \n            secondmax = dp1[i] \n \n    # Base case for every node \n    dp1[node] = 1\n    if firstmax != -1: # Add \n        dp1[node] += firstmax \n \n    # Find dp[2] \n    if secondmax != -1:\n        dp2[node] = 1 + firstmax + secondmax \n    diameter = max(diameter, max(dp1[node], dp2[node]));\n    # Return maximum of both \n    return max(dp1[node], dp2[node]) \n \n# Driver Code \nif __name__ == '__main__':\n \n    n, diameter = 5, -1\n \n    adj = [[] for i in range(n + 1)]\n     \n    # create undirected edges\n    adj[1].append(2) \n    adj[2].append(1) \n    adj[1].append(3) \n    adj[3].append(1) \n    adj[2].append(4) \n    adj[4].append(2) \n    adj[2].append(5) \n    adj[5].append(2) \n \n    dp1 = [0] * (n + 1) \n    dp2 = [0] * (n + 1) \n     \n    # Find diameter by calling function \n    dfs(1, 1, dp1, dp2, adj)\n    print('Diameter of the given tree is',\n                diameter )\n \n# This code is contributed by Rituraj Jain \n"], "Remove all leaf nodes from a Generic Tree or N-ary Tree -  ": ["# Python program to delete the\n# leaf from the generic tree\n \n# a treenode class\nclass TreeNode:\n    def __init__(self, data):\n        self.data = data\n        self.children = []\n \n# Recursive function which delete\n# the leaf from tree\ndef removeLeaf(root):\n    if(root==None): return None #if root is None return None\n    if(len(root.children)==0):return None #if root itself is leaf return None\n    # if root.children is a leaf node\n    # then delete it from children vector\n    i = 0\n    while i < len(root.children):\n        child = root.children[i]\n \n        # if it is  a leaf\n        if (len(child.children) == 0):\n \n            # shifting the vector to left\n            # after the point i\n            for j in range(i, len(root.children) - 1):\n                root.children[j] = root.children[j + 1]\n \n            # delete the last element\n            root.children.pop()\n            i -= 1\n        i += 1\n \n    # Remove all leaf node\n    # of children of root\n    for i in range(len(root.children)):\n \n        # call function for root.children\n        root.children[i]=removeLeaf(root.children[i])\n    return root\n# Function which will print the\n# tree level wise\ndef printTheTree(root):\n    if (root == None):\n        return\n    print('{} :'.format(root.data), end='')\n    for i in range(len(root.children)):\n        print('{} '.format(root.children[i].data), end='')\n    print()\n    for i in range(len(root.children)):\n        printTheTree(root.children[i])\n \n# Driver code\nif __name__ == '__main__':\n \n    #         5\n    #      / / \\ \\\n    #    1  2  3  8\n    #   /   /\\  \\\n    #  15  4  5  6\n \n    root = TreeNode(5)\n    child1 = TreeNode(1)\n    root.children.append(child1)\n    child11 = TreeNode(15)\n    child1.children.append(child11)\n    child2 = TreeNode(2)\n    root.children.append(child2)\n    child21 = TreeNode(4)\n    child22 = TreeNode(5)\n    child2.children.append(child21)\n    child2.children.append(child22)\n    child3 = TreeNode(3)\n    root.children.append(child3)\n    child31 = TreeNode(6)\n    child3.children.append(child31)\n    child4 = TreeNode(8)\n    root.children.append(child4)\n \n    root=removeLeaf(root)\n    printTheTree(root)\n \n# This code is contributed by sanjeev2552\n"], "Replace every node with depth in N-ary Generic Tree -  ": ["# Python code for the above approach\nfrom typing import List, Tuple\n \n# TreeNode class\nclass TreeNode:\n   \n    # To store node value\n    data: int\n     \n    # List of TreeNode to store\n    # the child nodes\n    children: List['TreeNode']\n \n    # Constructor to assign data to node\n    def __init__(self, data: int):\n        self.data = data\n        self.children = []\n \n# Function to take input level wise\n# i.e., in level order traversal\ndef take_input_level_wise(arr: List[int]) -> TreeNode:\n    idx = 1\n     \n    # Input root\n    root_data = arr[0]\n     \n    # Initialize tree with a root node\n    root = TreeNode(root_data)\n     \n    # Initialize queue for appending\n    # node as a child of parent in\n    # N-ary tree\n    pending_nodes = [root]\n     \n    # While queue is not empty append\n    # child to the node\n    while pending_nodes:\n       \n        # Take the first node\n        front = pending_nodes[0]\n        pending_nodes = pending_nodes[1:]\n         \n        # Input number of its child\n        num_child = arr[idx]\n        idx += 1\n        for i in range(num_child):\n            child_data = arr[idx]\n            idx += 1\n             \n            # Make child Node\n            child = TreeNode(child_data)\n             \n            # Append child node to\n            # it's parent\n            front.children.append(child)\n            pending_nodes.append(child)\n    return root\n \n# Function to print each node data\n# in level order\ndef print_level_at_new_line(root: TreeNode):\n    q = [root]\n    q.append(None)\n    while q:\n        first = q[0]\n        q = q[1:]\n        if first is None:\n           \n            # If there is no more nodes\n            if not q:\n                break\n                 \n            # All the nodes of current level are\n            # visited\n            print()\n            q.append(None)\n            continue\n        print(first.data, end=' ')\n         \n        # Append current node's child to queue\n        for i in range(len(first.children)):\n            q.append(first.children[i])\n \n# Helper function to replace the\n# node data with their level value\ndef helper(root: TreeNode, depth: int):\n   \n    # Replace the node data with\n    # it's depth\n    root.data = depth\n    for i in range(len(root.children)):\n        helper(root.children[i], depth + 1)\n \n# Function to replace with depth\ndef replace_with_depth_value(root: TreeNode):\n    helper(root, 0)\n \n \n# Driver Code\nif __name__ == '__main__':\n   \n    # Given level order traversal in\n    # the array arr[]\n    arr = [10, 3, 20, 30, 40, 2, 40, 50, 0, 0, 0, 0]\n \n    # Initialise Tree\n    root = take_input_level_wise(arr)\n \n    # Function call to replace with\n    # depth value\n    replace_with_depth_value(root)\n \n    # Print the tree in level order\n    print_level_at_new_line(root)\n     \n# This code is contributed by Potta Lokesh\n", "# Python code\n \n# TreeNode class\nclass TreeNode:\n  # To store node value\n  def __init__(self, data):\n    self.data = data\n    # List of TreeNode to store\n    # the child nodes\n    self.children = []\n \n# Function to take input level wise\n# i.e., in level order traversal and\n# assign value of node equal to its depth\ndef takeInputLevelWise(arr):\n  idx = 1\n  depthLevel = 1\n   \n  # Initialize tree with a root node\n  # with depth 0\n  root = TreeNode(0)\n  \n  # Initialize queue for appending\n  # node as a child of parent in\n  # N-ary tree\n  pendingNodes = []\n  pendingNodes.append(root)\n \n  # While queue is not empty append\n  # child to the node\n  while pendingNodes:\n    # Number of nodes present in the current level\n    size = len(pendingNodes)\n \n    while size > 0:\n      front = pendingNodes[0]\n      pendingNodes.pop(0)\n \n      # Input number of child\n      numChild = arr[idx]\n      idx += 1\n      for i in range(numChild):\n        idx += 1\n \n        # Make child Node and assign its data\n        # value equal to depthLevel\n        child = TreeNode(depthLevel)\n \n        # Append child node to\n        # it's parent\n        front.children.append(child)\n        pendingNodes.append(child)\n      size -= 1\n    # Increment depth level\n    depthLevel += 1\n  return root\n \n# Function to print each node data\n# in level order\ndef printLevelATNewLine(root):\n  q = []\n  q.append(root)\n  q.append(None)\n  while q:\n    first = q[0]\n    q.pop(0)\n    if first is None:\n      # If there is no more nodes to visit\n      if not q:\n        break\n      # All the nodes of current level are\n      # visited\n      print()\n      q.append(None)\n      continue\n    print(first.data, end=' ')\n \n    # Append current node's child to queue\n    for i in range(len(first.children)):\n      q.append(first.children[i])\n \n# Driver Code\nif __name__ == '__main__':\n  # Given level order traversal in\n  # the array arr[]\n  arr = [10, 3, 20, 30, 40, 2, 40, 50, 0, 0, 0, 0]\n \n  # Initialize Tree\n  root = takeInputLevelWise(arr)\n \n  # Function call to print\n  # in level order\n  printLevelATNewLine(root)\n"], "Check if given Generic N-ary Tree is Symmetric horizontally -  ": ["# Python code for the above approach\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n \n# Preorder traversal to check\n# if the generic tree\n# is symmetric or not\ndef preorder(root1, root2):\n \n        # If the values of both the\n        # root is not the same or if\n        # the number of children are\n        # not the same then return false\n    if (root1.val != root2.val or len(root1.children) != len(root2.children)):\n        return False\n \n    # Number of children\n    size = len(root1.children)\n \n    # Iterate left to right on\n    # left root and right to left\n    # on the right root\n \n    for i in range(0, (size + 1)//2):\n        # If any one branch is not\n        # symmetric then return false\n        if (preorder(root1.children[i],\n                     root2.children[size - 1 - i]) == False):\n            return False\n \n    # Tree is symmetric return true\n    return True\n \n# Function to check if the generic\n# tree is symmetric or not\ndef isSymmetric(root):\n \n    # Base case\n    if (root == None):\n        return True\n \n    # Apply preorder traversal\n    # on the tree\n    return preorder(root, root)\n \n# Driver code\n# Initialize the tree\nseven = Node(7)\nfive1 = Node(5)\nfive2 = Node(5)\nfour = Node(4)\nseven.children.append(five1)\nseven.children.append(four)\nseven.children.append(five2)\n \n# Call the function\n# and print the result\nif (isSymmetric(seven)):\n    print('True')\nelse:\n    print('False')\n \n    # This code is contributed by rj13to.\n"], "General Tree (Each node can have arbitrary number of children) Level Order Traversal -  ": ["# Python3 program to do level order traversal\n# of a generic tree\n  \n# Represents a node of an n-ary tree\nclass Node:\n     \n    def __init__(self, key):\n         \n        self.key = key\n        self.child = []\n   \n # Utility function to create a new tree node\ndef newNode(key):    \n    temp = Node(key)\n    return temp\n     \n# Prints the n-ary tree level wise\ndef LevelOrderTraversal(root):\n \n    if (root == None):\n        return;\n   \n    # Standard level order traversal code\n    # using queue\n    q = []  # Create a queue\n    q.append(root); # Enqueue root \n    while (len(q) != 0):\n     \n        n = len(q);\n  \n        # If this node has children\n        while (n > 0):\n         \n            # Dequeue an item from queue and print it\n            p = q[0]\n            q.pop(0);\n            print(p.key, end=' ')\n   \n            # Enqueue all children of the dequeued item\n            for i in range(len(p.child)):\n             \n                q.append(p.child[i]);\n            n -= 1\n   \n        print() # Print new line between two levels\n      \n# Driver program\nif __name__=='__main__':\n     \n    '''   Let us create below tree\n                  10\n            /   /    \\   \\\n            2  34    56   100\n           / \\         |   /  | \\\n          77  88       1   7  8  9\n    '''\n    root = newNode(10);\n    (root.child).append(newNode(2));\n    (root.child).append(newNode(34));\n    (root.child).append(newNode(56));\n    (root.child).append(newNode(100));\n    (root.child[0].child).append(newNode(77));\n    (root.child[0].child).append(newNode(88));\n    (root.child[2].child).append(newNode(1));\n    (root.child[3].child).append(newNode(7));\n    (root.child[3].child).append(newNode(8));\n    (root.child[3].child).append(newNode(9));\n   \n    print('Level order traversal Before Mirroring')\n    LevelOrderTraversal(root);\n \n    # This code is contributed by rutvik_56.\n"], "Height of a generic tree from parent array -  ": ["# Python3 code to find height \n# of N-ary tree in O(n)\nfrom collections import deque\n \nMAX = 1001\n \n# Adjacency list to\n# store N-ary tree\nadj = [[] for i in range(MAX)]\n \n# Build tree in tree in O(n)\ndef build_tree(arr, n):\n   \n    root_index = 0\n \n    # Iterate for all nodes\n    for i in range(n):\n \n        # if root node, store \n        # index\n        if (arr[i] == -1):\n            root_index = i\n        else:\n            adj[i].append(arr[i])\n            adj[arr[i]].append(i)\n \n    return root_index\n \n# Applying BFS\ndef BFS(start):\n   \n    # map is used as visited \n    # array\n    vis = {}\n \n    q = deque()\n    max_level_reached = 0\n \n    # height of root node is \n    # zero\n    q.append([start, 0])\n \n    # p.first denotes node in \n    # adjacency list\n    # p.second denotes level of \n    # p.first\n    p = []\n \n    while (len(q) > 0):\n        p = q.popleft()\n        vis[p[0]] = 1\n \n        # store the maximum level \n        # reached\n        max_level_reached = max(max_level_reached,\n                                p[1])\n \n        for i in range(len(adj[p[0]])):\n \n            # adding 1 to previous level\n            # stored on node p.first\n            # which is parent of node \n            # adj[p.first][i]\n            # if adj[p.first][i] is not visited\n            if (adj[p[0]][i] not in vis ):\n                q.append([adj[p[0]][i],\n                          p[1] + 1])\n \n    return max_level_reached\n \n# Driver code\nif __name__ == '__main__':\n   \n    # node 0 to node n-1\n    parent = [-1, 0, 1, 2, 3]\n \n    # Number of nodes in tree\n    n = len(parent)\n \n    root_index = build_tree(parent, n)\n    ma = BFS(root_index)\n    print('Height of N-ary Tree=',\n          ma)\n \n# This code is contributed by Mohit Kumar 29\n", "# Python3 code to find height of N-ary \n# tree in O(n) (Efficient Approach) \n \n# Recur For Ancestors of node and \n# store height of node at last \ndef fillHeight(p, node, visited, height):\n     \n    # If root node \n    if (p[node] == -1): \n \n        # mark root node as visited \n        visited[node] = 1\n        return 0\n \n    # If node is already visited \n    if (visited[node]): \n        return height[node] \n \n    # Visit node and calculate its height \n    visited[node] = 1\n \n    # recur for the parent node \n    height[node] = 1 + fillHeight(p, p[node], \n                                  visited, height) \n \n    # return calculated height for node \n    return height[node]\n \ndef findHeight(parent, n):\n     \n    # To store max height \n    ma = 0\n \n    # To check whether or not node is \n    # visited before \n    visited = [0] * n\n \n    # For Storing Height of node \n    height = [0] * n \n \n    for i in range(n):\n \n        # If not visited before \n        if (not visited[i]):\n            height[i] = fillHeight(parent, i,\n                                   visited, height) \n \n        # store maximum height so far \n        ma = max(ma, height[i])\n \n    return ma\n \n# Driver Code\nif __name__ == '__main__':\n \n    parent = [-1, 0, 0, 0, 3, 1, 1, 2] \n    n = len(parent)\n \n    print('Height of N-ary Tree =',\n             findHeight(parent, n))\n \n# This code is contributed by PranchalK\n"], "How do Dynamic arrays work? -  ": ["# Python 3 program deals with all operation of a dynamic array\n# add, remove, resize memory of array is the main feature\n \n \nclass DynamicArray:\n \n    # create three variable array[] is a array,\n    # count will deal with no of element add by you and\n    # size will with size of array[]\n    array = None\n    count = 0\n    size = 0\n \n    # constructor initialize value to variable\n    def __init__(self):\n        self.array = [0] * (1)\n        self.count = 0\n        self.size = 1\n \n    # function add an element at the end of array\n    def add(self, data):\n \n        # check no of element is equal to size of array\n        if (self.count == self.size):\n            self.growSize()\n \n        # insert element at end of array\n        self.array[self.count] = data\n        self.count += 1\n \n    # function makes size double of array\n    def growSize(self):\n        temp = None\n        if (self.count == self.size):\n \n            # temp is a double size array of array\n            # and store array elements\n            temp = [0] * (self.size * 2)\n            i = 0\n            while (i < self.size):\n \n                # copy all array value into temp\n                temp[i] = self.array[i]\n                i += 1\n \n        # double size array temp initialize\n        # into variable array again\n        self.array = temp\n \n        # and make size is double also of array\n        self.size = self.size * 2\n \n    # function shrink size of array\n    # which block unnecessary remove them\n    def shrinkSize(self):\n        temp = None\n        if (self.count > 0):\n \n            # temp is a count size array\n            # and store array elements\n            temp = [0] * (self.count)\n            i = 0\n            while (i < self.count):\n \n                # copy all array value into temp\n                temp[i] = self.array[i]\n                i += 1\n            self.size = self.count\n \n            # count size array temp initialize\n            # into variable array again\n            self.array = temp\n \n    # function add an element at given index\n    def addAt(self, index,  data):\n \n        # if size is not enough make size double\n        if (self.count == self.size):\n            self.growSize()\n        i = self.count - 1\n        while (i >= index):\n \n            # shift all element right\n            # from given index\n            self.array[i + 1] = self.array[i]\n            i -= 1\n \n        # insert data at given index\n        self.array[index] = data\n        self.count += 1\n \n    # function remove last element or put\n    # zero at last index\n    def remove(self):\n        if (self.count > 0):\n            self.array[self.count - 1] = 0\n            self.count -= 1\n    # function shift all element of right\n    # side from given index in left\n \n    def removeAt(self, index):\n        if (self.count > 0):\n            i = index\n            while (i < self.count - 1):\n \n                # shift all element of right\n                # side from given index in left\n                self.array[i] = self.array[i + 1]\n                i += 1\n            self.array[self.count - 1] = 0\n            self.count -= 1\n \n    @staticmethod\n    def main(args):\n        da = DynamicArray()\n \n        # add 9 elements in array\n        da.add(1)\n        da.add(2)\n        da.add(3)\n        da.add(4)\n        da.add(5)\n        da.add(6)\n        da.add(7)\n        da.add(8)\n        da.add(9)\n \n        # print all array elements after add 9 elements\n        print('Elements of array:')\n        i = 0\n        while (i < da.size):\n            print(str(da.array[i]) + ' ', end='')\n            i += 1\n        print()\n \n        # print size of array and no of element\n        print('Size of array: ' + str(da.size))\n        print('No of elements in array: ' + str(da.count))\n \n        # shrinkSize of array\n        da.shrinkSize()\n \n        # print all array elements\n        print('Elements of array after shrinkSize of array:')\n        i = 0\n        while (i < da.size):\n            print(str(da.array[i]) + ' ', end='')\n            i += 1\n        print()\n \n        # print size of array and no of element\n        print('Size of array: ' + str(da.size))\n        print('No of elements in array: ' + str(da.count))\n \n        # add an element at index 1\n        da.addAt(1, 22)\n \n        # print Elements of array after adding an\n        # element at index 1\n        print('Elements of array after add an element at index 1:')\n        i = 0\n        while (i < da.size):\n            print(str(da.array[i]) + ' ', end='')\n            i += 1\n        print()\n \n        # print size of array and no of element\n        print('Size of array: ' + str(da.size))\n        print('No of elements in array: ' + str(da.count))\n \n        # delete last element\n        da.remove()\n \n        # print Elements of array after delete last\n        # element\n        print('Elements of array after delete last element:')\n        i = 0\n        while (i < da.size):\n            print(str(da.array[i]) + ' ', end='')\n            i += 1\n        print()\n \n        # print size of array and no of element\n        print('Size of array: ' + str(da.size))\n        print('No of elements in array: ' + str(da.count))\n \n        # delete element at index 1\n        da.removeAt(1)\n \n        # print Elements of array after delete\n        # an element index 1\n        print('Elements of array after delete element at index 1:')\n        i = 0\n        while (i < da.size):\n            print(str(da.array[i]) + ' ', end='')\n            i += 1\n        print()\n \n        # print size of array and no of element\n        print('Size of array: ' + str(da.size))\n        print('No of elements in array: ' + str(da.count))\n \n \n# Driver code\nif __name__ == '__main__':\n    DynamicArray.main([])\n \n    # This code is contributed by aadityaburujwale.\n"], "Queries to calculate Bitwise OR of each subtree of a given node in an N-ary Tree -  ": ["# Python3 program for the above approach\n  \n# Maximum Number of nodes\nN = 100005;\n  \n# Adjacency list\nadj = [[] for i in range(N)];\n  \n# Stores Bitwise OR of each node\nanswer = [0 for i in range(N)]\n  \n# Function to add edges to the Tree\ndef addEdgesToGraph(Edges, N):\n \n    # Traverse the edges\n    for i in range(N - 1):\n     \n        u = Edges[i][0];\n        v = Edges[i][1];\n  \n        # Add edges\n        adj[u].append(v);\n        adj[v].append(u);\n     \n# Function to perform DFS\n# Traversal on the given tree\ndef DFS(node, parent, Val):\n \n    # Initialize answer with bitwise\n    # OR of current node\n    answer[node] = Val[node];\n  \n    # Iterate over each child\n    # of the current node\n    for child in adj[node]:\n     \n        # Skip parent node\n        if (child == parent):\n            continue;\n  \n        # Call DFS for each child\n        DFS(child, node, Val);\n  \n        # Taking bitwise OR of the\n        # answer of the child to\n        # find node's OR value\n        answer[node] = (answer[node]\n                        | answer[child]);\n     \n# Function to call DFS from the'=\n# root for precomputing answers\ndef preprocess( Val):\n \n    DFS(1, -1, Val);\n \n# Function to calculate and print\n# the Bitwise OR for Q queries\ndef findSubtreeOR(Queries, Q, Val):\n \n    # Perform preprocessing\n    preprocess(Val);\n  \n    # Iterate over each given query\n    for i in range(Q):\n         \n        print(answer[Queries[i]], end=' ')\n   \n# Utility function to find and\n# print bitwise OR for Q queries\ndef findSubtreeORUtil( N, Edges, Val, Queries, Q):\n \n    # Function to add edges to graph\n    addEdgesToGraph(Edges, N);\n  \n    # Function call\n    findSubtreeOR(Queries, Q, Val);\n  \n# Driver Code\nif __name__=='__main__':\n     \n    # Number of nodes\n    N = 5;\n    Edges = [ [ 1, 2 ], [ 1, 3 ], [ 3, 4 ], [ 3, 5 ] ];\n  \n    Val = [ 0, 2, 3, 4, 8, 16 ];\n    Queries = [ 2, 3, 1 ];\n  \n    Q = len(Queries)\n  \n    # Function call\n    findSubtreeORUtil(N, Edges, Val,Queries, Q);\n \n    # This code is contributed by rutvik_56\n"], "Count of ancestors with smaller value for each node of an N-ary Tree -  ": ["# Python program for the above approach\nimport collections\nimport functools\n \n# Declaring ordered_set\n@functools.total_ordering\nclass ordered_set:\n    def __init__(self):\n        self.tree = collections.defaultdict(set)\n \n    def insert(self, val):\n        self.tree[val] = set()\n \n    def __le__(self, other):\n        return self.tree.keys() <= other.tree.keys()\n \n    def __eq__(self, other):\n        return self.tree.keys() == other.tree.keys()\n \n    def order_of_key(self, val):\n        return len([k for k in self.tree.keys() if k < val])\n \n    def erase(self, val):\n        del self.tree[val]\n \n# Map to store final ans for each node\nans = {}\n \n# Function to add an edge\n# between nodes u and v\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n \n# Function to count the number of\n# ancestors with values smaller\n# than that of the current node\ndef countSmallerAncestors(adj, root, par, ancestors):\n    # Map current node to\n    # number of smaller valued ancestors\n    ans[root] = ancestors.order_of_key(root)\n \n    # Add current node to path\n    ancestors.insert(root)\n    for node in adj[root]:\n        # Avoid cycles\n        if node != par:\n            countSmallerAncestors(\n                adj, node,\n                root, ancestors)\n \n    # Remove current node from path\n    ancestors.erase(root)\n \n# Driver Code\nif __name__ == '__main__':\n    # Number of nodes in graph\n    N = 7\n \n    # Initialize graph\n    adj = {i:[] for i in range(1,N+1)}\n \n    # Tree Formation\n    addEdge(adj, 1, 5)\n    addEdge(adj, 1, 4)\n    addEdge(adj, 4, 6)\n    addEdge(adj, 5, 3)\n    addEdge(adj, 5, 2)\n    addEdge(adj, 5, 7)\n \n    # Ordered set to store values in path\n    # from root to current node in dfs\n    ancestors = ordered_set()\n \n    countSmallerAncestors(adj, 1, -1, ancestors)\n \n    for i in range(1, N+1):\n        print(ans[i], end=' ')\n \n# # This code is contributed by Vikram_Shirsat\n"], "Minimize operations to convert each node of N-ary Tree from initial[i] to final[i] by flipping current node subtree in alternate fashion -  ": ["# Python3 program for the above approach\n \n# Create adjacency list\nN = 3\nadj = []\nfor i in range(N + 1):\n    adj.append([])\n  \nvisited = []\nans = 0\n  \n# Function to add an edges in graph\ndef addEdges(u, v):\n    global adj\n    adj[u].append(v)\n    adj[v].append(u)\n  \n# Function to perform the DFS of graph\n# recursively from a given vertex u\ndef DFSUtil(u, foo, foo1, initial, finall):\n    global visited, ans, adj\n    visited[u] = True\n \n    # Check for the condition for the\n    # flipping of node's initial value\n    if ((initial[u - 1] ^ foo) ^ finall[u - 1] == True):\n        ans+=1\n        foo ^= True\n \n    # Traverse all the children of the\n    # current source node u\n    for i in range(len(adj[u])):\n        # Swap foo and foo1 signifies\n        # there is change of level\n        if (visited[adj[u][i]] == False):\n            DFSUtil(adj[u][i], foo1, foo, initial, finall)\n \n# Function to perform the DFSUtil()\n# for all the unvisited vertices\ndef DFS(V, initial, finall):\n    global ans, visited\n    ans = 0\n    visited = [False]*V\n \n    # Traverse the given set of nodes\n    for u in range(1, 2):\n        # If the current node is\n        # unvisited\n        if (visited[u] == False):\n            DFSUtil(u, 0, 0, initial, finall)\n \n    # Print the number of operations\n    print(ans)\n  \n# Function to count the number of\n# flips required to change initial\n# node values to final node value\ndef countOperations(N, initial, finall, Edges):\n    # Add the given edges\n    for i in range(N - 1):\n        addEdges(Edges[i][0], Edges[i][1])\n \n    # DFS Traversal\n    DFS(N + 1, initial, finall)\n \nEdges = [ [ 1, 2 ], [ 1, 3 ] ]\ninitial = [ True, True, False ]\nfinall = [ False, True, True]\ncountOperations(N, initial, finall, Edges)\n \n# This code is contributed by rameshtravel07.\n"], "Construct the full k-ary tree from its preorder traversal -  ": ["# Python3 program to build full k-ary tree \n# from its preorder traversal and to print the \n# postorder traversal of the tree. \nfrom math import ceil, log\n \n# Utility function to create a new \n# tree node with k children \nclass newNode:\n    def __init__(self, value):\n        self.key = value\n        self.child = []\n \n# Function to build full k-ary tree \ndef BuildkaryTree(A, n, k, h, ind):\n     \n    # For None tree \n    if (n <= 0):\n        return None\n \n    nNode = newNode(A[ind[0]]) \n    if (nNode == None): \n        print('Memory error') \n        return None\n \n    # For adding k children to a node\n    for i in range(k):\n \n        # Check if ind is in range of array \n        # Check if height of the tree is \n        # greater than 1 \n        if (ind[0] < n - 1 and h > 1): \n            ind[0] += 1\n \n            # Recursively add each child \n            nNode.child.append(BuildkaryTree(A, n, k,\n                                             h - 1, ind))\n        else: \n            nNode.child.append(None)\n    return nNode\n \n# Function to find the height of the tree \ndef BuildKaryTree(A, n, k, ind):\n    height = int(ceil(log(float(n) * (k - 1) + 1) /\n                                      log(float(k)))) \n    return BuildkaryTree(A, n, k, height, ind)\n \n# Function to print postorder traversal\n# of the tree \ndef postord(root, k):\n    if (root == None):\n        return\n    for i in range(k):\n        postord(root.child[i], k) \n    print(root.key, end = ' ')\n \n# Driver Code\nif __name__ == '__main__':\n    ind = [0] \n    k = 3\n    n = 10\n    preorder = [ 1, 2, 5, 6, 7, 3, 8, 9, 10, 4] \n    root = BuildKaryTree(preorder, n, k, ind) \n    print('Postorder traversal of constructed', \n                        'full k-ary tree is: ') \n    postord(root, k)\n     \n# This code is contributed by pranchalK\n"], "Number of leaf nodes in the subtree of every node of an n-ary tree -  ": ["# Python3 program to print the number of\n# leaf nodes of every node\nadjacency = [[] for i in range(100)]\n \n# Function to insert edges of tree\ndef insert(x, y):\n    adjacency[x].append(y)\n \n# Function to run DFS on a tree\ndef dfs(node, leaf, vis):\n \n    leaf[node] = 0\n    vis[node] = 1\n \n    # iterate on all the nodes\n    # connected to node\n    for it in adjacency[node]:\n \n        # If not visited\n        if (vis[it] == False):\n            dfs(it, leaf, vis)\n            leaf[node] += leaf[it]\n \n    if (len(adjacency[node]) == 0):\n        leaf[node] = 1\n \n# Function to print number of\n# leaf nodes of a node\ndef printLeaf(n, leaf):\n     \n    # Function to print leaf nodes\n    for i in range(1, n + 1):\n        print('The node', i, 'has',  \n               leaf[i], 'leaf nodes')\n \n# Driver Code\n \n# Given N-ary Tree\n'''\n/*     1\n    / \\\n    2     3\n        / | \\\n        4 5 6 '''\n \nN = 6 # no of nodes\n# adjacency list for tree\n \ninsert(1, 2)\ninsert(1, 3)\ninsert(3, 4)\ninsert(3, 5)\ninsert(3, 6)\n \n# Store count of leaf in subtree of i\nleaf = [0 for i in range(N + 1)] \n \n# mark nodes visited\nvis = [0 for i in range(N + 1)] \n \ndfs(1, leaf, vis)\n \nprintLeaf(N, leaf)\n \n# This code is contributed by Mohit Kumar\n"], "Minimum valued node having maximum depth in an N-ary Tree -  ": ["# Python3 implementation of for\n# the above problem\nMAX = 100000\n  \ngraph = [[] for i in range(MAX + 1)]\n  \n# To store the height of each node\nmaxHeight = 0\nminNode = 0\n  \n# Function to perform dfs\ndef dfs(node, parent, h):\n     \n    global minNode, maxHeight\n     \n    # Store the height of node\n    height = h\n  \n    if (height > maxHeight):\n        maxHeight = height\n        minNode = node\n     \n    elif (height == maxHeight and\n          minNode > node):\n        minNode = node\n     \n    for to in graph[node]:\n        if to == parent:\n            continue\n         \n        dfs(to, node, h + 1)\n         \n# Driver code\nif __name__=='__main__':\n     \n    # Number of nodes\n    N = 5\n  \n    # Edges of the tree\n    graph[1].append(2)\n    graph[1].append(3)\n    graph[2].append(4)\n    graph[2].append(5)\n  \n    maxHeight = 0\n    minNode = 1\n  \n    dfs(1, 1, 0)\n     \n    print(minNode)\n \n# This code is contributed by rutvik_56\n"], "Largest subtree sum for each vertex of given N-ary Tree -  ": ["# Python3 program for the above approach\n \nV = 3\nM = 2\n \n# Function to perform the DFS\n# Traversal on the given Tree\ndef dfs(v, p):\n \n    # To check if v is leaf vertex\n    isLeaf = 1\n \n    # Initialize answer for vertex v\n    ans[v] = -10**9\n \n    # Traverse adjacency list of v\n    for u in adj[v]:\n        if (u == p):\n            continue\n \n        isLeaf = 0\n        dfs(u, v)\n \n        # Update maximum subtree sum\n        ans[v] = max(ans[u] + vals[v],max(ans[u], vals[u]))\n \n    # If v is leaf\n    if (isLeaf):\n        ans[v] = vals[v]\n \n# Function to calculate maximum\n# subtree sum for each vertex\ndef printAnswer(n, edges, vals):\n \n    # Stores the adjacency list\n    # vector<int> adj[n];\n \n    # Add Edges to the list\n    for i in range(n - 1):\n        u = edges[i][0] - 1\n        v = edges[i][1] - 1\n \n        adj[u].append(v)\n        adj[v].append(u)\n \n    # Calculate answer\n    dfs(0, -1)\n \n    # Print the result\n    for x in ans:\n        print(x, end=' ')\n \n# Driver Code\nif __name__ == '__main__':\n \n    # Given nodes\n    N = 4\n \n    # Give N edges\n    edges=[ [ 1, 2],\n            [ 1, 3],\n            [ 3, 4] ]\n \n    adj=[[] for i in range(N)]\n    ans=[0 for i in range(N)]\n \n    # Given values\n    vals=[1, -1, 0, 1]\n \n    # Function Call\n    printAnswer(N, edges, vals)\n \n# This code is contributed by mohit kumar 29\n"], "Convert a Generic Tree(N-array Tree) to Binary Tree -  ": ["class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.children = []\n \n \ndef convert(root):\n    if not root:\n        return None\n \n    if len(root.children) == 0:\n        return root\n \n    if len(root.children) == 1:\n        root.left = convert(root.children[0])\n        return root\n \n    root.left = convert(root.children[0])\n    root.right = convert(root.children[1])\n \n    for i in range(2, len(root.children)):\n        rightTreeRoot = root.right\n        while rightTreeRoot.left != None:\n            rightTreeRoot = rightTreeRoot.left\n        rightTreeRoot.left = convert(root.children[i])\n \n    return root\n \n \ndef printTree(root):\n    if not root:\n        return\n    print(root.val, end=' ')\n    printTree(root.left)\n    printTree(root.right)\n \n \nroot = TreeNode(1)\nroot.children.append(TreeNode(2))\nroot.children.append(TreeNode(3))\nroot.children.append(TreeNode(4))\nroot.children.append(TreeNode(5))\n \nroot.children[0].children.append(TreeNode(6))\nroot.children[0].children.append(TreeNode(7))\n \nroot.children[3].children.append(TreeNode(8))\nroot.children[3].children.append(TreeNode(9))\n \nbinaryTreeRoot = convert(root)\n \n# Output: 1 2 3 4 5 6 7 8 9\nprintTree(binaryTreeRoot)\n", "class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.children = []\n \n \ndef generic_to_binary(root: 'Node') -> TreeNode:\n    if not root:\n        return None\n \n    # create a binary tree node with the data of the current node\n    binary_node = TreeNode(root.val)\n \n    # convert the first child to a binary tree and set as left child of binary_node\n    if root.children:\n        binary_node.left = generic_to_binary(root.children[0])\n \n    # convert the next sibling to a binary tree and set as right child of binary_node\n    current = binary_node.left\n    for child in root.children[1:]:\n        current.right = generic_to_binary(child)\n        current = current.right\n \n    return binary_node\n \n \ndef printTree(root):\n    if not root:\n        return\n    print(root.val, end=' ')\n    printTree(root.left)\n    printTree(root.right)\n \n \nroot = TreeNode(1)\nroot.children.append(TreeNode(2))\nroot.children.append(TreeNode(3))\nroot.children.append(TreeNode(4))\nroot.children.append(TreeNode(5))\n \nroot.children[0].children.append(TreeNode(6))\nroot.children[0].children.append(TreeNode(7))\n \nroot.children[3].children.append(TreeNode(8))\nroot.children[3].children.append(TreeNode(9))\n \nbinaryTreeRoot = generic_to_binary(root)\n \n# Output: 1 2 6 7 3 4 5 8 9 \nprintTree(binaryTreeRoot)\n"], "Count unique paths with given sum in an N-ary Tree -  ": ["# Python3 program for the above approach\nmod = int(1e9 + 7)\n \n# Function for counting total\n# no of paths possible with\n# the sum is equal to X\ndef findTotalPath(X, n, dp):\n     \n  # If the path of the sum\n  # from the root to current\n  # node is stored in sum\n  if (X == 0):\n    return 1\n     \n  ans = 0\n \n  # If already computed\n  if (dp[X] != -1):\n    return dp[X]\n     \n  # Count different no of paths\n  # using all possible ways\n  for i in range(1, min(X, n) + 1):\n    ans = ans + findTotalPath(X - i, n, dp) % mod;\n    ans %= mod;\n \n  # Return total no of paths\n  dp[X] = ans\n  return ans\n \n# Driver Code\nif __name__ == '__main__':\n     \n  n = 3\n  X = 2\n \n  # Stores the number of ways\n  # to obtains sums 0 to X\n  dp = [-1] * (X + 1)\n \n  # Function call\n  print(findTotalPath(X, n, dp))\n   \n# This code is contributed by akhilsaini\n", "# Python program to count total\n# no of paths possible with\n# the sum is equal to X\n \n# Function for counting total\n# no of paths possible with\n# the sum is equal to X\ndef findTotalPath(X, n):\n \n    # Stores the number of ways\n    # to obtains sums 0 to X\n    dp = [0] * (X + 1)\n \n    # Base case\n    dp[0] = 1\n \n    # Fill the DP table iteratively\n    for i in range(1, X + 1):\n        for j in range(1, min(i, n) + 1):\n            dp[i] += dp[i - j]\n            dp[i] %= int(1e9 + 7)\n \n    # Return total no of paths\n    return dp[X]\n \n# Driver Code\nif __name__ == '__main__':\n \n    n = 3\n    X = 2\n \n    # Function call\n    print(findTotalPath(X, n))\n"], "Count of nodes in a given N-ary tree having distance to all leaf nodes equal in their subtree -  ": ["# Python code for the above approach\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n \n# Post-order traversal to find\n# depth of all branches of every\n# node of the tree\ndef postOrder(root, count):\n \n        # If root is a leaf node\n        # then return 1\n    if (len(root.children) == 0):\n        return 1\n \n    # Initialize a variable height\n    # calculate longest increasing path\n    height = 0\n \n    # Use recursion on all child nodes\n    for child in root.children:\n \n        # Get the height of the branch\n        h = postOrder(child, count)\n \n        # Initialize height of first\n        # explored branch\n        if (height == 0):\n            height = h\n \n        # If branches are unbalanced\n        # then store -1 in height\n        elif (h == -1 or height != h):\n            height = -1\n \n    # Increment the value of count\n    #  If height is not -1\n    if (height != -1):\n        count[0] += 1\n \n    # Return the height of branches\n    # including the root if height is\n    # not -1 or else return -1\n    if(height != -1):\n        return height + 1\n    else:\n        return -1\n \n# Function to find the number of nodes\n# in the N-ary tree with their branches\n# having equal height\ndef equalHeightBranches(root):\n \n    # Base case\n    if (root == None):\n        return 0\n \n    # Initialize a variable count\n    # to store the answer\n    count = [0]\n \n    # Apply post order traversal\n    # on the tree\n    postOrder(root, count)\n \n    # Return the answer\n    return count[0]\n \n# Driver code\n \n# Initialize the tree\nseven = Node(7)\nseven2 = Node(7)\nfive = Node(5)\nfour = Node(4)\nnine = Node(9)\none = Node(1)\ntwo = Node(2)\nsix = Node(6)\neight = Node(8)\nten = Node(10)\nthree = Node(3)\nmfour = Node(-4)\nmtwo = Node(-2)\nzero = Node(0)\nthree.children.append(mfour)\nthree.children.append(mtwo)\nthree.children.append(zero)\nten.children.append(three)\ntwo.children.append(six)\ntwo.children.append(seven2)\nfour.children.append(nine)\nfour.children.append(one)\nfour.children.append(five)\nseven.children.append(ten)\nseven.children.append(two)\nseven.children.append(eight)\nseven.children.append(four)\n \n# Call the function\n# and print the result\nprint(equalHeightBranches(seven))\n \n# This code is contributed by rj13to.\n"], "Kth ancestor of a node in an N-ary tree using Binary Lifting Technique -  ": ["# Python3 implementation of the approach\nimport math\n \nclass GfG :\n \n    # Private constructor for initializing\n    # the table and the height of the tree\n    def __init__(self, n):\n     \n        # log(n) with base 2\n        # To store the height of the tree\n        self.height = int(math.ceil(math.log10(n) / math.log10(2)))\n         \n        # Table for storing 2^ith parent\n        self.table = [0] * (n + 1)\n     \n    # Filling with -1 as initial\n    def preprocessing(self):\n        i = 0\n        while ( i < len(self.table)) :\n            self.table[i] = [-1]*(self.height + 1)\n            i = i + 1\n         \n    # Calculating sparse table[][] dynamically\n    def calculateSparse(self, u, v):\n     \n        # Using the recurrence relation to\n        # calculate the values of table[][]\n        self.table[v][0] = u\n        i = 1\n        while ( i <= self.height) :\n            self.table[v][i] = self.table[self.table[v][i - 1]][i - 1]\n \n            # If we go out of bounds of the tree\n            if (self.table[v][i] == -1):\n                break\n            i = i + 1\n         \n    # Function to return the Kth ancestor of V\n    def kthancestor(self, V, k):\n        i = 0\n \n        # Doing bitwise operation to\n        # check the set bit\n        while ( i <= self.height) :\n            if ((k & (1 << i)) != 0) :\n                V = self.table[V][i]\n                if (V == -1):\n                    break\n            i = i + 1\n         \n        return V\n     \n# Driver code\n \n# Number of vertices\nn = 6\n \n# Calling the constructor\nobj = GfG(n)\n \n# Pre-processing\nobj.preprocessing()\n \n# Calculating ancestors of v\nobj.calculateSparse(1, 2)\nobj.calculateSparse(1, 3)\nobj.calculateSparse(2, 4)\nobj.calculateSparse(2, 5)\nobj.calculateSparse(3, 6)\n \nK = 2\nV = 5\nprint(obj.kthancestor(V, K))\n     \n# This code is contributed by Arnab Kundu\n"], "Construct an N-ary Tree having no pair of adjacent nodes with same weight from given weights -  ": ["# Python3 program to implement\n# the above approach  \n \nN = 10**5 + 5\n \n#Keep track of visited nodes\nvisited=[0]*N\n \n#Function to construct a tree such\n#that there are no two adjacent\n#nodes with the same weight\ndef construct_tree(weights, n):\n    minimum = min(weights)\n    maximum = max(weights)\n \n    #If minimum and maximum\n    #elements are equal, i.e.\n    #array contains one distinct element\n    if (minimum == maximum):\n \n        #Tree cannot be constructed\n        print('No')\n        return\n \n    #Otherwise\n    else:\n        print('Yes')\n \n    #Find the edges below\n \n    #Choose weights[0] as root\n    root = weights[0]\n \n    #First Node is visited\n    visited[1] = 1\n \n    #Traverse the array\n    for i in range(n):\n \n        #If current element has the\n        #same weight as root and if\n        #the node is visited, then\n        #do not make an edge\n \n        #Otherwise, make an edge\n        if (weights[i] != root\n            and visited[i + 1] == 0):\n            print(1,i+1)\n \n            #Mark this node as visited\n            visited[i + 1] = 1\n \n    #Find a weight not same as the\n    #root & make edges with that node\n    notroot = 0\n    for i in range(n):\n \n        if (weights[i] != root):\n            notroot = i + 1\n            break\n \n    #Join non-roots with remaining nodes\n    for i in range(n):\n \n        #Check if current node's weight\n        #is same as root node's weight\n        #and if it is not visited or not\n        if (weights[i] == root\n            and visited[i + 1] == 0):\n            print(notroot,i + 1)\n            visited[i + 1] = 1\n \n#Driver Code\nif __name__ == '__main__':\n    weights=[1, 2, 1, 2, 5]\n \n    N = len(weights)\n \n    #Function Call\n    construct_tree(weights, N)\n"], "LCA for n-ary Tree | Constant Query O(1) -  ": ["# Python program to demonstrate LCA of n-ary tree\n# in constant time.\n \nfrom typing import List\n \n# stores the tree\nadj = [[] for _ in range(101)]\n# tracks the eulerwalk\neuler = []\n# depth for each node corresponding to eulerwalk\ndepthArr = []\n# stores first appearance index of every node\nFAI = [-1] * 101\n# stores depth for all nodes in the tree\nlevel = [0] * 101\n# pointer to euler walk\nptr = 0\n# sparse table\ndp = [[-1] * 18 for _ in range(101)]\n# stores log values\nlogn = [0] * 101\n# stores power of 2\np2 = [0] * 20\n \n \ndef buildSparseTable(n: int):\n    # initializing sparse table\n    for i in range(n):\n        dp[i][0] = i-1 if depthArr[i] > depthArr[i-1] else i\n \n    # dp to fill sparse table\n    for l in range(1, 15):\n        for i in range(n):\n            if dp[i][l-1] != -1 and dp[i+p2[l-1]][l-1] != -1:\n                dp[i][l] = dp[i+p2[l-1]][l-1] if depthArr[dp[i][l-1]\n                                                          ] > depthArr[dp[i+p2[l-1]][l-1]] else dp[i][l-1]\n            else:\n                break\n \n \ndef query(l: int, r: int) -> int:\n    d = r-l\n    dx = logn[d]\n    if l == r:\n        return l\n    if depthArr[dp[l][dx]] > depthArr[dp[r-p2[dx]][dx]]:\n        return dp[r-p2[dx]][dx]\n    else:\n        return dp[l][dx]\n \n \ndef preprocess():\n    global ptr\n    # memorizing powers of 2\n    p2[0] = 1\n    for i in range(1, 18):\n        p2[i] = p2[i-1]*2\n \n    # memorizing all log(n) values\n    val = 1\n    ptr = 0\n    for i in range(1, 101):\n        logn[i] = ptr-1\n        if val == i:\n            val *= 2\n            logn[i] = ptr\n            ptr += 1\n \n \ndef dfs(cur: int, prev: int, dep: int):\n    global ptr\n    # marking FAI for cur node\n    if FAI[cur] == -1:\n        FAI[cur] = ptr\n \n    level[cur] = dep\n \n    # pushing root to euler walk\n    euler.append(cur)\n \n    # incrementing euler walk pointer\n    ptr += 1\n \n    for x in adj[cur]:\n        if x != prev:\n            dfs(x, cur, dep+1)\n \n            # pushing cur again in backtrack\n            # of euler walk\n            euler.append(cur)\n \n            # increment euler walk pointer\n            ptr += 1\n \n \n# Create Level depthArray corresponding\n# to the Euler walk Array\ndef makeArr():\n    global depthArr\n    for x in euler:\n        depthArr.append(level[x])\n \n \ndef LCA(u: int, v: int) -> int:\n    # trivial case\n    if u == v:\n        return u\n \n    if FAI[u] > FAI[v]:\n        u, v = v, u\n \n    # doing RMQ in the required range\n    return euler[query(FAI[u], FAI[v])]\n \n \ndef addEdge(u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n \n \n# constructing the described tree\nnumberOfNodes = 8\naddEdge(1, 2)\naddEdge(1, 3)\naddEdge(2, 4)\naddEdge(2, 5)\naddEdge(2, 6)\naddEdge(3, 7)\naddEdge(3, 8)\n \n# performing required precalculations\npreprocess()\n \n# doing the Euler walk\nptr = 0\nFAI = [-1] * (numberOfNodes + 1)\ndfs(1, 0, 0)\n \n# creating depthArray corresponding to euler[]\nmakeArr()\n \n# building sparse table\nbuildSparseTable(len(depthArr))\n \nprint('LCA(6,7) : ', LCA(6, 7))\nprint('LCA(6,4) : ', LCA(6, 4))\n"], "Locking and Unlocking of Resources arranged in the form of n-ary Tree -  ": ["#Python code for the above approach\nclass narytree:\n    def __init__(self):\n        self.isLock = False\n        self.isLockable = True\n        self.parent = None\n        self.children = []\n         \n    def isLock(self):\n        return self.isLock\n     \n    def Lock(self, node):\n        if node.isLockable == False:\n            return\n        T = node\n        flag = False\n        while T != None:\n            if T.isLock == True:\n                flag = True\n                break\n            T = T.parent\n        if flag:\n            return\n        else:\n            node.isLock = True\n            T = node\n            while T != None:\n                T.isLockable = False\n                T = T.parent\n                 \n    def unLock(self, node):\n        if node.isLock == False:\n            return\n        T = node\n        node.isLock = False\n        while T != None:\n            T.isLockable = True\n            T = T.parent\n \n# Creating N-Array Tree\nroot = narytree()\n \nt1 = narytree()\nt1.parent = root\nt2 = narytree()\nt2.parent = root\nt3 = narytree()\nt3.parent = root\n \nroot.children.append(t1)\nroot.children.append(t2)\nroot.children.append(t3)\n \nt5 = narytree()\nt5.parent = root.children[0]\nroot.children[0].children.append(t5)\nt4 = narytree()\nt4.parent = root.children[1]\nroot.children[1].children.append(t4)\n \n# Locking t4 node.\nroot.Lock(t4)\n \n# Checking if the t4 node is locked.\nprint('t4 node is locked:', t4.isLock)\n \nroot.Lock(t2)\nprint('t2 node is locked:', t2.isLock)\n \n# Unlocking t4 node.\nroot.unLock(t4)\n \n# Now we should be able to lock the tree.\nroot.Lock(t2)\nprint('t2 node is locked:', t2.isLock)\n"], "Count of duplicate Subtrees in an N-ary Tree -  ": ["class Node:\n    def __init__(self, val):\n        self.data = val\n        self.children = []\n \n# Function to run dfs\n \n \ndef dfs(root, f):\n    # Base condition\n    if root == None:\n        return ''\n    s = '('\n    s += str(root.data)\n    # Dfs call for all children\n    for child in root.children:\n        s += dfs(child, f)\n    s += ')'\n    if s in f:\n        f[s] += 1\n    else:\n        f[s] = 1\n    # Return  answer string\n    return s\n \n# Function to count number of duplicate substrings\n \n \ndef duplicateSubtreeNaryTree(root):\n    # Declare a map\n    f = {}\n \n    # DFS call\n    dfs(root, f)\n    ans = 0\n \n    # Loop for traversing the map\n    for p in f:\n        if f[p] > 1:\n            ans += 1\n \n    # Return the count of duplicate subtrees\n    return ans\n \n \n# Building a tree\nroot = Node(1)\nroot.children.append(Node(2))\nroot.children.append(Node(2))\nroot.children.append(Node(3))\nroot.children[0].children.append(Node(4))\nroot.children[1].children.append(Node(4))\nroot.children[1].children.append(Node(4))\nroot.children[1].children.append(Node(3))\n \n# Function call\nprint(duplicateSubtreeNaryTree(root))\n"], "Build a segment tree for N-ary rooted tree -  ": ["# Python3 implementation of the above approach \nN = 100005\n  \n# Keeping the values array indexed by 1. \narr = [0, 1, 2, 2, 1, 4, 3, 6] \ntree = [[] for i in range(N)] \n  \nidx = 0\ntin = [0]*N \ntout = [0]*N \nconverted = [0]*N \n  \n# Function to perform DFS in the tree \ndef dfs(node, parent): \n    global idx \n    idx += 1\n    converted[idx] = node \n  \n    # To store starting range of a node \n    tin[node] = idx \n    for i in tree[node]: \n        if (i != parent): \n            dfs(i, node) \n  \n    # To store ending range of a node \n    tout[node] = idx \n  \n# Segment tree \nt = [0]*(N * 4) \n  \n# Build using the converted array indexes. \n# Here a simple n-ary tree is converted \n# into a segment tree. \n  \n# Now O(NlogN) range updates and queries \n# can be performed. \ndef build(node, start, end): \n  \n    if (start == end): \n        t[node] = arr[converted[start]] \n    else: \n        mid = (start + end) >> 1\n        build(2 * node, start, mid) \n        build(2 * node + 1, mid + 1, end) \n  \n        t[node] = t[2 * node] + t[2 * node + 1] \n  \n# Function to perform update operation \n# on the tree \ndef update(node, start, end,lf, rg, c): \n    if (start > end or start > rg or end < lf): \n        return\n  \n    if (start == end): \n        t[node] = c \n    else: \n  \n        mid = (start + end) >> 1\n        update(2 * node, start, mid, lf, rg, c) \n        update(2 * node + 1, mid + 1, end, lf, rg, c) \n  \n        t[node] = t[2 * node] + t[2 * node + 1] \n  \n# Function to find the sum at every node \ndef query(node, start, end, lf, rg): \n    if (start > rg or end < lf): \n        return 0\n  \n    if (lf <= start and end <= rg): \n        return t[node] \n    else: \n        ans = 0\n        mid = (start + end) >> 1\n        ans += query(2 * node, start, mid, lf, rg) \n  \n        ans += query(2 * node + 1, mid + 1, \n                    end, lf, rg) \n  \n        return ans \n  \n# Function to print tree \ndef printTree(q, node, n): \n    while (q > 0): \n          \n        # Calculating range of node in segment tree \n        lf = tin[node] \n        rg = tout[node] \n        res = query(1, 1, n, lf, rg) \n        print('sum at node',node,':',res) \n        node += 1\n        q -= 1\n  \n# Driver code \nif __name__ == '__main__': \n    n = 7\n    q = 7\n  \n    # Creating the tree. \n    tree[1].append(2) \n    tree[1].append(3) \n    tree[1].append(4) \n    tree[3].append(5) \n    tree[3].append(6) \n    tree[3].append(7) \n  \n    # DFS to get converted array. \n    idx = 0\n    dfs(1, -1) \n  \n    # Build segment tree with converted array. \n    build(1, 1, n) \n    printTree(7, 1, 7) \n  \n    # Updating the value at node 3 \n    node = 3\n    lf = tin[node] \n    rg = tout[node] \n    value = 4\n  \n    update(1, 1, n, lf, rg, value) \n  \n    print('After Update') \n    printTree(7, 1, 7) \n  \n# This code is contributed by mohit kumar 29 \n"], "Count of nodes in given N-ary tree such that their subtree is a Binary Tree -  ": ["# Python code for the above approach\nclass Node:\n \n  # constructor\n  def __init__(self, v):\n    self.val = v;\n    self.children = [];\n \n# Post-order traversal to find\n# depth of all branches of every\n# node of the tree\ndef postOrder(root):\n \n  # Initialize a variable sum to\n  # count number of binary trees\n  sum = 0;\n \n  # Integer to indicate if the tree\n  # rooted at current root is a\n  # valid binary tree\n  valid = 1;\n \n  # Use recursion on all child nodes\n  for child in root.children:\n \n    # Get the number of binary trees\n    binTrees = postOrder(child);\n \n    # If tree rooted at current child\n    # is not a valid binary tree then\n    # tree rooted at current root is\n    # also not a valid binary tree\n    if (binTrees[1] == 0):\n      valid = 0;\n \n    # If branches are unbalanced\n    # then store -1 in height\n    sum += binTrees[0];\n   \n \n  # Children are valid binary trees\n  # and the number of children\n  # are less than 3\n  if (valid == 1 and len(root.children) < 3):\n \n    # Root is also a valid binary tree\n    sum += 1\n   \n \n  # Children are leaf nodes but number\n  # of children are greater than 2\n  else:\n    valid = 0;\n \n  # Return the answer\n  return [ sum, valid ];\n \n \n# Function to find the number of\n# binary trees in an N-ary tree\ndef binTreesGeneric(root):\n \n  # Base case\n  if (root == None):\n    return 0;\n \n  # Apply post-order traversal on\n  # the root and return the answer\n  return postOrder(root)[0];\n \n \n# Driver code\n \n# Initialize the graph\ntwenty = Node(20);\nseven = Node(7);\nseven2 = Node(7);\nfive = Node(5);\nfour = Node(4);\nnine = Node(9);\none = Node(1);\ntwo = Node(2);\nsix = Node(6);\neight = Node(8);\nten = Node(10);\nthree = Node(3);\nmfour = Node(11);\nzero = Node(12);\nthree.children.append(mfour);\nthree.children.append(zero);\nten.children.append(three);\ntwo.children.append(six);\ntwo.children.append(seven2);\nfour.children.append(nine);\nfour.children.append(one);\nfour.children.append(five);\nseven.children.append(ten);\nseven.children.append(two);\nseven.children.append(eight);\nseven.children.append(four);\ntwenty.children.append(seven);\n \n# Call the function\n# and print the result\nprint((binTreesGeneric(twenty)));\n \n# This code is contributed by gfgking\n"], "Tree of Space - Locking and Unlocking N-Ary Tree -  ": ["# Python Implementation\n \n# Locking function\ndef lock(name):\n    ind = nodes.index(name)+1\n    c1 = ind * 2\n    c2 = ind * 2 + 1\n    if status[name] == 'lock' \\\n            or status[name] == 'fail':\n        return 'false'\n    else:\n        p = ind//2\n        status[nodes[p-1]] = 'fail'\n        status[name] = 'lock'\n        return 'true'\n \n# Unlocking function\ndef unlock(name):\n    if status[name] == 'lock':\n        status[name] = 'unlock'\n        return 'true'\n    else:\n        return 'false'\n \n# Upgrade function\ndef upgrade(name):\n    ind = nodes.index(name)+1\n \n    # left child of ind\n    c1 = ind * 2\n \n    # right child of ind\n    c2 = ind * 2 + 1\n    if c1 in range(1, n) and c2 in range(1, n):\n        if status[nodes[c1-1]] == 'lock' \\\n            and status[nodes[c2-1]] == 'lock':\n            status[nodes[c1-1]] = 'unlock'\n            status[nodes[c2-1]] = 'unlock'\n            status[nodes[ind-1]] = 'lock'\n            return 'true'\n        else:\n            return 'false'\n \n# Precomputation\ndef precompute(queries):\n  d = []\n   \n  # Traversing the queries\n  for j in queries:\n      i = j.split()\n      d.append(i[1])\n      d.append(int(i[0]))\n \n  status = {}\n  for j in range(0, len(d)-1, 2):\n      status[d[j]] = 0\n  return status, d\n \n# Function to perform operations\ndef operation(name, code):\n    result = 'false'\n     \n    # Choose operation to perform\n    if code == 1:\n        result = lock(name)\n    elif code == 2:\n        result = unlock(name)\n    elif code == 3:\n        result = upgrade(name)\n    return result\n   \n   \n# Driver Code\nif __name__ == '__main__':\n   \n      # Given Input\n    n = 7;m = 2\n    apis = 5\n    nodes = ['World', 'Asia', \\\n            'Africa', 'China', \\\n            'India', 'SouthAfrica', 'Egypt']\n    queries = ['1 China 9', '1 India 9', \\\n             '3 Asia 9', '2 India 9', '2 Asia 9']\n     \n    # Precomputation\n    status, d = precompute(queries)\n \n    # Function Call\n    for j in range(0, len(d) - 1, 2):\n        print(operation(d[j], d[j + 1]), end = ' ')\n"], "Even size subtree in n-ary tree -  ": ["# Python3 program to find number\n# of subtrees of even size\nans = 0\n \n# DFS function to traverse the tree \n# and find number of even size subtree\ndef dfs(adj, n, v):\n     \n    global ans\n \n    # Size of subtree is minimum possible\n    # 1 for leaf node.\n    size = 1\n \n    # Find size of subtree rooted at \n    # children nodes and add the size \n    # to current subtree size.\n    for ele in adj[v]:\n        size += dfs(adj, n, ele)\n \n    # If size is even then increment count.\n    if (size % 2 == 0):\n        ans += 1\n         \n    return size\n \n# Driver code\nif __name__ == '__main__':\n     \n    n = 10\n \n    adj = [[] for i in range(n + 1)]\n     \n    #             1\n    #            / \\\n    #           2   3\n    #          / \\   \\\n    #         4   5   6\n    #            / \\\n    #           7   8\n    adj[1].append(2)\n    adj[1].append(3)\n    adj[2].append(4)\n    adj[2].append(5)\n    adj[3].append(6)\n    adj[5].append(7)\n    adj[5].append(8)\n \n    #              1\n    #             / \\\n    #            2   3\n    #          / | \\  \\\n    #         4  5  6  7\n    #          / | \\\n    #         8  9 10\n    # \n    # adj[1].append(2)\n    # adj[1].append(3)\n    # adj[2].append(4)\n    # adj[2].append(5)\n    # adj[2].append(6)\n    # adj[3].append(7)\n    # adj[5].append(8)\n    # adj[5].append(9)\n    # adj[5].append(10)\n    # \n    # ans = 0\n     \n    dfs(adj, n, 1)\n \n    print(ans)\n \n# This code is contributed by mohit kumar 29\n"], "Maximum count of connected duplicate nodes in given N-ary Tree -  ": ["# Python code for the above approach\nclass Node:\n \n  # constructor\n  def __init__(self, v):\n    self.val = v;\n    self.children = [];\n   \n# Post order traversal function\n# to calculate the largest group\n# of connected nodes\ndef postOrder(root, maxi):\n \n  # If the current node has no\n  # children then return 1\n  if (len(root.children) == 0):\n    return 1;\n \n  # Initialize a variable sum to\n  # calculate largest group connected\n  # to current node with same value\n  # as current node\n  sum = 1;\n \n  # Iterate through all neighbors\n  for child in root.children:\n \n    # Get the value from children\n    nodes = postOrder(child, maxi);\n \n    # If child node value is same as\n    # current node then add the\n    # returned value to sum\n    if (child.val == root.val):\n      sum += nodes;\n   \n  # Update maximum connected\n  # nodes if sum is greater\n  maxi[0] = max(maxi[0], sum);\n \n  # Return the connected group\n  # to the current node\n  return sum;\n \n# Function to find the largest\n# number of nodes in a tree\ndef largestGroup(root):\n \n  # Base case\n  if (root == None):\n    return 0;\n \n  # Initialize a variable max\n  # to calculate largest group\n  maxi = [0];\n \n  # Post-order traversal\n  postOrder(root, maxi);\n \n  # Return the answer\n  return maxi[0];\n \n \n# Driver code\n \n# Initialize the tree\nthree1 = Node(3);\nthree2 = Node(3);\nthree3 = Node(3);\nthree4 = Node(3);\ntwo1 = Node(2);\ntwo2 = Node(2);\ntwo3 = Node(2);\ntwo4 = Node(2);\nfour1 = Node(4);\nfour2 = Node(4);\nfour3 = Node(4);\none1 = Node(1);\none2 = Node(1);\none3 = Node(1);\none4 = Node(1);\nthree2.children.append(two1);\nthree2.children.append(three1);\nthree2.children.append(three3);\nfour1.children.append(four2);\nfour1.children.append(four3);\ntwo2.children.append(one1);\ntwo2.children.append(one2);\ntwo2.children.append(two3);\none3.children.append(one4);\none3.children.append(two4);\nthree4.children.append(three2);\nthree4.children.append(four1);\nthree4.children.append(two2);\nthree4.children.append(one3);\n \n# Call the function\n# and print the result\nprint((largestGroup(three4)));\n \n# This code is contributed by gfgking\n"], "Count of subtrees possible from an N-ary Tree -  ": ["# Python3 program of the above approach\nMAX = 300004\n \n# Adjacency list to\n# represent the graph\ngraph = [[] for i in range(MAX)]\nmod = 10**9 + 7\n \n# Stores the count of subtrees\n# possible from given N-ary Tree\nans = 0\n \n# Utility function to count the number of\n# subtrees possible from given N-ary Tree\ndef countSubtreesUtil(cur, par):\n    global mod, ans\n     \n    # Stores the count of subtrees\n    # when cur node is the root\n    res = 1\n \n    # Traverse the adjacency list\n    for i in range(len(graph[cur])):\n \n        # Iterate over every ancestor\n        v = graph[cur][i]\n \n        if (v == par):\n            continue\n \n        # Calculate product of the number\n        # of subtrees for each child node\n        res = (res * (countSubtreesUtil(v, cur)+ 1)) % mod\n \n    # Update the value of ans\n    ans = (ans + res) % mod\n \n    # Return the resultant count\n    return res\n \n# Function to count the number of\n# subtrees in the given tree\ndef countSubtrees(N, adj):\n   \n    # Initialize an adjacency matrix\n    for i in range(N-1):\n        a = adj[i][0]\n        b = adj[i][1]\n \n        # Add the edges\n        graph[a].append(b)\n        graph[b].append(a)\n \n    # Function Call to count the\n    # number of subtrees possible\n    countSubtreesUtil(1, 1)\n \n    # Print count of subtrees\n    print (ans + 1)\n \n# Driver Code\nif __name__ == '__main__':\n    N = 3\n \n    adj = [ [ 0, 1 ], [ 1, 2 ] ]\n \n    countSubtrees(N, adj)\n \n# This code is contributed by mohit kumar 29.\n"], "Print List of nodes of given n-ary Tree with number of children in range [0, n] -  ": ["# Node Class\nfrom collections import OrderedDict\nclass Node:\n    def __init__(self, data_value):\n        self.key_ele = data_value\n        self.child = []\n \n# Function to find number of child\ndef numberOfChild(root, ele):\n    num = 0\n \n    if root is None:\n        return 0\n \n    # Initializing queue data structure\n    q = []\n    q.append(root)\n \n    while len(q) > 0:\n        n = len(q)\n        while n > 0:\n            nn = q.pop(0)\n            if nn.key_ele == ele:\n                num += len(nn.child)\n                return num\n            for i in range(len(nn.child)):\n                q.append(nn.child[i])\n            n -= 1\n    return num\n \n# Function to print the nodes\n# having children in range [0, n]\ndef printTree(root, vec):\n   \n    # map to store nodes\n    # with same number of children\n    mp = {}\n    for i in range(len(vec)):\n        temp = numberOfChild(root, vec[i])\n        if temp not in mp:\n            mp[temp] = []\n        mp[temp].append(vec[i])\n    mp = OrderedDict(sorted(mp.items()))\n    for key,value in mp.items():\n        print(f'{key} child: ', end='')\n        len_list = len(value)\n        s = 0\n        for element in value:\n            if s < len_list - 1:\n                print(element, end=', ')\n            else:\n                print(element, end='')\n            s += 1\n        print()\n \n# Driver Code\nvec = [1, 2, 3, 4, 5, 6, 7]\nmp = {}\nv = []\nroot = Node(1)\nroot.child.append(Node(2))\nroot.child.append(Node(3))\nroot.child.append(Node(4))\nroot.child[0].child.append(Node(5))\nroot.child[0].child.append(Node(6))\nroot.child[2].child.append(Node(7))\n \n    # Function call\nprintTree(root, vec)\n \n# This code is contributed by Potta Lokesh\n"], "Maximize sum of path from the Root to a Leaf node in N-ary Tree -  ": ["# Python3 program for the above approach\n \n# Stores the maximum sum of a path\nmaxSumPath = 0\n \n# Structure of a node in the tree\nclass Node:\n    def __init__(self, key):\n        self.val = key\n        self.child = []\n \n# Utility function to create a\n# new node in the tree\ndef newNode(key):\n    temp = Node(key)\n    return temp\n \n# Recursive function to calculate the\n# maximum sum in a path using DFS\ndef DFS(root, Sum):\n    global maxSumPath\n    # If current node is a leaf node\n    if (len(root.child) == 0):\n        maxSumPath = max(maxSumPath, Sum)\n        return\n \n    # Traversing all children of\n    # the current node\n    for i in range(len(root.child)):\n        # Recursive call for all\n        # the children nodes\n        DFS(root.child[i], Sum + root.child[i].val)\n \n# Given Generic Tree\nroot = newNode(1)\n(root.child).append(newNode(2))\n(root.child).append(newNode(3))\n(root.child[0].child).append(newNode(4))\n(root.child[1].child).append(newNode(6))\n(root.child[0].child).append(newNode(5))\n(root.child[1]).child.append(newNode(7))\n(root.child[1].child).append(newNode(8))\n \n# Function Call\nDFS(root, root.val)\n \nprint(maxSumPath)\n \n# This code is contributed by rameshtravel07.\n"], "Number of special nodes in an n-ary tree -  ": ["# Python3 implementation of the approach \n \n# DFS function to traverse the tree \n# and find number of special nodes \ndef dfs(val, n, adj, v, values): \n \n    # If value of current node is already \n    # present earlier in path then this \n    # node and all other nodes connected\n    # to it are not special \n    if val[v] in values: \n        return\n     \n    global ans\n \n    # Insert value of current node in \n    # set of values traversed \n    ans += 1\n    values.add(val[v]) \n \n    # Call dfs on all adjacent nodes \n    for ele in adj[v]: \n        dfs(val, n, adj, ele, values) \n \n    # Erase value of current node as all \n    # paths passing through current node \n    # are traversed \n    values.remove(val[v]) \n \n# Driver code \nif __name__ == '__main__':\n \n    val = [0, 2, 1, 4, 3, 4, 8, 10, 2, 5, 1] \n    n = len(val) \n \n    adj = [[] for i in range(n)] \n \n    adj[1].append(2) \n    adj[1].append(3) \n    adj[2].append(4) \n    adj[2].append(5) \n    adj[2].append(6) \n    adj[3].append(7) \n    adj[5].append(8) \n    adj[5].append(9) \n    adj[5].append(10) \n \n    values = set() \n    ans = 0\n    dfs(val, n, adj, 1, values) \n    print(ans) \n \n# This code is contributed by Rituraj Jain\n"], "Left and Right view of a Generic Tree -  ": ["# Python3 implementation for the above approach\nimport sys\n \n# Structure of Node\nclass Node:\n    def __init__(self, key):\n        self.val = key\n        self.child = []\n \n# Utility function to create a\n# new tree node\ndef newNode(key):\n    temp = Node(key)\n    return temp\n \n# Function to get the left view and\n# right view of the given tree\ndef getLeftRightview(root):\n    # Stores the nodes of each level\n    curNodes = []\n \n    # Push the root to initiate the\n    # level ordered traversal\n    curNodes.append(root)\n \n    # Stores the left and right views\n    leftView, rightView = [], []\n \n    # Iterate until queue is non-empty\n    while (len(curNodes) != 0):\n        # Find the number of nodes in\n        # current level\n        n = len(curNodes)\n \n        for i in range(n):\n            cur = curNodes[0]\n            curNodes.pop(0)\n \n            # If the node is first node\n            # in the level\n            if (i == 0):\n                leftView.append(cur.val)\n \n            # If the node is last node\n            # in the level\n            if (i == n - 1):\n                rightView.append(cur.val)\n \n            # Push all the childs of the\n            # current node into the queue\n            for it in range(len(cur.child)):\n                curNodes.append(cur.child[it])\n \n    # Print the left view\n    print('Left View: ', end = '')\n    for i in range(len(leftView)):\n        print(leftView[i], '', end = '')\n    print()\n \n    # Print the right view\n    print('RIght View: ', end = '')\n    for i in range(len(rightView)):\n        print(rightView[i], '', end = '')\n \nroot = newNode(1)\n(root.child).append(newNode(2))\n(root.child).append(newNode(3))\n(root.child[0].child).append(newNode(4))\n(root.child[1].child).append(newNode(6))\n(root.child[0].child).append(newNode(5))\n(root.child[1]).child.append(newNode(7))\n(root.child[1].child).append(newNode(8))\n \ngetLeftRightview(root)\n \n# This code is contributed by rameshtravel07.\n"], "Maximum Path sum in a N-ary Tree -  ": ["# Python code to implement the approach\n \n# Function to add edge\ndef addEdge(adj, s, d):\n    adj[s].append(d)\n    adj[d].append(s)\n \nresult = 0\n \n# Helper function to calculate\n# the maximum path sum using DFS\ndef findMaximumPathSum(currentNode, previousNode, adj, A):\n \n    # Nodes to which currentNode\n    # is connected to\n    v = adj[currentNode]\n    maximumBranchSum1 = 0\n    maximumBranchSum2 = 0\n    for i in range(len(v)):\n \n        # Checking whether the branch\n        # is visited already\n        if (v[i] == previousNode):\n            continue\n \n        findMaximumPathSum(v[i],\n                           currentNode, adj,\n                           A)\n \n        # Storing the maximum of value of branch path\n        # sums maximumBranchSum1 will store the maximum\n        # value maximumBranchSum2 will store the 2nd\n        # most maximum value\n        if (A[v[i]] > maximumBranchSum1):\n            maximumBranchSum2 = maximumBranchSum1\n            maximumBranchSum1 = A[v[i]]\n \n        else:\n            maximumBranchSum2 = max(maximumBranchSum2, A[v[i]])\n \n    global result\n    result = max(result, A[currentNode] +\n                 maximumBranchSum1 + maximumBranchSum2)\n \n    # Updating the value of current node with\n    # maximum path sum including currentNode\n    A[currentNode] += maximumBranchSum1\n \n \n# Driver code\n \nN = 6\nA = [4, -1, -3, 5, 7, -2]\nadj = []\n \nfor i in range(N):\n    adj.append([])\n \naddEdge(adj, 0, 1)\naddEdge(adj, 0, 2)\naddEdge(adj, 1, 3)\naddEdge(adj, 1, 4)\naddEdge(adj, 1, 5)\n \n# Driver code\nfindMaximumPathSum(0, -1, adj, A)\nprint(result)\n \n# This code is contributed by gfgking.\n"], "Find the node at the center of an N-ary tree -  ": ["# Python3 implementation of the above approach\n \n# To create tree\ntree = {}\npath = []\nmaxHeight, maxHeightNode = -1, -1\n \n# Function to store the path\n# from given vertex to the target\n# vertex in a vector path\ndef getDiameterPath(vertex, targetVertex, parent, path):\n   \n    # If the target node is found,\n    # push it into path vector\n    if (vertex == targetVertex):\n        path.append(vertex)\n        return True\n \n    for i in range(len(tree[vertex])):\n        # To prevent visiting a\n        # node already visited\n        if (tree[vertex][i] == parent):\n            continue\n \n        # Recursive call to the neighbours\n        # of current node inorder\n        # to get the path\n        if (getDiameterPath(tree[vertex][i], targetVertex, vertex, path)):\n            path.append(vertex)\n            return True\n    return False\n \n# Function to obtain and return the\n# farthest node from a given vertex\ndef farthestNode(vertex, parent, height):\n    global maxHeight, maxHeightNode\n    # If the current height is maximum\n    # so far, then save the current node\n    if (height > maxHeight):\n        maxHeight = height\n        maxHeightNode = vertex\n \n    # Iterate over all the neighbours\n    # of current node\n    if (vertex in tree):\n        for i in range(len(tree[vertex])):\n           \n            # This is to prevent visiting\n            # a already visited node\n            if (tree[vertex][i] == parent):\n                continue\n                 \n            # Next call will be at 1 height\n            # higher than our current height\n            farthestNode(tree[vertex][i], vertex, height + 1)\n \n# Function to add edges\ndef addedge(a, b):\n    if (a not in tree):\n        tree[a] = []\n \n    tree[a].append(b)\n \n    if (b not in tree):\n        tree[b] = []\n \n    tree[b].append(a)\n \ndef FindCenter(n):\n    # Now we will find the 1st farthest\n    # node from 0(any arbitrary node)\n \n    # Perform DFS from 0 and update\n    # the maxHeightNode to obtain\n    # the farthest node from 0\n \n    # Reset to -1\n    maxHeight = -1\n \n    # Reset to -1\n    maxHeightNode = -1\n \n    farthestNode(0, -1, 0)\n \n    # Stores one end of the diameter\n    leaf1 = maxHeightNode\n \n    # Similarly the other end of\n    # the diameter\n \n    # Reset the maxHeight\n    maxHeight = -1\n    farthestNode(maxHeightNode, -1, 0)\n \n    # Stores the second end\n    # of the diameter\n    leaf2 = maxHeightNode\n \n    # Store the diameter into\n    # the vector path\n    path = []\n \n    # Diameter is equal to the\n    # path between the two farthest\n    # nodes leaf1 and leaf2\n    getDiameterPath(leaf1, leaf2, -1, path)\n \n    pathSize = len(path)\n \n    if (pathSize % 2 == 1):\n        print(path[int(pathSize / 2)]*-1)\n    else:\n        print(path[int(pathSize / 2)], ', ', path[int((pathSize - 1) / 2)], sep = '', end = '')\n \nN = 4\n   \ntree = {}\naddedge(1, 0)\naddedge(1, 2)\naddedge(1, 3)\n \nFindCenter(N)\n \n# This code is contributed by suresh07.\n"], "Immediate Smaller element in an N-ary Tree -  ": ["# Python code for the above approach\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.child = []\n \n# Function to find immediate Smaller Element of a given number x\ndef immediateSmallerElementUtil(root, x, res):\n    if root is None:\n        return\n \n    # if root is greater than res, but less than x, then update res\n    if root.key < x:\n        if res[0] is None or res[0].key < root.key:\n            res[0] = root\n \n    # Recursive calling for every child\n    for i in range(len(root.child)):\n        immediateSmallerElementUtil(root.child[i], x, res)\n    return\n \n# Function to return immediate Smaller Element of x in tree\ndef immediateSmallerElement(root, x):\n    # resultant node\n    res = [None]\n    immediateSmallerElementUtil(root, x, res)\n    return res[0]\n \nif __name__ == '__main__':\n    # Creating a generic tree\n    root = Node(20)\n    root.child.append(Node(2))\n    root.child.append(Node(34))\n    root.child.append(Node(50))\n    root.child.append(Node(60))\n    root.child.append(Node(70))\n    root.child[0].child.append(Node(15))\n    root.child[0].child.append(Node(20))\n    root.child[1].child.append(Node(30))\n    root.child[2].child.append(Node(40))\n    root.child[2].child.append(Node(100))\n    root.child[2].child.append(Node(20))\n    root.child[0].child[1].child.append(Node(25))\n    root.child[0].child[1].child.append(Node(50))\n \n    x = 30\n \n    print('Immediate smaller element of', x, 'is', immediateSmallerElement(root, x).key)\n \n    # This code is contributed by lokeshpotta20.\n"], "Next Larger element in n-ary tree -  ": ["# Python program to find next larger element\n# in an n-ary tree.\nclass Node:\n  \n# Structure of a node of an n-ary tree\n    def __init__(self):\n        self.key = 0\n        self.child = []\n \n# Utility function to create a new tree node\ndef newNode(key):\n    temp = Node()\n    temp.key = key\n    temp.child = []\n    return temp\n \nres = None;    \ndef nextLargerElementUtil(root,x):\n    global res\n    if (root == None):\n        return;\n     \n     # if root is less than res but \n    # greater than x, update res\n    if (root.key > x):\n        if ((res == None or (res).key > root.key)):\n            res = root;\n             \n    # Number of children of root\n    numChildren = len(root.child)\n     \n     # Recur calling for every child\n    for i in range(numChildren):\n        nextLargerElementUtil(root.child[i], x)\n    return\n \n  # Function to find next Greater element \n# of x in tree\ndef nextLargerElement(root,x):\n   \n   # resultant node\n    global res\n    res=None\n     \n    # Calling helper function\n    nextLargerElementUtil(root, x)\n     \n    return res\n     \n    # Driver code\nroot = newNode(5)\n(root.child).append(newNode(1))\n(root.child).append(newNode(2))\n(root.child).append(newNode(3))\n(root.child[0].child).append(newNode(15))\n(root.child[1].child).append(newNode(4))\n(root.child[1].child).append(newNode(5))\n(root.child[2].child).append(newNode(6))\n \nx = 5\nprint('Next larger element of ' , x , ' is ',end='')\nprint(nextLargerElement(root, x).key)\n \n# This code is contributed by rag2127.\n", "class Node:\n    # Structure of a node of an n-ary tree\n    def __init__(self):\n        self.vcal = 0\n        self.children = []\n \n# Utility function to create a new tree node\n \n \ndef newNode(val):\n    temp = Node()\n    temp.val = val\n    temp.children = []\n    return temp\n \n \ndef postOrder(root, nodes):\n    if not root:\n        return\n    for child in root.children:\n        postOrder(child, nodes)\n    nodes.append(root.val)\n \n \ndef findNextLarger(root):\n    nodes = []\n    nextLarger = {}\n    postOrder(root, nodes)\n \n    stack = []\n    for num in nodes[::-1]:\n        while stack and stack[-1] <= num:\n            stack.pop()\n        nextLarger[num] = stack[-1] if stack else -1\n        stack.append(num)\n \n    return nextLarger\n \n \nroot = newNode(8)\nroot.children.append(newNode(3))\nroot.children.append(newNode(10))\nroot.children[0].children.append(newNode(1))\nroot.children[0].children.append(newNode(6))\nroot.children[0].children[1].children.append(newNode(4))\nroot.children[0].children[1].children.append(newNode(7))\nroot.children[1].children.append(newNode(14))\n \ntarget = 4\nnextLarger = findNextLarger(root)\nprint(f'The next larger element for {target} is: {nextLarger[target]}')\n"], "Kth Smallest Element in an N-ary Tree -  ": ["# Python3 program for the above approach\nimport sys\n \n# Structure of a node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.childs = []\n \n# Global variable set to Maximum\nMinimumElement = sys.maxsize\n \n# Function that gives the smallest\n# element under the range of key\ndef smallestEleUnderRange(root, data):\n    global MinimumElement\n    if root.data > data:\n        MinimumElement = min(root.data, MinimumElement)\n    for child in range(len(root.childs)):\n        smallestEleUnderRange(root.childs[child], data)\n \n# Function to find the Kth smallest element\ndef kthSmallestElement(root, k):\n    global MinimumElement\n    ans = -sys.maxsize\n    for i in range(k):\n        smallestEleUnderRange(root, ans)\n        ans = MinimumElement\n        MinimumElement = sys.maxsize\n    return ans\n \n# Function to create a new node\ndef newNode(data):\n    temp = Node(data)\n    return temp\n \n'''   Let us create below tree\n *              10\n *        /   /    \\   \\\n *        2  34    56   100\n *       / \\         |   /  | \\\n *      77  88       1   7  8  9\n'''\n \nroot = newNode(10)\n(root.childs).append(newNode(2))\n(root.childs).append(newNode(34))\n(root.childs).append(newNode(56))\n(root.childs).append(newNode(100))\n(root.childs[0].childs).append(newNode(77))\n(root.childs[0].childs).append(newNode(88))\n(root.childs[2].childs).append(newNode(1))\n(root.childs[3].childs).append(newNode(7))\n(root.childs[3].childs).append(newNode(8))\n(root.childs[3].childs).append(newNode(9))\n \nprint(kthSmallestElement(root, 3))\n \n# This code is contributed by divyesh072019.\n"], "Kth largest element in an N-array Tree -  ": ["# Python3 program for the above approach\nimport sys\n \n# Structure of N-array Tree\nclass Node:\n    # Constructor to set the data of\n    # the newly created tree node\n    def __init__(self, data):\n        self.data = data\n        self.childs = []\n     \n# Stores the minimum element\n# in the recursive call\nlargestELe = -sys.maxsize\n \n# Function to find the largest\n# element under the range of key\ndef largestEleUnderRange(root, data):\n    global largestELe\n    # If the current root's value\n    # is less than data\n    if (root.data < data) :\n        largestELe = max(root.data, largestELe)\n \n    # Iterate over all the childrens\n    for child in range(len(root.childs)):\n        # Update under current range\n        largestEleUnderRange(root.childs[child], data)\n \n# Function to find the Kth Largest\n# element in the given N-ary Tree\ndef KthLargestElement(root, K):\n    global largestELe\n    # Stores the resultant\n    # Kth maximum element\n    ans = sys.maxsize\n \n    # Iterate over the range [0, K]\n    for i in range(K):\n        # Recursively call for\n        # finding the maximum element\n        # from the given range\n        largestEleUnderRange(root, ans)\n \n        # Update the value of\n        # ans and largestEle\n        ans = largestELe\n        largestELe = -sys.maxsize\n \n    # Print the result\n    print(ans)\n \n'''   Create below the tree\n *              10\n *        /   /    \\   \\\n *        2  34    56   100\n *       / \\         |   /  | \\\n *      77  88       1   7  8  9\n'''\n \nroot = Node(10)\n(root.childs).append(Node(2));\n(root.childs).append(Node(34));\n(root.childs).append(Node(56));\n(root.childs).append(Node(100));\n(root.childs[0].childs).append(Node(77))\n(root.childs[0].childs).append(Node(88))\n(root.childs[2].childs).append(Node(1))\n(root.childs[3].childs).append(Node(7))\n(root.childs[3].childs).append(Node(8))\n(root.childs[3].childs).append(Node(9))\n \nK = 3\nKthLargestElement(root, K)\n \n# This code is contributed by rameshtravel07.\n"], "Print siblings of a given Node in N-ary Tree -  ": ["# Python3 code for the above approach\nfrom collections import deque\n \n# Class to represent a node of N-ary tree\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.child = []\n \n# Function to create a new node\ndef newNode(key):\n    temp = Node(key)\n    return temp\n \n# Function to find the siblings\n# of the node value\ndef Siblings(root, value):\n    flag = 0\n \n    if root is None:\n        return\n \n    # Stores nodes level wise\n    q = deque()\n \n    # Push the root\n    q.append(root)\n \n    # Continue until all levels\n    # are traversed\n    while len(q) > 0:\n        # Stores current node\n        temp = q.popleft()\n \n        # Enqueue all children of the current node\n        for i in range(len(temp.child)):\n            # If node value is found\n            if temp.child[i].key == value:\n                flag = 1\n \n                # Print all children of current node\n                # except value as the answer\n                for j in range(len(temp.child)):\n                    if value != temp.child[j].key:\n                        print(temp.child[j].key, end=' ')\n                break\n \n            # Push the child nodes\n            # of temp into the queue\n            q.append(temp.child[i])\n \n    if flag == 0:\n        print('No siblings!!')\n \ndef constructTree():\n    root = newNode(10)\n    root.child.append(newNode(20))\n    root.child.append(newNode(30))\n    root.child.append(newNode(40))\n    root.child[0].child.append(newNode(50))\n    root.child[0].child.append(newNode(60))\n    root.child[1].child.append(newNode(70))\n    root.child[1].child.append(newNode(80))\n    root.child[2].child.append(newNode(90))\n    root.child[2].child.append(newNode(100))\n    root.child[2].child.append(newNode(110))\n \n    return root\n \n# Driver Code\nif __name__ == '__main__':\n   \n    # Stores root of the\n    # constructed tree\n    root = constructTree()\n \n    X = 30\n     \n    # Print siblings of Node X\n    Siblings(root, X)\n     \n# This code is contributed by Potta Lokesh\n"], "Height of n-ary tree if parent array is given -  ": ["# Python program to find the height of the generic \n# tree(n-ary tree) if parent array is given \n \n# function to find the height of tree \ndef findHeight(parent, n): \n \n    res = 0\n \n    # Traverse each node \n    for i in range(n):             \n        # traverse to parent until -1 \n        # is reached \n        p = i\n        current = 1\n        while (parent[p] != -1):\n            current+= 1\n            p = parent[p] \n        res = max(res, current) \n    return res \n \n     \n# Driver code\nif __name__ == '__main__':\n    parent = [-1, 0, 1, 6, 6, 0, 0, 2, 7]\n    n = len(parent) \n    height = findHeight(parent, n) \n    print('Height of the given tree is:', height)\n \n# This code is contributed by SHUBHAMSINGH10\n", "# Python3 program to find the height of the generic\n# tree(n-ary tree) if parent array is given\n \n# function to fill the height vector\ndef rec(i, parent, height):\n   \n    # if we have reached root node the\n    # return 1 as height of root node\n    if (parent[i] == -1):\n        return 1\n \n    # if we have calculated height of a\n    # node then return if\n    if (height[i] != -1):\n        return height[i]\n \n    # height from root to a node = height\n    # from root to nodes parent + 1\n    height[i] = rec(parent[i], parent, height) + 1\n \n    # return nodes height\n    return height[i]\n \n# function to find the height of tree\ndef findHeight(parent, n):\n    res = 0\n \n    # vector to store heights of all nodes\n    height = [-1]*(n)\n \n    for i in range(n):\n        res = max(res, rec(i, parent, height))\n \n    return res\n \n# Driver program\nif __name__ == '__main__':\n    parent = [-1, 0, 1, 6, 6, 0, 0, 2, 7]\n    n = len(parent)\n    height = findHeight(parent, n)\n    print('Height of the given tree is: ',height)\n \n# This code is contributed by mohit kumar 29.\n"], "Find the cousins of a given element in an N-ary tree -  ": ["# Python code for the above approach \n \n# Structure of a node of N-ary tree\nclass Node:\n    def __init__ (self, k):\n        self.key = k;\n        self.child = [];\n \n# node creation\n \n# Function to find the cousins of a\n# given node in an N-array tree\ndef printCousins(root, value):\n \n    # Base case\n    if (root == None):\n        return;\n \n    q = [];\n    q.append(root);\n \n    # If we find the node\n    # with value as the key\n    found = False;\n \n    qsize = 0;\n    tempp = None\n \n    while (len(q) != 0 and found != 1):\n        qsize = len(q);\n \n        while (qsize != 0):\n \n            # Storing the current node\n            tempp = q[0];\n            q.pop(0);\n \n            # If we have already found\n            # the value as child of a node,\n            # we need to insert children of other\n            # node of same level in the queue\n            if (found == True):\n                for i in range(len(tempp.child)):\n                    if (tempp.child[i] != None):\n                        q.append(tempp.child[i]);\n \n            # If value is child of tempp node\n            for i in range(len(tempp.child)):\n                if (tempp.child[i] != None and tempp.child[i].key == value):\n                    found = True;\n \n            # If value is not the child of tempp node\n            # then insert all the children\n            # of the tempp node\n            if (found == False):\n                for i in range(len(tempp.child)):\n                    if (tempp.child[i] != None):\n                        q.append(tempp.child[i]);\n \n            qsize -= 1\n \n    if (found):\n \n        # Queue will contain the cousins\n        qsize = len(q);\n \n        if (qsize == 0):\n            print('NA');\n        for i in range(qsize):\n            tempp = q[0];\n            q.pop(0);\n            print(tempp.key, end= ' ');\n    else:\n \n        # When value  is not in the tree\n        print('Not Possible');\n    print('')\n    return;\n \n# Driver Code\nroot = Node(10);\nroot.child.append(Node(77));\nroot.child.append(Node(90));\nroot.child.append(Node(35));\nroot.child.append(Node(19));\nroot.child[0].child.append(Node(88));\nroot.child[0].child.append(Node(98));\nroot.child[0].child[1].child.append(Node(76));\nroot.child[0].child[1].child.append(Node(20));\nroot.child[1].child.append(Node(61));\nroot.child[1].child.append(Node(74));\nroot.child[2].child.append(Node(39));\nroot.child[3].child.append(Node(17));\nroot.child[3].child.append(Node(72));\nroot.child[3].child.append(Node(19));\n \n# Find the cousins of value\nvalue = 39;\nprintCousins(root, value);\n \n# This code is contributed by gfgking\n"], "Number of ways to traverse an N-ary tree -  ": ["# Python3 program to find the\n# number of ways to traverse a\n# n-ary tree starting from the root node\n \n \nclass Node:\n    def __init__(self, key):\n        self.child = []\n        self.key = key\n \n# Utility function to create a new tree node\n \n \ndef newNode(key):\n    temp = Node(key)\n    return temp\n \n# Utility Function to find factorial of given number\n \n \ndef factorial(n):\n \n    if (n == 0):\n        return 1\n \n    return n*factorial(n-1)\n \n# Function to calculate the number of ways of traversing\n# the n-ary starting from root.\n# self function is just a modified breadth-first search.\n# We can use a depth-first search too.\n \n \ndef calculateWays(root):\n \n    ways = 1  # Initialize result\n \n    # If the tree is empty there is no way of traversing\n    # the tree.\n    if (root == None):\n        return 0\n \n    # Create a queue and enqueue root to it.\n    q = []\n    q.append(root)\n \n    # Level order traversal.\n    while (len(q) > 0):\n        # Dequeue an item from queue and print it\n        p = q[0]\n        q = q[1:]\n \n        # The number of ways is the product of\n        # factorials of number of children of each node.\n        ways = ways*(factorial(len(p.child)))\n \n        # Enqueue all childrent of the dequeued item\n        for i in range(len(p.child)):\n            q.append(p.child[i])\n \n    return(ways)\n \n#  Let us create below tree\n# *         A\n# *         / / \\ \\\n# *     B F D E\n# *     / \\     | /|\\\n# *     K J G C H I\n# *     /\\         \\\n# * N M         L\n \n \nroot = newNode('A')\n(root.child).append(newNode('B'))\n(root.child).append(newNode('F'))\n(root.child).append(newNode('D'))\n(root.child).append(newNode('E'))\n(root.child[0].child).append(newNode('K'))\n(root.child[0].child).append(newNode('J'))\n(root.child[2].child).append(newNode('G'))\n(root.child[3].child).append(newNode('C'))\n(root.child[3].child).append(newNode('H'))\n(root.child[3].child).append(newNode('I'))\n(root.child[0].child[0].child).append(newNode('N'))\n(root.child[0].child[0].child).append(newNode('M'))\n(root.child[3].child[2].child).append(newNode('L'))\n \nprint(calculateWays(root))\n"], "Print N-ary tree graphically -  ": ["# Python3 implementation to print N-ary Tree graphically\n \n# Structure of the node\nclass tnode:\n    def __init__(self, data):\n        self.n = data\n        self.root = []\n \n# Function to print the\n# N-ary tree graphically\ndef printNTree(x,flag,depth,isLast):\n    # Condition when node is None\n    if x == None:\n        return\n       \n    # Loop to print the depths of the\n    # current node\n    for i in range(1, depth):\n        # Condition when the depth\n        # is exploring\n        if flag[i]:\n            print('| ','', '', '', end = '')\n           \n        # Otherwise print\n        # the blank spaces\n        else:\n            print(' ', '', '', '', end = '')\n       \n    # Condition when the current\n    # node is the root node\n    if depth == 0:\n        print(x.n)\n       \n    # Condition when the node is\n    # the last node of\n    # the exploring depth\n    elif isLast:\n        print('+---', x.n)\n           \n        # No more childrens turn it\n        # to the non-exploring depth\n        flag[depth] = False\n    else:\n        print('+---', x.n)\n   \n    it = 0\n    for i in x.root:\n        it+=1\n         \n        # Recursive call for the\n        # children nodes\n        printNTree(i, flag, depth + 1, it == (len(x.root) - 1))\n    flag[depth] = True\n  \n# Function to form the Tree and\n# print it graphically\ndef formAndPrintTree():\n    nv = 10\n    r = tnode(0)\n    n1 = tnode(1)\n    n2 = tnode(2)\n    n3 = tnode(3)\n    n4 = tnode(4)\n    n5 = tnode(5)\n    n6 = tnode(6)\n    n7 = tnode(7)\n    n8 = tnode(8)\n    n9 = tnode(9)\n       \n    # Array to keep track\n    # of exploring depths\n      \n    flag = [True]*(nv)\n       \n    # Tree Formation\n    r.root.append(n1)\n    n1.root.append(n4)\n    n1.root.append(n5)\n    r.root.append(n2)\n    r.root.append(n3)\n    n3.root.append(n6)\n    n3.root.append(n7)\n    n7.root.append(n9)\n    n3.root.append(n8)\n   \n    printNTree(r, flag, 0, False)\n \nformAndPrintTree();\n \n# This code is contributed by suresh07.\n"], "Maximum width of an N-ary tree -  ": ["# Python3 program to implement\n# the above approach\nfrom collections import deque\n \n# Function to find the maximum width of\n#. he tree using level order traversal\ndef maxWidth(N, M, cost, s):\n     \n    # Store the edges of the tree\n    adj = [[] for i in range(N)]\n    for i in range(M):\n        adj[s[i][0]].append(s[i][1])\n \n    # Stores maximum width\n    # of the tree\n    result = 0\n \n    # Stores the nodes\n    # of each level\n    q = deque()\n \n    # Insert root node\n    q.append(0)\n \n    # Perform level order\n    # traversal on the tree\n    while (len(q) > 0):\n \n        # Stores the size of\n        # the queue\n        count = len(q)\n \n        # Update maximum width\n        result = max(count, result)\n \n        # Push the nodes of the next\n        # level and pop the elements\n        # of the current level\n        while (count > 0):\n \n            # Get element from the\n            # front the Queue\n            temp = q.popleft()\n \n            # Push all nodes of the next level.\n            for i in adj[temp]:\n                q.append(i)\n                 \n            count -= 1\n \n    # Return the result.\n    return result\n \n# Driver Code\nif __name__ == '__main__':\n     \n    N = 11\n    M = 10\n \n    edges = []\n    edges.append([0, 1])\n    edges.append([0, 2])\n    edges.append([0, 3])\n    edges.append([1, 4])\n    edges.append([1, 5])\n    edges.append([3, 6])\n    edges.append([4, 7])\n    edges.append([6, 1])\n    edges.append([6, 8])\n    edges.append([6, 9])\n \n    cost = [ 1, 2, -1, 3, 4, 5,\n             8, 2, 6, 12, 7] \n     \n    # Constructed tree is:\n    #           1\n    #         / | \\\n    #        2 -1  3\n    #       / \\       \\\n    #      4   5        8\n    #     /          / | \\\n    #  2         6  12  7\n    print(maxWidth(N, M, cost, edges))\n \n# This code is contributed by mohit kumar 29\n"], "Average width in a N-ary tree -  ": ["# Python3 program for the above approach\nans = []\n \n# Node structure\nclass Node:\n    def __init__(self, key):\n        self.val = key\n        self.child = []\n \n# Utility function to create a new\n# tree node\ndef newNode(key):\n    temp = Node(key)\n    return temp\n \n# Function to find levels and\n# subtree sizes\ndef UtilityFun(root, ans):\n    if (root == None):\n        return [ 0, 0 ]\n \n    # Num nodes and level with just\n    # a single node\n    totalNodes, totalLevels = 1, 1\n \n    # Recur for all children\n    for i in range(len(root.child)):\n        info = UtilityFun(root.child[i], ans)\n        totalNodes += info[0]\n        totalLevels = max(totalLevels, 1 + info[1])\n \n    # Finding the current Width\n    currentAverageWidth = int(totalNodes / totalLevels)\n \n    # Storing in ans\n    ans.append([ root.val, currentAverageWidth ])\n \n    return [ totalNodes, totalLevels ]\n \n# Function to find the average width\n# of all nodes\ndef findAvgWidth(root):\n    if (root == None):\n        return []\n \n    # Function Call\n    UtilityFun(root, ans)\n    return ans\n \n# Function to display the values\ndef display(ans):\n    for i in range(len(ans)):\n        print(ans[i][0], ':', ans[i][1], ', ', sep='',end='')\n \n# Given Input\nroot = newNode(1)\n(root.child).append(newNode(2))\n(root.child).append(newNode(3))\n(root.child[0].child).append(newNode(4))\n(root.child[1].child).append(newNode(5))\n(root.child[0].child).append(newNode(6))\n(root.child[1]).child.append(newNode(7))\n(root.child[1].child).append(newNode(8))\n \n# Function Call\nfindAvgWidth(root)\n \n# Function Call\ndisplay(ans)\n \n# This code is contributed by divyesh072019.\n"], "Minimum distance between two given nodes in an N-ary tree -  ": ["# Python3 program for the above approach\n \n# Structure of Node\nclass Node:\n    def __init__(self, key):\n        self.val = key\n        self.left = None\n        self.right = None\n        self.child = []\n \n# Utility function to create a\n# new tree node\ndef newNode(key):\n    temp = Node(key)\n    return temp\n \nflag = 0\n \n# Function to get the path\n# from root to a node\ndef findPath(root, key, arr):\n    global flag\n    if (root==None):\n        return\n    arr.append(root.val)\n    # if key is found set flag and return\n    if (root.val == key):\n        flag = 1\n        return\n    # recur for all children\n    for i in range(len(root.child)):\n        findPath(root.child[i], key, arr)\n \n        # if key is found dont need to pop values\n        if (flag == 1):\n            return\n \n    arr.pop()\n    return\n \ndef findMinDist(root, A, B):\n    global flag\n    if (root == None):\n        return\n    val = root.val\n \n    # vector to store both paths\n    arr1 = []\n    arr2 = []\n \n    # set flag as false;\n    flag = 0\n \n    # find path from root to node a\n    findPath(root, A, arr1)\n \n    # set flag again as false;\n    flag = 0\n \n    # find path from root to node b\n    findPath(root, B, arr2)\n \n    # to store index of LCA node\n    j=0\n \n    # if unequal values are found\n    # return previous value\n    for i in range(min(len(arr1), len(arr2))):\n        if (arr1[i] != arr2[i]):\n            val = arr1[i - 1]\n            j = i - 1\n            break\n    d1, d2 = 0, 0\n \n    # iterate for finding distance\n    # between LCA(a, b) and a\n    for i in range(j, len(arr1)):\n        if (arr1[i] == A):\n            break\n        else:\n            d1 += 1\n \n    # iterate for finding distance\n    # between LCA(a, b) and b\n    for i in range(j, len(arr2)):\n        if (arr2[i] == B):\n            break\n        else:\n            d2 += 1\n    # get distance\n    val = d1 + d2\n    print(val)\n \nroot = newNode(1)\n(root.child).append(newNode(2))\n(root.child).append(newNode(3))\n(root.child[0].child).append(newNode(4))\n(root.child[0].child).append(newNode(5))\n(root.child[1].child).append(newNode(6))\n(root.child[1]).child.append(newNode(7))\n(root.child[1].child).append(newNode(8))\nA, B = 4, 3\n \n# get min distance\nfindMinDist(root, A, B)\n \n# This code is contributed by rameshtravel07.\n"], "Print all root to leaf paths of an N-ary tree -  ": ["# Python3 program for the above approach\n \n# Structure of an N ary tree node\nclass Node:\n     \n    def __init__(self, x):\n         \n        self.data = x\n        self.child = []\n \n# Function to print the root to leaf\n# path of the given N-ary Tree\ndef printPath(vec):\n     \n    # Print elements in the vector\n    for ele in vec:\n        print(ele, end = ' ')\n         \n    print()\n \n# Utility function to print all\n# root to leaf paths of an Nary Tree\ndef printAllRootToLeafPaths(root):\n     \n    global vec\n     \n    # If root is null\n    if (not root):\n        return\n \n    # Insert current node's\n    # data into the vector\n    vec.append(root.data)\n \n    # If current node is a leaf node\n    if (len(root.child) == 0):\n \n        # Print the path\n        printPath(vec)\n \n        # Pop the leaf node\n        # and return\n        vec.pop()\n        return\n \n    # Recur for all children of\n    # the current node\n    for i in range(len(root.child)):\n \n        # Recursive Function Call\n        printAllRootToLeafPaths(root.child[i])\n         \n    vec.pop()    \n \n# Function to print root to leaf path\ndef printRootToLeafPaths(root):\n     \n    global vec\n     \n    # If root is null, return\n    if (not root):\n        return\n \n    # Utility function call\n    printAllRootToLeafPaths(root)\n \n# Driver Code\nif __name__ == '__main__':\n     \n    # Given N-Ary tree\n    vec = []\n    root = Node(1)\n    root.child.append(Node(2))\n    root.child.append(Node(3))\n    root.child[0].child.append(Node(4))\n    root.child[1].child.append(Node(5))\n    root.child[1].child.append(Node(6))\n    root.child[1].child[1].child.append(Node(7))\n    root.child[1].child[1].child.append(Node(8))\n \n    # Function Call\n    printRootToLeafPaths(root)\n \n# This code is contributed by mohit kumar 29\n"], "Number of leaf nodes in a perfect N-ary tree of height K -  ": ["# python code to implement the approach\nmod = 1e9 + 7\n \n# Find the number of leaf nodes in a\n# perfect k-ary tree of height m\ndef karyTree(N, K):\n   \n    # Initialize variable\n    res = 1\n \n    # Run until height is positive\n    while (K > 0):\n        if (K & 1):\n            res = (res * N) % mod\n        N = (N * N) % mod\n        K >>= 1\n \n    # Return answer\n    return res\n \n# Driver code\nN,K = 2,2\n \n# Function call\nprint(karyTree(N, K))\n \n# This code is contributed by ishankhandelwals\n"], "Maximum level sum in N-ary Tree -  ": ["# Python3 program for the above approach\nfrom collections import deque\n \n# Function to find the maximum sum\n# a level in N-ary treeusing BFS\ndef maxLevelSum(N, M, Value, Edges):\n     \n    # Stores the edges of the graph\n    adj = [[] for i in range(N)]\n \n    # Create Adjacency list\n    for i in range(M):\n        adj[Edges[i][0]].append(Edges[i][1])\n \n    # Initialize result\n    result = Value[0]\n \n    # Stores the nodes of each level\n    q = deque()\n \n    # Insert root\n    q.append(0)\n \n    # Perform level order traversal\n    while (len(q) > 0):\n \n        # Count of nodes of the\n        # current level\n        count = len(q)\n \n        sum = 0\n \n        # Traverse the current level\n        while (count):\n \n            # Dequeue a node from queue\n            temp = q.popleft()\n \n            # Update sum of current level\n            sum = sum + Value[temp]\n \n            # Enqueue the children of\n            # dequeued node\n            for i in range(len(adj[temp])):\n                q.append(adj[temp][i])\n                 \n            count -= 1\n \n        # Update maximum level sum\n        result = max(sum, result)\n \n    # Return the result\n    return result\n \n# Driver Code\nif __name__ == '__main__':\n     \n    # Number of nodes\n    N = 10\n \n    # Edges of the N-ary tree\n    Edges = [ [ 0, 1 ], [ 0, 2 ],\n              [ 0, 3 ], [ 1, 4 ],\n              [ 1, 5 ], [ 3, 6 ],\n              [ 6, 7 ], [ 6, 8 ],\n              [ 6, 9 ] ]\n               \n    # Given cost\n    Value = [ 1, 2, -1, 3, 4, \n              5, 8, 6, 12, 7 ]\n \n    # Function call\n    print(maxLevelSum(N, N - 1, \n                      Value, Edges))\n \n# This code is contributed by mohit kumar 29\n"], "Determine the count of Leaf nodes in an N-ary tree -  ": ["# Python3 program to find number \n# of leaf nodes \n \n# Function to calculate \n# leaf nodes in n-ary tree \ndef calcNodes(N, I):\n    result = 0\n \n    result = I * (N - 1) + 1\n \n    return result \n \n# Driver Code \nif __name__ == '__main__':\n    N = 5\n    I = 2\n \n    print('Leaf nodes = ', \n           calcNodes(N, I))\n \n# This code is contributed \n# by SHUBHAMSINGH10\n"], "Path from the root node to a given node in an N-ary Tree -  ": ["# Python3 program for the above approach\nfrom bisect import bisect_left\n \n# Function to find the path\n# from root to N\ndef PrintPathNodes(N):\n \n    # Stores the number of\n    # nodes at (i + 1)-th level\n    arr = []\n    arr.append(1)\n \n    # Stores the number of nodes\n    k = 1\n \n    # Stores if the current\n    # level is even or odd\n    flag = True\n    while (k < N):\n \n        # If level is odd\n        if (flag == True):\n            k *= 2\n            flag = False\n \n        # If level is even\n        else:\n            k *= 4\n            flag = True\n \n        # If level with\n        # node N is reached\n        if (k > N):\n            break\n \n        # Push into vector\n        arr.append(k)\n    lenn = len(arr)\n    prefix = [0]*(lenn)\n    prefix[0] = 1\n \n    # Compute prefix sums of count\n    # of nodes in each level\n    for i in range(1,lenn):\n        prefix[i] = arr[i] + prefix[i - 1]\n    it = bisect_left(prefix, N)\n \n    # Stores the level in which\n    # node N s present\n    ind = it\n    temp = N\n \n    # Store path\n    path = []\n    path.append(N)\n    while (ind > 1):\n        val = temp - prefix[ind - 1]\n \n        if (ind % 2 != 0):\n            temp = prefix[ind - 2] + (val + 1) // 2\n        else:\n            temp = prefix[ind - 2] + (val + 3) // 4\n        ind -= 1\n \n        # Insert temp into path\n        path.append(temp)\n    if (N != 1):\n        path.append(1)\n \n    # Print path\n    for i in range(len(path)-1, -1, -1):\n        print(path[i], end=' ')\n \n# Driver Code\nif __name__ == '__main__':\n    N = 14\n \n    # Function Call\n    PrintPathNodes(N)\n \n    # This code is contributed by mohit kumar 29\n"], "Replace each node in given N-ary Tree with sum of all its subtrees -  ": ["# Python implementation of the approach\n \n# Class for the node of the tree\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.children = []\n \n# Function to replace node with\n# sum of its left subtree, right\n# subtree and its sum\ndef sumReplacementNary(node):\n    if (node == None):\n        return 0\n \n    # Total children count\n    total = len(node.children)\n \n    # Taking sum of all the nodes\n    for i in range(0, total):\n        node.data += sumReplacementNary(node.children[i])\n \n    return node.data\n \n \ndef preorderTraversal(node):\n    if (node == None):\n        return\n \n    # Total children count\n    total = len(node.children)\n \n    # Print the current node's data\n    print(node.data, end=' ')\n \n    # All the children except the last\n    for i in range(0, total):\n        preorderTraversal(node.children[i])\n \n# Driver code\n# Create the following tree\n#            1\n#          / | \\\n#         2  3  4\n#       / \\ \\\n#      5  6  7\n \n \nroot = Node(1)\nroot.children.append(Node(2))\nroot.children.append(Node(3))\nroot.children.append(Node(4))\nroot.children[0].children.append(Node(5))\nroot.children[0].children.append(Node(6))\nroot.children[0].children.append(Node(7))\n \nprint('Initial Pre-order Traversal: ')\npreorderTraversal(root)\nprint('\\n')\n \nprint('Final Pre-order Traversal: ')\nsumReplacementNary(root)\npreorderTraversal(root)\n"], "Maximum value at each level in an N-ary Tree -  ": ["# Python3 program for the above approach\n \n# Function to find the maximum value\n# at each level of N-ary tree\ndef maxAtLevel(N, M, Value, Edges):\n     \n    # Stores the adjacency list\n    adj = [[] for i in range(N)]\n \n    # Create the adjacency list\n    for i in range(M):\n        u = Edges[i][0]\n        v = Edges[i][1]\n        adj[u].append(v)\n \n    # Perform level order traversal\n    # of nodes at each level\n    q = []\n \n    # Push the root node\n    q.append(0)\n \n    # Iterate until queue is empty\n    while (len(q)):\n         \n        # Get the size of queue\n        count = len(q)\n \n        maxVal = 0\n \n        # Iterate for: all the nodes\n        # in the queue currently\n        while (count):\n             \n            # Dequeue an node from queue\n            temp = q[0]\n            q.remove(q[0])\n \n            maxVal = max(maxVal, Value[temp])\n \n            # Enqueue the children of\n            # dequeued node\n            for i in range(len(adj[temp])):\n                q.append(adj[temp][i])\n                 \n            count -= 1\n \n        # Print the result\n        print(maxVal, end = ' ')\n \n# Driver Code\nif __name__ == '__main__':\n     \n    # Number of nodes\n    N = 10\n \n    # Edges of the N-ary tree\n    Edges = [ [ 0, 1 ], [ 0, 2 ],\n              [ 0, 3 ], [ 1, 4 ],\n              [ 1, 5 ], [ 3, 6 ],\n              [ 6, 7 ], [ 6, 8 ],\n              [ 6, 9 ] ]\n \n    # Given cost\n    Value = [ 1, 2, -1, 3, 4, \n              5, 8, 6, 12, 7 ]\n \n    # Function Call\n    maxAtLevel(N, N - 1, Value, Edges)\n \n# This code is contributed by ipg2016107\n"], "Preorder Traversal of N-ary Tree Without Recursion -  ": ["# Python3 program to find height of \n# full binary tree \n# using preorder\n \nclass newNode(): \n   \n    def __init__(self, key): \n        self.key = key\n        # all children are stored in a list \n        self.child =[]\n         \n# Function to traverse tree without recursion \ndef traverse_tree(root):\n  \n    # Stack to store the nodes \n    nodes=[]\n \n    # push the current node onto the stack \n    nodes.append(root) \n   \n    # loop while the stack is not empty \n    while (len(nodes)):  \n   \n        # store the current node and pop it from the stack \n        curr = nodes[0] \n        nodes.pop(0) \n   \n        # current node has been travarsed \n        print(curr.key,end=' ')\n        # store all the childrent of current node from \n        # right to left. \n        for it in range(len(curr.child)-1,-1,-1):  \n            nodes.insert(0,curr.child[it])\n  \n          \n# Driver program to test above functions \nif __name__ == '__main__':\n    '''   Let us create below tree  \n   *            A  \n   *        /  / \\  \\  \n   *       B  F   D  E  \n   *      / \\     |  /|\\  \n   *     K  J     G C H I  \n   *    / \\         |   |  \n   *   N   M        O   L  \n   '''\n    root = newNode('A') \n    (root.child).append(newNode('B')) \n    (root.child).append(newNode('F')) \n    (root.child).append(newNode('D')) \n    (root.child).append(newNode('E')) \n    (root.child[0].child).append(newNode('K')) \n    (root.child[0].child).append(newNode('J')) \n    (root.child[2].child).append(newNode('G')) \n    (root.child[3].child).append(newNode('C')) \n    (root.child[3].child).append(newNode('H')) \n    (root.child[3].child).append(newNode('I')) \n    (root.child[0].child[0].child).append(newNode('N')) \n    (root.child[0].child[0].child).append(newNode('M')) \n    (root.child[3].child[0].child).append(newNode('O')) \n    (root.child[3].child[2].child).append(newNode('L')) \n   \n    traverse_tree(root)\n  \n# This code is contributed by SHUBHAMSINGH10\n"], "Check mirror in n-ary tree -  ": ["# Python3 program to check if two n-ary trees are mirror.\n \n# Function to check given two trees are mirror\n# of each other or not\ndef checkMirrorTree(M, N, u1, v1, u2, v2):\n    # Map to store nodes of the tree\n    mp = {}\n \n    # Traverse first tree nodes\n    for i in range(N):\n        if u1[i] in mp:\n            mp[u1[i]].append(v1[i])\n        else:\n            mp[u1[i]] = []\n      \n    # Traverse second tree nodes\n    for i in range(N):\n        if u2[i] in mp and len(mp[u2[i]]) > 0:\n            if(mp[u2[i]][-1] != v2[i]):\n                return 0\n            mp[u2[i]].pop()\n    return 1\n \nM, N = 7, 6\n      \n#Tree 1\nu1 = [ 1, 1, 1, 10, 10, 10 ]\nv1 = [ 10, 7, 3, 4, 5, 6 ]\n \n#Tree 2\nu2 = [ 1, 1, 1, 10, 10, 10 ]\nv2 = [ 3, 7, 10, 6, 5, 4 ]\n \nif(checkMirrorTree(M, N, u1, v1, u2, v2)):\n   print('Yes')\nelse:\n   print('No')\n     \n    # This code is contributed by rameshtravel07.\n", "# Python3 program to check two n-ary trees are mirror.\n \n# Function to check given two trees are mirror\n# of each other or not\ndef checkMirrorTree(n, e, A, B):\n    # Lists to store nodes of the tree\n    s = []\n    q = []\n \n    # initializing both list with empty stack and queue\n    for i in range(n + 1):\n        s.append([])\n        queue = []\n        q.append(queue)\n \n   # add all nodes of tree 1 to\n   # list of stack and tree 2 to list of queue\n    for i in range(0, 2 * e, 2):\n        s[A[i]].append(A[i + 1])\n        q[B[i]].append(B[i + 1])\n \n    # now take out the stack and queues\n    # for each of the nodes and compare them\n    # one by one\n    for i in range(1, n + 1):\n        while (len(s[i]) > 0 and len(q[i]) > 0):\n            a = s[i][len(s[i]) - 1]\n            s[i].pop()\n            b = q[i][0]\n            q[i].pop(0)\n \n            if (a != b):\n                return 0\n    return 1\n \n  # Driver code\nn = 3\ne = 2\nA = [ 1, 2, 1, 3 ]\nB = [ 1, 3, 1, 2 ]\n \nif (checkMirrorTree(n, e, A, B) == 1):\n    print('Yes')\nelse:\n    print('No')\n     \n    # This code is contributed by decode2207.\n"], "Number of nodes greater than a given value in n-ary tree -  ": ["# Python3 program to find number of nodes \n# greater than x \n \n# Structure of a node of n-ary tree \nclass Node: \n    def __init__(self, data): \n        self.key = data \n        self.child = [] \n \n# Function to find number of nodes \n# greater than x \ndef nodesGreaterThanX(root: Node, x: int) -> int: \n    if root is None: \n        return 0\n \n    count = 0\n \n    # if current root is greater \n    # than x increment count \n    if root.key > x: \n        count += 1\n \n    # Number of children of root \n    numChildren = len(root.child) \n \n    # recursively calling for every child \n    for i in range(numChildren): \n        child = root.child[i] \n        count += nodesGreaterThanX(child, x) \n \n    # return the count \n    return count \n \n# Driver Code \nif __name__ == '__main__': \n \n    ans = 0\n    k = 25\n \n    # Let us create below tree \n    # 5 \n    #         / | \\ \n    # 1 2 3 \n    #     / / \\ \\ \n    # 15 4 5 6 \n \n    root = Node(5) \n    (root.child).append(Node(1)) \n    (root.child).append(Node(2)) \n    (root.child).append(Node(3)) \n    (root.child[0].child).append(Node(15)) \n    (root.child[1].child).append(Node(4)) \n    (root.child[1].child).append(Node(5)) \n    (root.child[2].child).append(Node(6)) \n \n    x = 5\n \n    print('Number of nodes greater than % d are % d' %\n        (x, nodesGreaterThanX(root, x))) \n \n# This code is contributed by \n# sanjeev2552 \n"], "Number of children of given node in n-ary Tree -  ": ["# Python3 program to find number\n# of children of given node\n \n# Node of a linked list \nclass Node: \n    def __init__(self, data = None): \n        self.key = data \n        self.child = []\n \n# Function to calculate number\n# of children of given node\ndef numberOfChildren( root, x):\n \n    # initialize the numChildren as 0\n    numChildren = 0\n \n    if (root == None):\n        return 0\n \n    # Creating a queue and appending the root\n    q = []\n    q.append(root)\n \n    while (len(q) > 0) :\n        n = len(q)\n \n        # If this node has children\n        while (n > 0): \n \n            # Dequeue an item from queue and\n            # check if it is equal to x\n            # If YES, then return number of children\n            p = q[0]\n            q.pop(0)\n            if (p.key == x) :\n                numChildren = numChildren + len(p.child)\n                return numChildren\n             \n            i = 0\n             \n            # Enqueue all children of the dequeued item\n            while ( i < len(p.child)):\n                q.append(p.child[i])\n                i = i + 1\n            n = n - 1\n \n    return numChildren\n \n# Driver program\n \n# Creating a generic tree\nroot = Node(20)\n(root.child).append(Node(2))\n(root.child).append(Node(34))\n(root.child).append(Node(50))\n(root.child).append(Node(60))\n(root.child).append(Node(70))\n(root.child[0].child).append(Node(15))\n(root.child[0].child).append(Node(20))\n(root.child[1].child).append(Node(30))\n(root.child[2].child).append(Node(40))\n(root.child[2].child).append(Node(100))\n(root.child[2].child).append(Node(20))\n(root.child[0].child[1].child).append(Node(25))\n(root.child[0].child[1].child).append(Node(50))\n \n# Node whose number of\n# children is to be calculated\nx = 50\n \n# Function calling\nprint( numberOfChildren(root, x) )\n \n# This code is contributed by Arnab Kundu\n"], "Second Largest element in n-ary tree -  ": ["# Utility class representing a node of n-ary tree\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.child = []\n \n# Utility function to create a new tree node\ndef newNode(key):\n    temp = Node(key)\n    return temp\n \ndef secondLargestUtil(root, first, second):\n    if root is None:\n        return\n \n    # If first is None, make root equal to first\n    if first[0] is None:\n        first[0] = root\n \n    # if root is greater than first then second\n    # will become first and update first equal\n    # to root\n    elif root.key > first[0].key:\n        second[0] = first[0]\n        first[0] = root\n    # if second is None, then\n    # update first only if root is less than first\n    elif second[0] is None:\n        if root.key < first[0].key:\n            second[0] = root\n \n    # If root is less than first but greater than second\n    elif root.key < first[0].key and root.key > second[0].key:\n        second[0] = root\n \n    # Recursively calling for every child\n    for i in range(len(root.child)):\n        secondLargestUtil(root.child[i], first, second)\n \ndef secondLargest(root):\n    # second will store the second highest value\n    second = [None]\n \n    # first will store the largest value in the tree\n    first = [None]\n \n    # calling the helper function\n    secondLargestUtil(root, first, second)\n \n    if second[0] is None:\n        return None\n \n    # return the second largest element\n    return second[0]\n \n# Driver program\nif __name__ == '__main__':\n    '''\n    Let us create below tree\n           5\n       /   |  \\\n       1   2   3\n      /   / \\   \\\n     15  4   5   6\n    '''\n    root = newNode(5)\n    root.child.append(newNode(1))\n    root.child.append(newNode(2))\n    root.child.append(newNode(3))\n    root.child[0].child.append(newNode(15))\n    root.child[1].child.append(newNode(4))\n    root.child[1].child.append(newNode(5))\n    root.child[2].child.append(newNode(6))\n \n    result = secondLargest(root)\n    if result is not None:\n        print('Second largest element is : ', result.key)\n    else:\n        print('Second largest element not found')\n \n# This code is contributed by lokeshpotta20.\n"], "Largest element in an N-ary Tree -  ": ["# Python3 program for the above approach\n \n# Structure of a\n# node of N-ary tree\nclass Node:\n    # Constructor to set the data of\n    # the newly created tree node\n    def __init__(self, key):\n        self.key = key\n        self.child = []\n \n# Stores the node with largest value\nmaximum = None\n \n# Function to create a new Node\ndef newNode(key):\n    temp = Node(key)\n \n    # Return the newly created node\n    return temp\n \n# Function to find the node with\n# largest value in N-ary tree\ndef findlargest(root):\n    global maximum\n    # Base Case\n    if (root == None):\n        return\n \n    # If maximum is null, return\n    # the value of root node\n    if ((maximum) == None):\n        maximum = root\n \n    # If value of the root is greater\n    # than maximum, update the maximum node\n    elif (root.key > (maximum).key):\n        maximum = root\n \n    # Recursively call for all the\n    # children of the root node\n    for i in range(len(root.child)):\n        findlargest(root.child[i])\n \n# Given N-ary tree\nroot = newNode(11)\n(root.child).append(newNode(21))\n(root.child).append(newNode(29))\n(root.child).append(newNode(90))\n(root.child[0].child).append(newNode(18))\n(root.child[1].child).append(newNode(10))\n(root.child[1].child).append(newNode(12))\n(root.child[2].child).append(newNode(77))\n \nfindlargest(root)\n \n# Print the largest value\nprint(maximum.key)\n \n# This code is contributed by decode2207.\n"], "Check if the given n-ary tree is a binary tree -  ": ["# Python implementation of the approach\n \n# Structure of a node of an n-ary tree\nclass Node:\n \n    def __init__(self,key):\n     \n        self.key = key\n        self.child = []\n     \n \n# Utility function to create\n# a new tree node\ndef newNode(key):\n \n    temp = Node(key)\n    return temp\n \n# Function that returns true\n# if the given tree is binary\ndef isBinaryTree(root):\n     \n    # Base case\n    if (root == None):\n        return True\n \n    # Count will store the number of\n    # children of the current node\n    count = 0\n    for i in range(len(root.child)):\n         \n        # If any child of the current node doesn't\n        # satisfy the condition of being\n        # a binary tree node\n        if (isBinaryTree(root.child[i]) == False):\n            return False\n \n        # Increment the count of children\n        count += 1\n \n        # If current node has more\n        # than 2 children\n        if (count > 2):\n            return False\n     \n    return True\n \n# Driver code\nroot = newNode('A')\n(root.child).append(newNode('B'))\n(root.child).append(newNode('C'))\n(root.child[0].child).append(newNode('D'))\n(root.child[0].child).append(newNode('E'))\n(root.child[1].child).append(newNode('F'))\n \nif (isBinaryTree(root)):\n    print('Yes')\nelse:\n    print('No')\n \n# This code is contributed by shinjanpatra\n"], "Serialize and Deserialize an N-ary Tree -  ": ["# A Python program to serialize and deserialize an N-ary tree\nimport sys\n \n# A node of N-ary tree\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.children = []\n \n# A utility function to create a new N-ary tree node\ndef newNode(key):\n    temp = Node(key)\n    return temp\n \n# This function stores the given N-ary tree in a file pointed by fp\ndef serialize(root, fp):\n    # Base case\n    if not root:\n        return\n \n    # Else, store current node and recur for its children\n    fp.write(root.key + ' ')\n    for child in root.children:\n        serialize(child, fp)\n \n    # Store marker at the end of children\n    fp.write(') ')\n \n# This function constructs N-ary tree from a file pointed by 'fp'.\n# This function returns 0 to indicate that the next item is a valid\n# tree key. Else returns 0\ndef deSerialize(fp):\n    # Read next item from file. If there are no more items or next\n    # item is marker, then return None to indicate same\n    val = fp.read(1)\n    if not val or val == ')':\n        return None\n \n    # Else create node with this item and recur for children\n    root = newNode(val)\n    while True:\n        child = deSerialize(fp)\n        if not child:\n            break\n        root.children.append(child)\n \n    # Finally return the node for successful finish\n    return root\n \n# A utility function to create a dummy tree shown in above diagram\ndef createDummyTree():\n    root = newNode('A')\n    root.children = [newNode('B'), newNode('C'), newNode('D')]\n    root.children[0].children = [newNode('E'), newNode('F')]\n    root.children[2].children = [newNode('G'), newNode('H'), newNode('I'), newNode('J')]\n    root.children[0].children[1].children = [newNode('K')]\n    return root\n \n# A utility function to traverse the constructed N-ary tree\ndef traverse(root):\n    if root:\n        print(root.key, end=' ')\n        for child in root.children:\n            traverse(child)\n \n# Driver program to test above functions\ndef main():\n    # Let us create an N-ary tree shown in above diagram\n    root = createDummyTree()\n \n    # Let us open a file and serialize the tree into the file\n    fp = open('tree.txt', 'w')\n    serialize(root, fp)\n    fp.close()\n \n    # Let us deserialize the stored tree into root1\n    fp = open('tree.txt', 'r')\n    root1 = deSerialize(fp)\n    fp.close()\n \n    print('Constructed N-Ary Tree from file is ')\n    traverse(root1)\n \nif __name__ == '__main__':\n    main()\n"], "Sum of all elements of N-ary Tree -  ": ["# Python3 program to find sum of all\n# elements in generic tree\n \n# Represents a node of an n-ary tree\nclass Node:\n    def __init__(self):\n        self.key = 0\n        self.child = []\n \n# Utility function to create a new tree node\ndef newNode(key):\n    temp = Node()\n    temp.key = key\n    temp.child = []\n    return temp\n  \n# Function to compute the sum\n# of all elements in generic tree\ndef sumNodes(root):\n    # initialize the sum variable\n    Sum = 0\n  \n    if root == None:\n        return 0\n  \n    # Creating a queue and pushing the root\n    q = []\n    q.append(root)\n  \n    while len(q) != 0:\n        n = len(q)\n  \n        # If this node has children\n        while n > 0:\n            # Dequeue an item from queue and\n            # add it to variable 'sum'\n            p = q[0]\n            q.pop(0)\n            Sum += p.key\n  \n            # push all children of the dequeued item\n            for i in range(len(p.child)):\n                q.append(p.child[i])\n            n-=1\n    return Sum\n \n# Creating a generic tree\nroot = newNode(20)\n(root.child).append(newNode(2))\n(root.child).append(newNode(34))\n(root.child).append(newNode(50))\n(root.child).append(newNode(60))\n(root.child).append(newNode(70))\n(root.child[0].child).append(newNode(15))\n(root.child[0].child).append(newNode(20))\n(root.child[1].child).append(newNode(30))\n(root.child[2].child).append(newNode(40))\n(root.child[2].child).append(newNode(100))\n(root.child[2].child).append(newNode(20))\n(root.child[0].child[1].child).append(newNode(25))\n(root.child[0].child[1].child).append(newNode(50))\nprint(sumNodes(root))\n \n# This code is contributed by divyeshrabadiya07.\n"], "Diameter of an N-ary tree -  ": ["# Python program to find the height of an N-ary \n# tree \n  \n# Structure of a node of an n-ary tree \nclass Node: \n    def __init__(self, x): \n        self.key = x \n        self.child = [] \n  \n# Utility function that will return the depth \n# of the tree \ndef depthOfTree(ptr): \n      \n    # Base case \n    if (not ptr): \n        return 0\n    maxdepth = 0\n  \n    # Check for all children and find \n    # the maximum depth \n    for it in ptr.child: \n        maxdepth = max(maxdepth , depthOfTree(it)) \n    return maxdepth + 1\n  \n# Function to calculate the diameter \n# of the tree \ndef diameter(ptr): \n      \n    # Base case \n    if (not ptr): \n        return 0\n  \n    # Find top two highest children \n    max1, max2 = 0, 0\n    for it in ptr.child: \n        h = depthOfTree(it) \n        if (h > max1): \n           max2, max1 = max1, h \n        elif (h > max2): \n           max2 = h \n  \n    # Iterate over each child for diameter \n    maxChildDia = 0\n    for it in ptr.child: \n        maxChildDia = max(maxChildDia, diameter(it)) \n    return max(maxChildDia, max1 + max2 + 1) \n  \n# Driver program \nif __name__ == '__main__': \n    # /*   Let us create below tree \n    # *           A \n    # *         / /  \\  \\ \n    # *       B  F   D  E \n    # *      / \\     |  /|\\ \n    # *     K  J    G  C H I \n    # *      /\\            \\ \n    # *    N   M            L \n    # */ \n  \n    root = Node('A') \n    (root.child).append(Node('B')) \n    (root.child).append(Node('F')) \n    (root.child).append(Node('D')) \n    (root.child).append(Node('E')) \n    (root.child[0].child).append(Node('K')) \n    (root.child[0].child).append(Node('J')) \n    (root.child[2].child).append(Node('G')) \n    (root.child[3].child).append(Node('C')) \n    (root.child[3].child).append(Node('H')) \n    (root.child[3].child).append(Node('I')) \n    (root.child[0].child[0].child).append(Node('N')) \n    (root.child[0].child[0].child).append(Node('M')) \n    (root.child[3].child[2].child).append(Node('L')) \n  \n    print(diameter(root)) \n  \n# This code is contributed by mohit kumar 29\n", "# Python3 program to find the height of an N-ary \n# tree \n  \n# Structure of a node of an n-ary tree \n# Structure of a node of an n-ary tree \nclass Node: \n  \n    # Utility function to create a tree node \n    def __init__(self, key): \n  \n        self.key = key; \n        self.child = []; \ndiameter_of_tree = 0; \n  \ndef diameter(ptr): \n    global diameter_of_tree \n  \n    # Base case \n    # Base case \n    if (ptr == None): \n        return 0; \n  \n    # Find top two highest children \n    max1 = 0\n    max2 = 0; \n    for it in range(len(ptr.child)): \n  \n        h = diameter(ptr.child[it]); \n        if (h > max1): \n            max2 = max1 \n            max1 = h; \n        elif (h > max2): \n            max2 = h; \n  \n    # Find whether our node can be part of diameter \n    diameter_of_tree = max(max1 + max2 + 1, diameter_of_tree); \n  \n    return max(max1,max2) + 1; \n  \ndef main(): \n    ''' us create below tree \n        *         A \n        *         / / \\ \\ \n        *     B F D E \n        *     / \\ / /|\\ \n        *     K J G C H I \n        *     /\\         | \n        * N M     L \n    '''\n    root = Node('A'); \n    (root.child).append(Node('B')); \n    (root.child).append(Node('F')); \n    (root.child).append(Node('D')); \n    (root.child).append(Node('E')); \n    (root.child[0].child).append(Node('K')); \n    (root.child[0].child).append(Node('J')); \n    (root.child[2].child).append(Node('G')); \n    (root.child[3].child).append(Node('C')); \n    (root.child[3].child).append(Node('H')); \n    (root.child[3].child).append(Node('I')); \n    (root.child[0].child[0].child).append(Node('N')); \n    (root.child[0].child[0].child).append(Node('M')); \n    (root.child[3].child[2].child).append(Node('L')); \n      \n    diameter(root); \n      \n    print(diameter_of_tree); \n  \nmain() \n  \n# This code is contributed by phasing17. \n", "# C++ implementation to find \n# diameter of a tree using \n# DFS in ONE TRAVERSAL \nmaxN = 10005\n  \n# The array to store the \n# height of the nodes \nheight = [0 for i in range(maxN)] \n  \n# Adjacency List to store \n# the tree \ntree = [[] for i in range(maxN)] \n  \n# variable to store diameter \n# of the tree \ndiameter = 0\n  \n# Function to add edge between \n# node u to node v \ndef addEdge(u, v): \n    \n    # add edge from u to v \n    tree[u].append(v) \n      \n    # add edge from v to u \n    tree[v].append(u) \n  \ndef dfs(cur, par): \n    global diameter \n      \n    # Variables to store the height of children \n    # of cur node with maximum heights \n    max1 = 0\n    max2 = 0\n      \n    # going in the adjacency list of the current node \n    for u in tree[cur]: \n        \n        # if that node equals parent discard it \n        if(u == par): \n            continue\n          \n        # calling dfs for child node \n        dfs(u, cur) \n          \n        # calculating height of nodes \n        height[cur] = max(height[cur], height[u]) \n          \n        # getting the height of children \n        # of cur node with maximum height \n        if(height[u] >= max1): \n            max2 = max1 \n            max1 = height[u] \n        elif(height[u] > max2): \n            max2 = height[u] \n    height[cur] += 1\n      \n    # Diameter of a tree can be calculated as \n    # diameter passing through the node \n    # diameter doesn't includes the cur node \n    diameter = max(diameter, height[cur]) \n    diameter = max(diameter, max1 + max2 + 1) \n  \n# Driver Code \n# n is the number of nodes in tree \nn = 7\n  \n# Adding edges to the tree \naddEdge(1, 2) \naddEdge(1, 3) \naddEdge(1, 4) \naddEdge(2, 5) \naddEdge(4, 6) \naddEdge(4, 7) \n  \n# Calling the dfs function to \n# calculate the diameter of tree \ndfs(1, 0) \n  \nprint('Diameter of tree is :', diameter - 1) \n  \n# This code is contributed by avanitrachhadiya2155\n"], "Insertion in n-ary tree in given order and Level order traversal -  ": ["# Python3 implementation of the approach\n \n# Node creation\nclass Node:\n \n    # Constructor\n    def __init__(self, data):  \n         \n        self.val = data\n         \n        # Since n children are possible for a root.\n        # A list created to store all the children.\n        self.child = []   \n \n \n# Function to insert\ndef insert(root, parent, node):\n     \n    # Root is empty then the node will become the root\n    if root is None:\n        root = node               \n \n    else:\n        if root.val == parent:\n            root.child.append(node)             \n        else:\n \n            # Recursive approach to \n            # insert the child\n            l = len(root.child)\n             \n            for i in range(l):\n                if root.child[i].val == parent:\n                    insert(root.child[i], parent, node)\n                else:\n                    insert(root.child[i], parent, node)\n \n# Function that calls levelorder method to \n# perform level order traversal\ndef levelorder_root(root):\n    if root:\n        level = []\n        level.append(root)\n        print(root.val)\n        levelorder(level)\n \n# Function to perform level order traversal\ndef levelorder(prev_level):\n \n    cur_level = []\n    print_data = []\n    l = len(prev_level)\n \n    if l == 0:\n        exit()\n \n    for i in range(l):    \n        prev_level_len = len(prev_level[i].child)\n \n        for j in range(prev_level_len):\n             \n            # enqueue all the children\n            # into cur_level list\n            cur_level.append(\n                   prev_level[i].child[j])  \n \n            # Copies the entire cur_level\n            # list into prev_level\n            print_data.append(\n                   prev_level[i].child[j].val)\n \n    prev_level = cur_level[:]                 \n    print(*print_data)\n    levelorder(prev_level)\n \n \n# Driver code\n \n# -1 is the root element    \narr = [-1, -1, -1, -1, -1]\nroot = Node(-1)\nl = len(arr)\nque = []\n \n# Inserting root element to the queue\nque.append(-1)\n \nwhile 1:\n    temp = []\n    for i in range(l):\n        if arr[i] in que:\n             \n            # Insert elements into the tree\n            insert(root, arr[i], Node(i)) \n            temp.append(i)\n \n    # Append child nodes into the queue\n    # and insert the child\n    que = temp[:]                      \n     \n    if len(que)== 0:\n        break\n \nlevelorder_root(root)    \n"], "Mirror of n-ary Tree -  ": ["# Python program to mirror an n-ary tree\n \n# Represents a node of an n-ary tree\nclass Node :\n \n    # Utility function to create a new tree node\n    def __init__(self ,key):\n        self.key = key \n        self.child = []\n \n \n# Function to convert a tree to its mirror\ndef mirrorTree(root):\n     \n    # Base Case : nothing to do if root is None\n    if root is None:\n        return\n     \n    # Number of children of root \n    n = len(root.child)\n \n    # If number of child is less than 2 i.e. \n    # 0 or 1 we don't need to do anything\n    if n <2 :\n        return\n     \n    # Calling mirror function for each child\n    for i in range(n):\n        mirrorTree(root.child[i]);\n     \n    # Reverse variable sized array of child pointers\n    root.child.reverse()\n     \n \n# Prints the n-ary tree level wise\n \ndef printNodeLevelWise(root):\n    if root is None:\n        return\n     \n    # create a queue and enqueue root to it\n    queue = []\n    queue.append(root)\n \n    # Do level order traversal. Two loops are used\n    # to make sure that different levels are printed\n    # in different lines\n    while(len(queue) >0):\n \n        n = len(queue)\n        while(n > 0) :\n \n            # Dequeue an item from queue and print it\n            p = queue[0]\n            queue.pop(0)\n            print(p.key,end=' ')\n     \n            # Enqueue all children of the dequeued item\n            for index, value in enumerate(p.child):\n                queue.append(value)\n \n            n -= 1\n        print() # Separator between levels\n         \n \n# Driver Program\n \n    '''   Let us create below tree\n    *              10\n    *        /   /    \\   \\\n    *        2  34    56   100\n    *                 |   /  | \\\n    *                 1   7  8  9\n    '''\n \nroot = Node(10)\nroot.child.append(Node(2))\nroot.child.append(Node(34))\nroot.child.append(Node(56))\nroot.child.append(Node(100))\nroot.child[2].child.append(Node(1))\nroot.child[3].child.append(Node(7))\nroot.child[3].child.append(Node(8))\nroot.child[3].child.append(Node(9))\n \nprint ('Level order traversal Before Mirroring')\nprintNodeLevelWise(root)\n \nmirrorTree(root)\n     \nprint ('\\nLevel Order traversal After Mirroring')\nprintNodeLevelWise(root)\n"], "Depth of an N-Ary tree -  ": ["# Python program to find the height of \n# an N-ary tree \n  \n# Structure of a node of an n-ary tree \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.child = [] \n  \n# Utility function to create a new tree node \ndef new_node(key): \n    temp = Node(key) \n    return temp \n  \n# Function that will return the depth \n# of the tree \ndef depth_of_tree(ptr): \n    # Base case \n    if ptr is None: \n        return 0\n  \n    # Check for all children and find \n    # the maximum depth \n    maxdepth = 0\n    for child in ptr.child: \n        maxdepth = max(maxdepth, depth_of_tree(child)) \n  \n    return maxdepth + 1\n  \n# Driver program \nif __name__ == '__main__': \n    ''' Let us create below tree \n            A \n        / / \\ \\ \n        B F D E \n        / \\ | /|\\ \n        K J G C H I \n        /\\         \\ \n        N M         L \n    '''\n  \n    root = new_node('A') \n    root.child.extend([new_node('B'), new_node('F'), new_node('D'), new_node('E')]) \n    root.child[0].child.extend([new_node('K'), new_node('J')]) \n    root.child[2].child.append(new_node('G')) \n    root.child[3].child.extend([new_node('C'), new_node('H'), new_node('I')]) \n    root.child[0].child[0].child.extend([new_node('N'), new_node('M')]) \n    root.child[3].child[2].child.append(new_node('L')) \n  \n    print(depth_of_tree(root)) \n"], "ZigZag Level Order Traversal of an N-ary Tree -  ": ["# Python3 program for the above approach\n \n# Structure of a tree node\nclass Node:\n    def __init__(self, key):\n        self.val = key\n        self.child = []\n \n# Function to create a new node\ndef newNode(key):\n    temp = Node(key)\n    return temp\n  \n# Function to perform zig zag traversal\n# of the given tree\ndef zigzagLevelOrder(root):\n    if (root == None):\n        return\n  \n    # Stores the vectors containing nodes\n    # in each level of tree respectively\n    result = []\n  \n    # Create a queue for BFS\n    q = []\n  \n    # Enqueue Root of the tree\n    q.append(root)\n  \n    # Standard Level Order Traversal\n    # code using queue\n    while len(q) > 0:\n        size = len(q)\n  \n        # Stores the element in the\n        # current level\n        curLevel = []\n  \n        # Iterate over all nodes of\n        # the current level\n        for i in range(size):\n            node = q[0]\n            q.pop(0)\n  \n            curLevel.append(node.val)\n  \n            # Insert all children of the\n            # current node into the queue\n            for j in range(len(node.child)):\n                q.append(node.child[j])\n  \n        # Insert curLevel into result\n        result.append(curLevel)\n  \n    # Loop to Print the ZigZag Level order\n    # Traversal of the given tree\n    for i in range(len(result)):\n       \n        # If i+1 is even reverse the order\n        # of nodes in the current level\n        if ((i + 1) % 2 == 0):\n            result[i].reverse()\n  \n        # Print the node of ith level\n        for j in range(len(result[i])):\n            print(result[i][j], end = ' ')\n        print()\n \nroot = newNode(1)\n(root.child).append(newNode(2))\n(root.child).append(newNode(3))\n(root.child[0].child).append(newNode(4))\n(root.child[0].child).append(newNode(5))\n(root.child[1].child).append(newNode(6))\n(root.child[1]).child.append(newNode(7))\n(root.child[1].child).append(newNode(8))\n \n# Function Call\nzigzagLevelOrder(root)\n \n# This code is contributed by decode2207.\n"], "Level Order Traversal of N-ary Tree -  ": ["# Python code for above implementation\nclass Node:\n      \n    def __init__(self, key):\n          \n        self.key = key\n        self.child = []\n    \n # Utility function to create a new tree node\ndef newNode(key):   \n    temp = Node(key)\n    return temp\n      \n# Prints the n-ary tree level wise\ndef LevelOrderTraversal(root):\n  \n    if (root == None):\n        return;\n    \n    # Standard level order traversal code\n    # using queue\n    q = []  # Create a queue\n    q.append(root); # Enqueue root\n    while (len(q) != 0):\n      \n        n = len(q);\n   \n        # If this node has children\n        while (n > 0):\n          \n            # Dequeue an item from queue and print it\n            p = q[0]\n            q.pop(0);\n            print(p.key, end=' ')\n    \n            # Enqueue all children of the dequeued item\n            for i in range(len(p.child)):\n              \n                q.append(p.child[i]);\n            n -= 1\n    \n        print() # Print new line between two levels\n \nif __name__ == '__main__':\n    root = newNode(1);\n    root.child.append(newNode(3));\n    root.child.append(newNode(2));\n    root.child.append(newNode(4));\n    root.child[0].child.append(newNode(5));\n    root.child[0].child.append(newNode(6));\n  \n    # LevelOrderTraversal obj;\n    LevelOrderTraversal(root);\n    \n  # This code is contributed by poojaagarwal2.\n", "# Python code for above implementation\nans = []\nlevel = 0\n \nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n \ndef levelOrder(root):\n    global level\n    if len(ans) == level:\n        ans.append([root.val])\n    else:\n        ans[level].append(root.val)\n    level += 1\n    for n in root.children:\n        levelOrder(n)\n    level -= 1\n \nroot = Node(1)\nroot.children.append(Node(3))\nroot.children.append(Node(2))\nroot.children.append(Node(4))\nroot.children[0].children.append(Node(5))\nroot.children[0].children.append(Node(6))\n \nlevelOrder(root)\nfor v in ans:\n    for x in v:\n        print(x, end=' ')\n    print()\n \n# This code is contributed by Tapesh(tapeshdua420)\n"], "Iterative Postorder Traversal of N-ary Tree -  ": ["# Python Program to iterative\n# Postorder Traversal of N-ary Tree\n# Node class\nclass Node:\n    def __init__(self,_val):\n        self.val = _val\n        self.children = []\n \n# Helper class to.append node and it's index\n# into the stack\nclass Pair:\n    def __init__(self,_node, _childrenIndex):\n        self.node = _node\n        self.childrenIndex = _childrenIndex\n \n# We will keep the start index as 0,\n# because first we always\n# process the left most children\ncurrentRootIndex = 0\nstack = []\npostorderTraversal = []\n \n# Function to perform iterative postorder traversal\ndef postorder(root):\n \n    global currentRootIndex\n    global stack\n    global postorderTraversal\n \n    while (root != None or len(stack) != 0):\n        if (root != None):\n             \n            # append the root and it's index\n            # into the stack\n            stack.append(Pair(root, currentRootIndex))\n            currentRootIndex = 0\n \n            # If root don't have any children's that\n            # means we are already at the left most\n            # node, so we will mark root as None\n            if (len(root.children) >= 1):\n                root = root.children[0]\n            else:\n                root = None\n            continue\n \n        # We will.Pop the top of the stack and\n        #.append it to our answer\n        temp = stack.pop()\n        postorderTraversal.append(temp.node.val)\n \n        # Repeatedly we will the.Pop all the\n        # elements from the stack till.Popped\n        # element is last children of top of\n        # the stack\n        while (len(stack) != 0 and temp.childrenIndex ==\n                len(stack[-1].node.children) - 1):\n            temp = stack[-1]\n            stack.pop()\n             \n            postorderTraversal.append(temp.node.val)\n \n        # If stack is not empty, then simply assign\n        # the root to the next children of top\n        # of stack's node\n        if (len(stack) != 0):\n \n            root = stack[-1].node.children[temp.childrenIndex + 1]\n            currentRootIndex = temp.childrenIndex + 1\n \n    return postorderTraversal\n \n# Driver Code\nroot = Node(1)\nroot.children.append(Node(3))\nroot.children.append(Node(2))\nroot.children.append(Node(4))\nroot.children[0].children.append(Node(5))\nroot.children[0].children.append(Node(6))\nprint('[',end='')\ntemp = postorder(root)\nsize = len(temp)\ncount = 0\nfor v in temp:\n \n    print(v,end='')\n    count += 1\n    if(count < size):\n        print(',',end=' ')\n \nprint(']')\n \n# This code is contributed by shinjanpatra\n"], "Preorder Traversal of an N-ary Tree -  ": ["# Python3 program for Iterative Preorder\n# Traversal of N-ary Tree.\n# Preorder: Root, print children\n# from left to right.\n \nfrom collections import deque\n \n# Node Structure of K-ary Tree\n \n \nclass NewNode():\n \n    def __init__(self, val):\n        self.key = val\n        # all children are stored in a list\n        self.child = []\n \n \n# Utility function to print the\n# preorder of the given K-Ary Tree\ndef preorderTraversal(root):\n \n    Stack = deque([])\n    # 'Preorder'-> contains all the\n    # visited nodes.\n    Preorder = []\n    Preorder.append(root.key)\n    Stack.append(root)\n    while len(Stack) > 0:\n        # 'Flag' checks whether all the child\n        # nodes have been visited.\n        flag = 0\n        # CASE 1- If Top of the stack is a leaf\n        # node then remove it from the stack:\n        if len((Stack[len(Stack)-1]).child) == 0:\n            X = Stack.pop()\n            # CASE 2- If Top of the stack is\n            # Parent with children:\n        else:\n            Par = Stack[len(Stack)-1]\n        # a)As soon as an unvisited child is\n        # found(left to right sequence),\n        # Push it to Stack and Store it in\n        # Auxiliary List(Marked Visited)\n        # Start Again from Case-1, to explore\n        # this newly visited child\n        for i in range(0, len(Par.child)):\n            if Par.child[i].key not in Preorder:\n                flag = 1\n                Stack.append(Par.child[i])\n                Preorder.append(Par.child[i].key)\n                break\n                # b)If all Child nodes from left to right\n                # of a Parent have been visited\n                # then remove the parent from the stack.\n        if flag == 0:\n            Stack.pop()\n    print(Preorder)\n \n \n# Execution Start From here\nif __name__ == '__main__':\n    # input nodes\n    '''\n \n      1\n   /  |  \\\n  /   |   \\\n 2    3    4\n/ \\      / | \\\n/   \\    7  8  9\n5     6    \n/    / | \\ \n10   11 12 13\n \n    '''\n \nroot = NewNode(1)\nroot.child.append(NewNode(2))\nroot.child.append(NewNode(3))\nroot.child.append(NewNode(4))\nroot.child[0].child.append(NewNode(5))\nroot.child[0].child[0].child.append(NewNode(10))\nroot.child[0].child.append(NewNode(6))\nroot.child[0].child[1].child.append(NewNode(11))\nroot.child[0].child[1].child.append(NewNode(12))\nroot.child[0].child[1].child.append(NewNode(13))\nroot.child[2].child.append(NewNode(7))\nroot.child[2].child.append(NewNode(8))\nroot.child[2].child.append(NewNode(9))\n \npreorderTraversal(root)\n", "# Python3 program for Recursive Preorder Traversal of N-ary Tree\n \n# Node Structure of K-ary Tree\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n \n# Utility function to create a new tree node\ndef newNode(key):\n    temp = Node(key)\n    return temp\n \n# Recursive function to print the preorder of the given K-Ary Tree\ndef fun(root, v):\n    if root is None:\n        return\n    v.append(root.val)\n    for i in range(len(root.children)):\n        fun(root.children[i], v)\n    return\n \n# Function to print preorder list\ndef preorderTraversal(root):\n    v = []\n    fun(root, v)\n    for it in v:\n        print(it, end=' ')\n \n# Input nodes\n'''\n              1\n            / | \\\n           /  |  \\\n          2   3   4\n         / \\     / | \\\n        5   6    7 8  9\n       /  / | \\\n      10 11 12 13\n'''\n \nroot = newNode(1)\nroot.children.append(newNode(2))\nroot.children.append(newNode(3))\nroot.children.append(newNode(4))\n \nroot.children[0].children.append(newNode(5))\nroot.children[0].children[0].children.append(newNode(10))\nroot.children[0].children.append(newNode(6))\nroot.children[0].children[1].children.append(newNode(11))\nroot.children[0].children[1].children.append(newNode(12))\nroot.children[0].children[1].children.append(newNode(13))\nroot.children[2].children.append(newNode(7))\nroot.children[2].children.append(newNode(8))\nroot.children[2].children.append(newNode(9))\n \npreorderTraversal(root)\n \n# This code is contributed by lokeshpotta20.\n"], "Inorder traversal of an N-ary Tree -  ": ["# Python3 implementation of the approach\nclass GFG:\n     \n    # Class for the node of the tree\n    class Node:\n        def __init__(self,n,data):\n            # List of children\n            self.children = [None]*n\n            self.data = data\n     \n    # Function to print the inorder traversal \n    # of the n-ary tree \n    def inorder(self, node):\n        if node == None:\n            return\n         \n        # Total children count \n        total = len(node.children)\n         \n        # All the children except the last\n        for i in range(total-1):\n            self.inorder(node.children[i])\n         \n        # Print the current node's data\n        print(node.data,end=' ')\n         \n        # Last child \n        self.inorder(node.children[total-1])\n     \n    # Driver code\n    def main(self):\n        # Create the following tree  \n        #          1 \n        #       /  |  \\ \n        #      2   3   4 \n        #    / | \\ \n        #   5  6  7\n         \n        n = 3\n        root = self.Node(n, 1)\n        root.children[0] = self.Node(n, 2)\n        root.children[1] = self.Node(n, 3)\n        root.children[2] = self.Node(n, 4)\n        root.children[0].children[0] = self.Node(n, 5)\n        root.children[0].children[1] = self.Node(n, 6) \n        root.children[0].children[2] = self.Node(n, 7)\n         \n        self.inorder(root)\n         \nob = GFG() # Create class object\nob.main() # Call main function\n \n# This code is contributed by Shivam Singh\n"], "Dynamic Programming - Subset Sum Problem": ["# A recursive solution for subset sum\n# problem\n \n \n# Returns true if there is a subset\n# of set[] with sun equal to given sum\ndef isSubsetSum(set, n, sum):\n \n    # Base Cases\n    if (sum == 0):\n        return True\n    if (n == 0):\n        return False\n \n    # If last element is greater than\n    # sum, then ignore it\n    if (set[n - 1] > sum):\n        return isSubsetSum(set, n - 1, sum)\n \n    # Else, check if sum can be obtained\n    # by any of the following\n    # (a) including the last element\n    # (b) excluding the last element\n    return isSubsetSum(\n        set, n-1, sum) or isSubsetSum(\n        set, n-1, sum-set[n-1])\n \n \n# Driver code\nif __name__ == '__main__':\n    set = [3, 34, 4, 12, 5, 2]\n    sum = 9\n    n = len(set)\n    if (isSubsetSum(set, n, sum) == True):\n        print('Found a subset with given sum')\n    else:\n        print('No subset with given sum')\n \n# This code is contributed by Nikita Tiwari.\n", "# Python program for the above approach\n \n# Taking the matrix as globally\ntab = [[-1 for i in range(2000)] for j in range(2000)]\n \n \n# Check if possible subset with\n# given sum is possible or not\ndef subsetSum(a, n, sum):\n \n    # If the sum is zero it means\n    # we got our expected sum\n    if (sum == 0):\n        return 1\n \n    if (n <= 0):\n        return 0\n \n    # If the value is not -1 it means it\n    # already call the function\n    # with the same value.\n    # it will save our from the repetition.\n    if (tab[n - 1][sum] != -1):\n        return tab[n - 1][sum]\n \n    # If the value of a[n-1] is\n    # greater than the sum.\n    # we call for the next value\n    if (a[n - 1] > sum):\n        tab[n - 1][sum] = subsetSum(a, n - 1, sum)\n        return tab[n - 1][sum]\n    else:\n \n        # Here we do two calls because we\n        # don't know which value is\n        # full-fill our criteria\n        # that's why we doing two calls\n        tab[n - 1][sum] = subsetSum(a, n - 1, sum)\n        return tab[n - 1][sum] or subsetSum(a, n - 1, sum - a[n - 1])\n \n \n# Driver Code\nif __name__ == '__main__':\n    n = 5\n    a = [1, 5, 3, 7, 4]\n    sum = 12\n    if (subsetSum(a, n, sum)):\n        print('YES')\n    else:\n        print('NO')\n \n# This code is contributed by shivani.\n", "# A Dynamic Programming solution for subset\n# sum problem Returns true if there is a subset of\n# set[] with sun equal to given sum\n \n \n# Returns true if there is a subset of set[]\n# with sum equal to given sum\ndef isSubsetSum(set, n, sum):\n \n    # The value of subset[i][j] will be\n    # true if there is a\n    # subset of set[0..j-1] with sum equal to i\n    subset = ([[False for i in range(sum + 1)]\n               for i in range(n + 1)])\n \n    # If sum is 0, then answer is true\n    for i in range(n + 1):\n        subset[i][0] = True\n \n    # If sum is not 0 and set is empty,\n    # then answer is false\n    for i in range(1, sum + 1):\n        subset[0][i] = False\n \n    # Fill the subset table in bottom up manner\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if j < set[i-1]:\n                subset[i][j] = subset[i-1][j]\n            if j >= set[i-1]:\n                subset[i][j] = (subset[i-1][j] or\n                                subset[i - 1][j-set[i-1]])\n \n    return subset[n][sum]\n \n \n# Driver code\nif __name__ == '__main__':\n    set = [3, 34, 4, 12, 5, 2]\n    sum = 9\n    n = len(set)\n    if (isSubsetSum(set, n, sum) == True):\n        print('Found a subset with given sum')\n    else:\n        print('No subset with given sum')\n \n# This code is contributed by\n# sahil shelangia.\n", "# Returns True if there is a subset of set[]\n# with a sum equal to the given sum\ndef isSubsetSum(nums, n, sum):\n    # Create a list to store the previous row result\n    prev = [False] * (sum + 1)\n \n    # If sum is 0, then the answer is True\n    prev[0] = True\n \n    # If sum is not 0 and the set is empty,\n    # then the answer is False\n    for i in range(1, n + 1):\n        curr = [False] * (sum + 1)\n        for j in range(1, sum + 1):\n            if j < nums[i - 1]:\n                curr[j] = prev[j]\n            if j >= nums[i - 1]:\n                curr[j] = prev[j] or prev[j - nums[i - 1]]\n        # Now curr becomes prev for (i+1)-th element\n        prev = curr\n \n    return prev[sum]\n \n# Driver code\nif __name__ == '__main__':\n    nums = [3, 34, 4, 12, 5, 2]\n    sum_value = 9\n    n = len(nums)\n    if isSubsetSum(nums, n, sum_value):\n        print('Found a subset with the given sum')\n    else:\n        print('No subset with the given sum')\n"], "Difference between Brute Force and Dynamic Programming -  ": [], "Setting up a C++ Competitive Programming Environment -  ": [], "C++: Methods of code shortening in competitive programming -  ": [], "Python Input Methods for Competitive Programming -  ": ["# basic method of input output\n# input N\nn = int(input())\n \n# input the array\narr = [int(x) for x in input().split()]\n \n# initialize variable\nsummation = 0\n \n# calculate sum\nfor x in arr:\n    summation += x\n     \n# print answer\nprint(summation)\n", "# import inbuilt standard input output \nfrom sys import stdin, stdout \n \n# suppose a function called main() and\n# all the operations are performed\ndef main():\n \n    # input via readline method\n    n = stdin.readline()\n \n    # array input similar method\n    arr = [int(x) for x in stdin.readline().split()]\n \n    #initialize variable\n    summation = 0\n     \n    # calculate sum\n    for x in arr:\n        summation += x\n \n    # could use inbuilt summation = sum(arr)\n \n    # print answer via write\n    # write method writes only\n    # string operations\n    # so we need to convert any\n    # data into string for input\n    stdout.write(str(summation))\n \n# call the main method\nif __name__ == '__main__':\n    main()    \n", "import sys\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\n \na,b,c,d = get_ints()\n", "import sys\ndef get_ints(): return list(map(int, sys.stdin.readline().strip().split()))\n \nArr = get_ints()\n", "import sys\ndef get_string(): return sys.stdin.readline().strip()\n \nstring = get_string()\n", "# template begins\n#####################################\n \n# import libraries for input/ output handling\n# on generic level\nimport atexit, io, sys\n \n# A stream implementation using an in-memory bytes \n# buffer. It inherits BufferedIOBase.\nbuffer = io.BytesIO()\nsys.stdout = buffer\n \n# print via here\n@atexit.register\ndef write():\n    sys.stdout.write(buffer.getvalue())\n \n#####################################\n# template ends\n \n# normal method followed\n# input N\nn = int(input())\n \n# input the array\narr = [int(x) for x in input().split()]\n \n# initialize variable\nsummation = 0\n \n# calculate sum\nfor x in arr:\n    summation += x\n \n# print answer\nprint(summation)\n"], "Ways to read input from console in Java -  ": [], "Basic Input / Output in C++ -  ": [], "Input/Output from external file in C/C++, Java and Python for Competitive Programming | Set 2 -  ": [], "Input/Output from external file in C/C++, Java and Python for Competitive Programming -  ": [], "Fast I/O for Competitive Programming in Python -  ": ["# Python program to illustrate the use \n# of fast Input / Output \nimport io, os, time \n  \n# Function to take normal input \ndef normal_io(): \n    \n      # Stores the start time \n    start = time.perf_counter() \n      \n    # Take Input \n    s = input().strip(); \n      \n      # Stores the end time \n    end = time.perf_counter() \n      \n    # Print the time taken \n    print('\\nTime taken in Normal I / O:', \\ \n                      end - start) \n  \n# Function for Fast Input \ndef fast_io(): \n    \n    # Reinitialize the Input function \n    # to take input from the Byte Like  \n    # objects \n    input = io.BytesIO(os.read(0, \\ \n         os.fstat(0).st_size)).readline \n  \n    # Fast Input / Output \n    start = time.perf_counter() \n  \n    # Taking input as string  \n    s = input().decode() \n      \n      # Stores the end time \n    end = time.perf_counter() \n  \n    # Print the time taken \n    print('\\nTime taken in Fast I / O:', \\ \n                      end - start) \n  \n# Driver Code \nif __name__ == '__main__': \n  \n    # Function Call \n    normal_io() \n      \n    fast_io() \n", "# Python program to illustrate the use \n# of fast Input / Output \nimport time, sys \n  \n# Function to take normal input \ndef normal_out(): \n    \n      # Stores the start time \n    start = time.perf_counter() \n  \n    # Output Integer \n    n = 5\n    print(n) \n  \n    # Output String \n    s = ' '\n    print(s) \n  \n    # Output List \n    arr = [1, 2, 3, 4] \n    print(*arr) \n  \n      # Stores the end time \n    end = time.perf_counter() \n      \n    # Print the time taken \n    print('\\nTime taken in Normal Output:', \\ \n                      end - start) \n  \n# Function for Fast Output \ndef fast_out(): \n  \n    start = time.perf_counter() \n    # Output Integer \n    n = 5\n    sys.stdout.write(str(n)+'\\n') \n  \n    # Output String \n    s = ' \\n'\n    sys.stdout.write(s) \n  \n    # Output Array \n    arr = [1, 2, 3, 4] \n    sys.stdout.write( \n        ' '.join(map(str, arr)) + '\\n'\n    ) \n          \n    # Stores the end time \n    end = time.perf_counter() \n      \n    # Print the time taken \n    print('\\nTime taken in Fast Output:', \\ \n                      end - start) \n  \n# Driver Code \nif __name__ == '__main__': \n  \n    # Function Call \n    normal_out() \n      \n    fast_out() \n"], "Fast I/O in Java in Competitive Programming -  ": [], "Policy based data structures in g++ -  ": [], "Meet in the middle -  ": ["# Python program to demonstrate working of Meet in the\n# Middle algorithm for maximum subset sum problem.\nfrom typing import List\nimport bisect\nX = [0] * 2000005\nY = [0] * 2000005\n \n# Find all possible sum of elements of a[] and store\n# in x[]\ndef calcsubarray(a: List[int], x: List[int], n: int, c: int) -> None:\n    for i in range((1 << n)):\n        s = 0\n        for j in range(n):\n            if (i & (1 << j)):\n                s += a[j + c]\n        x[i] = s\n \n# Returns the maximum possible sum less or equal to S\ndef solveSubsetSum(a: List[int], n: int, S: int) -> int:\n    global Y\n     \n    # Compute all subset sums of first and second\n    # halves\n    calcsubarray(a, X, n // 2, 0)\n    calcsubarray(a, Y, n - n // 2, n // 2)\n    size_X = 1 << (n // 2)\n    size_Y = 1 << (n - n // 2)\n \n    # Sort Y (we need to do doing binary search in it)\n    YY = Y[:size_Y]\n    YY.sort()\n    Y = YY\n \n    # To keep track of the maximum sum of a subset\n    # such that the maximum sum is less than S\n    maxx = 0\n \n    # Traverse all elements of X and do Binary Search\n    # for a pair in Y with maximum sum less than S.\n    for i in range(size_X):\n \n        if (X[i] <= S):\n \n            # lower_bound() returns the first address\n            # which has value greater than or equal to\n            # S-X[i].\n            p = bisect.bisect_left(Y, S - X[i])\n \n            # If S-X[i] was not in array Y then decrease\n            # p by 1\n            if (p == size_Y or (p < size_Y and Y[p] != (S - X[i]))):\n                p -= 1\n            if ((Y[p] + X[i]) > maxx):\n                maxx = Y[p] + X[i]\n    return maxx\n \n# Driver code\nif __name__ == '__main__':\n \n    a = [3, 34, 4, 12, 5, 2]\n    n = len(a)\n    S = 10\n    print('Largest value smaller than or equal to given sum is {}'.format(\n        solveSubsetSum(a, n, S)))\n \n# This code is contributed by sanjeev2552\n"], "BFS using STL for competitive coding -  ": [], "MEX (Minimum Excluded) in Competitive Programming -  ": [], "Dynamic Programming in Game Theory for Competitive Programming -  ": [], "DP on Trees for Competitive Programming -  ": [], "Frequency Measuring Techniques for Competitive Programming -  ": ["# Python program to count frequencies \n# of array items\ndef countFreq(arr, n):\n     \n    # mark all array elements as not visited\n    visited = [False for i in range(n)]\n     \n    # Traverse through array elements \n    # and count frequencies\n    for i in range(n):\n         \n        # Skip this element if already processed\n        if visited[i] == True:\n            continue\n             \n        # count frequency\n        count = 1\n         \n        for j in range(i + 1, n):\n            if arr[i] == arr[j]:\n                visited[j] = True\n                count += 1\n        print(arr[i], count)\n     \n# Driver code\na = [10, 20, 20, 10, 10, 20, 5, 20]\n \nn = len(a)\n \ncountFreq(a, n)\n \n# This code is contributed \n# by Mohit kumar 29\n", "# Python3 program to count frequencies of \n# array items having small values.\ndef countFreq(arr, n, limit):\n     \n    # Create an array to store counts. \n    # The size of array is limit+1 and \n    # all values are initially 0\n    count = [0 for i in range(limit + 1)]\n \n    # Traverse through array elements and\n    # count frequencies (assuming that\n    # elements are limited by limit)\n    for i in range(n):\n        count[arr[i]] += 1\n \n    for i in range(limit + 1):\n        if (count[i] > 0):\n            print(i, count[i])\n \n# Driver Code\narr = [ 5, 5, 6, 6, 5, 6,\n        1, 2, 3, 10, 10 ]\nn = len(arr)\nlimit = 10\n \ncountFreq(arr, n, limit)\n \n# This code is contributed by avanitrachhadiya2155\n", "# Python3 program to count frequencies of array items\nlimit = 255\ndef countFreq(Str) :\n \n    # Create an array to store counts. The size\n    # of array is limit+1 and all values are \n    # initially 0\n    count = [0] * (limit + 1)\n   \n    # Traverse through string characters and\n    # count frequencies \n    for i in range(len(Str)) :\n        count[ord(Str[i])] += 1\n   \n    for i in range(limit + 1) :\n       if (count[i] > 0) :\n        print(chr(i), count[i]) \n  \nStr = ' '\ncountFreq(Str)\n \n# This code is contributed by divyeshrabadiya07\n", "# Python3 program to count frequencies of array items\nlimit = 25; \ndef countFreq(str):\n     \n    # Create an array to store counts. The size\n    # of array is limit+1 and all values are \n    # initially 0\n    count = [0 for i in range(limit + 1)]\n   \n    # Traverse through string characters and\n    # count frequencies \n    for i in range(len(str)):   \n        count[ord(str[i]) - ord('A')] += 1\n   \n    for i in range(limit + 1):\n       if (count[i] > 0):\n           print(chr(i + ord('A')), count[i])\n \n# Driver code\nif __name__=='__main__':\n     \n    str = ' ';\n    countFreq(str);\n     \n# This code is contributed by Pratham76\n", "# Python3 program to count frequencies of array items\ndef countFreq(arr, n):\n \n    mp = {}\n  \n    # Traverse through array elements and\n    # count frequencies\n    for i in range(n):\n        if arr[i] in mp:\n            mp[arr[i]] += 1\n        else:\n            mp[arr[i]] = 1\n  \n    # Traverse through map and print frequencies\n    for x in sorted(mp):\n        print(x, mp[x])\n \n# Driver Code\narr = [ 10, 20, 20, 10, 10, 20, 5, 20 ]\nn = len(arr)\n \ncountFreq(arr, n)\n \n# This code is contributed by divyesh072019\n", "# Python3 program to count frequencies of array items \ndef countFreq(arr, n):\n    mp = {}\n     \n    # Traverse through array elements and \n    # count frequencies \n    for i in range(n):\n        if arr[i] not in mp:\n            mp[arr[i]] = 1\n        else:\n            mp[arr[i]] += 1\n \n    # To print elements according to first \n    # occurrence, traverse array one more time \n    # print frequencies of elements and mark \n    # frequencies as -1 so that same element \n    # is not printed multiple times. \n    for i in range(n):\n        if(mp[arr[i]] != -1):\n            print(arr[i], mp[arr[i]])\n            mp[arr[i]] = -1\n \n# Driver code\narr = [10, 20, 20, 10, 10, 20, 5, 20 ]\nn = len(arr)\ncountFreq(arr, n)\n \n# This code is contributed by rag2127\n"], "PreComputation Technique on Arrays -  ": ["# This function prints the array\ndef print_array(arr, N):\n    for i in range(N):\n        print(arr[i], end = ' ')\n    print()\n \n# This function calculates the PrefixSum\n# of the array\ndef PrefixSum(ARR, N):\n \n    # PRE[] array stores the result\n    PRE = [0] * N\n    for i in range(N):\n \n        # At index 0, no previous values\n        # are present\n        if (i == 0):\n            PRE[i] = ARR[i]\n        else:\n            PRE[i] = PRE[i - 1] + ARR[i]\n    print('Prefix Sum: ', end = '')\n    print_array(PRE, N)\n \n# This function finds the Suffix\n# sum of the array\ndef SuffixSum(ARR, N):\n \n    # This array stores the result\n    SUF = [0] * N\n    for i in range(N - 1, -1, -1):\n \n        # At index N-1, there is no suffix\n        # value available\n        if (i == N - 1):\n            SUF[i] = ARR[i]\n        else:\n            SUF[i] = SUF[i + 1] + ARR[i]\n    print('Suffix Sum: ', end = '')\n    print_array(SUF, N)\n \n# Driver code\nif __name__ == '__main__':\n    N = 5\n    ARR = [4, 2, 1, -1, 3]\n    print('Given Array: ', end = '')\n    print_array(ARR, N)\n \n    # Funtion call to calculate prefix sum\n    PrefixSum(ARR, N)\n \n    # Function call to calculate suffix sum\n    SuffixSum(ARR, N)\n"], "Precomputation Techniques for Competitive Programming -  ": [], "Ternary Search for Competitive Programming -  ": [], "Binary Search on Answer Tutorial with Problems -  ": ["class Solution:\n    def minXvalue(self, arr, H):\n        X = max(arr)\n        lo, hi = 0, X\n        while lo <= hi:\n            x = (lo + hi) // 2\n            req_time = 0\n            for val in arr:\n                # ceil value\n                req_time += (val + x - 1) // x\n            if req_time <= H:\n                X = x\n                hi = x - 1\n            else:\n                lo = x + 1\n        return X\n \n# Driver code\nif __name__ == '__main__':\n    solution = Solution()\n    arr = [8, 11, 18, 20]\n    h = 10\n    result = solution.minXvalue(arr, h)\n \n    # Function Call\n    print('Minimum value of X will be:', result)\n     \n \n# by phasing17\n"], "Bitwise Hacks for Competitive Programming -  ": ["# num = number, pos = position at which we want to set the bit\ndef set (num, pos):\n  # First step = Shift '1'\n  # Second step = Bitwise OR\n  num |= (1 << pos)\n  print(num)\n   \nnum, pos = 4, 1\n \nset(num, pos)\n \n# This code is contributed by sarajadhav12052009\n", "# First Step: Getting which have all '1's except the\n# given position\n \n \ndef unset(num, pos):\n    # Second Step: Bitwise AND this number with the given number\n    num &= (~(1 << pos))\n    print(num)\n \n \nnum, pos = 7, 1\n \nunset(num, pos)\n", "def toggle(num, pos):\n  # First Step: Shifts '1'\n  # Second Step: XOR num\n  num ^= (1 << pos)\n  print(num)\n   \n   \nnum, pos = 4, 1\n \ntoggle(num, pos)\n \n# This code is contributed by sarajadhav12052009\n", "# code\ndef at_position(num,pos):\n    bit = num & (1<<pos)\n    return bit\n   \nnum = 5\npos = 0\nbit = at_position(num, pos)\nprint(bit)\n", "num = 4\n \n# Inverting every bit of number num\nprint(~num)\n", "num = 4\ntwos_complement = -num\n \nprint(f'This is two's complement {twos_complement}')\nprint(f'This is also two's complement {~num + 1}')\n \n# This code is contributed by sarajadhav12052009\n", "def strip_last_set_bit(num):\n    num &= (num - 1)\n    print(num)\n \n \nnum = 7\n \nstrip_last_set_bit(num)\n", "def lowest_set_bit(num):\n    num &= (-num)\n    print(num)\n \n \nnum = 10\n \nlowest_set_bit(num)\n", "num = 12\nprint(num >> 1)\n", "# Python program for the above approach\n \nnum = 12\nans = num<<1\nprint(ans)\n \n# This code is contributed by Shubham Singh\n"], "Bit Manipulation for Competitive Programming -  ": [], "GCD (Greatest Common Divisor) Practice Problems for Competitive Programming -  ": ["def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n"], "Binary Exponentiation for Competitive Programming -  ": ["# Python Implementation\nmod = 10**9 + 7\n \ndef power(a, b):\n    result = 1\n    while b:\n        if b & 1:\n            result = (result * a) % mod\n        a = (a * a) % mod\n        b >>= 1\n    return result\n \nprint(power(2, 42))\n \n# This code is contributed by Sakshi\n", "# Binary exponentiation\ndef apply(S, P):\n    temp = [0] * len(S)\n    for i in range(1, len(S)):\n        temp[i] = S[P[i]]\n    for i in range(1, len(S)):\n        S[i] = temp[i]\n \n# Function to apply Permutation P to Sequence S K number of times\ndef solve(S, P, K):\n    while K:\n        if K & 1:\n            apply(S, P)\n        apply(P, P)\n        K >>= 1\n \nif __name__ == '__main__':\n    P = [0, 2, 3, 4, 1]\n    S = [0, 2, 1, 3, 4]\n    K = 2\n    solve(S, P, K)\n    print('New Sequence =', end=' ')\n    for i in range(1, len(S)):\n        print(S[i], end=' ')\n"], "Euler Totient for Competitive Programming -  ": ["def ETF(n):\n    phi_n = n\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            phi_n -= phi_n // i\n        i += 1\n    if n > 1:\n        phi_n -= phi_n // n\n    return phi_n\n"], "Must do Math for Competitive Programming -  ": ["def GCD(A, B):\n    if (B == 0):\n        return A\n    else:\n        return GCD(B, A % B)\n \n      # This code is contributed by subham348.\n", "def sieve(N):\n \n    isPrime = [True for i in range(N + 1)]\n \n    isPrime[0] = False\n    isPrime[1] = False\n \n    for i in range(2, int(N ** 0.5) + 1):\n \n        # Mark all the multiples of i as composite numbers\n        if (isPrime[i] == True):\n            for j in range(i * i, N + 1, i):\n                isPrime[j] = False\n \n # This code is contributed by phasing17.\n", "def expo(a, b, m):\n    if b == 0:\n        return 1\n    p = expo(a, b // 2, m) % m\n    p = (p * p) % m\n     \n    return [p, (a * p) % m][b % 2]\n", "# Python3 program to implement the approach\n \n# This function returns modulo inverse of a with respect \n# to m using extended Euclid Algorithm \n# Assumption: a and m are coprimes, i.e., \n# gcd(a, m) = 1 \ndef modInverse(a, m):\n  \n    m0 = m; \n    y = 0\n    x = 1; \n   \n    if (m == 1):\n      return 0; \n   \n    while (a > 1) :\n      \n        # q is quotient \n        q = int(a / m); \n        t = m; \n   \n        # m is remainder now, process same as \n        # Euclid's algo \n        m = a % m\n        a = t; \n        t = y; \n   \n        # Update y and x \n        y = x - q * y; \n        x = t; \n      \n    # Make x positive \n    if (x < 0) :\n       x += m0; \n   \n    return x; \n  \n# This code is contributed by phasing17\n"], "How to get started with Competitive Programming in JavaScript -  ": [], "Java Generics to Code Efficiently in Competitive Programming -  ": [], "Java tricks for competitive programming (for Java 8) -  ": [], "Efficiently Reading Input For Competitive Programming using Java 8 -  ": [], "Setting up Java Competitive Programming Environment -  ": [], "C++ tricks for competitive programming (for C++ 11) -  ": [], "Common mistakes to be avoided in Competitive Programming in C++ | Beginners -  ": [], "Writing code faster during Competitive Programming in C++ -  ": [], "Writing C/C++ code efficiently in Competitive programming -  ": [], "Setting Up Sublime Text For Competitive Coding in C++14 on Ubuntu -  ": [], "Setting up Sublime Text For Competitive Programming (C++) Using Fast Olympic Coding Plugin -  ": [], "How to setup Competitive Programming in Visual Studio Code for C++ -  ": [], "Why C++ is best for Competitive Programming? -  ": [], "Python Tricks for Competitive Coding -  ": [], "Python in Competitive Programming -  ": ["alphabets = ['a', 'b', 'c'] \nfor item in alphabets: \n    len(item)  \n", "alphabets = ['a', 'b', 'c'] \nfn = len\nfor item in alphabets: \n        fn(item) \n", "import datetime \nalphabets = [str(x)for x in range(10000000)] \na = datetime.datetime.now() # store initial time \nfor item in alphabets: \n    len(item) \nb = datetime.datetime.now() # store final time \nprint (b-a).total_seconds() # results \na = datetime.datetime.now() \nfn = len                    # function stored locally \nfor item in alphabets: \n    fn(item) \nb = datetime.datetime.now() \nprint (b-a).total_seconds() \n", "from itertools import permutations \nperm = permutations([1, 2, 3], 2) \nfor i in list(perm): \n    print i \n  \n# Answer->(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2) \n"], "Why is python best suited for Competitive Coding? -  ": ["# Python code to demonstrate how to take space\n# separated inputs.\narr = [int(a) for a in input().strip().split(' ')]\n \nprint(arr)\n"], "Getting Started with Competitive Programming in Python -  ": ["# Creating a list\nnumbers = [1, 2, 3, 4, 5]\n \n# Accessing list elements\nprint(numbers[0])  # Output: 1\n \n# String concatenation\nname = 'John'\ngreeting = 'Hello, ' + name + '!'\nprint(greeting)  # Output: Hello, John!\n", "# Node class to represent a linked list node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# Linked list class with basic operations\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n \n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = new_node\n \n    def print_list(self):\n        current = self.head\n        while current:\n            print(current.data, end=' -> ')\n            current = current.next\n        print('None')\n \n# Usage of linked list\nlinked_list = LinkedList()\nlinked_list.append(1)\nlinked_list.append(2)\nlinked_list.append(3)\nlinked_list.print_list()\n", "def find_max_element(arr):\n    max_element = arr[0]\n    for num in arr:\n        if num > max_element:\n            max_element = num\n    return max_element\n", "def find_max_element_1(arr):\n    # Solution 1: Using built-in max() function\n    return max(arr)\n \ndef find_max_element_2(arr):\n    # Solution 2: Using a loop to find max element\n    max_element = arr[0]\n    for num in arr:\n        if num > max_element:\n            max_element = num\n    return max_element\n", "def find_max_element_1(arr):\n    # Solution 1: Using built-in max() function\n    return max(arr)\n \ndef find_max_element_2(arr):\n    # Solution 2: Using a loop to find max element\n    max_element = arr[0]\n    for num in arr:\n        if num > max_element:\n            max_element = num\n    return max_element\n", "# Iterative Binary Search Function\n# It returns index of x in given array arr if present,\n# else returns -1\ndef binary_search(arr, x):\n    low = 0\n    high = len(arr) - 1\n    mid = 0\n \n    while low <= high:\n \n        mid = (high + low) // 2\n \n        # If x is greater, ignore left half\n        if arr[mid] < x:\n            low = mid + 1\n \n        # If x is smaller, ignore right half\n        elif arr[mid] > x:\n            high = mid - 1\n \n        # means x is present at mid\n        else:\n            return mid\n \n    # If we reach here, then the element was not present\n    return -1\n \n \n# Test array\narr = [ 2, 3, 4, 10, 40 ]\nx = 10\n \n# Function call\nresult = binary_search(arr, x)\n \nif result != -1:\n    print('Element is present at index', str(result))\nelse:\n    print('Element is not present in array')\n \n# This code is contributed by Nikhil Garg(https://www.instagram.com/nikhilgarg471/)\n", "# Python program for insert and search\n# operation in a Trie\n \nclass TrieNode:\n     \n    # Trie node class\n    def __init__(self):\n        self.children = [None]*26\n \n        # isEndOfWord is True if node represent the end of the word\n        self.isEndOfWord = False\n \nclass Trie:\n     \n    # Trie data structure class\n    def __init__(self):\n        self.root = self.getNode()\n \n    def getNode(self):\n     \n        # Returns new trie node (initialized to NULLs)\n        return TrieNode()\n \n    def _charToIndex(self,ch):\n         \n        # private helper function\n        # Converts key current character into index\n        # use only 'a' through 'z' and lower case\n         \n        return ord(ch)-ord('a')\n \n \n    def insert(self,key):\n         \n        # If not present, inserts key into trie\n        # If the key is prefix of trie node,\n        # just marks leaf node\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n \n            # if current character is not present\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n \n        # mark last node as leaf\n        pCrawl.isEndOfWord = True\n \n    def search(self, key):\n         \n        # Search key in the trie\n        # Returns true if key presents\n        # in trie, else false\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return False\n            pCrawl = pCrawl.children[index]\n \n        return pCrawl.isEndOfWord\n \n# Driver function\ndef main():\n \n    # Input keys (use only 'a' through 'z' and lower case)\n    keys = ['the','a','there','anaswe','any',\n            'by','their']\n    output = ['Not present in trie',\n            'Present in trie']\n \n    # Trie object\n    t = Trie()\n \n    # Construct trie\n    for key in keys:\n        t.insert(key)\n \n    # Search for different keys\n    print('{} ---- {}'.format('the',output[t.search('the')]))\n    print('{} ---- {}'.format('these',output[t.search('these')]))\n    print('{} ---- {}'.format('their',output[t.search('their')]))\n    print('{} ---- {}'.format('thaw',output[t.search('thaw')]))\n \nif __name__ == '__main__':\n    main()\n \n# This code is contributed by Nikhil Garg(https://www.instagram.com/nikhilgarg471/)\n"], "Tips for testing code in Competitive programming -  ": [], "Importance of Testing In Competitive Programming -  ": [], "Logarithm tricks for Competitive Programming -  ": ["# Python3 implementation to check that \n# a integer is a power of two \nimport math\n \n# Function to check if the number \n# is a power of two             \ndef isPowerOfTwo(n):\n     \n    return(math.ceil(math.log(n) //\n                     math.log(2)) ==\n           math.floor(math.log(n) //\n                      math.log(2))); \n                     \n# Driver code \nif __name__=='__main__':\n     \n    N = 8\n     \n    if isPowerOfTwo(N):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed by rutvik_56    \n", "# Python3 implementation to find \n# Kth root of the number \nimport math\n \n# Function to find the \n# Kth root of the number \ndef kth_root(n, k):\n     \n    return(pow(k, ((1.0 / k) * (math.log(n) /\n                                math.log(k)))))\n \n# Driver code\nif __name__=='__main__':\n     \n    n = 8.0\n    k = 3\n     \n    print(round(kth_root(n, k)))\n \n# This code is contributed by dipesh99kumar\n", "# Python3 implementation count the \n# number of digits in a number\nimport math\n \n# Function to count the \n# number of digits in a number \ndef countDigit(n):\n     \n    return(math.floor(math.log10(n) + 1))\n \n# Driver code\nif __name__=='__main__':\n     \n    n = 80\n \n    print(countDigit(n))\n \n# This code is contributed by dipesh99kumar\n", "# Python3 implementation to check if a \n# number is a power of the other number\nfrom math import log\n \n# Function to check if \n# the number is power of K \ndef isPower(n, k):\n     \n    # Logarithm function to \n    # calculate value \n    res1 = int(log(n) / log(k))\n    res2 = log(n) / log(k)\n     \n    # Compare to the result1 \n    # or result2 both are equal \n    return(res1 == res2)\n \n# Driver code\nif __name__=='__main__':\n     \n    n = 8\n    k = 2\n     \n    if (isPower(n, k)):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed by dipesh99kumar\n", "# Python3 implementation to find the\n# previous and next power of K \nfrom math import log\n \n# Function to return the highest power\n# of k less than or equal to n\ndef prevPowerofK(n, k):\n     \n    p = (int)(log(n) / log(k));\n    return pow(k, p);\n \n# Function to return the smallest power\n# of k greater than or equal to n\ndef nextPowerOfK(n, k):\n     \n    return prevPowerofK(n, k) * k;\n \n# Driver Code\nif __name__=='__main__':\n     \n    N = 7\n    K = 2\n     \n    print(prevPowerofK(N, K), end = ' ')\n    print(nextPowerOfK(N, K))\n \n# This code is contributed by dipesh99kumar\n", "# Python3 implementation to find the\n# rightmost set bit\nimport math\n \n# Function to find the rightmost\n# bit set of the integer N\ndef getFirstSetBitPos(n):\n \n    return math.log2(n & -n) + 1;\n \n# Driver Code\nif __name__=='__main__':\n     \n    N = 8\n \n    print(int(getFirstSetBitPos(N)))\n \n# This code is contributed by dipesh99kumar\n"], "A Better Way To Approach Competitive Programming -  ": [], "How To Make Competitive Programming Interesting? -  ": [], "Most Critical Mistakes & Tips in Competitive Programming -  ": ["# Case: Stack Overflow\na = 100000\nb = 100000\n# Expected answer ? 10^10 but\n# no the answer you get is 1410065408, error in\n# precision.\nc = a * b\nd = a * b\n# Note: Still error will be generated because\n# calculation was done on two ints which were later\n# converted into long long ie they already\n# lost their data before converting\n \n# Print and display on console\nprint(c, d)\n \n# Now if we store a value more than its capacity then\n# what happens is the number line of range of value\n# becomes a number\n# Example: Circle, If min val is 1 and max is 9, so if\n# we add 1 to 9 it will result in 1, it looped back to\n# starting, this is overflow\n \np = float('inf')\n \n# An example of overflow\nprint('An example of overflow ', p + 1)\n \n# Long long is way better than double,\n# double although can store more than long long but\n# in exchange it will cost you your precision.\n# We can simply use the below command as follows:\n# print(fixed(no scientific notation) setprecision(0){removes decimal} variable)\n# to give value same form as long long\n \n# Question where the answer came wrong coz of overflow!!\nt = int(input())\nwhile t > 0:\n    n = int(input())\n \n    # Here, before i used int and got wrong answer,\n    # then made it long long\n    pdt = 1\n    for i in range(n):\n        temp = int(input())\n        pdt *= temp\n \n    if pdt % 10 == 2 or pdt % 10 == 3 or pdt % 10 == 5:\n        print('YES')\n    else:\n        print('NO')\n     \n    t -= 1\n    \n", "# Creating a list and initializing objects\n# by passing custom integer numbers\nmy_list = [1, 4, 2, 5, 6, 3, 9, 0, 10, 3, 15, 17, 3]\n \n# Operation 1\n# Finding the minimum element in the list\nmin_element = min(my_list)\nprint('Min element:', min_element)\n \n# Operation 2\n# Finding the maximum element in the list\nmax_element = max(my_list)\nprint('Max element:', max_element)\n \n# Operation 3\n# Sum of all elements\nsum_of_elements = sum(my_list)\nprint('The sum of all elements:', sum_of_elements)\n \n# Operation 4\n# Count the frequency of an element in the list\nfrequency_of_3 = my_list.count(3)\nprint('Frequency of 3 is:', frequency_of_3)\n \n# Operation 5\n# Finds an element and returns its index\ntry:\n    index = my_list.index(3)\n    print('The element is at position:', index)\nexcept ValueError:\n    print('Element not found')\n \n# Operation 6\n# Reversing a list using reverse() method\nmy_list.reverse()\nprint('Reversed List:', my_list)\n \n# Operation 7\n# Sort list using sort() method\nmy_list.sort()\nprint('Sorted List:', my_list)\n"], "How to begin with Competitive Programming? -  ": ["# A Sample Python program for beginners with Competitive Programming\n \n# Returns index of x in arr if it is present,\n# else returns -1\ndef search(arr, x):\n    n = len(arr)\n    for j in range(0,n):\n        if (x == arr[j]):\n            return j\n    return -1\n \n# Input number of test cases\nt = int(input())\n \n# One by one run for all input test cases\nfor i in range(0,t):\n \n    # Input the size of the array\n    n = int(input())\n \n    # Input the array\n    arr = map(int, input().split())\n \n    # Input the element to be searched\n    x = int(input())\n \n    print(search(arr, x))\n \n    # The element can also be searched by index method\n    # But you need to handle the exception when element is not found\n    # Uncomment the below line to get that working.\n    # arr.index(x)\n"], "Introduction to Dynamic Programming on Trees -  ": ["# Python3 code to find the maximum path sum  \ndp = [0]*100\n  \n# Function for dfs traversal and \n# to store the maximum value in \n# dp[] for every node till the leaves  \ndef dfs(a, v, u, parent): \n      \n    # Initially dp[u] is always a[u] \n    dp[u] = a[u - 1] \n      \n    # Stores the maximum value from nodes \n    maximum = 0\n      \n    # Traverse the tree \n    for child in v[u]: \n          \n        # If child is parent, then we continue  \n        # without recursing further  \n        if child == parent: \n            continue\n          \n        # Call dfs for further traversal  \n        dfs(a, v, child, u) \n          \n        # Store the maximum of previous visited   \n        # node and present visited node  \n        maximum = max(maximum, dp[child]) \n          \n    # Add the maximum value  \n    # returned to the parent node  \n    dp[u] += maximum \n  \n  \n# Function that returns the maximum value \ndef maximumValue(a, v): \n    dfs(a, v, 1, 0) \n    return dp[1] \n  \n# Driver Code  \ndef main(): \n      \n    # Number of nodes  \n    n = 14\n      \n    # Adjacency list as a dictionary \n    v = {} \n    for i in range(n + 1): \n        v[i] = [] \n          \n    # Create undirected edges  \n    # initialize the tree given in the diagram  \n    v[1].append(2), v[2].append(1) \n    v[1].append(3), v[3].append(1)  \n    v[1].append(4), v[4].append(1)  \n    v[2].append(5), v[5].append(2)  \n    v[2].append(6), v[6].append(2)  \n    v[3].append(7), v[7].append(3)  \n    v[4].append(8), v[8].append(4)  \n    v[4].append(9), v[9].append(4)  \n    v[4].append(10), v[10].append(4)  \n    v[5].append(11), v[11].append(5)  \n    v[5].append(12), v[12].append(5)  \n    v[7].append(13), v[13].append(7)  \n    v[7].append(14), v[14].append(7)  \n      \n    # Values of node 1, 2, 3....14  \n    a = [ 3, 2, 1, 10, 1, 3, 9, \n          1, 5, 3, 4, 5, 9, 8 ] \n      \n    # Function call \n    print(maximumValue(a, v)) \nmain() \n  \n# This code is contributed by stutipathak31jan   \n"], "Memoization (1D, 2D and 3D) -  ": ["# Python3 program to find the Nth term\n# of Fibonacci series\n \n# Fibonacci Series using Recursion\ndef fib(n):\n \n \n    # Base case\n    if (n <= 1):\n        return n\n \n    # recursive calls\n    return fib(n - 1) + fib(n - 2)\n \n# Driver Code\nif __name__=='__main__':\n    n = 6\n    print (fib(n))\n  \n# This code is contributed by \n# Shivi_Aggarwal\n", "# Python program to find the Nth term\n# of Fibonacci series\nterm = [0 for i in range(1000)]\n \n# Fibonacci Series using memoized Recursion\ndef fib(n):\n   \n  # base case\n  if n <= 1:\n    return n\n \n  # if fib(n) has already been computed\n  # we do not do further recursive calls\n  # and hence reduce the number of repeated\n  # work\n  if term[n] != 0:\n    return term[n]\n \n  else:\n     \n    # store the computed value of fib(n)\n    # in an array term at index n to\n    # so that it does not needs to be\n    # precomputed again\n    term[n] = fib(n - 1) + fib(n - 2)\n    return term[n]\n \n# Driver Code\nn = 6\nprint(fib(n))\n \n# This code is contributed by rohitsingh07052\n", "# A Naive recursive implementation of LCS problem\n \n# Returns length of LCS for X[0..m-1], Y[0..n-1]\ndef lcs(X, Y, m, n):\n    if (m == 0 or n == 0):\n        return 0;\n    if (X[m - 1] == Y[n - 1]):\n        return 1 + lcs(X, Y, m - 1, n - 1);\n    else:\n        return max(lcs(X, Y, m, n - 1),\n                  lcs(X, Y, m - 1, n));\n \n# Driver Code\nif __name__=='__main__':\n    X = 'AGGTAB';\n    Y = 'GXTXAYB';\n    m = len(X);\n    n = len(Y);\n    print('Length of LCS is {}n'.format(lcs(X, Y, m, n)))\n \n# This code is contributed by rutvik_56.\n", "# Python3 program to memoize\n# recursive implementation of LCS problem\n \n# Returns length of LCS for X[0..m-1], Y[0..n-1]\n# memoization applied in recursive solution\ndef lcs(X, Y, m, n):\n \n    global arr\n \n    # base case\n    if (m == 0 or n == 0):\n        return 0\n \n    # if the same state has already been\n    # computed\n    if (arr[m - 1][n - 1] != -1):\n        return arr[m - 1][n - 1]\n \n    # if equal, then we store the value of the\n    # function call\n    if (X[m - 1] == Y[n - 1]):\n \n        # store it in arr to avoid further repetitive\n        # work in future function calls\n        arr[m - 1][n - 1] = 1 + lcs(X, Y, m - 1, n - 1)\n        return arr[m - 1][n - 1]\n \n    else:\n \n        # store it in arr to avoid further repetitive\n        # work in future function calls\n        arr[m - 1][n - 1] = max(lcs(X, Y, m, n - 1),\n                                lcs(X, Y, m - 1, n))\n        return arr[m - 1][n - 1]\n \n \n# Driver code\n \narr = [[0]*1000]*1000\n \nfor i in range(0, 1000):\n    for j in range(0, 1000):\n        arr[i][j] = -1\n \nX = 'AGGTAB'\nY = 'GXTXAYB'\n \nm = len(X)\nn = len(Y)\n \nprint('Length of LCS is ', lcs(X, Y, m, n))\n \n# This code is contributed by Dharanendra L V.\n", "# A recursive implementation of LCS problem of three strings\n \n# Returns length of LCS for X[0..m-1], Y[0..n-1]\ndef lcs(X, Y, Z, m, n, o):\n    # base case\n    if m == 0 or n == 0 or o == 0:\n      return 5\n     \n    # if equal, then check for next combination\n    if X[m - 1] == Y[n - 1] and Y[n - 1] == Z[o - 1]:\n      # recursive call\n      return 1 + lcs(X, Y, Z, m - 1, n - 1, o - 1)\n    else:\n      # return the maximum of the three other\n      # possible states in recursion\n      return max(lcs(X, Y, Z, m, n - 1, o), max(lcs(X, Y, Z, m - 1, n, o), lcs(X, Y, Z, m, n, o - 1)))\n \nX = 'geeks'.split()\nY = 'geeksfor'.split()\nZ = 'geeksforge'.split()\nm = len(X)\nn = len(Y)\no = len(Z)\nprint('Length of LCS is', lcs(X, Y, Z, m, n, o))\n \n# This code is contributed by rameshtravel07.\n", "# A memoize recursive implementation of LCS problem\n \n# Returns length of LCS for X[0..m-1], Y[0..n-1] */\n# memoization applied in recursive solution\ndef lcs(X, Y, Z, m, n, o):\n    global arr\n \n    # base case\n    if(m == 0 or n == 0 or o == 0):\n        return 0\n \n    # if the same state has already been\n    # computed\n    if (arr[m - 1][n - 1][o - 1] != -1):\n        return arr[m - 1][n - 1][o - 1]\n \n    # if equal, then we store the value of the\n    # function call\n    if (X[m - 1] == Y[n - 1] and\n            Y[n - 1] == Z[o - 1]):\n \n        # store it in arr to avoid further repetitive work\n        # in future function calls\n        arr[m - 1][n - 1][o - 1] = 1 + lcs(X, Y, Z, m - 1,\n                                           n - 1, o - 1)\n        return arr[m - 1][n - 1][o - 1]\n \n    else:\n \n        # store it in arr to avoid further repetitive work\n        # in future function calls\n        arr[m - 1][n - 1][o - 1] = max(lcs(X, Y, Z, m, n - 1, o),\n                                       max(lcs(X, Y, Z, m - 1, n, o), lcs(X, Y, Z, m, n, o - 1)))\n        return arr[m - 1][n - 1][o - 1]\n \n# Driver Code\narr = [[[0 for k in range(100)] for j in range(100)] for i in range(100)]\n \nfor i in range(100):\n    for j in range(100):\n        for k in range(100):\n            arr[i][j][k] = -1\n \nX = 'geeks'\nY = 'geeksfor'\nZ = ' '\nm = len(X)\nn = len(Y)\no = len(Z)\nprint('Length of LCS is ', lcs(X, Y, Z, m, n, o))\n \n# This code is contributed by Dharanendra L V.\n"], "Practice Questions for Recursion | Set 7 -  ": ["fp = 15\n  \n  \ndef fun(n): \n    global fp \n    if (n <= 2): \n        fp = 1\n        return 1\n  \n    t = fun(n - 1) \n    f = t + fp \n    fp = t \n    return f \n  \n# Driver code \n  \n  \nprint(fun(5)) \n  \n# This code is contributed by shubhamsingh10 \n", "def fun(n): \n  \n    if(n > 0): \n        fun(n - 1) \n        print(n, end=' ') \n        fun(n - 1) \n  \n# driver code \n  \n  \nfun(4) \n  \n# This code is contributed by shubhamsingh10 \n"], "Practice Questions for Recursion | Set 6 -  ": ["def abc(s):\n    if(len(s) == 0):\n        return\n     \n    abc(s[1:])\n    abc(s[1:])\n    print(s[0])\n     \n# This code is contributed by shubhamsingh10\n", "def abc(s):\n    if(len(s) == 0):\n        return\n     \n    abc(s[1:])\n    abc(s[1:])\n    print(s[0],end='')\n \n \n# Driver code\n \nabc('xyz')\n \n# This code is contributed by shubhamsingh10\n", "def fun(count):\n    print(count)\n    if(count < 3):\n        count+=1\n        fun(fun(fun(count))) \n     \n    return count \n  \n \nif __name__=='__main__':  \n     \n    fun(1) \n \n# This code is contributed by Shubhamsingh10 \n"], "Practice Questions for Recursion | Set 5 -  ": ["def fun(a, b):\n    if (b == 0):\n        return 0\n    if (b % 2 == 0):\n        return fun(a + a, b//2) \n     \n    return fun(a + a, b//2) + a \n \n# Driver code\n \nprint(fun(4, 3))\n \n# This code is contributed by SHUBHAMSINGH10\n", "def fun(a, b):\n    if (b == 0):\n        return 1\n    if (b % 2 == 0):\n        return fun(a*a, b//2) \n     \n    return fun(a*a, b//2)*a \n  \n# Driver code\n  \nprint(fun(4, 3))\n \n# This code is contributed by shubhamsingh10\n", "def fun(n):\n     \n    if (n > 100):\n        return n - 10\n     \n    return fun(fun(n + 11))\n     \n# Driver code\nprint(fun(99))\n \n# This code is contributed by Shubhamsingh10\n"], "Practice Questions for Recursion | Set 4 -  ": ["def fun(x):\n     \n    if(x > 0):\n        x -= 1\n        fun(x) \n        print(x , end=' ')\n        x -= 1\n        fun(x) \n         \n# Driver code\na = 4\nfun(a) \n \n# This code is contributed by SHUBHAMSINGH10\n", "def fun( a, n):\n    if(n == 1):\n        return a[0]\n    else:\n        x = fun(a, n - 1)\n    if(x > a[n - 1]):\n        return x\n    else:\n        return a[n - 1]\n \n# Driver code\narr = [12, 10, 30, 50, 100]\nprint(fun(arr, 5))\n \n# This code is contributed by shubhamsingh10\n", "def fun(i) : \n \n    if (i % 2 == 1) :\n        i += 1\n        return (i - 1)\n    else :\n        return fun(fun(i - 1))\n   \nprint(fun(200))\n \n# This code is contributed by divyeshrabadiya07\n"], "Practice Questions for Recursion | Set 3 -  ": ["def  fun1(n): \n    i = 0 \n    if (n > 1): \n        fun1(n - 1)  \n    for i in range(n): \n        print(' * ',end='') \n  \n# This code is contributed by shubhamsingh10 \n", "LIMIT = 1000\ndef fun2(n): \n    if (n <= 0): \n        return\n    if (n > LIMIT): \n        return\n    print(n, end=' ') \n    fun2(2 * n) \n    print(n, end=' ') \n  \n# This code is contributed by shubhamsingh10 \n"], "Practice Questions for Recursion | Set 2 -  ": ["# Assume that n is greater than or equal to 1 */\ndef fun1(n):\n    if(n == 1):\n        return 0\n    else:\n        return 1 + fun1(n//2)\n", "# Assume that n is greater than or equal to 0 */\ndef fun2(n):\n    if(n == 0):\n        return\n     \n    fun2(n // 2)\n    print(n % 2, end='')\n"], "Practice Questions for Recursion | Set 1 -  ": ["def fun1(x, y) : \n  \n    if (x == 0) : \n        return y \n    else : \n        return fun1(x - 1, x + y) \n  \n# This code is contributed by divyesh072019\n", "# Minimum index finder \ndef minIndex(arr, s, e): \n      \n    sml = sys.maxsize \n    mindex = 0\n      \n    for i in range(s, e): \n        if (sml > arr[i]): \n            sml = arr[i] \n            mindex = i \n              \n    return mindex \n  \ndef fun2(arr, start_index, end_index): \n      \n    if (start_index >= end_index): \n        return\n          \n    # minIndex() returns index of minimum value in \n    # array arr[start_index...end_index] \n    min_index = minIndex(arr, start_index, end_index) \n    arr[start_index], arr[min_index] = arr[min_index], arr[start_index] \n    fun2(arr, start_index + 1, end_index) \n  \n# This code is contributed by rag2127\n"], "Centroid Decomposition of Tree -  ": ["import collections\n \nMAXN = 1025\n \ntree = collections.defaultdict(list)\ncentroidTree = collections.defaultdict(list)\ncentroidMarked = [False]*MAXN\n \n# method to add edge between to nodes of the undirected tree \ndef addEdge(u, v):\n    tree[u].append(v)\n    tree[v].append(u)\n \n# method to setup subtree sizes and nodes in current tree \ndef DFS(src, visited, subtree_size, n):\n    # mark node visited \n    visited[src] = True\n \n    # increase count of nodes visited \n    n[0] += 1\n \n    # initialize subtree size for current node\n    subtree_size[src] = 1\n \n    # recur on non-visited and non-centroid neighbours \n    for it in tree[src]:\n        if not visited[it] and not centroidMarked[it]:\n            DFS(it, visited, subtree_size, n)\n            subtree_size[src] += subtree_size[it]\n \ndef getCentroid(src, visited, subtree_size, n):\n    # assume the current node to be centroid \n    is_centroid = True\n \n    # mark it as visited \n    visited[src] = True\n \n    # track heaviest child of node, to use in case node is \n    # not centroid \n    heaviest_child = 0\n \n    # iterate over all adjacent nodes which are children \n    # (not visited) and not marked as centroid to some \n    # subtree\n    for it in tree[src]:\n        if not visited[it] and not centroidMarked[it]:\n            # If any adjacent node has more than n/2 nodes,\n            # current node cannot be centroid \n            if subtree_size[it] > n/2:\n                is_centroid = False\n \n            # update heaviest child \n            if heaviest_child == 0 or subtree_size[it] > subtree_size[heaviest_child]:\n                heaviest_child = it\n \n    # if current node is a centroid \n    if is_centroid and n - subtree_size[src] <= n/2:\n        return src\n \n    # else recur on heaviest child \n    return getCentroid(heaviest_child, visited, subtree_size, n)\n \n# function to get the centroid of tree rooted at src.\n# tree may be the original one or may belong to the forest \n# function to get the centroid of tree rooted at src.\n# tree may be the original one or may belong to the forest \ndef getCentroidTree(src):\n    visited = [False]*MAXN\n \n    subtree_size = [0]*MAXN\n \n    # initialize auxiliary arrays\n    n = [0]\n \n    # DFS to set up subtree sizes and nodes in current tree \n    DFS(src, visited, subtree_size, n)\n \n    visited = [False]*MAXN\n \n    centroid = getCentroid(src, visited, subtree_size, n[0])\n \n    centroidMarked[centroid] = True\n \n    return centroid\n \n \n# function to generate centroid tree of tree rooted at src \ndef decomposeTree(root):\n    # get centroid for current tree \n    cend_tree = getCentroidTree(root)\n \n    print(cend_tree, end=' ')\n \n \n    # for every node adjacent to the found centroid, \n    # decompose the tree rooted at that node\n    for it in tree[cend_tree]:\n        if not centroidMarked[it]:\n            decomposeTree(it)\n \n# driver code\nif __name__ == '__main__':\n    # number of nodes in the tree \n    n = 16\n \n    # arguments in order: node u, node v\n    # sequencing starts from 1 \n    addEdge(1, 4)\n    addEdge(2, 4)\n    addEdge(3, 4)\n    addEdge(4, 5)\n    addEdge(5, 6)\n    addEdge(6, 7)\n    addEdge(7, 8)\n    addEdge(7, 9)\n    addEdge(6, 10)\n    addEdge(10, 11)\n    addEdge(11, 12)\n    addEdge(11, 13)\n    addEdge(12, 14)\n    addEdge(13, 15)\n    addEdge(13, 16)\n \n    # generates centroid tree \n    decomposeTree(1)\n"], "Dinic's algorithm for Maximum Flow -  ": ["# Python implementation of Dinic's Algorithm\nclass Edge:\n    def __init__(self, v, flow, C, rev):\n        self.v = v\n        self.flow = flow\n        self.C = C\n        self.rev = rev\n \n# Residual Graph\n \n \nclass Graph:\n    def __init__(self, V):\n        self.adj = [[] for i in range(V)]\n        self.V = V\n        self.level = [0 for i in range(V)]\n \n    # add edge to the graph\n    def addEdge(self, u, v, C):\n \n        # Forward edge : 0 flow and C capacity\n        a = Edge(v, 0, C, len(self.adj[v]))\n \n        # Back edge : 0 flow and 0 capacity\n        b = Edge(u, 0, 0, len(self.adj[u]))\n        self.adj[u].append(a)\n        self.adj[v].append(b)\n \n    # Finds if more flow can be sent from s to t\n    # Also assigns levels to nodes\n    def BFS(self, s, t):\n        for i in range(self.V):\n            self.level[i] = -1\n \n        # Level of source vertex\n        self.level[s] = 0\n \n        # Create a queue, enqueue source vertex\n        # and mark source vertex as visited here\n        # level[] array works as visited array also\n        q = []\n        q.append(s)\n        while q:\n            u = q.pop(0)\n            for i in range(len(self.adj[u])):\n                e = self.adj[u][i]\n                if self.level[e.v] < 0 and e.flow < e.C:\n \n                    # Level of current vertex is\n                    # level of parent + 1\n                    self.level[e.v] = self.level[u]+1\n                    q.append(e.v)\n \n        # If we can not reach to the sink we\n        # return False else True\n        return False if self.level[t] < 0 else True\n \n# A DFS based function to send flow after BFS has\n# figured out that there is a possible flow and\n# constructed levels. This functions called multiple\n# times for a single call of BFS.\n# flow : Current flow send by parent function call\n# start[] : To keep track of next edge to be explored\n#           start[i] stores count of edges explored\n#           from i\n# u : Current vertex\n# t : Sink\n    def sendFlow(self, u, flow, t, start):\n        # Sink reached\n        if u == t:\n            return flow\n \n        # Traverse all adjacent edges one -by -one\n        while start[u] < len(self.adj[u]):\n \n            # Pick next edge from adjacency list of u\n            e = self.adj[u][start[u]]\n            if self.level[e.v] == self.level[u]+1 and e.flow < e.C:\n \n                # find minimum flow from u to t\n                curr_flow = min(flow, e.C-e.flow)\n                temp_flow = self.sendFlow(e.v, curr_flow, t, start)\n \n                # flow is greater than zero\n                if temp_flow and temp_flow > 0:\n \n                    # add flow to current edge\n                    e.flow += temp_flow\n \n                    # subtract flow from reverse edge\n                    # of current edge\n                    self.adj[e.v][e.rev].flow -= temp_flow\n                    return temp_flow\n            start[u] += 1\n \n    # Returns maximum flow in graph\n    def DinicMaxflow(self, s, t):\n \n        # Corner case\n        if s == t:\n            return -1\n \n        # Initialize result\n        total = 0\n \n        # Augument the flow while there is path\n        # from source to sink\n        while self.BFS(s, t) == True:\n \n            # store how many edges are visited\n            # from V { 0 to V }\n            start = [0 for i in range(self.V+1)]\n            while True:\n                flow = self.sendFlow(s, float('inf'), t, start)\n                if not flow:\n                    break\n \n                # Add path flow to overall flow\n                total += flow\n \n        # return maximum flow\n        return total\n \n \ng = Graph(6)\ng.addEdge(0, 1, 16)\ng.addEdge(0, 2, 13)\ng.addEdge(1, 2, 10)\ng.addEdge(1, 3, 12)\ng.addEdge(2, 1, 4)\ng.addEdge(2, 4, 14)\ng.addEdge(3, 2, 9)\ng.addEdge(3, 5, 20)\ng.addEdge(4, 3, 7)\ng.addEdge(4, 5, 4)\nprint('Maximum flow', g.DinicMaxflow(0, 5))\n \n# This code is contributed by rupasriachanta421.\n"], "Find minimum s-t cut in a flow network -  ": [], "Ford-Fulkerson Algorithm for Maximum Flow Problem -  ": [], "Euler Circuit in a Directed Graph -  ": ["# A Python3 program to check if a given \n# directed graph is Eulerian or not\n \nfrom collections import defaultdict\n \nclass Graph():\n \n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n        self.IN = [0] * vertices\n \n    def addEdge(self, v, u):\n \n        self.graph[v].append(u)\n        self.IN[u] += 1\n \n    def DFSUtil(self, v, visited):\n        visited[v] = True\n        for node in self.graph[v]:\n            if visited[node] == False:\n                self.DFSUtil(node, visited)\n \n    def getTranspose(self):\n        gr = Graph(self.V)\n \n        for node in range(self.V):\n            for child in self.graph[node]:\n                gr.addEdge(child, node)\n \n        return gr\n \n    def isSC(self):\n        visited = [False] * self.V\n \n        v = 0\n        for v in range(self.V):\n            if len(self.graph[v]) > 0:\n                break\n \n        self.DFSUtil(v, visited)\n \n        # If DFS traversal doesn't visit all \n        # vertices, then return false.\n        for i in range(self.V):\n            if visited[i] == False:\n                return False\n \n        gr = self.getTranspose()\n \n        visited = [False] * self.V\n        gr.DFSUtil(v, visited)\n \n        for i in range(self.V):\n            if visited[i] == False:\n                return False\n \n        return True\n \n    def isEulerianCycle(self):\n \n        # Check if all non-zero degree vertices \n        # are connected\n        if self.isSC() == False:\n            return False\n \n        # Check if in degree and out degree of \n        # every vertex is same\n        for v in range(self.V):\n            if len(self.graph[v]) != self.IN[v]:\n                return False\n \n        return True\n \n \ng = Graph(5);\ng.addEdge(1, 0);\ng.addEdge(0, 2);\ng.addEdge(2, 1);\ng.addEdge(0, 3);\ng.addEdge(3, 4);\ng.addEdge(4, 0);\nif g.isEulerianCycle():\n   print( 'Given directed graph is eulerian');\nelse:\n   print( 'Given directed graph is NOT eulerian');\n \n# This code is contributed by Divyanshu Mehta\n"], "Eulerian path and circuit for undirected graph -  ": ["# Python program to check if a given graph is Eulerian or not\n#Complexity : O(V+E)\n \nfrom collections import defaultdict\n \n# This class represents a undirected graph using adjacency list representation\n \n \nclass Graph:\n \n    def __init__(self, vertices):\n        self.V = vertices  # No. of vertices\n        self.graph = defaultdict(list)  # default dictionary to store graph\n \n    # function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n \n    # A function used by isConnected\n    def DFSUtil(self, v, visited):\n        # Mark the current node as visited\n        visited[v] = True\n \n        # Recur for all the vertices adjacent to this vertex\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.DFSUtil(i, visited)\n \n    '''Method to check if all non-zero degree vertices are\n    connected. It mainly does DFS traversal starting from \n    node with non-zero degree'''\n \n    def isConnected(self):\n \n        # Mark all the vertices as not visited\n        visited = [False]*(self.V)\n \n        #  Find a vertex with non-zero degree\n        for i in range(self.V):\n            if len(self.graph[i]) != 0:\n                break\n \n        # If there are no edges in the graph, return true\n        if i == self.V-1:\n            return True\n \n        # Start DFS traversal from a vertex with non-zero degree\n        self.DFSUtil(i, visited)\n \n        # Check if all non-zero degree vertices are visited\n        for i in range(self.V):\n            if visited[i] == False and len(self.graph[i]) > 0:\n                return False\n \n        return True\n \n    '''The function returns one of the following values\n       0 --> If graph is not Eulerian\n       1 --> If graph has an Euler path (Semi-Eulerian)\n       2 --> If graph has an Euler Circuit (Eulerian)  '''\n \n    def isEulerian(self):\n        # Check if all non-zero degree vertices are connected\n        if self.isConnected() == False:\n            return 0\n        else:\n            # Count vertices with odd degree\n            odd = 0\n            for i in range(self.V):\n                if len(self.graph[i]) % 2 != 0:\n                    odd += 1\n \n            '''If odd count is 2, then semi-eulerian.\n            If odd count is 0, then eulerian\n            If count is more than 2, then graph is not Eulerian\n            Note that odd count can never be 1 for undirected graph'''\n            if odd == 0:\n                return 2\n            elif odd == 2:\n                return 1\n            elif odd > 2:\n                return 0\n \n     # Function to run test cases\n \n    def test(self):\n        res = self.isEulerian()\n        if res == 0:\n            print('graph is not Eulerian')\n        elif res == 1:\n            print('graph has a Euler path')\n        else:\n            print('graph has a Euler cycle')\n \n \n# Let us create and test graphs shown in above figures\ng1 = Graph(5)\ng1.addEdge(1, 0)\ng1.addEdge(0, 2)\ng1.addEdge(2, 1)\ng1.addEdge(0, 3)\ng1.addEdge(3, 4)\ng1.test()\n \ng2 = Graph(5)\ng2.addEdge(1, 0)\ng2.addEdge(0, 2)\ng2.addEdge(2, 1)\ng2.addEdge(0, 3)\ng2.addEdge(3, 4)\ng2.addEdge(4, 0)\ng2.test()\n \ng3 = Graph(5)\ng3.addEdge(1, 0)\ng3.addEdge(0, 2)\ng3.addEdge(2, 1)\ng3.addEdge(0, 3)\ng3.addEdge(3, 4)\ng3.addEdge(1, 3)\ng3.test()\n \n# Let us create a graph with 3 vertices\n# connected in the form of cycle\ng4 = Graph(3)\ng4.addEdge(0, 1)\ng4.addEdge(1, 2)\ng4.addEdge(2, 0)\ng4.test()\n \n# Let us create a graph with all vertices\n# with zero degree\ng5 = Graph(3)\ng5.test()\n \n# This code is contributed by Neelam Yadav\n"], "Kahn's algorithm for Topological Sorting -  ": ["# A Python program to print topological sorting of a graph\n# using indegrees\nfrom collections import defaultdict\n \n# Class to represent a graph\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list) # dictionary containing adjacency List\n        self.V = vertices # No. of vertices\n \n    # function to add an edge to graph\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n \n \n    # The function to do Topological Sort. \n    def topologicalSort(self):\n         \n        # Create a vector to store indegrees of all\n        # vertices. Initialize all indegrees as 0.\n        in_degree = [0]*(self.V)\n         \n        # Traverse adjacency lists to fill indegrees of\n           # vertices.  This step takes O(V + E) time\n        for i in self.graph:\n            for j in self.graph[i]:\n                in_degree[j] += 1\n \n        # Create an queue and enqueue all vertices with\n        # indegree 0\n        queue = []\n        for i in range(self.V):\n            if in_degree[i] == 0:\n                queue.append(i)\n \n        # Initialize count of visited vertices\n        cnt = 0\n \n        # Create a vector to store result (A topological\n        # ordering of the vertices)\n        top_order = []\n \n        # One by one dequeue vertices from queue and enqueue\n        # adjacents if indegree of adjacent becomes 0\n        while queue:\n \n            # Extract front of queue (or perform dequeue)\n            # and add it to topological order\n            u = queue.pop(0)\n            top_order.append(u)\n \n            # Iterate through all neighbouring nodes\n            # of dequeued node u and decrease their in-degree\n            # by 1\n            for i in self.graph[u]:\n                in_degree[i] -= 1\n                # If in-degree becomes zero, add it to queue\n                if in_degree[i] == 0:\n                    queue.append(i)\n \n            cnt += 1\n \n        # Check if there was a cycle\n        if cnt != self.V:\n            print ('There exists a cycle in the graph')\n        else :\n            # Print topological order\n            print (top_order)\n \n \ng = Graph(6)\ng.addEdge(5, 2);\ng.addEdge(5, 0);\ng.addEdge(4, 0);\ng.addEdge(4, 1);\ng.addEdge(2, 3);\ng.addEdge(3, 1);\n \nprint ('Following is a Topological Sort of the given graph')\ng.topologicalSort()\n \n# This code is contributed by Neelam Yadav \n"], "Union-Find Algorithm | (Union By Rank and Find by Optimized Path Compression) -  ": ["# Python3 program to implement Union-Find \n# with union by rank and path compression.\n \n# set parent of every node to itself \n# and size of node to one \ndef initialize(n):\n    global Arr, size\n    for i in range(n + 1):\n        Arr[i] = i \n        size[i] = 1\n \n# Each time we follow a path, find \n# function compresses it further \n# until the path length is greater \n# than or equal to 1. \ndef find(i):\n    global Arr, size\n     \n    # while we reach a node whose \n    # parent is equal to itself \n    while (Arr[i] != i):\n        Arr[i] = Arr[Arr[i]] # Skip one level \n        i = Arr[i] # Move to the new level\n    return i\n \n# A function that does union of two \n# nodes x and y where xr is root node \n# of x and yr is root node of y \ndef _union(xr, yr):\n    global Arr, size\n    if (size[xr] < size[yr]): # Make yr parent of xr \n        Arr[xr] = Arr[yr] \n        size[yr] += size[xr]\n    else: # Make xr parent of yr\n        Arr[yr] = Arr[xr] \n        size[xr] += size[yr]\n \n# The main function to check whether \n# a given graph contains cycle or not \ndef isCycle(adj, V):\n    global Arr, size\n     \n    # Iterate through all edges of graph, \n    # find nodes connecting them. \n    # If root nodes of both are same, \n    # then there is cycle in graph.\n    for i in range(V):\n        for j in range(len(adj[i])):\n            x = find(i) # find root of i \n            y = find(adj[i][j]) # find root of adj[i][j] \n \n            if (x == y):\n                return 1 # If same parent \n            _union(x, y) # Make them connect\n    return 0\n \n# Driver Code\nMAX_VERTEX = 101\n \n# Arr to represent parent of index i \nArr = [None] * MAX_VERTEX \n \n# Size to represent the number of nodes \n# in subgraph rooted at index i \nsize = [None] * MAX_VERTEX \n \nV = 3\n \n# Initialize the values for array \n# Arr and Size \ninitialize(V) \n \n# Let us create following graph \n#     0 \n# | \\ \n# | \\ \n# 1-----2 \n \n# Adjacency list for graph \nadj = [[] for i in range(V)] \n \nadj[0].append(1) \nadj[0].append(2) \nadj[1].append(2) \n \n# call is_cycle to check if it \n# contains cycle \nif (isCycle(adj, V)): \n    print('Graph contains Cycle.') \nelse:\n    print('Graph does not contain Cycle.')\n \n# This code is contributed by PranchalK\n"], "Union By Rank and Path Compression in Union-Find Algorithm -  ": ["# Naive implementation of find\ndef find(parent, i):\n     \n    if (parent[i] == -1):\n        return i\n     \n    return find(parent, parent[i])\n \n# Naive implementation of union()\ndef Union(parent, x, y):\n \n    xset = find(parent, x)\n    yset = find(parent, y)\n    parent[xset] = yset\n \n# This code is contributed by rutvik_56\n", "# A union by rank and path compression based\n# program to detect cycle in a graph\nfrom collections import defaultdict\n \n# a structure to represent a graph\n \n \nclass Graph:\n \n    def __init__(self, num_of_v):\n        self.num_of_v = num_of_v\n        self.edges = defaultdict(list)\n \n    # graph is represented as an\n    # array of edges\n    def add_edge(self, u, v):\n        self.edges[u].append(v)\n \n \nclass Subset:\n    def __init__(self, parent, rank):\n        self.parent = parent\n        self.rank = rank\n \n# A utility function to find set of an element\n# node(uses path compression technique)\n \n \ndef find(subsets, node):\n    if subsets[node].parent != node:\n        subsets[node].parent = find(subsets, subsets[node].parent)\n    return subsets[node].parent\n \n# A function that does union of two sets\n# of u and v(uses union by rank)\n \n \ndef union(subsets, u, v):\n \n    # Attach smaller rank tree under root\n    # of high rank tree(Union by Rank)\n    if subsets[u].rank > subsets[v].rank:\n        subsets[v].parent = u\n    elif subsets[v].rank > subsets[u].rank:\n        subsets[u].parent = v\n \n    # If ranks are same, then make one as\n    # root and increment its rank by one\n    else:\n        subsets[v].parent = u\n        subsets[u].rank += 1\n \n# The main function to check whether a given\n# graph contains cycle or not\n \n \ndef isCycle(graph):\n \n    # Allocate memory for creating sets\n    subsets = []\n \n    for u in range(graph.num_of_v):\n        subsets.append(Subset(u, 0))\n \n    # Iterate through all edges of graph,\n    # find sets of both vertices of every\n    # edge, if sets are same, then there\n    # is cycle in graph.\n    for u in graph.edges:\n        u_rep = find(subsets, u)\n \n        for v in graph.edges[u]:\n            v_rep = find(subsets, v)\n \n            if u_rep == v_rep:\n                return True\n            else:\n                union(subsets, u_rep, v_rep)\n \n \n# Driver Code\ng = Graph(3)\n \n# add edge 0-1\ng.add_edge(0, 1)\n \n# add edge 1-2\ng.add_edge(1, 2)\n \n# add edge 0-2\ng.add_edge(0, 2)\n \nif isCycle(g):\n    print('Graph contains cycle')\nelse:\n    print('Graph does not contain cycle')\n \n# This code is contributed by\n# Sampath Kumar Surine\n"], "Dial's Algorithm (Optimized Dijkstra for small range weights) -  ": ["from typing import List, Tuple\nINF = 0x3f3f3f3f\n \n# This class represents a directed graph using adjacency list representation\nclass Graph:\n    def __init__(self, V: int):\n        # No. of vertices\n        self.V = V\n         \n        # In a weighted graph, we need to store vertex and weight pair for every edge\n        self.adj = [[] for _ in range(V)]\n \n    # function to add an edge to graph\n    def addEdge(self, u: int, v: int, w: int):\n        self.adj[u].append((v, w))\n        self.adj[v].append((u, w))\n \n    # Prints shortest paths from src to all other vertices.\n    # W is the maximum weight of an edge\n    def shortestPath(self, src: int, W: int):\n        # With each distance, iterator to that vertex in its bucket is stored so that vertex can be deleted\n        # in O(1) at time of updation. So dist[i][0] = distance of ith vertex from src vertex\n        # dist[i][1] = iterator to vertex i in bucket number\n        dist = [[INF, None] for _ in range(self.V)]\n \n        # Initialize distance of source vertex\n        dist[src][0] = 0\n \n        # Create buckets B[].\n        # B[i] keep vertex of distance label i\n        B = [[] for _ in range(W * self.V + 1)]\n        B[0].append(src)\n \n        idx = 0\n        while True:\n            # Go sequentially through buckets till one non-empty bucket is found\n            while len(B[idx]) == 0 and idx < W * self.V:\n                idx += 1\n \n            # If all buckets are empty, we are done.\n            if idx == W * self.V:\n                break\n \n            # Take top vertex from bucket and pop it\n            u = B[idx][0]\n            B[idx].pop(0)\n \n            # Process all adjacents of extracted vertex \n            # 'u' and update their distances if required.\n            for v, weight in self.adj[u]:\n                du = dist[u][0]\n                dv = dist[v][0]\n \n                # If there is shorted path to v through u.\n                if dv > du + weight:\n                    # If dv is not INF then it must be in \n                    # B[dv] bucket, so erase its entry using iterator\n                    # in O(1)\n                    if dv != INF:\n                        B[dv].remove(v)\n \n                    # updating the distance\n                    dist[v][0] = du + weight\n                    dv = dist[v][0]\n \n                    # pushing vertex v into updated distance's bucket\n                    B[dv].append(v)\n \n                    # storing updated iterator in dist[v][1]\n                    dist[v][1] = len(B[dv]) - 1\n \n        # Print shortest distances stored in dist[]\n        print('Vertex Distance from Source')\n        for i in range(self.V):\n            print(f'{i}     {dist[i][0]}')\n \n# Driver program to test methods of graph class\ndef main():\n    # create the graph given in above figure\n    V = 9\n    W = 14\n    g = Graph(V)\n \n    g.addEdge(0, 1, 4)\n    g.addEdge(0, 7, 8)\n    g.addEdge(1, 2, 8)\n    g.addEdge(1, 7, 11)\n    g.addEdge(2, 3, 7)\n    g.addEdge(2, 8, 2)\n    g.addEdge(2, 5, 4)\n    g.addEdge(3, 4, 9)\n    g.addEdge(3, 5, 14)\n    g.addEdge(4, 5, 10)\n    g.addEdge(5, 6, 2)\n    g.addEdge(6, 7, 1)\n    g.addEdge(6, 8, 6)\n    g.addEdge(7, 8, 7)\n \n    g.shortestPath(0, W)\n \nif __name__ == '__main__':\n    main()\n     \n# This code is contributed by sanjanasikarwar24\n"], "0-1 BFS (Shortest Path in a Binary Weight Graph) -  ": ["# Python3 program to implement single source \n# shortest path for a Binary Graph \nfrom sys import maxsize as INT_MAX \nfrom collections import deque \n  \n# no.of vertices \nV = 9\n  \n# a structure to represent edges \nclass node: \n    def __init__(self, to, weight): \n  \n        # two variable one denote the node \n        # and other the weight \n        self.to = to \n        self.weight = weight \n  \n# vector to store edges \nedges = [0] * V \nfor i in range(V): \n    edges[i] = [] \n  \n# Prints shortest distance from  \n# given source to every other vertex \ndef zeroOneBFS(src: int): \n  \n    # Initialize distances from given source \n    dist = [0] * V \n    for i in range(V): \n        dist[i] = INT_MAX \n  \n    # double ende queue to do BFS. \n    Q = deque() \n    dist[src] = 0\n    Q.append(src) \n  \n    while Q: \n        v = Q[0] \n        Q.popleft() \n  \n        for i in range(len(edges[v])): \n  \n            # checking for the optimal distance \n            if (dist[edges[v][i].to] >  \n                dist[v] + edges[v][i].weight): \n                dist[edges[v][i].to] = dist[v] + edges[v][i].weight \n  \n                # Put 0 weight edges to front and 1 weight \n                # edges to back so that vertices are processed \n                # in increasing order of weights. \n                if edges[v][i].weight == 0: \n                    Q.appendleft(edges[v][i].to) \n                else: \n                    Q.append(edges[v][i].to) \n  \n    # printing the shortest distances \n    for i in range(V): \n        print(dist[i], end = ' ') \n    print() \n  \ndef addEdge(u: int, v: int, wt: int): \n    edges[u].append(node(v, wt)) \n    edges[u].append(node(v, wt)) \n  \n# Driver Code \nif __name__ == '__main__': \n  \n    addEdge(0, 1, 0) \n    addEdge(0, 7, 1) \n    addEdge(1, 7, 1) \n    addEdge(1, 2, 1) \n    addEdge(2, 3, 0) \n    addEdge(2, 5, 0) \n    addEdge(2, 8, 1) \n    addEdge(3, 4, 1) \n    addEdge(3, 5, 1) \n    addEdge(4, 5, 1) \n    addEdge(5, 6, 1) \n    addEdge(6, 7, 1) \n    addEdge(7, 8, 1) \n  \n    # source node \n    src = 0\n    zeroOneBFS(src) \n  \n# This code is contributed by \n# sanjeev2552 \n"], "Floyd Warshall Algorithm -  ": ["# Python3 Program for Floyd Warshall Algorithm\n \n# Number of vertices in the graph\nV = 4\n \n# Define infinity as the large\n# enough value. This value will be\n# used for vertices not connected to each other\nINF = 99999\n \n# Solves all pair shortest path\n# via Floyd Warshall Algorithm\n \n \ndef floydWarshall(graph):\n    ''' dist[][] will be the output \n       matrix that will finally\n        have the shortest distances \n        between every pair of vertices '''\n    ''' initializing the solution matrix \n    same as input graph matrix\n    OR we can say that the initial \n    values of shortest distances\n    are based on shortest paths considering no \n    intermediate vertices '''\n \n    dist = list(map(lambda i: list(map(lambda j: j, i)), graph))\n \n    ''' Add all vertices one by one \n    to the set of intermediate\n     vertices.\n     ---> Before start of an iteration, \n     we have shortest distances\n     between all pairs of vertices \n     such that the shortest\n     distances consider only the \n     vertices in the set \n    {0, 1, 2, .. k-1} as intermediate vertices.\n      ----> After the end of a \n      iteration, vertex no. k is\n     added to the set of intermediate \n     vertices and the \n    set becomes {0, 1, 2, .. k}\n    '''\n    for k in range(V):\n \n        # pick all vertices as source one by one\n        for i in range(V):\n \n            # Pick all vertices as destination for the\n            # above picked source\n            for j in range(V):\n \n                # If vertex k is on the shortest path from\n                # i to j, then update the value of dist[i][j]\n                dist[i][j] = min(dist[i][j],\n                                 dist[i][k] + dist[k][j]\n                                 )\n    printSolution(dist)\n \n \n# A utility function to print the solution\ndef printSolution(dist):\n    print('Following matrix shows the shortest distances\\\n between every pair of vertices')\n    for i in range(V):\n        for j in range(V):\n            if(dist[i][j] == INF):\n                print('%7s' % ('INF'), end=' ')\n            else:\n                print('%7d\\t' % (dist[i][j]), end=' ')\n            if j == V-1:\n                print()\n \n \n# Driver's code\nif __name__ == '__main__':\n    '''\n                10\n           (0)------->(3)\n            |         /|\\\n          5 |          |\n            |          | 1\n           \\|/         |\n           (1)------->(2)\n                3           '''\n    graph = [[0, 5, INF, 10],\n             [INF, 0, 3, INF],\n             [INF, INF, 0,   1],\n             [INF, INF, INF, 0]\n             ]\n    # Function call\n    floydWarshall(graph)\n# This code is contributed by Mythri J L\n"], "Level of Each node in a Tree from source node (using BFS) -  ": ["# Python3 Program to determine level\n# of each node and print level\nimport queue\n \n# function to determine level of\n# each node starting from x using BFS\n \n \ndef printLevels(graph, V, x):\n \n    # array to store level of each node\n    level = [None] * V\n    marked = [False] * V\n \n    # create a queue\n    que = queue.Queue()\n \n    # enqueue element x\n    que.put(x)\n \n    # initialize level of source\n    # node to 0\n    level[x] = 0\n \n    # marked it as visited\n    marked[x] = True\n \n    # do until queue is empty\n    while (not que.empty()):\n \n        # get the first element of queue\n        x = que.get()\n \n        # traverse neighbors of node x\n        for i in range(len(graph[x])):\n \n            # b is neighbor of node x\n            b = graph[x][i]\n \n            # if b is not marked already\n            if (not marked[b]):\n \n                # enqueue b in queue\n                que.put(b)\n \n                # level of b is level of x + 1\n                level[b] = level[x] + 1\n \n                # mark b\n                marked[b] = True\n \n    # display all nodes and their levels\n    print('Nodes', ' ', 'Level')\n    for i in range(V):\n        print(' ', i,  ' --> ', level[i])\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # adjacency graph for tree\n    V = 8\n    graph = [[] for i in range(V)]\n \n    graph[0].append(1)\n    graph[0].append(2)\n    graph[1].append(3)\n    graph[1].append(4)\n    graph[1].append(5)\n    graph[2].append(5)\n    graph[2].append(6)\n    graph[6].append(7)\n \n    # call levels function with source as 0\n    printLevels(graph, V, 0)\n \n# This code is contributed by PranchalK\n"], "Heap queue (or heapq) in Python -  ": ["# importing 'heapq' to implement heap queue\nimport heapq\n \n# initializing list\nli = [5, 7, 9, 1, 3]\n \n# using heapify to convert list into heap\nheapq.heapify(li)\n \n# printing created heap\nprint ('The created heap is : ',(list(li)))\n", "# importing 'heapq' to implement heap queue\nimport heapq\n \n# initializing list\nli = [5, 7, 9, 1, 3]\n \n# using heapify to convert list into heap\nheapq.heapify(li)\n \n# printing created heap\nprint('The created heap is : ', end='')\nprint(list(li))\n \n# using heappush() to push elements into heap\n# pushes 4\nheapq.heappush(li, 4)\n \n# printing modified heap\nprint('The modified heap after push is : ', end='')\nprint(list(li))\n \n# using heappop() to pop smallest element\nprint('The popped and smallest element is : ', end='')\nprint(heapq.heappop(li))\n", "# importing 'heapq' to implement heap queue\nimport heapq\n \n# initializing list 1\nli1 = [5, 1, 9, 4, 3]\n \n# initializing list 2\nli2 = [5, 7, 9, 4, 3]\n \n# using heapify() to convert list into heap\nheapq.heapify(li1)\nheapq.heapify(li2)\n \n# using heappushpop() to push and pop items simultaneously\n# pops 2\nprint('The popped item using heappushpop() is : ', end='')\nprint(heapq.heappushpop(li1, 2))\n \n# using heapreplace() to push and pop items simultaneously\n# pops 3\nprint('The popped item using heapreplace() is : ', end='')\nprint(heapq.heapreplace(li2, 2))\n", "# Python code to demonstrate working of\n# nlargest() and nsmallest()\n \n# importing 'heapq' to implement heap queue\nimport heapq\n \n# initializing list\nli1 = [6, 7, 9, 4, 3, 5, 8, 10, 1]\n \n# using heapify() to convert list into heap\nheapq.heapify(li1)\n \n# using nlargest to print 3 largest numbers\n# prints 10, 9 and 8\nprint('The 3 largest numbers in list are : ', end='')\nprint(heapq.nlargest(3, li1))\n \n# using nsmallest to print 3 smallest numbers\n# prints 1, 3 and 4\nprint('The 3 smallest numbers in list are : ', end='')\nprint(heapq.nsmallest(3, li1))\n", "import heapq\n \n# Initialize a list with some values\nvalues = [5, 1, 3, 7, 4, 2]\n \n# Convert the list into a heap\nheapq.heapify(values)\n \n# Print the heap\nprint('Heap:', values)\n \n# Add a new value to the heap\nheapq.heappush(values, 6)\n \n# Print the updated heap\nprint('Heap after push:', values)\n \n# Remove and return the smallest element from the heap\nsmallest = heapq.heappop(values)\n \n# Print the smallest element and the updated heap\nprint('Smallest element:', smallest)\nprint('Heap after pop:', values)\n \n# Get the n smallest elements from the heap\nn_smallest = heapq.nsmallest(3, values)\n \n# Print the n smallest elements\nprint('Smallest 3 elements:', n_smallest)\n \n# Get the n largest elements from the heap\nn_largest = heapq.nlargest(2, values)\n \n# Print the n largest elements\nprint('Largest 2 elements:', n_largest)\n"], "PriorityQueue in Java -  ": [], "Priority Queue in C++ Standard Template Library (STL) -  ": [], "Deque in Python -  ": ["from collections import deque \n     \n# Declaring deque \nqueue = deque(['name','age','DOB'])  \n     \nprint(queue)\n", "# importing 'collections' for deque operations\nimport collections\n \n# initializing deque\nde = collections.deque([1, 2, 3])\nprint('deque: ', de)\n \n# using append() to insert element at right end\n# inserts 4 at the end of deque\nde.append(4)\n \n# printing modified deque\nprint('\\nThe deque after appending at right is : ')\nprint(de)\n \n# using appendleft() to insert element at left end\n# inserts 6 at the beginning of deque\nde.appendleft(6)\n \n# printing modified deque\nprint('\\nThe deque after appending at left is : ')\nprint(de)\n", "# importing 'collections' for deque operations\nimport collections\n \n# initializing deque\nde = collections.deque([6, 1, 2, 3, 4])\nprint('deque: ', de)\n \n# using pop() to delete element from right end\n# deletes 4 from the right end of deque\nde.pop()\n \n# printing modified deque\nprint('\\nThe deque after deleting from right is : ')\nprint(de)\n \n# using popleft() to delete element from left end\n# deletes 6 from the left end of deque\nde.popleft()\n \n# printing modified deque\nprint('\\nThe deque after deleting from left is : ')\nprint(de)\n", "# Python code to demonstrate working of \n# insert(), index(), remove(), count()\n \n# importing 'collections' for deque operations\nimport collections\n \n# initializing deque\nde = collections.deque([1, 2, 3, 3, 4, 2, 4])\n \n# using index() to print the first occurrence of 4\nprint ('The number 4 first occurs at a position : ')\nprint (de.index(4,2,5))\n \n# using insert() to insert the value 3 at 5th position\nde.insert(4,3)\n \n# printing modified deque\nprint ('The deque after inserting 3 at 5th position is : ')\nprint (de)\n \n# using count() to count the occurrences of 3\nprint ('The count of 3 in deque is : ')\nprint (de.count(3))\n \n# using remove() to remove the first occurrence of 3\nde.remove(3)\n \n# printing modified deque\nprint ('The deque after deleting first occurrence of 3 is : ')\nprint (de)\n", "# Python Program to demonstrate \n# how to find size of a Dequeue\nfrom collections import deque\n \n# initializing deque\nde = deque([1, 2, 3, 4, 5, 6])\nprint('Current Deque: ', de)\n \n# printing current size of deque\nprint(f'Size of Deque: {len(de)}')\n \n# using pop() to delete element from right end\n# deletes 6 from the right end of deque\nde.pop()\n \n# printing modified deque\nprint('\\nThe deque after deleting from right is: ', end = '')\nprint(de)\n \n# printing current size of deque\nprint(f'Size of Deque: {len(de)}')\n \n# This code is contributed by Susobhan Akhuli\n", "# Python Program to demonstrate\n# accessing the front and back of a Deque\n \nfrom collections import deque\n \n# initializing deque\nde = deque([1, 2, 3, 4, 5, 6])\nprint('Current Deque: ', de)\n \n# Accessing the front element of the deque\nprint('Front element of the deque:', de[0])\n \n# Accessing the back element of the deque\nprint('Back element of the deque:', de[-1])\n \n# This code is contributed by Susobhan Akhuli\n", "# Python code to demonstrate working of \n# extend(), extendleft(), rotate(), reverse()\n \n# importing 'collections' for deque operations\nimport collections\n \n# initializing deque\nde = collections.deque([1, 2, 3,])\n \n# using extend() to add numbers to right end \n# adds 4,5,6 to right end\nde.extend([4,5,6])\n \n# printing modified deque\nprint ('The deque after extending deque at end is : ')\nprint (de)\n \n# using extendleft() to add numbers to left end \n# adds 7,8,9 to left end\nde.extendleft([7,8,9])\n \n# printing modified deque\nprint ('The deque after extending deque at beginning is : ')\nprint (de)\n \n# using rotate() to rotate the deque\n# rotates by 3 to left\nde.rotate(-3)\n \n# printing modified deque\nprint ('The deque after rotating deque is : ')\nprint (de)\n \n# using reverse() to reverse the deque\nde.reverse()\n \n# printing modified deque\nprint ('The deque after reversing deque is : ')\nprint (de)\n"], "Deque interface in Java with Example -  ": [], "Queue in Python -  ": ["# Python program to  \n# demonstrate queue implementation \n# using list \n  \n# Initializing a queue \nqueue = [] \n  \n# Adding elements to the queue \nqueue.append('a') \nqueue.append('b') \nqueue.append('c') \n  \nprint('Initial queue') \nprint(queue) \n  \n# Removing elements from the queue \nprint('\\nElements dequeued from queue') \nprint(queue.pop(0)) \nprint(queue.pop(0)) \nprint(queue.pop(0)) \n  \nprint('\\nQueue after removing elements') \nprint(queue) \n  \n# Uncommenting print(queue.pop(0)) \n# will raise and IndexError \n# as the queue is now empty \n", "# Python program to \n# demonstrate queue implementation \n# using collections.dequeue \n  \n  \nfrom collections import deque \n  \n# Initializing a queue \nq = deque() \n  \n# Adding elements to a queue \nq.append('a') \nq.append('b') \nq.append('c') \n  \nprint('Initial queue') \nprint(q) \n  \n# Removing elements from a queue \nprint('\\nElements dequeued from the queue') \nprint(q.popleft()) \nprint(q.popleft()) \nprint(q.popleft()) \n  \nprint('\\nQueue after removing elements') \nprint(q) \n  \n# Uncommenting q.popleft() \n# will raise an IndexError \n# as queue is now empty \n", "# Python program to \n# demonstrate implementation of \n# queue using queue module \n  \n  \nfrom queue import Queue \n  \n# Initializing a queue \nq = Queue(maxsize = 3) \n  \n# qsize() give the maxsize  \n# of the Queue  \nprint(q.qsize())  \n  \n# Adding of element to queue \nq.put('a') \nq.put('b') \nq.put('c') \n  \n# Return Boolean for Full  \n# Queue  \nprint('\\nFull: ', q.full())  \n  \n# Removing element from queue \nprint('\\nElements dequeued from the queue') \nprint(q.get()) \nprint(q.get()) \nprint(q.get()) \n  \n# Return Boolean for Empty  \n# Queue  \nprint('\\nEmpty: ', q.empty()) \n  \nq.put(1) \nprint('\\nEmpty: ', q.empty())  \nprint('Full: ', q.full()) \n  \n# This would result into Infinite  \n# Loop as the Queue is empty.  \n# print(q.get()) \n"], "Queue Interface In Java -  ": [], "Queue in C++ Standard Template Library (STL) -  ": [], "Stack in Python -  ": ["# Python program to\n# demonstrate stack implementation\n# using list\n \nstack = []\n \n# append() function to push\n# element in the stack\nstack.append('a')\nstack.append('b')\nstack.append('c')\n \nprint('Initial stack')\nprint(stack)\n \n# pop() function to pop\n# element from stack in\n# LIFO order\nprint('\\nElements popped from stack:')\nprint(stack.pop())\nprint(stack.pop())\nprint(stack.pop())\n \nprint('\\nStack after elements are popped:')\nprint(stack)\n \n# uncommenting print(stack.pop())\n# will cause an IndexError\n# as the stack is now empty\n", "# Python program to\n# demonstrate stack implementation\n# using collections.deque\n \nfrom collections import deque\n \nstack = deque()\n \n# append() function to push\n# element in the stack\nstack.append('a')\nstack.append('b')\nstack.append('c')\n \nprint('Initial stack:')\nprint(stack)\n \n# pop() function to pop\n# element from stack in\n# LIFO order\nprint('\\nElements popped from stack:')\nprint(stack.pop())\nprint(stack.pop())\nprint(stack.pop())\n \nprint('\\nStack after elements are popped:')\nprint(stack)\n \n# uncommenting print(stack.pop())\n# will cause an IndexError\n# as the stack is now empty\n", "# Python program to\n# demonstrate stack implementation\n# using queue module\n \nfrom queue import LifoQueue\n \n# Initializing a stack\nstack = LifoQueue(maxsize=3)\n \n# qsize() show the number of elements\n# in the stack\nprint(stack.qsize())\n \n# put() function to push\n# element in the stack\nstack.put('a')\nstack.put('b')\nstack.put('c')\n \nprint('Full: ', stack.full())\nprint('Size: ', stack.qsize())\n \n# get() function to pop\n# element from stack in\n# LIFO order\nprint('\\nElements popped from the stack')\nprint(stack.get())\nprint(stack.get())\nprint(stack.get())\n \nprint('\\nEmpty: ', stack.empty())\n", "# Python program to demonstrate\n# stack implementation using a linked list.\n# node class\n \nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n \n \nclass Stack:\n \n    # Initializing a stack.\n    # Use a dummy node, which is\n    # easier for handling edge cases.\n    def __init__(self):\n        self.head = Node('head')\n        self.size = 0\n \n    # String representation of the stack\n    def __str__(self):\n        cur = self.head.next\n        out = ''\n        while cur:\n            out += str(cur.value) + '->'\n            cur = cur.next\n        return out[:-2]\n \n    # Get the current size of the stack\n    def getSize(self):\n        return self.size\n \n    # Check if the stack is empty\n    def isEmpty(self):\n        return self.size == 0\n \n    # Get the top item of the stack\n    def peek(self):\n \n        # Sanitary check to see if we\n        # are peeking an empty stack.\n        if self.isEmpty():\n            raise Exception('Peeking from an empty stack')\n        return self.head.next.value\n \n    # Push a value into the stack.\n    def push(self, value):\n        node = Node(value)\n        node.next = self.head.next\n        self.head.next = node\n        self.size += 1\n \n    # Remove a value from the stack and return.\n    def pop(self):\n        if self.isEmpty():\n            raise Exception('Popping from an empty stack')\n        remove = self.head.next\n        self.head.next = self.head.next.next\n        self.size -= 1\n        return remove.value\n \n \n# Driver Code\nif __name__ == '__main__':\n    stack = Stack()\n    for i in range(1, 11):\n        stack.push(i)\n    print(f'Stack: {stack}')\n \n    for _ in range(1, 6):\n        remove = stack.pop()\n        print(f'Pop: {remove}')\n    print(f'Stack: {stack}')\n"], "Stack Class in Java -  ": [], "Stack in C++ STL -  ": [], "sort() in Python -  ": ["unsorted_list = [2,4,5,32,6,255,5,42]\nunsorted_list.sort()\nprint('Now it is sorted:', unsorted_list)\n", "# List of Integers\nnumbers = [1, 3, 4, 2]\n \n# Sorting list of Integers\nnumbers.sort()\n \nprint(numbers)\n \n# List of Floating point numbers\ndecimalnumber = [2.01, 2.00, 3.67, 3.28, 1.68]\n \n# Sorting list of Floating point numbers\ndecimalnumber.sort()\n \nprint(decimalnumber)\n \n# List of strings\nwords = ['Geeks', 'For', 'Geeks']\n \n# Sorting list of strings\nwords.sort()\n \nprint(words)\n", "# List of Integers\nnumbers = [1, 3, 4, 2]\n \n# Sorting list of Integers\nnumbers.sort(reverse=True)\n \nprint(numbers)\n \n# List of Floating point numbers\ndecimalnumber = [2.01, 2.00, 3.67, 3.28, 1.68]\n \n# Sorting list of Floating point numbers\ndecimalnumber.sort(reverse=True)\n \nprint(decimalnumber)\n \n# List of strings\nwords = ['Geeks', 'For', 'Geeks']\n \n# Sorting list of strings\nwords.sort(reverse=True)\n \nprint(words)\n", "def sortSecond(val):\n    return val[1] \n \n# list1 to demonstrate the use of sorting \n# using second key \nlist1 = [(1,2),(3,3),(1,1)]\n \n# sorts the array in ascending according to \n# second element\nlist1.sort(key=sortSecond) \nprint(list1)\n \n# sorts the array in descending according to\n# second element\nlist1.sort(key=sortSecond,reverse=True)\nprint(list1)\n"], "Arrays.sort() in Java with examples -  ": [], "std::sort() in C++ STL -  ": [], "Unbounded Binary Search Example (Find the point where a monotonically increasing function becomes positive first time) -  ": ["# Python3 program for Unbound Binary search.\n \n# Let's take an example function as \n# f(x) = x^2 - 10*x - 20\n# Note that f(x) can be any monotonically \n# increasing function\ndef f(x): \n    return (x * x - 10 * x - 20)\n \n# Returns the value x where above function\n# f() becomes positive first time.\ndef findFirstPositive() :\n     \n    # When first value itself is positive\n    if (f(0) > 0):\n        return 0\n \n    # Find 'high' for binary search\n    # by repeated doubling\n    i = 1\n    while (f(i) <= 0) :\n        i = i * 2\n \n    # Call binary search\n    return binarySearch(i/2, i)\n \n# Searches first positive value of \n# f(i) where low <= i <= high\ndef binarySearch(low, high):\n    if (high >= low) :\n         \n        # mid = (low + high)/2\n        mid = low + (high - low)/2;  \n \n        # If f(mid) is greater than 0 \n        # and one of the following two\n        # conditions is true:\n        # a) mid is equal to low\n        # b) f(mid-1) is negative\n        if (f(mid) > 0 and (mid == low or f(mid-1) <= 0)) :\n            return mid;\n \n        # If f(mid) is smaller than or equal to 0\n        if (f(mid) <= 0) :\n            return binarySearch((mid + 1), high)\n        else : # f(mid) > 0\n            return binarySearch(low, (mid -1))\n     \n    # Return -1 if there is no positive\n    # value in given range \n    return -1;\n \n# Driver Code\nprint ('The value n where f() becomes '+\n      'positive first is ', findFirstPositive());\n \n# This code is contributed by rishabh_jain\n"], "Gaussian Elimination to Solve Linear Equations -  ": ["# Python3 program to demonstrate working of\n# Gaussian Elimination method\nN = 3\n \n# function to get matrix content\ndef gaussianElimination(mat):\n \n    # reduction into r.e.f.\n    singular_flag = forwardElim(mat)\n \n    # if matrix is singular\n    if (singular_flag != -1):\n \n        print('Singular Matrix.')\n \n        # if the RHS of equation corresponding to\n        #   zero row  is 0, * system has infinitely\n        #   many solutions, else inconsistent*/\n        if (mat[singular_flag][N]):\n            print('Inconsistent System.')\n        else:\n            print('May have infinitely many solutions.')\n \n        return\n \n    # get solution to system and print it using\n    #   backward substitution\n    backSub(mat)\n \n# function for elementary operation of swapping two rows\ndef swap_row(mat, i, j):\n \n    for k in range(N + 1):\n \n        temp = mat[i][k]\n        mat[i][k] = mat[j][k]\n        mat[j][k] = temp\n \n# function to reduce matrix to r.e.f.\ndef forwardElim(mat):\n    for k in range(N):\n       \n        # Initialize maximum value and index for pivot\n        i_max = k\n        v_max = mat[i_max][k]\n \n        # find greater amplitude for pivot if any\n        for i in range(k + 1, N):\n            if (abs(mat[i][k]) > v_max):\n                v_max = mat[i][k]\n                i_max = i\n \n        # if a principal diagonal element  is zero,\n        # it denotes that matrix is singular, and\n        # will lead to a division-by-zero later.\n        if not mat[k][i_max]:\n            return k    # Matrix is singular\n \n        # Swap the greatest value row with current row\n        if (i_max != k):\n            swap_row(mat, k, i_max)\n \n        for i in range(k + 1, N):\n \n            # factor f to set current row kth element to 0,\n            # and subsequently remaining kth column to 0 */\n            f = mat[i][k]/mat[k][k]\n \n            # subtract fth multiple of corresponding kth\n            # row element*/\n            for j in range(k + 1, N + 1):\n                mat[i][j] -= mat[k][j]*f\n \n            # filling lower triangular matrix with zeros*/\n            mat[i][k] = 0\n \n        # print(mat);        //for matrix state\n \n    # print(mat);            //for matrix state\n    return -1\n \n# function to calculate the values of the unknowns\ndef backSub(mat):\n \n    x = [None for _ in range(N)]    # An array to store solution\n \n    # Start calculating from last equation up to the\n    #  first */\n    for i in range(N-1, -1, -1):\n \n        # start with the RHS of the equation */\n        x[i] = mat[i][N]\n \n        # Initialize j to i+1 since matrix is upper\n        #  triangular*/\n        for j in range(i + 1, N):\n           \n            # subtract all the lhs values\n            # except the coefficient of the variable\n            # whose value is being calculated */\n            x[i] -= mat[i][j]*x[j]\n \n        # divide the RHS by the coefficient of the\n        #  unknown being calculated\n        x[i] = (x[i]/mat[i][i])\n \n    print('\\nSolution for the system:')\n    for i in range(N):\n        print('{:.8f}'.format(x[i]))\n \n# Driver program\n \n# input matrix\nmat = [[3.0, 2.0, -4.0, 3.0], [2.0, 3.0, 3.0, 15.0], [5.0, -3, 1.0, 14.0]]\ngaussianElimination(mat)\n \n# This code is contributed by phasing17\n", "import numpy as np\nMAXN = 100\n \n# Function to perform partial pivot for Gaussian elimination\ndef partial_pivot(A, n):\n    # Iterate through each row in the matrix\n    for i in range(n):\n        pivot_row = i\n        # Find the row with the maximum absolute value in the current column\n        for j in range(i + 1, n):\n            if abs(A[j][i]) > abs(A[pivot_row][i]):\n                pivot_row = j\n        # Swap the current row with the row having the maximum absolute value\n        if pivot_row != i:\n            A[[i, pivot_row]] = A[[pivot_row, i]]\n        # Perform Gaussian elimination on the matrix\n        for j in range(i + 1, n):\n            factor = A[j][i] / A[i][i]\n            A[j] -= factor * A[i]\n \n# Function to perform back substitution to solve the system of equations\ndef back_substitute(A, n):\n    x = np.zeros(n)\n    # Iterate through each row in reverse order\n    for i in range(n - 1, -1, -1):\n        sum_val = sum(A[i][j] * x[j] for j in range(i + 1, n))\n        # Solve for x[i] using the previously calculated values of x\n        x[i] = (A[i][n] - sum_val) / A[i][i]\n    return x\n# Driver code\nif __name__ == '__main__':\n    n = 3\n    # Coefficient matrix augmented with the constant terms\n    A = np.array([[3.0, 2.0, -4.0, 3.0],\n                  [2.0, 3.0, 3.0, 15.0],\n                  [5.0, -3, 1.0, 14.0]])\n     \n    # Perform Gaussian elimination with partial pivot\n    partial_pivot(A, n)\n    x = back_substitute(A, n)\n     \n    print('Solution for the system:')\n    for i in range(n):\n        print(x[i])\n#This code is contributed by Vikram_Shirsat\n"], "Program for nth Catalan Number -  ": ["# A recursive function to\n# find nth catalan number\n \n \ndef catalan(n):\n    # Base Case\n    if n <= 1:\n        return 1\n \n    # Catalan(n) is the sum\n    # of catalan(i)*catalan(n-i-1)\n    res = 0\n    for i in range(n):\n        res += catalan(i) * catalan(n-i-1)\n \n    return res\n \n \n# Driver Code\nfor i in range(10):\n    print(catalan(i), end=' ')\n# This code is contributed by\n# Nikhil Kumar Singh (nickzuck_007)\n", "# A dynamic programming based function to find nth\n# Catalan number\n \n \ndef catalan(n):\n    if (n == 0 or n == 1):\n        return 1\n \n    # Table to store results of subproblems\n    catalan = [0]*(n+1)\n \n    # Initialize first two values in table\n    catalan[0] = 1\n    catalan[1] = 1\n \n    # Fill entries in catalan[]\n    # using recursive formula\n    for i in range(2, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i-j-1]\n \n    # Return last entry\n    return catalan[n]\n \n \n# Driver code\nfor i in range(10):\n    print(catalan(i), end=' ')\n# This code is contributed by Ediga_manisha\n", "# Python program for nth Catalan Number\n# Returns value of Binomial Coefficient C(n, k)\n \n \ndef binomialCoefficient(n, k):\n \n    # since C(n, k) = C(n, n - k)\n    if (k > n - k):\n        k = n - k\n \n    # initialize result\n    res = 1\n \n    # Calculate value of [n * (n-1) *---* (n-k + 1)]\n    # / [k * (k-1) *----* 1]\n    for i in range(k):\n        res = res * (n - i)\n        res = res / (i + 1)\n    return res\n \n# A Binomial coefficient based function to\n# find nth catalan number in O(n) time\n \n \ndef catalan(n):\n    c = binomialCoefficient(2*n, n)\n    return c/(n + 1)\n \n \n# Driver Code\nfor i in range(10):\n    print(catalan(i), end=' ')\n \n# This code is contributed by Aditi Sharma\n", "# Function to print the number\ndef catalan(n):\n \n    cat_ = 1\n \n    # For the first number\n    print(cat_, ' ', end='')  # C(0)\n \n    # Iterate till N\n    for i in range(1, n):\n \n        # Calculate the number\n        # and print it\n        cat_ *= (4 * i - 2)\n        cat_ //= (i + 1)\n        print(cat_, ' ', end='')\n \n \n# Driver code\nn = 5\n \n# Function call\ncatalan(n)\n \n# This code is contributed by rohan07\n", "def findCatalan(n):\n    b = 1\n \n    # calculating n!\n    for i in range(1, n + 1, 1):\n        b = b * i\n \n    # calculating n! * n!\n    b = b * b\n    d = 1\n \n    # calculating (2n)!\n    for i in range(1, 2 * n + 1, 1):\n        d = d * i\n         \n    # calculating (2n)! / (n! * n!)\n    ans = d / b\n     \n    # calculating (2n)! / ((n! * n!) * (n+1))\n    ans = ans / (n + 1)\n \n    return ans\n \n# Driver Code\nn = 50\nprint(int(findCatalan(n)))\n \n# This code is contributed by ajaymakavana.\n"], "Queries of nCr%p in O(1) time complexity -  ": ["# Python3 program to answer queries\n# of nCr in O(1) time.\nN = 1000001\n \n# array to store inverse of 1 to N\nfactorialNumInverse = [None] * (N + 1)\n \n# array to precompute inverse of 1! to N!\nnaturalNumInverse = [None] * (N + 1)\n \n# array to store factorial of \n# first N numbers\nfact = [None] * (N + 1)\n \n# Function to precompute inverse of numbers\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = (naturalNumInverse[p % i] *\n                                   (p - int(p / i)) % p)\n \n# Function to precompute inverse \n# of factorials\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n \n    # precompute inverse of natural numbers\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = (naturalNumInverse[i] *\n                                  factorialNumInverse[i - 1]) % p\n \n# Function to calculate factorial of 1 to N\ndef factorial(p):\n    fact[0] = 1\n \n    # precompute factorials\n    for i in range(1, N + 1):\n        fact[i] = (fact[i - 1] * i) % p\n \n# Function to return nCr % p in O(1) time\ndef Binomial(N, R, p):\n     \n    # n C r = n!*inverse(r!)*inverse((n-r)!)\n    ans = ((fact[N] * factorialNumInverse[R])% p *\n                      factorialNumInverse[N - R])% p\n    return ans\n \n# Driver Code\nif __name__ == '__main__':\n     \n    # Calling functions to precompute the\n    # required arrays which will be required\n    # to answer every query in O(1)\n    p = 1000000007\n    InverseofNumber(p)\n    InverseofFactorial(p)\n    factorial(p)\n \n    # 1st query\n    N = 15\n    R = 4\n    print(Binomial(N, R, p))\n \n    # 2nd query\n    N = 20\n    R = 3\n    print(Binomial(N, R, p))\n \n# This code is contributed by\n# Surendra_Gangwar\n"], "Compute nCr%p using Lucas Theorem -  ": ["# A Lucas Theorem based solution  \n# to compute nCr % p \n  \n# Returns nCr % p. In this Lucas  \n# Theorem based program, this  \n# function is only called for \n# n < p and r < p. \ndef nCrModpDP(n, r, p): \n      \n    # The array C is going to store \n    # last row of pascal triangle \n    # at the end. And last entry  \n    # of last row is nCr \n    C = [0] * (n + 1); \n  \n    # Top row of Pascal Triangle \n    C[0] = 1;  \n  \n    # One by constructs remaining  \n    # rows of Pascal Triangle from  \n    # top to bottom \n    for i in range(1, (n + 1)): \n          \n        # Fill entries of current  \n        # row using previous row \n        # values \n        j = min(i, r);  \n        while(j > 0): \n            C[j] = (C[j] + C[j - 1]) % p; \n            j -= 1; \n    return C[r]; \n  \n# Lucas Theorem based function that   \n# returns nCr % p. This function \n# works like decimal to binary  \n# conversion recursive function. \n# First we compute last digits of  \n# n and r in base p, then recur \n# for remaining digits \ndef nCrModpLucas(n, r, p): \n      \n    # Base case \n    if (r == 0): \n        return 1; \n          \n    # Compute last digits of n \n    # and r in base p \n    ni = int(n % p); \n    ri = int(r % p); \n          \n    # Compute result for last digits  \n    # computed above, and for remaining  \n    # digits. Multiply the two results  \n    # and compute the result of  \n    # multiplication in modulo p. \n    # Last digits of n and r \n    return (nCrModpLucas(int(n / p), int(r / p), p) * \n            nCrModpDP(ni, ri, p)) % p; # Remaining digits \n  \n# Driver Code \nn = 1000; \nr = 900;  \np = 13; \nprint('Value of nCr % p is',  \n       nCrModpLucas(n, r, p)); \n  \n# This code is contributed by mits \n"], "Introduction and Dynamic Programming solution to compute nCr%p -  ": ["# A Dynamic Programming based solution to compute nCr % p\n \n# Returns nCr % p\ndef nCrModp(n, r, p):\n \n    # Optimization for the cases when r is large\n    # compared to n-r \n    if (r > n- r):\n        r = n - r  \n \n    # The array C is going to store last row of\n    # pascal triangle at the end. And last entry\n    # of last row is nCr.\n    C = [0 for i in range(r + 1)]\n \n    C[0] = 1 # Top row of Pascal Triangle\n \n    # One by constructs remaining rows of Pascal\n    # Triangle from top to bottom\n    for i in range(1, n + 1):\n \n        # Fill entries of current row \n        # using previous row values\n        for j in range(min(i, r), 0, -1):\n \n            # nCj = (n - 1)Cj + (n - 1)C(j - 1)\n            C[j] = (C[j] + C[j-1]) % p\n \n    return C[r]\n \n# Driver Program\nn = 10\nr = 2\np = 13\nprint('Value of nCr % p is', nCrModp(n, r, p))\n \n# This code is contributed by Soumen Ghosh\n", "# Python3 program to find the nCr%p\n# based on optimal Dynamic\n# Programming implementation and\n# Pascal Triangle concepts\n \n# Returns (a * b) % mod\ndef moduloMultiplication(a, b, mod):\n    # Initialize result\n    res = 0\n \n    # Update a if it is more than\n    # or equal to mod\n    a %= mod\n \n    while (b):\n \n        # If b is odd, add a with result\n        if (b & 1):\n            res = (res + a) % mod\n \n        # Here we assume that doing 2*a\n        # doesn't cause overflow\n        a = (2 * a) % mod\n        b >>= 1    # b = b / 2\n \n    return res\n \n \n# Global Variables\nx, y = 0, 1\n \n# Function for extended Euclidean Algorithm\n \n \ndef gcdExtended(a, b):\n    global x, y\n \n    # Base Case\n    if (a == 0):\n \n        x = 0\n        y = 1\n        return b\n \n    # To store results of recursive call\n    gcd = gcdExtended(b % a, a)\n    x1 = x\n    y1 = y\n \n    # Update x and y using results of recursive\n    # call\n    x = y1 - int(b / a) * x1\n    y = x1\n \n    return gcd\n \n \ndef modInverse(a, m):\n \n    g = gcdExtended(a, m)\n \n    # Return -1 if b and m are not co-prime\n    if (g != 1):\n        return -1\n \n    # m is added to handle negative x\n    return (x % m + m) % m\n \n \n# Function to compute a/b under modulo m\ndef modDivide(a, b, m):\n \n    a = a % m\n    inv = modInverse(b, m)\n    if (inv == -1):\n        return 0\n    else:\n        return (inv * a) % m\n \n \n# Function to calculate nCr % p\ndef nCr(n, r, p):\n \n    # Edge Case which is not possible\n    if (r > n):\n        return 0\n \n    # Optimization for the cases when r is large\n    if (r > n - r):\n        r = n - r\n \n    # x stores the current result at\n    x = 1\n \n    # each iteration\n    # Initialized to 1 as nC0 is always 1.\n    for i in range(1, r + 1):\n \n        # Formula derived for calculating result is\n        # C(n,r-1)*(n-r+1)/r\n        # Function calculates x*(n-i+1) % p.\n        x = moduloMultiplication(x, (n + 1 - i), p)\n \n        # Function calculates x/i % p.\n        x = modDivide(x, i, p)\n \n    return x\n \n# Driver Code\nn = 5\nr = 3\np = 1000000007\nprint('Value of nCr % p is ', nCr(n, r, p))\n \n# This code is contributed by phasing17\n"], "Program to calculate the value of nCr Efficiently -  ": ["# Python3 implementation to find nCr\n \nfrom math import *\n \n# Function to find the nCr\n \n \ndef printNcR(n, r):\n \n    # p holds the value of n*(n-1)*(n-2)...,\n    # k holds the value of r*(r-1)...\n    p = 1\n    k = 1\n \n    # C(n, r) == C(n, n-r),\n    # choosing the smaller value\n    if (n - r < r):\n        r = n - r\n \n    if (r != 0):\n        while (r):\n            p *= n\n            k *= r\n \n            # gcd of p, k\n            m = gcd(p, k)\n \n            # dividing by gcd, to simplify product\n            # division by their gcd saves from \n            # the overflow\n            p //= m\n            k //= m\n \n            n -= 1\n            r -= 1\n \n        # k should be simplified to 1\n        # as C(n, r) is a natural number\n        # (denominator should be 1 )\n \n    else:\n        p = 1\n \n    # if our approach is correct p = ans and k =1\n    print(p)\n \n \n# Driver code\nif __name__ == '__main__':\n    n = 50\n    r = 25\n \n    printNcR(n, r)\n \n# this code is contributed by\n# ChitraNayal\n"], "Program to calculate value of nCr -  ": ["# Python 3 program To calculate \n# The Value Of nCr\n \ndef nCr(n, r):\n \n    return (fact(n) / (fact(r) \n                * fact(n - r)))\n \n# Returns factorial of n\ndef fact(n):\n    if n == 0:\n        return 1\n    res = 1\n     \n    for i in range(2, n+1):\n        res = res * i\n         \n    return res\n \n# Driver code\nn = 5\nr = 3\nprint(int(nCr(n, r)))\n \n# This code is contributed\n# by Smitha\n", "def nCr(n, r):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    return nCr(n-1, r-1) + nCr(n-1, r)\n \n \nprint(nCr(5, 3))  # Output: 10\n \n# This code is contributed by Susobhan Akhuli\n", "n = 5\nr = 2\nsum = 1\n \n# Calculate the value of n choose r using the binomial coefficient formula\nfor i in range(1, r+1):\n    sum = sum * (n - r + i) / i\n \nprint(int(sum))\n# This code is contributed by divyansh2212\n"], "Matrix Exponentiation -  ": ["# Python3 program to find value of f(n) \n# where f(n) is defined as\n# F(n) = F(n-1) + F(n-2) + F(n-3), n >= 3\n# Base Cases :\n# F(0) = 0, F(1) = 1, F(2) = 1\n \n# A utility function to multiply two \n# matrices a[][] and b[][]. Multiplication \n# result is stored back in b[][]\ndef multiply(a, b):\n     \n    # Creating an auxiliary matrix \n    # to store elements of the\n    # multiplication matrix\n    mul = [[0 for x in range(3)]\n              for y in range(3)];\n    for i in range(3):\n        for j in range(3):\n            mul[i][j] = 0;\n            for k in range(3):\n                mul[i][j] += a[i][k] * b[k][j];\n \n    # storing the multiplication\n    # result in a[][]\n    for i in range(3):\n        for j in range(3):\n            a[i][j] = mul[i][j]; # Updating our matrix\n    return a;\n \n# Function to compute F raise \n# to power n-2.\ndef power(F, n):\n \n    M = [[1, 1, 1], [1, 0, 0], [0, 1, 0]];\n \n    # Multiply it with initial values i.e \n    # with F(0) = 0, F(1) = 1, F(2) = 1\n    if (n == 1):\n        return F[0][0] + F[0][1];\n \n    power(F, int(n / 2));\n \n    F = multiply(F, F);\n \n    if (n % 2 != 0):\n        F = multiply(F, M);\n \n    # Multiply it with initial values i.e \n    # with F(0) = 0, F(1) = 1, F(2) = 1\n    return F[0][0] + F[0][1] ;\n \n# Return n'th term of a series defined \n# using below recurrence relation.\n# f(n) is defined as\n# f(n) = f(n-1) + f(n-2) + f(n-3), n>=3\n# Base Cases :\n# f(0) = 0, f(1) = 1, f(2) = 1\ndef findNthTerm(n):\n    F = [[1, 1, 1], [1, 0, 0], [0, 1, 0]];\n \n    return power(F, n - 2);\n \n# Driver code\nn = 5;\n \nprint('F(5) is', \n      findNthTerm(n));\n \n# This code is contributed by mits\n"], "Modular Exponentiation (Power in Modular Arithmetic) -  ": ["# Iterative Function to calculate (x^y)%p in O(log y)\ndef power(x, y, p):\n \n    # Initialize result\n    res = 1\n \n    while (y > 0):\n \n        # If y is odd, multiply x with result\n        if ((y & 1) != 0):\n            res = res * x\n \n        # y must be even now\n        y = y >> 1  # y = y/2\n        x = x * x  # Change x to x^2\n \n    return res % p\n \n  # Driver Code\n \n \nx = 2\ny = 5\np = 13\nprint('Power is ', power(x, y, p))\n# This code is contributed by Khushboogoyal499\n", "# Iterative Python3 program\n# to compute modular power\n \n# Iterative Function to calculate\n# (x^y)%p in O(log y) \ndef power(x, y, p) :\n    res = 1     # Initialize result\n \n    # Update x if it is more\n    # than or equal to p\n    x = x % p \n     \n    if (x == 0) :\n        return 0\n \n    while (y > 0) :\n         \n        # If y is odd, multiply\n        # x with result\n        if ((y & 1) == 1) :\n            res = (res * x) % p\n \n        # y must be even now\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n         \n    return res\n     \n \n# Driver Code\n \nx = 2; y = 5; p = 13\nprint('Power is ', power(x, y, p))\n \n \n# This code is contributed by Nikita Tiwari.\n"], "Write an iterative O(Log y) function for pow(x, y) -  ": ["# Iterative Python3 program\n# to implement pow(x, n)\n \n# Iterative Function to\n# calculate (x^y) in O(logy)\ndef power(x, y):\n \n    # Initialize result\n    res = 1\n     \n    while (y > 0):\n         \n        # If y is odd, multiply\n        # x with result\n        if ((y & 1) == 1) :\n            res = res * x\n \n        # y must be even \n        # now y = y/2\n        y = y >> 1\n         \n        # Change x to x^2\n        x = x * x\n     \n    return res\n \n \n# Driver Code\nx = 3\ny = 5\n \nprint('Power is ',\n       power(x, y))\n \n# This code is contributed\n# by ihritik\n", "#python code to demonstrate the above approach\ndef power(x, y):\n    if y==0:\n        return 1\n \n    temp = power(x, y // 2)\n    # if y is even\n    if y % 2 == 0:\n        return temp * temp\n    else:\n        return x * temp * temp\n \n \ndef main():\n    x = 3\n    y = 5\n \n    print('Power is : ', power(x,y))\n \n \nmain()\n"], "Implementation of Chinese Remainder theorem (Inverse Modulo based implementation) -  ": ["# A Python3 program to demonstrate  \n# working of Chinese remainder  \n# Theorem  \n  \n# Returns modulo inverse of a with  \n# respect to m using extended  \n# Euclid Algorithm. Refer below  \n# post for details:  \n# https://www. .org/ \n# multiplicative-inverse-under-modulo-m/  \ndef inv(a, m) :  \n      \n    m0 = m  \n    x0 = 0\n    x1 = 1\n  \n    if (m == 1) :  \n        return 0\n  \n    # Apply extended Euclid Algorithm  \n    while (a > 1) :  \n        # q is quotient  \n        q = a // m  \n  \n        t = m  \n  \n        # m is remainder now, process  \n        # same as euclid's algo  \n        m = a % m  \n        a = t  \n  \n        t = x0  \n  \n        x0 = x1 - q * x0  \n  \n        x1 = t  \n      \n    # Make x1 positive  \n    if (x1 < 0) :  \n        x1 = x1 + m0  \n  \n    return x1  \n  \n# k is size of num[] and rem[].  \n# Returns the smallest  \n# number x such that:  \n# x % num[0] = rem[0],  \n# x % num[1] = rem[1],  \n# ..................  \n# x % num[k-2] = rem[k-1]  \n# Assumption: Numbers in num[]  \n# are pairwise coprime  \n# (gcd for every pair is 1)  \ndef findMinX(num, rem, k) :  \n      \n    # Compute product of all numbers  \n    prod = 1\n    for i in range(0, k) :  \n        prod = prod * num[i]  \n  \n    # Initialize result  \n    result = 0\n  \n    # Apply above formula  \n    for i in range(0,k):  \n        pp = prod // num[i]  \n        result = result + rem[i] * inv(pp, num[i]) * pp  \n      \n      \n    return result % prod  \n  \n# Driver method  \nnum = [3, 4, 5]  \nrem = [2, 3, 1]  \nk = len(num)  \nprint( 'x is ' , findMinX(num, rem, k))  \n  \n# This code is contributed by Nikita Tiwari.  \n"], "Introduction to Chinese Remainder Theorem -  ": ["# A Python3 program to demonstrate  \n# working of Chinise remainder Theorem \n  \n# k is size of num[] and rem[].  \n# Returns the smallest number x  \n# such that: \n# x % num[0] = rem[0],  \n# x % num[1] = rem[1],  \n# .................. \n# x % num[k-2] = rem[k-1] \n# Assumption: Numbers in num[]  \n# are pairwise coprime (gcd for \n# every pair is 1) \ndef findMinX(num, rem, k): \n    x = 1; # Initialize result \n  \n    # As per the Chinise remainder \n    # theorem, this loop will \n    # always break. \n    while(True): \n          \n        # Check if remainder of  \n        # x % num[j] is rem[j]  \n        # or not (for all j from  \n        # 0 to k-1) \n        j = 0; \n        while(j < k): \n            if (x % num[j] != rem[j]): \n                break; \n            j += 1; \n  \n        # If all remainders  \n        # matched, we found x \n        if (j == k): \n            return x; \n  \n        # Else try next number \n        x += 1; \n  \n# Driver Code \nnum = [3, 4, 5]; \nrem = [2, 3, 1]; \nk = len(num); \nprint('x is', findMinX(num, rem, k)); \n  \n# This code is contributed by mits \n"], "Modular multiplicative inverse -  ": ["# Python3 program to find modular\n# inverse of A under modulo M\n \n# A naive method to find modulor\n# multiplicative inverse of A\n# under modulo M\n \n \ndef modInverse(A, M):\n \n    for X in range(1, M):\n        if (((A % M) * (X % M)) % M == 1):\n            return X\n    return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n    A = 3\n    M = 11\n \n    # Function call\n    print(modInverse(A, M))\n \n# This code is contributed by Nikita Tiwari.\n", "# Python3 program to find multiplicative modulo\n# inverse using Extended Euclid algorithm.\n \n# Global Variables\nx, y = 0, 1\n \n# Function for extended Euclidean Algorithm\n \n \ndef gcdExtended(a, b):\n    global x, y\n \n    # Base Case\n    if (a == 0):\n        x = 0\n        y = 1\n        return b\n \n    # To store results of recursive call\n    gcd = gcdExtended(b % a, a)\n    x1 = x\n    y1 = y\n \n    # Update x and y using results of recursive\n    # call\n    x = y1 - (b // a) * x1\n    y = x1\n \n    return gcd\n \n \ndef modInverse(A, M):\n \n    g = gcdExtended(A, M)\n    if (g != 1):\n        print('Inverse doesn't exist')\n \n    else:\n \n        # m is added to handle negative x\n        res = (x % M + M) % M\n        print('Modular multiplicative inverse is ', res)\n \n \n# Driver Code\nif __name__ == '__main__':\n    A = 3\n    M = 11\n \n    # Function call\n    modInverse(A, M)\n \n \n# This code is contributed by phasing17\n", "# Iterative Python 3 program to find\n# modular inverse using extended\n# Euclid algorithm\n \n# Returns modulo inverse of a with\n# respect to m using extended Euclid\n# Algorithm Assumption: a and m are\n# coprimes, i.e., gcd(A, M) = 1\n \n \ndef modInverse(A, M):\n    m0 = M\n    y = 0\n    x = 1\n \n    if (M == 1):\n        return 0\n \n    while (A > 1):\n \n        # q is quotient\n        q = A // M\n \n        t = M\n \n        # m is remainder now, process\n        # same as Euclid's algo\n        M = A % M\n        A = t\n        t = y\n \n        # Update x and y\n        y = x - q * y\n        x = t\n \n    # Make x positive\n    if (x < 0):\n        x = x + m0\n \n    return x\n \n \n# Driver code\nif __name__ == '__main__':\n    A = 3\n    M = 11\n \n    # Function call\n    print('Modular multiplicative inverse is',\n          modInverse(A, M))\n \n# This code is contributed by Nikita tiwari.\n", "# Python3 program to find modular\n# inverse of A under modulo M\n \n# This program works only if M is prime.\n \n# Function to find modular\n# inverse of A under modulo M\n# Assumption: M is prime\n \n \ndef modInverse(A, M):\n \n    g = gcd(A, M)\n \n    if (g != 1):\n        print('Inverse doesn't exist')\n \n    else:\n \n        # If A and M are relatively prime,\n        # then modulo inverse is A^(M-2) mod M\n        print('Modular multiplicative inverse is ',\n              power(A, M - 2, M))\n \n# To compute x^y under modulo M\n \n \ndef power(x, y, M):\n \n    if (y == 0):\n        return 1\n \n    p = power(x, y // 2, M) % M\n    p = (p * p) % M\n \n    if(y % 2 == 0):\n        return p\n    else:\n        return ((x * p) % M)\n \n# Function to return gcd of a and b\n \n \ndef gcd(a, b):\n    if (a == 0):\n        return b\n \n    return gcd(b % a, a)\n \n \n# Driver Code\nif __name__ == '__main__':\n    A = 3\n    M = 11\n \n    # Function call\n    modInverse(A, M)\n \n \n# This code is contributed by Nikita Tiwari.\n"], "Modulo 10^9+7 (1000000007) -  ": ["def factorial( n) :\n    M = 1000000007\n    f = 1\n \n    for i in range(1, n + 1): \n        f = f * i # WRONG APPROACH as \n                  # f may exceed (2^64 - 1) \n \n    return f % M \n \n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n", "def factorial( n) :\n    M = 1000000007\n    f = 1\n \n    for i in range(1, n + 1): \n        f = (f * i) % M # Now f never can \n                        # exceed 10^9+7 \n \n    return f \n \n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n", "def mod(a, m):\n    return (a%m + m) % m\n \n# This code is contributed by\n# Shubham Singh(SHUBHAMSINGH10)\n"], "Inclusion-Exclusion and its various Applications -  ": ["n = 100\ncount = 0\n \n# Count the number of integers divisible by 2\nfor i in range(2, n, 2):\n    count += 1\n \n# Count the number of integers divisible by 3\nfor i in range(3, n, 3):\n    count += 1\n \n# Count the number of integers divisible by 5\nfor i in range(5, n, 5):\n    count += 1\n \n# Count the number of integers divisible by both 2 and 3\nfor i in range(6, n, 6):\n    count -= 1\n \n# Count the number of integers divisible by both 2 and 5\nfor i in range(10, n, 10):\n    count -= 1\n \n# Count the number of integers divisible by both 3 and 5\nfor i in range(15, n, 15):\n    count -= 1\n \n# Count the number of integers divisible by 2, 3, and 5\nfor i in range(30, n, 30):\n    count += 1\n \n# Print the final count\nprint(f'The number of positive integers less than {n} that are divisible by either 2, 3, or 5 is {count}.')\n"], "Euler's Totient function for all numbers smaller than or equal to n -  ": ["# Python program to compute \n# Totient function for \n# all numbers smaller than \n# or equal to n. \n \n# Computes and prints \n# totient of all numbers \n# smaller than or equal to n. \ndef computeTotient(n): \n \n    # Create and initialize \n    # an array to store \n    # phi or totient values \n    phi=[] \n    for i in range(n + 2): \n        phi.append(0) \n \n    for i in range(1, n+1): \n \n        phi[i] = i # indicates not evaluated yet \n                    # and initializes for product \n                    # formula. \n \n    # Compute other Phi values \n    for p in range(2,n+1): \n     \n        # If phi[p] is not computed already, \n        # then number p is prime \n        if (phi[p] == p): \n         \n            # Phi of a prime number p is \n            # always equal to p-1. \n            phi[p] = p-1\n \n            # Update phi values of all \n            # multiples of p \n            for i in range(2*p,n+1,p): \n             \n                # Add contribution of p to its \n                # multiple i by multiplying with \n                # (1 - 1/p) \n                phi[i] = (phi[i]//p) * (p-1) \n     \n \n    # Print precomputed phi values \n    for i in range(1,n+1): \n        print('Totient of ', i ,' is ', \n        phi[i]) \n \n# Driver code \n \nn = 12\ncomputeTotient(n) \n \n# This code is contributed \n# by Anant Agarwal \n", "# python program for the above approach\nimport math\ndef Euler_totient_function(n):\n    result = 1\n    for i in range(2,n+1):\n        c = 0\n        if n % i == 0:\n            while (n % i == 0):\n                c+=1\n                n //= i\n        if (c > 0):\n            power = math.pow(i,c-1)\n            m = math.pow(i,c-1)*(i-1)\n            result*=m\n    if (n > 1):\n        result *= (n - 1)\n    return int(result)\n \n \nfor i in range(1,13):\n    print('Euler_totient_function(' , i , '): ',end='')\n    print(Euler_totient_function(i))\n"], "Euler's Totient Function -  ": ["# A simple Python3 program \n# to calculate Euler's \n# Totient Function\n \n# Function to return\n# gcd of a and b\ndef gcd(a, b):\n \n    if (a == 0):\n        return b\n    return gcd(b % a, a)\n \n# A simple method to evaluate\n# Euler Totient Function\ndef phi(n):\n \n    result = 1\n    for i in range(2, n):\n        if (gcd(i, n) == 1):\n            result+=1\n    return result\n \n# Driver Code\nfor n in range(1, 11):\n    print('phi(',n,') = ', \n           phi(n), sep = '')\n            \n# This code is contributed\n# by Smitha\n", "# Python 3 program to calculate\n# Euler's Totient Function\n# using Euler's product formula\n \ndef phi(n) :\n \n    result = n   # Initialize result as n\n      \n    # Consider all prime factors\n    # of n and for every prime\n    # factor p, multiply result with (1 - 1 / p)\n    p = 2\n    while p * p<= n :\n \n        # Check if p is a prime factor.\n        if n % p == 0 :\n \n            # If yes, then update n and result\n            while n % p == 0 :\n                n = n // p\n            result = result * (1.0 - (1.0 / float(p)))\n        p = p + 1\n         \n         \n    # If n has a prime factor\n    # greater than sqrt(n)\n    # (There can be at-most one\n    # such prime factor)\n    if n > 1 :\n        result -= result // n\n  #Since in the set {1,2,....,n-1}, all numbers are relatively prime with n\n  #if n is a prime number\n  \n    return int(result)\n     \n     \n# Driver program to test above function\nfor n in range(1, 11) :\n    print('phi(', n, ') = ', phi(n))\n    \n \n# This code is contributed\n# by Nikita Tiwari.\n", "# Python3 program to calculate \n# Euler's Totient Function\ndef phi(n):\n     \n    # Initialize result as n\n    result = n; \n \n    # Consider all prime factors\n    # of n and subtract their\n    # multiples from result\n    p = 2; \n    while(p * p <= n):\n         \n        # Check if p is a \n        # prime factor.\n        if (n % p == 0): \n             \n            # If yes, then \n            # update n and result\n            while (n % p == 0):\n                n = int(n / p);\n            result -= int(result / p);\n        p += 1;\n \n    # If n has a prime factor\n    # greater than sqrt(n)\n    # (There can be at-most \n    # one such prime factor)\n    if (n > 1):\n        result -= int(result / n);\n    return result;\n \n# Driver Code\nfor n in range(1, 11):\n    print('phi(',n,') =', phi(n));\n     \n# This code is contributed \n# by mits\n"], "Euclidean algorithms (Basic and Extended) -  ": ["# Python3 program to demonstrate Basic Euclidean Algorithm\n \n \n# Function to return gcd of a and b\ndef gcd(a, b):\n    if a == 0:\n        return b\n \n    return gcd(b % a, a)\n \n# Driver code\nif __name__ == '__main__':\n  a = 10\n  b = 15\n  print('gcd(', a, ',', b, ') = ', gcd(a, b))\n \n  a = 35\n  b = 10\n  print('gcd(', a, ',', b, ') = ', gcd(a, b))\n \n  a = 31\n  b = 2\n  print('gcd(', a, ',', b, ') = ', gcd(a, b))\n \n# Code Contributed By Mohit Gupta_OMG <(0_o)>\n", "# Python program to demonstrate working of extended\n# Euclidean Algorithm\n \n# function for extended Euclidean Algorithm\n \n \ndef gcdExtended(a, b):\n \n    # Base Case\n    if a == 0:\n        return b, 0, 1\n \n    gcd, x1, y1 = gcdExtended(b % a, a)\n \n    # Update x and y using results of recursive\n    # call\n    x = y1 - (b//a) * x1\n    y = x1\n \n    return gcd, x, y\n \n \n# Driver code\na, b = 35, 15\ng, x, y = gcdExtended(a, b)\nprint('gcd(', a, ',', b, ') = ', g)\n"], "Linear Diophantine Equations -  ": ["# Python 3 program to check for solutions \n# of diophantine equations\nfrom math import gcd\n \n# This function checks if integral \n# solutions are possible\ndef isPossible(a, b, c):\n    return (c % gcd(a, b) == 0)\n \n# Driver Code\nif __name__ == '__main__':\n     \n    # First example\n    a = 3\n    b = 6\n    c = 9\n    if (isPossible(a, b, c)):\n        print('Possible')\n    else:\n        print('Not Possible')\n \n    # Second example\n    a = 3\n    b = 6\n    c = 8\n    if (isPossible(a, b, c)):\n        print('Possible')\n    else:\n        print('Not Possible')\n \n    # Third example\n    a = 2\n    b = 5\n    c = 1\n    if (isPossible(a, b, c)):\n        print('Possible')\n    else:\n        print('Not Possible')\n         \n# This code is contributed by\n# Surendra_Gangwar\n", "class LinearDiophantineEquations:\n     \n    # Function to find the GCD of two numbers\n    def gcd(self, a, b):\n        if a == 0:\n            return b\n        return self.gcd(b % a, a)\n     \n    # Function to check if integral solutions are possible\n    def isPossible(self, a, b, c):\n        gcd = self.gcd(a, b)\n        return c % gcd == 0\n     \n    # Driver function\n    def main(self):\n        a, b, c = 3, 6, 9\n        if self.isPossible(a, b, c):\n            print('Possible')\n        else:\n            print('Not Possible')\n         \n# Create an object of the class and call the main function\nld = LinearDiophantineEquations()\nld.main()\n"], "Sum of all the factors of a number -  ": ["# Simple Python 3 program to \n# find sum of all divisors of\n# a natural number\nimport math  \n \n# Function to calculate sum \n# of all divisors of given\n#  natural number\ndef divSum(n) :\n    if(n == 1):\n       return 1\n \n    # Final result of summation \n    # of divisors\n    result = 0\n   \n    # find all divisors which\n    # divides 'num'\n    for i in range(2,(int)(math.sqrt(n))+1) :\n \n        # if 'i' is divisor of 'n'\n        if (n % i == 0) :\n \n            # if both divisors are same \n            # then add it only once\n            # else add both\n            if (i == (n/i)) :\n                result = result + i\n            else :\n                result = result + (i + n//i)\n         \n         \n    # Add 1 and n to result as above \n    # loop considers proper divisors\n    # greater than 1.\n    return (result + n + 1)\n   \n# Driver program to run the case\nn = 30\nprint(divSum(n))\n \n# This code is contributed by Nikita Tiwari.\n", "# Formula based Python3 code to find \n# sum of all divisors of n.\nimport math as m\n \n# Returns sum of all factors of n.\ndef sumofFactors(n):\n     \n    # Traversing through all\n    # prime factors\n    res = 1\n    for i in range(2, int(m.sqrt(n) + 1)):\n         \n        curr_sum = 1\n        curr_term = 1\n         \n        while n % i == 0:\n             \n            n = n / i;\n \n            curr_term = curr_term * i;\n            curr_sum += curr_term;\n             \n        res = res * curr_sum\n     \n    # This condition is to handle the \n    # case when n is a prime number \n    # greater than 2\n    if n > 2:\n        res = res * (1 + n)\n \n    return res;\n \n# driver code    \nsum = sumofFactors(30)\nprint ('Sum of all divisors is: ',sum)\n \n# This code is contributed by Saloni Gupta\n"], "Prime Factorization using Sieve O(log n) for multiple queries -  ": ["# Python3 program to find prime factorization \n# of a number n in O(Log n) time with \n# precomputation allowed.\nimport math as mt\n \nMAXN = 100001\n \n# stores smallest prime factor for\n# every number\nspf = [0 for i in range(MAXN)]\n \n# Calculating SPF (Smallest Prime Factor) \n# for every number till MAXN.\n# Time Complexity : O(nloglogn)\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n         \n        # marking smallest prime factor \n        # for every number to be itself.\n        spf[i] = i\n \n    # separately marking spf for \n    # every even number as 2\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n \n    for i in range(3, mt.ceil(mt.sqrt(MAXN))):\n         \n        # checking if i is prime\n        if (spf[i] == i):\n             \n            # marking SPF for all numbers\n            # divisible by i\n            for j in range(i * i, MAXN, i): \n                 \n                # marking spf[j] if it is \n                # not previously marked\n                if (spf[j] == j):\n                    spf[j] = i\n \n# A O(log n) function returning prime \n# factorization by dividing by smallest \n# prime factor at every step\ndef getFactorization(x):\n    ret = list()\n    while (x != 1):\n        ret.append(spf[x])\n        x = x // spf[x]\n \n    return ret\n \n# Driver code\n \n# precalculating Smallest Prime Factor\nsieve()\nx = 12246\nprint('prime factorization for', x, ': ',\n                                end = '')\n \n# calling getFactorization function\np = getFactorization(x)\n \nfor i in range(len(p)):\n    print(p[i], end = ' ')\n \n# This code is contributed \n# by Mohit kumar 29\n"], "Efficient program to print all prime factors of a given number": [], "Least prime factor of numbers till n -  ": ["# Python 3 program to print the \n# least prime factors of numbers\n# less than or equal to n using\n# modified Sieve of Eratosthenes\n \ndef leastPrimeFactor(n) :\n     \n    # Create a vector to store least primes.\n    # Initialize all entries as 0.\n    least_prime = [0] * (n + 1)\n \n    # We need to print 1 for 1.\n    least_prime[1] = 1\n \n    for i in range(2, n + 1) :\n         \n        # least_prime[i] == 0\n        # means it i is prime\n        if (least_prime[i] == 0) :\n             \n            # marking the prime number\n            # as its own lpf\n            least_prime[i] = i\n \n            # mark it as a divisor for all its\n            # multiples if not already marked\n            for j in range(i * i, n + 1, i) :\n                if (least_prime[j] == 0) :\n                    least_prime[j] = i\n         \n         \n    # print least prime factor \n    # of numbers till n\n    for i in range(1, n + 1) :\n        print('Least Prime factor of '\n              ,i , ': ' , least_prime[i] )\n         \n \n# Driver program \n \nn = 10\nleastPrimeFactor(n)\n \n \n# This code is contributed \n# by Nikita Tiwari.\n"], "Find all factors of a Natural Number -  ": ["# Python implementation of Naive method \n# to print all divisors \n  \n# method to print the divisors \ndef printDivisors(n) : \n    i = 1\n    while i <= n : \n        if (n % i==0) : \n            print (i,end=' ') \n        i = i + 1\n          \n# Driver method \nprint ('The divisors of 100 are: ') \nprintDivisors(100) \n  \n#This code is contributed by Nikita Tiwari. \n", "# A Better (than Naive) Solution to find all divisors \nimport math  \n  \n# method to print the divisors \ndef printDivisors(n) : \n      \n    # Note that this loop runs till square root \n    i = 1\n    while i <= math.sqrt(n): \n          \n        if (n % i == 0) : \n              \n            # If divisors are equal, print only one \n            if (n / i == i) : \n                print (i,end=' ') \n            else : \n                # Otherwise print both \n                print (i , int(n/i), end=' ') \n        i = i + 1\n  \n# Driver method \nprint ('The divisors of 100 are: ') \nprintDivisors(100) \n  \n#This code is contributed by Nikita Tiwari. \n"], "Segmented Sieve -  ": ["# This functions finds all primes smaller than 'limit'\n# using simple sieve of eratosthenes.\ndef simpleSieve(limit):\n \n    # Create a boolean array 'mark[0..limit-1]' and\n    # initialize all entries of it as true. A value\n    # in mark[p] will finally be false if 'p' is Not\n    # a prime, else true.\n    mark = [True for i in range(limit)]\n \n    # One by one traverse all numbers so that their\n    # multiples can be marked as composite.\n    for p in range(p * p, limit - 1, 1):\n \n        # If p is not changed, then it is a prime\n        if (mark[p] == True):\n \n            # Update all multiples of p\n            for i in range(p * p, limit - 1, p):\n                mark[i] = False\n \n    # Print all prime numbers and store them in prime\n    for p in range(2, limit - 1, 1):\n        if (mark[p] == True):\n            print(p, end=' ')\n \n# This code is contributed by Dharanendra L V.\n", "# Python3 program to print all primes \n# smaller than n, using segmented sieve \nimport math\nprime = []\n \n# This method finds all primes \n# smaller than 'limit' using \n# simple sieve of eratosthenes. \n# It also stores found primes in list prime\ndef simpleSieve(limit):\n     \n    # Create a boolean list 'mark[0..n-1]' and  \n    # initialize all entries of it as True. \n    # A value in mark[p] will finally be False \n    # if 'p' is Not a prime, else True. \n    mark = [True for i in range(limit + 1)]\n    p = 2\n    while (p * p <= limit):\n         \n        # If p is not changed, then it is a prime \n        if (mark[p] == True): \n             \n            # Update all multiples of p \n            for i in range(p * p, limit + 1, p): \n                mark[i] = False \n        p += 1\n         \n    # Print all prime numbers \n    # and store them in prime \n    for p in range(2, limit): \n        if mark[p]:\n            prime.append(p)\n            print(p,end = ' ')\n             \n# Prints all prime numbers smaller than 'n' \ndef segmentedSieve(n):\n     \n    # Compute all primes smaller than or equal \n    # to square root of n using simple sieve\n    limit = int(math.floor(math.sqrt(n)) + 1)\n    simpleSieve(limit)\n     \n    # Divide the range [0..n-1] in different segments \n    # We have chosen segment size as sqrt(n). \n    low = limit\n    high = limit * 2\n     \n    # While all segments of range [0..n-1] are not processed, \n    # process one segment at a time \n    while low < n:\n        if high >= n:\n            high = n\n             \n        # To mark primes in current range. A value in mark[i] \n        # will finally be False if 'i-low' is Not a prime, \n        # else True. \n        mark = [True for i in range(limit + 1)]\n         \n        # Use the found primes by simpleSieve() \n        # to find primes in current range \n        for i in range(len(prime)):\n             \n            # Find the minimum number in [low..high] \n            # that is a multiple of prime[i] \n            # (divisible by prime[i]) \n            # For example, if low is 31 and prime[i] is 3, \n            # we start with 33. \n            loLim = int(math.floor(low / prime[i]) *\n                                         prime[i])\n            if loLim < low:\n                loLim += prime[i]\n                 \n            # Mark multiples of prime[i] in [low..high]: \n            # We are marking j - low for j, i.e. each number \n            # in range [low, high] is mapped to [0, high-low] \n            # so if range is [50, 100] marking 50 corresponds \n            # to marking 0, marking 51 corresponds to 1 and \n            # so on. In this way we need to allocate space \n            # only for range \n            for j in range(loLim, high, prime[i]):\n                mark[j - low] = False\n                 \n        # Numbers which are not marked as False are prime \n        for i in range(low, high):\n            if mark[i - low]:\n                print(i, end = ' ')\n                 \n        # Update low and high for next segment \n        low = low + limit\n        high = high + limit\n \n# Driver Code\nn = 100\nprint('Primes smaller than', n, ':')\nsegmentedSieve(100)\n \n# This code is contributed by bhavyadeep\n"], "Sieve of Eratosthenes -  ": ["# Python program to print all \n# primes smaller than or equal to \n# n using Sieve of Eratosthenes \n  \n  \ndef SieveOfEratosthenes(n): \n  \n    # Create a boolean array \n    # 'prime[0..n]' and initialize \n    #  all entries it as true. \n    # A value in prime[i] will \n    # finally be false if i is \n    # Not a prime, else true. \n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n  \n        # If prime[p] is not \n        # changed, then it is a prime \n        if (prime[p] == True): \n  \n            # Update all multiples of p \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n  \n    # Print all prime numbers \n    for p in range(2, n+1): \n        if prime[p]: \n            print(p) \n  \n  \n# Driver code \nif __name__ == '__main__': \n    n = 20\n    print('Following are the prime numbers smaller'), \n    print('than or equal to', n) \n    SieveOfEratosthenes(n) \n", "# Python program for the above approach \nPrimes = [0] * 500001\ndef SieveOfEratosthenes(n) : \n      \n    Primes[0] = 1\n    i = 3\n    while(i*i <= n) :  \n        if (Primes[i // 2] == 0) : \n            for j in range(3 * i, n+1, 2 * i) :  \n                Primes[j // 2] = 1\n                  \n        i += 2\n          \n# Driver Code \nif __name__ == '__main__': \n  \n    n = 100\n    SieveOfEratosthenes(n) \n    for i in range(1, n+1) : \n        if (i == 2) : \n            print( i, end = ' ') \n        elif (i % 2 == 1 and Primes[i // 2] == 0) : \n            print( i, end = ' ') \n      \n    # This code is contributed by code_hunt.\n"], "Introduction to Primality Test and School Method -  ": ["# A school method based Python3 \n# program to check if a number \n# is prime \n  \n  \ndef isPrime(n): \n  \n    # Corner case \n    if n <= 1: \n        return False\n  \n    # Check from 2 to n-1 \n    for i in range(2, n): \n        if n % i == 0: \n            return False\n  \n    return True\n  \n  \n# Driver Program to test above function \nprint('true') if isPrime(11) else print('false') \nprint('true') if isPrime(14) else print('false') \n  \n# This code is contributed by Smitha Dinesh Semwal \n", "# Optimised school method based PYTHON program \n# to check if a number is prime \n# import the math module \nimport math \n  \n# function to check whether the number is prime or not \n  \n  \ndef isPrime(n): \n  \n    # Corner case \n    if (n <= 1): \n        return False\n  \n    # Check from 2 to square root of n \n    for i in range(2, int(math.sqrt(n)) + 1): \n        if (n % i == 0): \n            return False\n    return True\n  \n  \n# Driver Program to test above function \nprint('true') if isPrime(11) else print('false') \nprint('true') if isPrime(15) else print('false') \n  \n# This code is contributed by bhoomikavemula \n", "# Python program to check the given number \n# is prime or not \n  \n# Function to check if the given number \n# is prime or not. \nimport math \n  \ndef isPrime(n): \n    if n == 2 or n == 3: \n        return True\n    elif n <= 1 or n % 2 == 0 or n % 3 == 0: \n        return False\n        \n        # To check through all numbers of the form 6k \u00b1 1 \n    # until i <= square root of n, with step value 6 \n    for i in range(5, int(math.sqrt(n))+1, 6): \n        if n % i == 0 or n % (i+2) == 0: \n            return False\n  \n    return True\n  \n# # Driver code \nprint(isPrime(11)) \nprint(isPrime(20)) \n  \n# # This code is contributed by Harsh Master\n"], "C++ bitset and its application -  ": [], "Bits manipulation (Important tactics) -  ": ["# Direct XOR of all numbers from 1 to n\ndef computeXOR(n):\n    if (n % 4 is 0):\n        return n\n    if (n % 4 is 1):\n        return 1\n    if (n % 4 is 2):\n        return n + 1\n    else:\n        return 0\n \n       \n# This code is contributed by akashish__\n", "# Count of numbers (x) smaller than or equal to n such that n+x = n^x:\n# here unset bits means zero bits\n \n# function to count number of values less than\n# equal to n that satisfy the given condition\ndef countValues(n):\n   \n    # unset_bits keeps track of count of un-set\n    # bits in binary representation of n\n    unset_bits=0\n    while (n):\n        if ((n & 1) == 0):\n            unset_bits+=1\n        n=n>>1\n \n    # Return 2 ^ unset_bits i.e. pow(2,count of zero bits)\n    return 1 << unset_bits\n \n# Driver code\nn = 15\nprint(countValues(n))\n \n# This code is contributed by akashish__\n", "#  Function to check if x is power of 2\ndef isPowerOfTwo(x):\n   \n  # First x in the below expression is\n  # for  the case when x is 0 \n  return x and (not(x & (x - 1)))\n \n# This code is contributed by akashish__\n", "# Python Code\nnumber = 0b011\nprint(number)\n \n# This code is contributed by akashish__\n", "a = 5\nb = 7\nprint('Before Swapping, a = ',a,' ','b = ',b)\na ^= b\nb ^= a\na ^= b\nprint('After Swapping, a = ',a,' ','b = ',b)\n \n# This code is contributed by akashish__\n", "def setBitNumber(n):\n    # Below steps set bits after\n    # MSB (including MSB)\n \n    # Suppose n is 273 (binary\n    # is 100010001). It does following\n    # 100010001 | 010001000 = 110011001\n    n |= n >> 1\n \n    # This makes sure 4 bits\n    # (From MSB and including MSB)\n    # are set. It does following\n    # 110011001 | 001100110 = 111111111\n    n |= n >> 2\n \n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n \n    # Increment n by 1 so that\n    # there is only one set bit\n    # which is just before original\n    # MSB. n now becomes 1000000000\n    n = n + 1\n \n    # Return original MSB after shifting.\n    # n now becomes 100000000\n    return (n >> 1)\n   \n# This code is contributed by akashish__\n", "# function to check if all the bits\n# are set or not in the binary\n# representation of 'n'\ndef allBitsAreSet(n):\n  # if true, then all bits are set\n  if (((n + 1) & n) == 0):\n    return True\n \n  # else all bits are not set\n  return False\n \n# Function to check if a number\n# has bits in alternate pattern\ndef bitsAreInAltOrder(n):\n  num = n ^ (n >> 1)\n \n  # To check if all bits are set in 'num'\n  return allBitsAreSet(num)\n \n \n# This code is contributed by akashish__\n"], "Python Operators -  ": ["# python program to demonstrate the use of '/' \nprint(5/5)\nprint(10/2)\nprint(-10/2)\nprint(20.0/2)\n", "# python program to demonstrate the use of '//'\nprint(10//3)\nprint (-5//2)\nprint (5.0//2)\nprint (-5.0//2)\n", "# Examples of Arithmetic Operator\na = 9\nb = 4\n \n# Addition of numbers\nadd = a + b\n \n# Subtraction of numbers\nsub = a - b\n \n# Multiplication of number\nmul = a * b\n \n# Modulo of both number\nmod = a % b\n \n# Power\np = a ** b\n \n# print results\nprint(add)\nprint(sub)\nprint(mul)\nprint(mod)\nprint(p)\n", "# Examples of Relational Operators\na = 13\nb = 33\n \n# a > b is False\nprint(a > b)\n \n# a < b is True\nprint(a < b)\n \n# a == b is False\nprint(a == b)\n \n# a != b is True\nprint(a != b)\n \n# a >= b is False\nprint(a >= b)\n \n# a <= b is True\nprint(a <= b)\n", "# Examples of Logical Operator\na = True\nb = False\n \n# Print a and b is False\nprint(a and b)\n \n# Print a or b is True\nprint(a or b)\n \n# Print not a is False\nprint(not a)\n", "# Examples of Bitwise operators\na = 10\nb = 4\n \n# Print bitwise AND operation\nprint(a & b)\n \n# Print bitwise OR operation\nprint(a | b)\n \n# Print bitwise NOT operation\nprint(~a)\n \n# print bitwise XOR operation\nprint(a ^ b)\n \n# print bitwise right shift operation\nprint(a >> 2)\n \n# print bitwise left shift operation\nprint(a << 2)\n", "# Examples of Assignment Operators\na = 10\n \n# Assign value\nb = a\nprint(b)\n \n# Add and assign value\nb += a\nprint(b)\n \n# Subtract and assign value\nb -= a\nprint(b)\n \n# multiply and assign\nb *= a\nprint(b)\n \n# bitwise lishift operator\nb <<= a\nprint(b)\n", "a = 10\nb = 20\nc = a\n \nprint(a is not b)\nprint(a is c)\n", "# Python program to illustrate\n# not 'in' operator\nx = 24\ny = 20\nlist = [10, 20, 30, 40, 50]\n \nif (x not in list):\n    print('x is NOT present in given list')\nelse:\n    print('x is present in given list')\n \nif (y in list):\n    print('y is present in given list')\nelse:\n    print('y is NOT present in given list')\n", "# Program to demonstrate conditional operator\na, b = 10, 20\n \n# Copy value of a in min if a < b else copy b\nmin = a if a < b else b\n \nprint(min)\n", "# Examples of Operator Precedence\n \n# Precedence of '+' & '*'\nexpr = 10 + 20 * 30\nprint(expr)\n \n# Precedence of 'or' & 'and'\nname = 'Alex'\nage = 0\n \nif name == 'Alex' or name == 'John' and age >= 2:\n    print('Hello! Welcome.')\nelse:\n    print('Good Bye!!')\n", "# Examples of Operator Associativity\n \n# Left-right associativity\n# 100 / 10 * 10 is calculated as\n# (100 / 10) * 10 and not\n# as 100 / (10 * 10)\nprint(100 / 10 * 10)\n \n# Left-right associativity\n# 5 - 2 + 3 is calculated as\n# (5 - 2) + 3 and not\n# as 5 - (2 + 3)\nprint(5 - 2 + 3)\n \n# left-right associativity\nprint(5 - (2 + 3))\n \n# right-left associativity\n# 2 ** 3 ** 2 is calculated as\n# 2 ** (3 ** 2) and not\n# as (2 ** 3) ** 2\nprint(2 ** 3 ** 2)\n"], "Operators in Java -  ": [], "Operators in C | Set 2 (Relational and Logical Operators) -  ": [], "Operators in C -  ": [], "Window Sliding Technique -  ": ["# code\nimport sys\n \n# O(n * k) solution for finding\n# maximum sum of a subarray of size k\nINT_MIN = -sys.maxsize - 1\n \n# Returns maximum sum in a\n# subarray of size k.\n \n \ndef maxSum(arr, n, k):\n \n    # Initialize result\n    max_sum = INT_MIN\n \n    # Consider all blocks\n    # starting with i.\n    for i in range(n - k + 1):\n        current_sum = 0\n        for j in range(k):\n            current_sum = current_sum + arr[i + j]\n \n        # Update result if required.\n        max_sum = max(current_sum, max_sum)\n \n    return max_sum\n \n \n# Driver code\narr = [1, 4, 2, 10, 2,\n       3, 1, 0, 20]\nk = 4\nn = len(arr)\nprint(maxSum(arr, n, k))\n \n# This code is contributed by mits\n", "# O(n) solution for finding\n# maximum sum of a subarray of size k\n \n \ndef maxSum(arr, k):\n    # length of the array\n    n = len(arr)\n \n    # n must be greater than k\n    if n < k:\n        print('Invalid')\n        return -1\n \n    # Compute sum of first window of size k\n    window_sum = sum(arr[:k])\n \n    # first sum available\n    max_sum = window_sum\n \n    # Compute the sums of remaining windows by\n    # removing first element of previous\n    # window and adding last element of\n    # the current window.\n    for i in range(n - k):\n        window_sum = window_sum - arr[i] + arr[i + k]\n        max_sum = max(window_sum, max_sum)\n \n    return max_sum\n \n \n# Driver code\narr = [1, 4, 2, 10, 2, 3, 1, 0, 20]\nk = 4\nprint(maxSum(arr, k))\n \n# This code is contributed by Kyle McClay\n"], "Convert an Array to reduced form using Hashing -  ": ["from typing import List\nimport sys\n \ndef convert(arr: List[int])->List[int]:\n    n = len(arr)\n    result = [0]*n\n    curr_pos = 0\n \n    # Iterate over the array\n    for i in range(n):\n        minn = sys.maxsize\n        idx = -1\n \n        # Find the minimum element and keep\n        # its position of occurrence\n        for j in range(n):\n            if (minn > arr[j]):\n                minn = arr[j]\n                idx = j\n \n        # Update the result at minimum index element\n        # with new Position\n        result[idx] = curr_pos\n \n        # Increment the new position\n        curr_pos += 1\n \n        # Update the original element at current minimum\n        # element with maximum value possible, so that it\n        # won't be minimum in further iteration\n        arr[idx] = sys.maxsize\n \n    # Return the result\n    return result\n \n \ndef printArr(arr: List[int]):\n    for i in arr:\n        print(i, end=' ')\n \n \n# Driver program to test above method\nif __name__ == '__main__':\n    arr = [10, 20, 15, 12, 11, 50]\n    n = len(arr)\n \n    print('Given Array is ')\n    printArr(arr)\n \n    result = convert(arr)\n \n    print('\\n\\nConverted Array is ')\n    printArr(result)\n", "# Python3 program to convert an array \n# in reduced form\ndef convert(arr, n):\n    # Create a temp array and copy contents\n    # of arr[] to temp\n    temp = [arr[i] for i in range (n) ]\n     \n    # Sort temp array\n    temp.sort()\n     \n    # create a map\n    umap = {}\n     \n     \n    # One by one insert elements of sorted\n    # temp[] and assign them values from 0\n    # to n-1\n    val = 0\n    for i in range (n):\n        umap[temp[i]] = val\n        val += 1\n     \n    # Convert array by taking positions from umap\n    for i in range (n):\n        arr[i] = umap[arr[i]]\n     \ndef printArr(arr, n):\n    for i in range(n):\n        print(arr[i], end = ' ')\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [10, 20, 15, 12, 11, 50]\n    n = len(arr)\n    print('Given Array is ')\n    printArr(arr, n)\n    convert(arr , n)\n    print('\\n\\nConverted Array is ')\n    printArr(arr, n)\n \n# This code is contributed by Abhishek Gupta\n", "import heapq # Import heapq for the priority queue data structure\n \n# Function to convert an array into its reduced form\ndef convert(arr):\n    n = len(arr) # Get the length of the input array\n     \n    # Create a temporary list and copy the contents of arr to it\n    temp = list(arr)\n     \n    # Create a priority queue to get the array sorted in increasing order\n    # using heapq module\n    pq = []\n    for i in range(n):\n        heapq.heappush(pq, arr[i])\n     \n    i = 0\n     \n    # Taking elements from priority queue to temp list\n    while len(pq) != 0:\n        temp[i] = heapq.heappop(pq)\n        i += 1\n     \n    # Create a dictionary to store the index of each element in the sorted list\n    umap = {}\n     \n    # Assign ranks to the elements of the sorted list\n    val = 0\n    for i in range(n):\n        umap[temp[i]] = val\n        val += 1\n     \n    # Replace each element of the input array with its rank in the dictionary\n    for i in range(n):\n        arr[i] = umap[arr[i]]\n \n# Driver code to test the convert function\nif __name__ == '__main__':\n    arr = [10, 20, 15, 12, 11, 50]\n    print('Given array is')\n    print(arr)\n     \n    convert(arr)\n     \n    print('\\nConverted array is')\n    print(arr)\n"], "Prefix Sum of Matrix (Or 2D Array) -  ": ["# Python Program to find \n# prefix sum of 2d array\nR = 4\nC = 5\n \n# calculating new array\ndef prefixSum2D(a) :\n    global C, R\n    psa = [[0 for x in range(C)] \n              for y in range(R)] \n    psa[0][0] = a[0][0]\n \n    # Filling first row \n    # and first column\n    for i in range(1, C) :\n        psa[0][i] = (psa[0][i - 1] +\n                       a[0][i])\n    for i in range(0, R) :\n        psa[i][0] = (psa[i - 1][0] +\n                       a[i][0])\n \n    # updating the values in \n    # the cells as per the \n    # general formula\n    for i in range(1, R) :\n        for j in range(1, C) :\n \n            # values in the cells of \n            # new array are updated\n            psa[i][j] = (psa[i - 1][j] +\n                         psa[i][j - 1] -\n                         psa[i - 1][j - 1] +\n                           a[i][j])\n \n    # displaying the values\n    # of the new array\n    for i in range(0, R) :\n        for j in range(0, C) :\n            print (psa[i][j], \n                   end = ' ')\n        print ()\n \n# Driver Code\na = [[ 1, 1, 1, 1, 1 ],\n     [ 1, 1, 1, 1, 1 ],\n     [ 1, 1, 1, 1, 1 ],\n     [ 1, 1, 1, 1, 1 ]]\n \nprefixSum2D(a)\n \n# This code is contributed by \n# Manish Shaw(manishshaw1)\n", "def prefixsum(arr, n):\n    # vertical prefixsum\n    for j in range(n):\n        for i in range(1, n):\n            arr[i][j] += arr[i - 1][j]\n             \n    # horizontal prefixsum\n    for i in  range(n):\n        for j in range(1, n):\n            arr[i][j] += arr[i][j - 1]\n             \ndef printarr(arr, n):\n    for i in range(n):\n        for j in range(n):\n            print(arr[i][j], end = ' ')\n        print()\n         \n# Driver Code\nn = 3\narr = [[10,20,30],[5,10,20],[2,4,6]]\nprefixsum(arr,n)\nprintarr(arr,n)  \n \n# This code is contributed by\n# Vibhu Karnwal\n"], "Prefix Sum Array - Implementation and Applications in Competitive Programming -  ": ["# Python3 Program for Implementing \n# prefix sum array \n  \n# Fills prefix sum array \n  \n  \ndef fillPrefixSum(arr, n, prefixSum): \n  \n    prefixSum[0] = arr[0] \n  \n    # Adding present element \n    # with previous element \n    for i in range(1, n): \n        prefixSum[i] = prefixSum[i - 1] + arr[i] \n  \n  \n# Driver code \nif __name__ == '__main__': \n  arr = [10, 4, 16, 20] \n  n = len(arr) \n  \n  # Function call \n  prefixSum = [0 for i in range(n + 1)] \n  \n  fillPrefixSum(arr, n, prefixSum) \n  \n  for i in range(n): \n      print(prefixSum[i], ' ', end='') \n  \n# This code is contributed \n# by Anant Agarwal. \n", "# Python3 program for the above approach \n  \n# Driver code \nif __name__ == '__main__': \n    n = 6\n    a = [3, 6, 2, 8, 9, 2] \n    pf = [0 for i in range(n+2)] \n    for i in range(n): \n        pf[i + 1] = pf[i] + a[i] \n  \n    q = [[2, 3], [4, 6], [1, 5], [3, 6]] \n    for i in range(4): \n        l = q[i][0] \n        r = q[i][1] \n  \n        # Calculating sum from r to l. \n        print(pf[r] - pf[l - 1]) \n  \n# This code is contributed by gauravrajput1 \n", "# Python implementation of the approach \ndef find(m, q): \n    mx = 0\n    pre = [0 for i in range(5)] \n  \n    for i in range(m): \n        # take input a and b \n        a, b = q[i][0], q[i][1] \n  \n        # add 100 at first index and \n        # subtract 100 from last index \n  \n        # pre[1] becomes 100 \n        pre[a-1] += 100\n  \n        # pre[4] becomes -100 and this \n        pre[b] -= 100\n  \n        # continues m times as we input diff. values of a and b \n    for i in range(1, 5): \n  \n        # add all values in a cumulative way \n        pre[i] += pre[i - 1] \n  \n        # keep track of max value \n        mx = max(mx, pre[i]) \n    return mx \n  \n  \n# Driver Code \nm = 3\nq = [[2, 4], [1, 3], [1, 2]] \n  \n# Function call \nprint(find(m, q)) \n  \n# This code is contributed by rohitsingh07052 \n"], "Precision Handling in Python -  ": ["rounded = round(8.88888, 2) \nprint(rounded) \n  \nformatted = '{:.3f}'.format(9.999) \nprint(formatted)\n", "from decimal import Decimal, getcontext \n  \ngetcontext().prec = 3\n  \nresult = Decimal('3') / Decimal('9') \nprint(result) \n", "import math \n  \na = 3.4536\n  \nprint('The integral value of number is : ', end='') \nprint(math.trunc(a)) \n  \n# using ceil() to print number after ceiling \nprint('The smallest integer greater than number is : ', end='') \nprint(math.ceil(a)) \n  \n# using floor() to print number after flooring \nprint('The greatest integer smaller than number is : ', end='') \nprint(math.floor(a))\n", "a = 3.4536\n  \nprint('The value of number till 2 decimal place(using %) is : ', end='') \nprint('%.2f' % a) \n  \n# using format() to print value till 3 decimal places \nprint('The value of number till 3 decimal place(using format()) is : ', end='') \nprint('{0:.3f}'.format(a)) \n  \n# using round() to print value till 2 decimal places \nprint('The value of number till 2 decimal place(using round()) is : ', end='') \nprint(round(a, 2)) \n  \n# using f-string to print value till 2 decimal places \nprint('The value of number till 2 decimal place(using f-string) is : ', end='') \nprint(f'{a:0,.2f}')\n"], "How to Set Precision For Double Values in Java? -  ": [], "Precision of Floating Point Numbers in C++ (floor(), ceil(), trunc(), round() and setprecision()) -  ": [], "Counting frequencies of array elements -  ": ["# Python 3 program to count frequencies\n# of array items\ndef countFreq(arr, n):\n     \n    # Mark all array elements as not visited\n    visited = [False for i in range(n)]\n \n    # Traverse through array elements \n    # and count frequencies\n    for i in range(n):\n         \n        # Skip this element if already \n        # processed\n        if (visited[i] == True):\n            continue\n \n        # Count frequency\n        count = 1\n        for j in range(i + 1, n, 1):\n            if (arr[i] == arr[j]):\n                visited[j] = True\n                count += 1\n         \n        print(arr[i], count)\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [10, 20, 20, 10, 10, 20, 5, 20]\n    n = len(arr)\n    countFreq(arr, n)\n     \n# This code is contributed by\n# Shashank_Sharma\n", "# Python3 program to count frequencies \n# of array items\ndef countFreq(arr, n):\n \n    mp = dict()\n \n    # Traverse through array elements \n    # and count frequencies\n    for i in range(n):\n        if arr[i] in mp.keys():\n            mp[arr[i]] += 1\n        else:\n            mp[arr[i]] = 1\n             \n    # Traverse through map and print \n    # frequencies\n    for x in mp:\n        print(x, ' ', mp[x])\n \n# Driver code\narr = [10, 20, 20, 10, 10, 20, 5, 20 ]\nn = len(arr)\ncountFreq(arr, n)\n \n# This code is contributed by \n# Mohit kumar 29\n", "# Python3 program to count frequencies of array items\ndef countFreq(arr, n):\n     \n    mp = {}\n     \n    # Traverse through array elements and\n    # count frequencies\n    for i in range(n):\n        if arr[i] not in mp:\n            mp[arr[i]] = 0\n        mp[arr[i]] += 1\n         \n    # To print elements according to first\n    # occurrence, traverse array one more time\n    # print frequencies of elements and mark\n    # frequencies as -1 so that same element\n    # is not printed multiple times.\n    for i in range(n):\n        if (mp[arr[i]] != -1):\n            print(arr[i],mp[arr[i]])\n        mp[arr[i]] = -1\n \n# Driver code\n \narr = [10, 20, 20, 10, 10, 20, 5, 20]\nn = len(arr)\ncountFreq(arr, n)\n \n# This code is contributed by shubhamsingh10\n", "# Python program to count frequencies of\n# integers in array using Hashmap\n \ndef frequencyNumber(arr,size):\n    # Creating a HashMap containing integer\n        # as a key and occurrences as a value\n        freqMap = {}\n  \n        for i in range(size):\n            if (arr[i] in freqMap):\n  \n                # If number is present in freqMap,\n                # incrementing it's count by 1\n                freqMap[arr[i]] = freqMap[arr[i]] + 1\n            else:\n  \n                # If integer is not present in freqMap,\n                # putting this integer to freqMap with 1 as it's value\n                freqMap[arr[i]] = 1\n  \n        # Printing the freqMap\n        for key, value in freqMap.items():\n            print(f'{key} {value}')\n \n# Driver Code\narr = [10, 20, 20, 10, 10, 20, 5, 20]\nsize = len(arr)\nfrequencyNumber(arr,size)\n \n# This code is contributed by shinjanpatra\n", "from bisect import bisect_left, bisect_right\n \n# Function to find frequency of elements in the array\ndef countFreq(arr, n):\n    arr.sort()  # sort array for binary search\n \n    i = 0\n    while i < n:\n        # index of first and last occ of arr[i]\n        first_index = bisect_left(arr, arr[i])\n        last_index = bisect_right(arr, arr[i]) - 1\n        i = last_index + 1\n \n        fre = last_index - first_index + 1  # finding frequency\n        print(arr[i - 1], fre)  # printing frequency\n \n# Driver code\narr = [10, 20, 20, 10, 10, 20, 5, 20]\nn = len(arr)\ncountFreq(arr, n)\n"], "Maximum and minimum of an array using minimum number of comparisons -  ": ["# Python3 implementation\n \n \nclass pair:\n \n    def __init__(self):\n        self.min = None\n        self.max = None\n \n \n# This code contributed by phasing17\n", "# Python program of above implementation\n \n# structure is used to return two values from minMax()\n \nclass pair:\n    def __init__(self):\n        self.min = 0\n        self.max = 0\n \ndef getMinMax(arr: list, n: int) -> pair:\n    minmax = pair()\n \n    # If there is only one element then return it as min and max both\n    if n == 1:\n        minmax.max = arr[0]\n        minmax.min = arr[0]\n        return minmax\n \n    # If there are more than one elements, then initialize min\n    # and max\n    if arr[0] > arr[1]:\n        minmax.max = arr[0]\n        minmax.min = arr[1]\n    else:\n        minmax.max = arr[1]\n        minmax.min = arr[0]\n \n    for i in range(2, n):\n        if arr[i] > minmax.max:\n            minmax.max = arr[i]\n        elif arr[i] < minmax.min:\n            minmax.min = arr[i]\n \n    return minmax\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [1000, 11, 445, 1, 330, 3000]\n    arr_size = 6\n    minmax = getMinMax(arr, arr_size)\n    print('Minimum element is', minmax.min)\n    print('Maximum element is', minmax.max)\n \n# This code is contributed by\n# sanjeev2552\n", "# Python3 program of above implementation \ndef getMinMax(arr):\n     \n    n = len(arr)\n     \n    # If array has even number of elements then \n    # initialize the first two elements as minimum \n    # and maximum \n    if(n % 2 == 0):\n         \n        if arr[0] < arr[1]:\n            mn = arr[0]\n            mx = arr[1]\n        else:\n            mn = arr[1]\n            mx = arr[0]\n         \n        # set the starting index for loop \n        i = 2\n         \n    # If array has odd number of elements then \n    # initialize the first element as minimum \n    # and maximum \n    else:\n        mx = mn = arr[0]\n         \n        # set the starting index for loop \n        i = 1\n         \n    # In the while loop, pick elements in pair and \n    # compare the pair with max and min so far \n    while(i < n - 1):\n        if arr[i] < arr[i + 1]:\n            mx = max(mx, arr[i + 1])\n            mn = min(mn, arr[i])\n        else:\n            mx = max(mx, arr[i])\n            mn = min(mn, arr[i + 1])\n             \n        # Increment the index by 2 as two \n        # elements are processed in loop \n        i += 2\n     \n    return (mx, mn)\n     \n# Driver Code\nif __name__ =='__main__':\n     \n    arr = [1000, 11, 445, 1, 330, 3000]\n    mx, mn = getMinMax(arr)\n    print('Minimum element is', mn)\n    print('Maximum element is', mx)\n     \n# This code is contributed by Kaustav\n"], "Program to find sum of elements in a given array -  ": ["# python Program to find sum of elements\n# in a given array using recursion\n \n# function to return sum of elements\n# in an array of size n\n \n \ndef sum1(arr):\n    if len(arr) == 1:\n        return arr[0]\n    else:\n        return arr[0] + sum1(arr[1:])\n \n \narr = [12, 3, 4, 15]\nprint(sum1(arr))\n \n# This code is contributed by laxmigangarajula03\n", "# Python 3 code to find sum\n# of elements in given array\n \n \ndef _sum(arr, n):\n \n    # return sum using sum\n    # inbuilt sum() function\n    return(sum(arr))\n \n \n# driver function\narr = []\n# input values to list\narr = [12, 3, 4, 15]\n \n# calculating length of array\nn = len(arr)\n \nans = _sum(arr, n)\n \n# display sum\nprint('Sum of the array is ', ans)\n \n# This code is contributed by Himanshu Ranjan\n", "# Python3 program to find sum of elements\n# in a given array\n \n# Driver code\nif __name__ == '__main__':\n \n    arr = [12, 3, 4, 15]\n    n = len(arr)\n \n    # Calling accumulate function, passing\n    # first, last element and initial sum,\n    # which is 0 in this case.\n    print('Sum of given array is ', sum(arr))\n \n# This code is contributed by ukasp\n"], "Python Program to Check if a String is Palindrome or Not -  ": ["# Recursive function to check if a\n# string is palindrome\ndef isPalindrome(s):\n \n    # to change it the string is similar case\n    s = s.lower()\n    # length of s\n    l = len(s)\n \n    # if length is less than 2\n    if l < 2:\n        return True\n \n    # If s[0] and s[l-1] are equal\n    elif s[0] == s[l - 1]:\n \n        # Call is palindrome form substring(1,l-1)\n        return isPalindrome(s[1: l - 1])\n \n    else:\n        return False\n \n# Driver Code\ns = 'MalaYaLam'\nans = isPalindrome(s)\n \nif ans:\n    print('Yes')\n \nelse:\n    print('No')\n"], "Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1->2->3->4->5->NULL, m = 2 and n = 4, return 1->4->3->2->5->NULL. Note: Given m, n satisfy the following condition: 1 \u2264 m \u2264 n \u2264 length of list. Note 2: Usually the version often seen in the interviews is reversing the whole linked list which is obviously an easier version of this question.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @param B : integer\n    # @param C : integer\n    # @return the head node in the linked list\n    def reverseBetween(self, A, B, C):\n        \n        # 1->2->3->4->5->NULL, m = 2 and n = 4,\n        # 1->4->3->2->5->NULL.\n\n        head = A\n        current = A\n        prv = None\n        nxt = None\n        \n        step = 1\n        \n        while current is not None:\n            \n            if step < B:\n                prv = current\n                current = current.next\n\n            if step >= B and step <= C:\n                if step == B:\n                # this is a start of the reversed list\n                    last_non_reversed = prv\n                    last_reversed = current\n                \n                if step == C:\n                    # this is the end of the reversed list\n                    first_reversed = current\n                    first_non_reversed = current.next\n                \n                # part that does reverse\n                nxt = current.next\n                current.next = prv\n                prv = current\n                current = nxt\n\n            if step > C:\n                # We can skip these steps\n                break\n            \n            step += 1\n        \n        if last_non_reversed is not None:\n            last_non_reversed.next = first_reversed\n            \n        last_reversed.next = first_non_reversed\n        \n        if B == 1:\n            # In this case we did reverse from the very first element\n            head = prv\n            \n        return head\n\n\n\n", "Convert given Binary Tree to Doubly Linked List in Linear time -  ": ["# Python3 program to convert a given Binary Tree to Doubly Linked List  \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.left = self.right = None\n  \nclass BinaryTree: \n    # A simple recursive function to convert a given  \n    # Binary tree to Doubly Linked List  \n    # root    --> Root of Binary Tree  \n    # head --> Pointer to head node of created doubly linked list  \n    root, head = None, None\n      \n    def BToDll(self, root: Node): \n        if root is None: \n            return\n  \n        # Recursively convert right subtree \n        self.BToDll(root.right) \n  \n        # Insert root into doubly linked list \n        root.right = self.head \n  \n        # Change left pointer of previous head \n        if self.head is not None: \n            self.head.left = root \n  \n        # Change head of doubly linked list \n        self.head = root \n  \n        # Recursively convert left subtree \n        self.BToDll(root.left) \n  \n    @staticmethod\n    def print_list(head: Node): \n        print('Extracted Double Linked list is:') \n        while head is not None: \n            print(head.data, end = ' ') \n            head = head.right \n  \n# Driver program to test above function  \nif __name__ == '__main__': \n      \n    ''' \n    Constructing below tree \n            5 \n        // \\\\ \n        3 6 \n        // \\\\ \\\\ \n        1 4 8 \n    // \\\\ // \\\\ \n    0 2 7 9 \n    '''\n    tree = BinaryTree() \n    tree.root = Node(5) \n    tree.root.left = Node(3) \n    tree.root.right = Node(6) \n    tree.root.left.left = Node(1) \n    tree.root.left.right = Node(4) \n    tree.root.right.right = Node(8) \n    tree.root.left.left.left = Node(0) \n    tree.root.left.left.right = Node(2) \n    tree.root.right.right.left = Node(7) \n    tree.root.right.right.right = Node(9) \n  \n    tree.BToDll(tree.root) \n    tree.print_list(tree.head) \n  \n# This code is contributed by Rajat Srivastava \n"], "Implementation of Heavy Light Decomposition -  ": [], "Range Minimum Query (Square Root Decomposition and Sparse Table) -  ": ["# Python3 program to do range \n# minimum query in O(1) time with\n# O(n*n) extra space and O(n*n) \n# preprocessing time.\nMAX = 500\n  \n# lookup[i][j] is going to store \n# index of minimum value in\n# arr[i..j]\nlookup = [[0 for j in range(MAX)] \n             for i in range(MAX)]\n  \n# Structure to represent \n# a query range\nclass Query:\n     \n    def __init__(self, L, R):\n         \n        self.L = L\n        self.R = R\n  \n# Fills lookup array lookup[n][n] \n# for all possible values\n# of query ranges\ndef preprocess(arr, n):\n \n    # Initialize lookup[][] for the \n    # intervals with length 1\n    for i in range(n):\n        lookup[i][i] = i;\n  \n    # Fill rest of the entries in \n    # bottom up manner\n    for i in range(n):\n        for j in range(i + 1, n):\n  \n            # To find minimum of [0,4],\n            # we compare minimum\n            # of arr[lookup[0][3]] with arr[4].\n            if (arr[lookup[i][j - 1]] < arr[j]):\n                lookup[i][j] = lookup[i][j - 1];\n            else:\n                lookup[i][j] = j;    \n  \n# Prints minimum of given m \n# query ranges in arr[0..n-1]\ndef RMQ(arr, n, q, m):\n \n    # Fill lookup table for \n    # all possible input queries\n    preprocess(arr, n);\n  \n    # One by one compute sum of \n    # all queries\n    for i in range(m):\n \n        # Left and right boundaries \n        # of current range\n        L = q[i].L\n        R = q[i].R;\n  \n        # Print sum of current query range\n        print('Minimum of [' + str(L) + ', ' +\n               str(R) + '] is ' +\n               str(arr[lookup[L][R]]))\n \n# Driver code\nif __name__ == '__main__':\n     \n    a = [7, 2, 3, 0, 5, \n         10, 3, 12, 18]\n    n = len(a)    \n    q = [Query(0, 4),\n         Query(4, 7),\n         Query(7, 8)]    \n    m = len(q)    \n    RMQ(a, n, q, m);\n  \n# This code is contributed by Rutvik_56\n", "# Python3 program to do range minimum query\n# in O(1) time with O(n Log n) extra space\n# and O(n Log n) preprocessing time\nfrom math import log2\n \nMAX = 500\n \n# lookup[i][j] is going to store index of\n# minimum value in arr[i..j].\n# Ideally lookup table size should\n# not be fixed and should be determined\n# using n Log n. It is kept constant\n# to keep code simple.\nlookup = [[0 for i in range(500)]\n          for j in range(500)]\n \n# Structure to represent a query range\n \n \nclass Query:\n    def __init__(self, l, r):\n        self.L = l\n        self.R = r\n \n# Fills lookup array lookup[][]\n# in bottom up manner.\n \n \ndef preprocess(arr: list, n: int):\n    global lookup\n \n    # Initialize M for the\n    # intervals with length 1\n    for i in range(n):\n        lookup[i][0] = i\n \n    # Compute values from\n    # smaller to bigger intervals\n    j = 1\n    while (1 << j) <= n:\n \n        # Compute minimum value for\n        # all intervals with size 2^j\n        i = 0\n        while i + (1 << j) - 1 < n:\n \n            # For arr[2][10], we compare\n            # arr[lookup[0][3]] and\n            # arr[lookup[3][3]]\n            if (arr[lookup[i][j - 1]] <\n                    arr[lookup[i + (1 << (j - 1))][j - 1]]):\n                lookup[i][j] = lookup[i][j - 1]\n            else:\n                lookup[i][j] = lookup[i +\n                                      (1 << (j - 1))][j - 1]\n \n            i += 1\n        j += 1\n \n# Returns minimum of arr[L..R]\n \n \ndef query(arr: list, L: int, R: int) -> int:\n    global lookup\n \n    # For [2,10], j = 3\n    j = int(log2(R - L + 1))\n \n    # For [2,10], we compare\n    # arr[lookup[0][3]] and\n    # arr[lookup[3][3]],\n    if (arr[lookup[L][j]] <=\n            arr[lookup[R - (1 << j) + 1][j]]):\n        return arr[lookup[L][j]]\n    else:\n        return arr[lookup[R - (1 << j) + 1][j]]\n \n# Prints minimum of given\n# m query ranges in arr[0..n-1]\n \n \ndef RMQ(arr: list, n: int, q: list, m: int):\n \n    # Fills table lookup[n][Log n]\n    preprocess(arr, n)\n \n    # One by one compute sum of all queries\n    for i in range(m):\n \n        # Left and right boundaries\n        # of current range\n        L = q[i].L\n        R = q[i].R\n \n        # Print sum of current query range\n        print('Minimum of [%d, %d] is %d' %\n              (L, R, query(arr, L, R)))\n \n \n# Driver Code\nif __name__ == '__main__':\n    a = [7, 2, 3, 0, 5, 10, 3, 12, 18]\n    n = len(a)\n    q = [Query(0, 4), Query(4, 7),\n         Query(7, 8)]\n    m = len(q)\n \n    RMQ(a, n, q, m)\n \n# This code is contributed by\n# sanjeev2552\n"], "Lazy Propagation in Segment Tree -  ": ["# /* A recursive function to update the nodes which have the given\n#    index in their range. The following are parameters\n#     tree[] --> segment tree\n#     si     -->  index of current node in segment tree.\n#                 Initial value is passed as 0.\n#     ss and se --> Starting and ending indexes of array elements \n#                   covered under this node of segment tree.\n#                   Initial values passed as 0 and n-1.\n#     i    --> index of the element to be updated. This index \n#             is in input array.\n#    diff --> Value to be added to all nodes which have array\n#             index i in range */\ndef updateValueUtil(tree, ss, se, i, diff, si):\n     \n    # Base Case: If the input index lies outside the range\n    # of this segment\n    if i < ss or i > se:\n        return\n  \n    # If the input index is in range of this node, then\n    # update the value of the node and its children\n    st[si] = st[si] + diff\n    if se != ss:\n        mid = getMid(ss, se)\n        updateValueUtil(st, ss, mid, i, diff, 2*si + 1)\n        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2)\n \n# The code is contributed by Arushi jindal. \n", "# Python\n \n \ndef updateRangeUtil(si, ss, se, us, ue, diff):\n    # out of range\n    if (ss > se or ss > ue or se < us):\n        return\n \n    # Current node is a leaf node\n    if (ss == se):\n        # Add the difference to current node\n        tree[si] += diff\n        return\n \n    # If not a leaf node, recur for children.\n    mid = (ss + se) // 2\n    updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff)\n    updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff)\n \n    # Use the result of children calls to update this\n    # node\n    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2]\n", "# Python3 implementation of the approach \nMAX = 1000\n \n# Ideally, we should not use global variables \n# and large constant-sized arrays, we have \n# done it here for simplicity. \ntree = [0] * MAX; # To store segment tree \nlazy = [0] * MAX; # To store pending updates \n \n''' si -> index of current node in segment tree \n    ss and se -> Starting and ending indexes of elements \n                for which current nodes stores sum. \n    us and ue -> starting and ending indexes of update query \n    diff -> which we need to add in the range us to ue '''\ndef updateRangeUtil(si, ss, se, us, ue, diff) : \n \n    # If lazy value is non-zero for current node\n    # of segment tree, then there are some \n    # pending updates. So we need to make sure \n    # that the pending updates are done before \n    # making new updates. Because this value may be \n    # used by parent after recursive calls \n    # (See last line of this function) \n    if (lazy[si] != 0) :\n         \n        # Make pending updates using value \n        # stored in lazy nodes \n        tree[si] += (se - ss + 1) * lazy[si]; \n \n        # checking if it is not leaf node because if \n        # it is leaf node then we cannot go further \n        if (ss != se) :\n         \n            # We can postpone updating children we don't \n            # need their new values now. \n            # Since we are not yet updating children of si, \n            # we need to set lazy flags for the children \n            lazy[si * 2 + 1] += lazy[si]; \n            lazy[si * 2 + 2] += lazy[si]; \n         \n        # Set the lazy value for current node \n        # as 0 as it has been updated \n        lazy[si] = 0; \n     \n    # out of range \n    if (ss > se or ss > ue or se < us) :\n        return ; \n \n    # Current segment is fully in range \n    if (ss >= us and se <= ue) :\n         \n        # Add the difference to current node \n        tree[si] += (se - ss + 1) * diff; \n \n        # same logic for checking leaf node or not \n        if (ss != se) :\n         \n            # This is where we store values in lazy nodes, \n            # rather than updating the segment tree itself \n            # Since we don't need these updated values now \n            # we postpone updates by storing values in lazy[] \n            lazy[si * 2 + 1] += diff; \n            lazy[si * 2 + 2] += diff; \n         \n        return; \n \n    # If not completely in rang, but overlaps, \n    # recur for children, \n    mid = (ss + se) // 2; \n    updateRangeUtil(si * 2 + 1, ss,\n                    mid, us, ue, diff); \n    updateRangeUtil(si * 2 + 2, mid + 1, \n                    se, us, ue, diff); \n \n    # And use the result of children calls \n    # to update this node \n    tree[si] = tree[si * 2 + 1] + \\\n            tree[si * 2 + 2]; \n \n# Function to update a range of values \n# in segment tree \n \n''' us and eu -> starting and ending indexes \n                of update query \n    ue -> ending index of update query \n    diff -> which we need to add in the range us to ue '''\ndef updateRange(n, us, ue, diff) :\n    updateRangeUtil(0, 0, n - 1, us, ue, diff); \n \n''' A recursive function to get the sum of values \n    in given range of the array. The following are \n    parameters for this function. \n    si --> Index of current node in the segment tree. \n        Initially 0 is passed as root is always at' \n        index 0 \n    ss & se --> Starting and ending indexes of the \n                segment represented by current node, \n                i.e., tree[si] \n    qs & qe --> Starting and ending indexes of query \n                range '''\ndef getSumUtil(ss, se, qs, qe, si) : \n \n    # If lazy flag is set for current node \n    # of segment tree, then there are \n    # some pending updates. So we need to \n    # make sure that the pending updates are \n    # done before processing the sub sum query \n    if (lazy[si] != 0) :\n     \n        # Make pending updates to this node. \n        # Note that this node represents sum of \n        # elements in arr[ss..se] and all these \n        # elements must be increased by lazy[si] \n        tree[si] += (se - ss + 1) * lazy[si]; \n \n        # checking if it is not leaf node because if \n        # it is leaf node then we cannot go further \n        if (ss != se) :\n         \n            # Since we are not yet updating children os si, \n            # we need to set lazy values for the children \n            lazy[si * 2 + 1] += lazy[si]; \n            lazy[si * 2 + 2] += lazy[si]; \n \n        # unset the lazy value for current node \n        # as it has been updated \n        lazy[si] = 0; \n \n    # Out of range \n    if (ss > se or ss > qe or se < qs) :\n        return 0; \n \n    # At this point we are sure that \n    # pending lazy updates are done for \n    # current node. So we can return value\n    # (same as it was for query in our previous post) \n \n    # If this segment lies in range \n    if (ss >= qs and se <= qe) :\n        return tree[si]; \n \n    # If a part of this segment overlaps \n    # with the given range \n    mid = (ss + se) // 2; \n    return (getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n            getSumUtil(mid + 1, se, qs, qe, 2 * si + 2)); \n \n# Return sum of elements in range from \n# index qs (query start) to qe (query end). \n# It mainly uses getSumUtil() \ndef getSum(n, qs, qe) :\n     \n    # Check for erroneous input values \n    if (qs < 0 or qe > n - 1 or qs > qe) :\n        print('Invalid Input'); \n        return -1; \n \n    return getSumUtil(0, n - 1, qs, qe, 0); \n \n# A recursive function that constructs \n# Segment Tree for array[ss..se]. \n# si is index of current node in segment \n# tree st. \ndef constructSTUtil(arr, ss, se, si) : \n \n    # out of range as ss can never be\n    # greater than se \n    if (ss > se) :\n        return ; \n \n    # If there is one element in array, \n    # store it in current node of \n    # segment tree and return \n    if (ss == se) :\n     \n        tree[si] = arr[ss]; \n        return; \n     \n    # If there are more than one elements, \n    # then recur for left and right subtrees \n    # and store the sum of values in this node \n    mid = (ss + se) // 2; \n    constructSTUtil(arr, ss, mid, si * 2 + 1); \n    constructSTUtil(arr, mid + 1, se, si * 2 + 2); \n \n    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2]; \n \n''' Function to construct segment tree \nfrom given array. This function allocates memory \nfor segment tree and calls constructSTUtil() \nto fill the allocated memory '''\ndef constructST(arr, n) : \n     \n    # Fill the allocated memory st \n    constructSTUtil(arr, 0, n - 1, 0); \n     \n# Driver Code\nif __name__ == '__main__' : \n \n    arr = [1, 3, 5, 7, 9, 11]; \n    n = len(arr); \n \n    # Build segment tree from given array \n    constructST(arr, n); \n \n    # Print sum of values in array from index 1 to 3 \n    print('Sum of values in given range =',\n                        getSum(n, 1, 3)); \n \n    # Add 10 to all nodes at indexes from 1 to 5. \n    updateRange(n, 1, 5, 10); \n \n    # Find sum after the value is updated \n    print('Updated sum of values in given range =',\n                                getSum( n, 1, 3)); \n \n# This code is contributed by AnkitRai01\n"], "Segment Tree | Range Minimum Query -  ": ["# Python3 program for range minimum  \n# query using segment tree  \nimport sys; \nfrom math import ceil,log2; \n  \nINT_MAX = sys.maxsize; \n  \n# A utility function to get  \n# minimum of two numbers  \ndef minVal(x, y) : \n    return x if (x < y) else y;  \n  \n# A utility function to get the  \n# middle index from corner indexes.  \ndef getMid(s, e) : \n    return s + (e - s) // 2;  \n  \n''' A recursive function to get the  \nminimum value in a given range  \nof array indexes. The following  \nare parameters for this function.  \n  \n    st --> Pointer to segment tree  \n    index --> Index of current node in the  \n        segment tree. Initially 0 is  \n        passed as root is always at index 0  \n    ss & se --> Starting and ending indexes  \n                of the segment represented  \n                by current node, i.e., st[index]  \n    qs & qe --> Starting and ending indexes of query range '''\ndef RMQUtil( st, ss, se, qs, qe, index) : \n  \n    # If segment of this node is a part  \n    # of given range, then return  \n    # the min of the segment  \n    if (qs <= ss and qe >= se) : \n        return st[index];  \n  \n    # If segment of this node  \n    # is outside the given range  \n    if (se < qs or ss > qe) : \n        return INT_MAX;  \n  \n    # If a part of this segment  \n    # overlaps with the given range  \n    mid = getMid(ss, se);  \n    return minVal(RMQUtil(st, ss, mid, qs,  \n                          qe, 2 * index + 1),  \n                  RMQUtil(st, mid + 1, se, \n                          qs, qe, 2 * index + 2));  \n  \n# Return minimum of elements in range  \n# from index qs (query start) to  \n# qe (query end). It mainly uses RMQUtil()  \ndef RMQ( st, n, qs, qe) :  \n  \n    # Check for erroneous input values  \n    if (qs < 0 or qe > n - 1 or qs > qe) : \n      \n        print('Invalid Input');  \n        return -1;  \n      \n    return RMQUtil(st, 0, n - 1, qs, qe, 0);  \n  \n# A recursive function that constructs  \n# Segment Tree for array[ss..se].  \n# si is index of current node in segment tree st  \ndef constructSTUtil(arr, ss, se, st, si) : \n  \n    # If there is one element in array,  \n    # store it in current node of  \n    # segment tree and return  \n    if (ss == se) : \n  \n        st[si] = arr[ss];  \n        return arr[ss];  \n  \n    # If there are more than one elements,  \n    # then recur for left and right subtrees  \n    # and store the minimum of two values in this node  \n    mid = getMid(ss, se);  \n    st[si] = minVal(constructSTUtil(arr, ss, mid, \n                                    st, si * 2 + 1), \n                    constructSTUtil(arr, mid + 1, se, \n                                    st, si * 2 + 2));  \n      \n    return st[si];  \n  \n'''Function to construct segment tree  \nfrom given array. This function allocates  \nmemory for segment tree and calls constructSTUtil() \nto fill the allocated memory '''\ndef constructST( arr, n) : \n  \n    # Allocate memory for segment tree  \n  \n    # Height of segment tree  \n    x = (int)(ceil(log2(n)));  \n  \n    # Maximum size of segment tree  \n    max_size = 2 * (int)(2**x) - 1;  \n   \n    st = [0] * (max_size);  \n  \n    # Fill the allocated memory st  \n    constructSTUtil(arr, 0, n - 1, st, 0);  \n  \n    # Return the constructed segment tree  \n    return st;  \n  \n# Driver Code \nif __name__ == '__main__' :  \n  \n    arr = [1, 3, 2, 7, 9, 11];  \n    n = len(arr);  \n  \n    # Build segment tree from given array  \n    st = constructST(arr, n);  \n  \n    qs = 1; # Starting index of query range  \n    qe = 5; # Ending index of query range  \n  \n    # Print minimum value in arr[qs..qe]  \n    print('Minimum of values in range [', qs,  \n          ',', qe, ']', 'is =', RMQ(st, n, qs, qe));  \n  \n# This code is contributed by AnkitRai01  \n"], "Segment Tree | Sum of given range -  ": ["# Python3 program to show segment tree operations like \n# construction, query and update \nfrom math import ceil, log2;\n \n# A utility function to get the\n# middle index from corner indexes. \ndef getMid(s, e) :\n    return s + (e -s) // 2; \n \n''' A recursive function to get the sum of values \n    in the given range of the array. The following \n    are parameters for this function. \n \n    st --> Pointer to segment tree \n    si --> Index of current node in the segment tree. \n           Initially 0 is passed as root is always at index 0 \n    ss & se --> Starting and ending indexes of the segment\n                represented by current node, i.e., st[si] \n    qs & qe --> Starting and ending indexes of query range '''\ndef getSumUtil(st, ss, se, qs, qe, si) : \n \n    # If segment of this node is a part of given range, \n    # then return the sum of the segment \n    if (qs <= ss and qe >= se) :\n        return st[si]; \n \n    # If segment of this node is\n    # outside the given range \n    if (se < qs or ss > qe) :\n        return 0; \n \n    # If a part of this segment overlaps \n    # with the given range \n    mid = getMid(ss, se); \n     \n    return (getSumUtil(st, ss, mid, qs, qe, 2 * si + 1) +\n           getSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2)); \n \n''' A recursive function to update the nodes \nwhich have the given index in their range. \nThe following are parameters st, si, ss and se \nare same as getSumUtil() \ni --> index of the element to be updated. \n      This index is in the input array. \ndiff --> Value to be added to all nodes \nwhich have i in range '''\ndef updateValueUtil(st, ss, se, i, diff, si) : \n \n    # Base Case: If the input index lies \n    # outside the range of this segment \n    if (i < ss or i > se) :\n        return; \n \n    # If the input index is in range of this node, \n    # then update the value of the node and its children \n    st[si] = st[si] + diff; \n     \n    if (se != ss) :\n     \n        mid = getMid(ss, se); \n        updateValueUtil(st, ss, mid, i, \n                        diff, 2 * si + 1); \n        updateValueUtil(st, mid + 1, se, i, \n                         diff, 2 * si + 2); \n \n# The function to update a value in input array \n# and segment tree. It uses updateValueUtil() \n# to update the value in segment tree \ndef updateValue(arr, st, n, i, new_val) : \n \n    # Check for erroneous input index \n    if (i < 0 or i > n - 1) :\n         \n        print('Invalid Input', end = ''); \n        return; \n \n    # Get the difference between \n    # new value and old value \n    diff = new_val - arr[i]; \n \n    # Update the value in array \n    arr[i] = new_val; \n \n    # Update the values of nodes in segment tree \n    updateValueUtil(st, 0, n - 1, i, diff, 0); \n \n# Return sum of elements in range from \n# index qs (query start) to qe (query end).\n# It mainly uses getSumUtil() \ndef getSum(st, n, qs, qe) : \n \n    # Check for erroneous input values \n    if (qs < 0 or qe > n - 1 or qs > qe) :\n \n        print('Invalid Input', end = ''); \n        return -1; \n     \n    return getSumUtil(st, 0, n - 1, qs, qe, 0); \n \n# A recursive function that constructs \n# Segment Tree for array[ss..se]. \n# si is index of current node in segment tree st \ndef constructSTUtil(arr, ss, se, st, si) : \n \n    # If there is one element in array, \n    # store it in current node of \n    # segment tree and return \n    if (ss == se) :\n     \n        st[si] = arr[ss]; \n        return arr[ss]; \n     \n    # If there are more than one elements, \n    # then recur for left and right subtrees \n    # and store the sum of values in this node \n    mid = getMid(ss, se); \n     \n    st[si] = (constructSTUtil(arr, ss, mid, st, si * 2 + 1) +\n             constructSTUtil(arr, mid + 1, se, st, si * 2 + 2)); \n     \n    return st[si]; \n \n''' Function to construct segment tree \nfrom given array. This function allocates memory\nfor segment tree and calls constructSTUtil() to \nfill the allocated memory '''\ndef constructST(arr, n) : \n \n    # Allocate memory for the segment tree \n \n    # Height of segment tree \n    x = (int)(ceil(log2(n))); \n \n    # Maximum size of segment tree \n    max_size = 2 * (int)(2**x) - 1;\n     \n    # Allocate memory\n    st = [0] * max_size; \n \n    # Fill the allocated memory st \n    constructSTUtil(arr, 0, n - 1, st, 0); \n \n    # Return the constructed segment tree \n    return st; \n \n# Driver Code\nif __name__ == '__main__' : \n \n    arr = [1, 3, 5, 7, 9, 11]; \n    n = len(arr); \n \n    # Build segment tree from given array \n    st = constructST(arr, n); \n \n    # Print sum of values in array from index 1 to 3 \n    print('Sum of values in given range = ',\n                       getSum(st, n, 1, 3)); \n \n    # Update: set arr[1] = 10 and update \n    # corresponding segment tree nodes \n    updateValue(arr, st, n, 1, 10); \n \n    # Find sum after the value is updated \n    print('Updated sum of values in given range = ',\n                     getSum(st, n, 1, 3), end = ''); \n     \n# This code is contributed by AnkitRai01\n", "class SegmentTree:\n    def __init__(self, array):\n        self.size = len(array)\n        self.tree = [0] * (4 * self.size)\n        self.build_tree(array, 0, 0, self.size - 1)\n \n    def build_tree(self, array, tree_index, left, right):\n        if left == right:\n            self.tree[tree_index] = array[left]\n            return\n        mid = (left + right) // 2\n        self.build_tree(array, 2 * tree_index + 1, left, mid)\n        self.build_tree(array, 2 * tree_index + 2, mid + 1, right)\n        self.tree[tree_index] = min(self.tree[2 * tree_index + 1], self.tree[2 * tree_index + 2])\n \n    def query(self, tree_index, left, right, query_left, query_right):\n        if query_left <= left and right <= query_right:\n            return self.tree[tree_index]\n        mid = (left + right) // 2\n        min_value = float('inf')\n        if query_left <= mid:\n            min_value = min(min_value, self.query(2 * tree_index + 1, left, mid, query_left, query_right))\n        if query_right > mid:\n            min_value = min(min_value, self.query(2 * tree_index + 2, mid + 1, right, query_left, query_right))\n        return min_value\n \n    def query_range(self, left, right):\n        return self.query(0, 0, self.size - 1, left, right)\n \n \nif __name__ == '__main__':\n    array = [1, 3, 2, 5, 4, 6]\n    st = SegmentTree(array)\n    print(st.query_range(1, 5)) # 2\n"], "Counting Triangles in a Rectangular space using BIT -  ": ["# A Python3 program implementing\n# the above queries\nmaxn = 2005\n \n# 2D Binary Indexed Tree.\n# Note: global variable\n# will have initially all \n# elements zero\nbit = [[0 for j in range(maxn)] \n          for i in range(maxn)]\n \n# function to add a point \n# at(x, y)\ndef update(x, y):\n \n    y1 = 0\n    while (x < maxn):\n     \n        # x is the xth BIT that will \n        # be updated while y is the \n        # indices where an update\n        # will be made in xth BIT\n        y1 = y\n         \n        while (y1 < maxn):        \n            bit[x][y1] += 1\n            y1 += (y1 & -y1)\n \n        # next BIT that should \n        # be updated\n        x += x & -x\n \n# Function to return number of \n# points in the rectangle(1, 1),\n# (x, y)\ndef query(x, y):\n \n    res = 0\n    y1 = 0\n     \n    while (x > 0):\n     \n        # xth BIT's yth node must \n        # be added to the result\n        y1 = y\n         \n        while (y1 > 0):        \n            res += bit[x][y1]\n            y1 -= y1 & -y1        \n \n        # next BIT that will contribute \n        # to the result\n        x -= x & -x\n     \n    return res\n \n# (x1, y1) is the lower left \n# and (x2, y2) is the upper \n# right corner of the rectangle\ndef pointsInRectangle(x1, y1, \n                      x2, y2):\n \n    # Returns number of points \n    # in the rectangle (x1, y1), \n    # (x2, y2) as described in \n    # text above\n    return (query(x2, y2) - query(x1 - 1, y2) -\n            query(x2, y1 - 1) + query(x1 - 1, y1 - 1))\n \n# Returns count of triangles with \n# n points, i.e., it returns nC3\ndef findTriangles(n):\n \n    # returns pts choose 3\n    return ((n * (n - 1) *\n            (n - 2)) // 6)\n \n# Driver code\nif __name__ == '__main__':\n \n    # inserting points\n    update(2, 2)\n    update(3, 5)\n    update(4, 2)\n    update(4, 5)\n    update(5, 4)\n \n    print('No. of triangles in the ' +\n          'rectangle (1, 1)  (6, 6) are: ',\n           findTriangles(pointsInRectangle(1, 1, \n                                           6, 6)))\n    update(3, 3)\n    print('No. of triangles in the rectangle ' +\n          '(1, 1) (6, 6) are:', findTriangles(\n            pointsInRectangle(1, 1, 6, 6)))\n \n# This code is contributed by Rutvik_56\n"], "Two Dimensional Binary Indexed Tree or Fenwick Tree -  ": ["'''Python3  program to implement 2D Binary Indexed Tree \n   \n2D BIT is basically a BIT where each element is another BIT. \nUpdating by adding v on (x, y) means it's effect will be found \nthroughout the rectangle [(x, y), (max_x, max_y)], \nand query for (x, y) gives you the result of the rectangle \n[(0, 0), (x, y)], assuming the total rectangle is \n[(0, 0), (max_x, max_y)]. So when you query and update on \nthis BIT,you have to be careful about how many times you are \nsubtracting a rectangle and adding it. Simple set union formula \nworks here. \n   \nSo if you want to get the result of a specific rectangle \n[(x1, y1), (x2, y2)], the following steps are necessary: \n   \nQuery(x1,y1,x2,y2) = getSum(x2, y2)-getSum(x2, y1-1) - \n                    getSum(x1-1, y2)+getSum(x1-1, y1-1) \n   \nHere 'Query(x1,y1,x2,y2)' means the sum of elements enclosed \nin the rectangle with bottom-left corner's co-ordinates \n(x1, y1) and top-right corner's co-ordinates - (x2, y2) \n   \nConstraints -> x1<=x2 and y1<=y2 \n   \n    /\\ \ny | \n    |     --------(x2,y2) \n    |     | | \n    |     | | \n    |     | | \n    |     --------- \n    | (x1,y1) \n    | \n    |___________________________ \n(0, 0)             x--> \n   \nIn this program we have assumed a square matrix. The \nprogram can be easily extended to a rectangular one. '''\n \nN = 4 # N-.max_x and max_y \n \n# A structure to hold the queries \nclass Query:\n \n    def __init__(self, x1,y1,x2,y2):\n     \n        self.x1 = x1;\n        self.y1 = y1;\n        self.x2 = x2;\n        self.y2 = y2;\n \n \n# A function to update the 2D BIT \ndef updateBIT(BIT,x,y,val):\n     \n    while x <= N:\n     \n        # This loop update all the 1D BIT inside the \n        # array of 1D BIT = BIT[x] \n        while y <= N:\n            BIT[x][y] += val;\n            y += (y & -y)\n         \n        x += (x & -x)\n     \n    return; \n \n \n# A function to get sum from (0, 0) to (x, y) \ndef getSum(BIT,x,y):\n \n    sum = 0; \n     \n    while x > 0:\n        # This loop sum through all the 1D BIT \n        # inside the array of 1D BIT = BIT[x] \n        while y > 0:\n \n            sum += BIT[x][y]; \n            y -= y&-y\n         \n        x -= x&-x\n     \n    return sum; \n \n \n# A function to create an auxiliary matrix \n# from the given input matrix \ndef constructAux(mat,aux):\n    # Initialise Auxiliary array to 0 \n    for  i in range(N + 1):\n        for j in range(N + 1):\n            aux[i][j] = 0\n   \n    # Construct the Auxiliary Matrix \n    for j in range(1, N + 1):\n        for i in range(1, N + 1):\n            aux[i][j] = mat[N - j][i - 1];\n   \n    return\n \n \n# A function to construct a 2D BIT \ndef construct2DBIT(mat,BIT):\n    # Create an auxiliary matrix \n    aux = [None for i in range(N + 1)]\n    for i in range(N + 1) : \n     \n        aux[i]= [None for i in range(N + 1)]\n     \n    constructAux(mat, aux)\n   \n    # Initialise the BIT to 0 \n    for i in range(1, N + 1): \n        for j in range(1, N + 1): \n            BIT[i][j] = 0; \n   \n    for j in range(1, N + 1): \n     \n        for i in range(1, N + 1): \n         \n            # Creating a 2D-BIT using update function \n            # everytime we/ encounter a value in the \n            # input 2D-array \n            v1 = getSum(BIT, i, j); \n            v2 = getSum(BIT, i, j - 1); \n            v3 = getSum(BIT, i - 1, j - 1); \n            v4 = getSum(BIT, i - 1, j); \n   \n            # Assigning a value to a particular element \n            # of 2D BIT \n            updateBIT(BIT, i, j, aux[i][j] -\n                     (v1 - v2 - v4 + v3)); \n         \n     \n    return; \n \n \n# A function to answer the queries \ndef answerQueries(q,m,BIT):\n     \n    for i in range(m):\n      \n        x1 = q[i].x1 + 1; \n        y1 = q[i].y1 + 1; \n        x2 = q[i].x2 + 1; \n        y2 = q[i].y2 + 1; \n   \n        ans = getSum(BIT, x2, y2) - \\\n                  getSum(BIT, x2, y1 - 1) - \\\n                  getSum(BIT, x1 - 1, y2) + \\\n                  getSum(BIT, x1 - 1, y1 - 1); \n   \n        print('Query (', q[i].x1, ', ', q[i].y1, ', ', q[i].x2, ', ' , q[i].y2, ') = ' ,ans, sep = '') \n     \n    return; \n \n \n# Driver Code\nmat= [[1, 2, 3, 4], \n                    [5, 3, 8, 1], \n                    [4, 6, 7, 5], \n                    [2, 4, 8, 9]]; \n   \n# Create a 2D Binary Indexed Tree \nBIT = [None for i in range(N + 1)]\nfor i in range(N + 1):\n \n    BIT[i]= [None for i in range(N + 1)]\n    for j in range(N + 1):\n            BIT[i][j]=0\n         \n     \nconstruct2DBIT(mat, BIT); \n   \n''' Queries of the form - x1, y1, x2, y2 \n    For example the query- {1, 1, 3, 2} means the sub-matrix- \n        y \n        /\\ \n    3 | 1 2 3 4     Sub-matrix \n    2 | 5 3 8 1     {1,1,3,2} --.     3 8 1 \n    1 | 4 6 7 5                                 6 7 5 \n    0 | 2 4 8 9 \n        | \n    --|------ 0 1 2 3 ---. x \n        | \n       \n        Hence sum of the sub-matrix = 3+8+1+6+7+5 = 30 \n     \n    '''\nq = [Query(1, 1, 3, 2), Query(2, 3, 3, 3), Query(1, 1, 1, 1)]; \nm = len(q)\n   \nanswerQueries(q, m, BIT); \n \n# This code is contributed by phasing17\n"], "Inversion count in Array using BIT -  ": ["# Python3 program to count inversions using  \n# Binary Indexed Tree  \n  \n# Returns sum of arr[0..index]. This function \n# assumes that the array is preprocessed and  \n# partial sums of array elements are stored  \n# in BITree[].  \ndef getSum( BITree, index): \n    sum = 0 # Initialize result  \n      \n    # Traverse ancestors of BITree[index]  \n    while (index > 0):  \n  \n        # Add current element of BITree to sum  \n        sum += BITree[index]  \n  \n        # Move index to parent node in getSum View  \n        index -= index & (-index)  \n  \n    return sum\n  \n# Updates a node in Binary Index Tree (BITree)  \n# at given index in BITree. The given value \n# 'val' is added to BITree[i] and all of its \n# ancestors in tree.  \ndef updateBIT(BITree, n, index, val): \n  \n    # Traverse all ancestors and add 'val'  \n    while (index <= n):  \n  \n        # Add 'val' to current node of BI Tree  \n        BITree[index] += val  \n  \n        # Update index to that of parent \n        # in update View  \n        index += index & (-index)  \n  \n# Returns count of inversions of size three  \ndef getInvCount(arr, n): \n  \n    invcount = 0 # Initialize result  \n  \n    # Find maximum element in arrays  \n    maxElement = max(arr) \n  \n    # Create a BIT with size equal to  \n    # maxElement+1 (Extra one is used  \n    # so that elements can be directly  \n    # be used as index) \n    BIT = [0] * (maxElement + 1)  \n    for i in range(n - 1, -1, -1): \n  \n        invcount += getSum(BIT, arr[i] - 1)  \n        updateBIT(BIT, maxElement, arr[i], 1)  \n    return invcount  \n      \n# Driver code  \nif __name__ =='__main__': \n    arr = [8, 4, 2, 1]  \n    n = 4\n    print('Inversion Count : ',  \n           getInvCount(arr, n)) \n      \n# This code is contributed by \n# Shubham Singh(SHUBHAMSINGH10) \n", "# Python3 program to count inversions using Binary Indexed Tree \nfrom bisect import bisect_left as lower_bound \n  \n# Returns sum of arr[0..index]. This function assumes \n# that the array is preprocessed and partial sums of \n# array elements are stored in BITree. \ndef getSum(BITree, index): \n  \n    sum = 0 # Initialize result \n  \n    # Traverse ancestors of BITree[index] \n    while (index > 0): \n  \n        # Add current element of BITree to sum \n        sum += BITree[index] \n  \n        # Move index to parent node in getSum View \n        index -= index & (-index) \n  \n    return sum\n  \n# Updates a node in Binary Index Tree (BITree) at given index \n# in BITree. The given value 'val' is added to BITree[i] and \n# all of its ancestors in tree. \ndef updateBIT(BITree, n, index, val): \n  \n    # Traverse all ancestors and add 'val' \n    while (index <= n): \n  \n        # Add 'val' to current node of BI Tree \n        BITree[index] += val \n  \n    # Update index to that of parent in update View \n    index += index & (-index) \n  \n# Converts an array to an array with values from 1 to n \n# and relative order of smaller and greater elements remains \n# same. For example, 7, -90, 100, 1 is converted to \n# 3, 1, 4 ,2 \ndef convert(arr, n): \n  \n    # Create a copy of arrp in temp and sort the temp array \n    # in increasing order \n    temp = [0]*(n) \n    for i in range(n): \n        temp[i] = arr[i] \n    temp = sorted(temp) \n  \n    # Traverse all array elements \n    for i in range(n): \n  \n        # lower_bound() Returns pointer to the first element \n        # greater than or equal to arr[i] \n        arr[i] = lower_bound(temp, arr[i]) + 1\n  \n# Returns inversion count arr[0..n-1] \ndef getInvCount(arr, n): \n  \n    invcount = 0 # Initialize result \n  \n    # Convert arr to an array with values from 1 to n and \n    # relative order of smaller and greater elements remains \n    # same. For example, 7, -90, 100, 1 is converted to \n    # 3, 1, 4 ,2 \n    convert(arr, n) \n  \n    # Create a BIT with size equal to maxElement+1 (Extra \n    # one is used so that elements can be directly be \n    # used as index) \n    BIT = [0] * (n + 1) \n  \n    # Traverse all elements from right. \n    for i in range(n - 1, -1, -1): \n  \n        # Get count of elements smaller than arr[i] \n        invcount += getSum(BIT, arr[i] - 1) \n  \n        # Add current element to BIT \n        updateBIT(BIT, n, arr[i], 1) \n  \n    return invcount \n  \n# Driver program \nif __name__ == '__main__': \n  \n    arr = [8, 4, 2, 1] \n    n = len(arr) \n    print('Number of inversions are : ',getInvCount(arr, n)) \n  \n# This code is contributed by mohit kumar 29 \n"], "Binary Indexed Tree or Fenwick Tree -  ": ["# Python implementation of Binary Indexed Tree \n  \n# Returns sum of arr[0..index]. This function assumes \n# that the array is preprocessed and partial sums of \n# array elements are stored in BITree[]. \ndef getsum(BITTree,i): \n    s = 0 #initialize result \n  \n    # index in BITree[] is 1 more than the index in arr[] \n    i = i+1\n  \n    # Traverse ancestors of BITree[index] \n    while i > 0: \n  \n        # Add current element of BITree to sum \n        s += BITTree[i] \n  \n        # Move index to parent node in getSum View \n        i -= i & (-i) \n    return s \n  \n# Updates a node in Binary Index Tree (BITree) at given index \n# in BITree. The given value 'val' is added to BITree[i] and \n# all of its ancestors in tree. \ndef updatebit(BITTree , n , i ,v): \n  \n    # index in BITree[] is 1 more than the index in arr[] \n    i += 1\n  \n    # Traverse all ancestors and add 'val' \n    while i <= n: \n  \n        # Add 'val' to current node of BI Tree \n        BITTree[i] += v \n  \n        # Update index to that of parent in update View \n        i += i & (-i) \n  \n  \n# Constructs and returns a Binary Indexed Tree for given \n# array of size n. \ndef construct(arr, n): \n  \n    # Create and initialize BITree[] as 0 \n    BITTree = [0]*(n+1) \n  \n    # Store the actual values in BITree[] using update() \n    for i in range(n): \n        updatebit(BITTree, n, i, arr[i]) \n  \n    # Uncomment below lines to see contents of BITree[] \n    #for i in range(1,n+1): \n    #     print BITTree[i], \n    return BITTree \n  \n  \n# Driver code to test above methods \nfreq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9] \nBITTree = construct(freq,len(freq)) \nprint('Sum of elements in arr[0..5] is ' + str(getsum(BITTree,5))) \nfreq[3] += 6\nupdatebit(BITTree, len(freq), 3, 6) \nprint('Sum of elements in arr[0..5]'+\n                    ' after update is ' + str(getsum(BITTree,5))) \n  \n# This code is contributed by Raju Varshney \n"], "Trie | (Display Content) -  ": ["##Display words in a trie (recursive approach)\nclass TrieNode:\n    def __init__(self):\n        self.children=[None]*26\n        self.isEndOfWord=False\n         \nclass Trie:\n    def __init__(self):\n        self.root=self.getNode()\n         \n    def getNode(self):\n        return TrieNode()\n     \n    def _charToIndex(self,ch):\n        return ord(ch)-ord('a')\n     \n    def search(self,key):\n        pCrawl=self.root\n        length=len(key)\n        for level in range(length):\n            index=self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return False\n            pCrawl=pCrawl.children[index]\n             \n        return pCrawl.isEndOfWord\n     \n    def insert(self,key):\n        pCrawl=self.root\n        length=len(key)\n        for level in range(length):\n            index=self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                pCrawl.children[index]=self.getNode()\n                 \n            pCrawl=pCrawl.children[index]\n             \n        pCrawl.isEndOfWord=True\n         \n    def delete(self,key):\n        queue=[]\n        pCrawl=self.root\n        prev=self.root\n        length=len(key)\n        for level in range(length):\n            index=self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return\n            if pCrawl.isEndOfWord:\n                queue.append([pCrawl,level])\n                 \n            pCrawl=pCrawl.children[index]\n             \n        if pCrawl.isEndOfWord == False:\n            return\n        ##If is a prefix of another tree, just change leaf\n        flag=False\n        for i in range(26):\n            if pCrawl.children[index]:\n                flag=True\n        if flag:\n            pCrawl.isEndOfWord==False\n            return\n        ##If not a prefix but a tree longer than others, delete until isEndOfWord == True again/reach root(a unique trie)\n        if len(queue)==0:\n            index=self._charToIndex(key[0])\n            self.root.children[index]=None\n            return\n        pCrawl,level=queue.pop()\n        index=self._charToIndex(key[level])\n        pCrawl.children[index]=None\n         \n    def haschild(self,node):\n        for i in range(26):\n            if node.children[i]:\n                return True\n        return False\n     \n    def displayUtil(self,visited,node,str):\n        index=0\n        while index<26:\n            if node.children[index]:\n                str+=chr(97+index)\n                #print(2,str)\n                if node.children[index].isEndOfWord == False:\n                    self.displayUtil(visited,node.children[index],str)\n                    str=str[0 : (len(str)-1)]\n                else:\n                    if str not in visited:\n                        visited.append(str)\n                    if self.haschild(node.children[index]):\n                        self.displayUtil(visited,node.children[index],str)\n                        str=str[0 : (len(str)-1)]\n                     \n            index+=1\n     \n    def display(self):\n        visited=[]\n        str=''\n        self.displayUtil(visited,self.root,str)\n        print('Content of Trie:')\n        for i in range(len(visited)):\n            print(visited[i])\n         \n                       \nkeys = ['the','a','there','bye','any',\n            'by','their','answer']\noutput = ['Not present in trie','Present in trie']\nt=Trie()\nfor key in keys:\n    t.insert(key)\n \nt.display()\n \n#This code is contributed by Zhaoxin Ban\n"], "Trie | (Delete) -  ": ["class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\n \ndef getNode():\n    pNode = TrieNode()\n    pNode.isEndOfWord = False\n    return pNode\n \ndef insert(root, key):\n    pCrawl = root\n    for i in range(len(key)):\n        index = ord(key[i]) - ord('a')\n        if not pCrawl.children[index]:\n            pCrawl.children[index] = getNode()\n        pCrawl = pCrawl.children[index]\n    pCrawl.isEndOfWord = True\n \ndef search(root, key):\n    pCrawl = root\n    for i in range(len(key)):\n        index = ord(key[i]) - ord('a')\n        if not pCrawl.children[index]:\n            return False\n        pCrawl = pCrawl.children[index]\n    return pCrawl and pCrawl.isEndOfWord\n \ndef isEmpty(root):\n    for i in range(26):\n        if root.children[i]:\n            return False\n    return True\n \ndef remove(root, key, depth = 0):\n    if not root:\n        return None\n \n    if depth == len(key):\n        if root.isEndOfWord:\n            root.isEndOfWord = False\n        if isEmpty(root):\n            del root\n            root = None\n        return root\n \n    index = ord(key[depth]) - ord('a')\n    root.children[index] = remove(root.children[index], key, depth + 1)\n \n    if isEmpty(root) and not root.isEndOfWord:\n        del root\n        root = None\n    return root\n \nif __name__ == '__main__':\n    keys = ['the', 'a', 'there', 'answer', 'any', 'by', 'bye', 'their', 'hero', 'heroplane']\n    root = getNode()\n    for i in range(len(keys)):\n        insert(root, keys[i])\n    if search(root, 'the'):\n        print('Yes')\n    else:\n        print('No')\n    if search(root, 'these'):\n        print('Yes')\n    else:\n        print('No')\n    root = remove(root, 'heroplane')\n    if search(root, 'hero'):\n        print('Yes')\n    else:\n        print('No')\n"], "Trie | (Insert and Search) -  ": ["# Python3 code \n \nclass TrieNode:\n     \n    # Trie node class\n    def __init__(self):\n        self.children = [None for _ in range(26)]\n \n        # isEndOfWord is True if node represent the end of the word\n        self.isEndOfWord = False\n", "# Python program for insert and search\n# operation in a Trie\n \nclass TrieNode:\n     \n    # Trie node class\n    def __init__(self):\n        self.children = [None]*26\n \n        # isEndOfWord is True if node represent the end of the word\n        self.isEndOfWord = False\n \nclass Trie:\n     \n    # Trie data structure class\n    def __init__(self):\n        self.root = self.getNode()\n \n    def getNode(self):\n     \n        # Returns new trie node (initialized to NULLs)\n        return TrieNode()\n \n    def _charToIndex(self,ch):\n         \n        # private helper function\n        # Converts key current character into index\n        # use only 'a' through 'z' and lower case\n         \n        return ord(ch)-ord('a')\n \n \n    def insert(self,key):\n         \n        # If not present, inserts key into trie\n        # If the key is prefix of trie node, \n        # just marks leaf node\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n \n            # if current character is not present\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n \n        # mark last node as leaf\n        pCrawl.isEndOfWord = True\n \n    def search(self, key):\n         \n        # Search key in the trie\n        # Returns true if key presents \n        # in trie, else false\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                return False\n            pCrawl = pCrawl.children[index]\n \n        return pCrawl.isEndOfWord\n \n# driver function\ndef main():\n \n    # Input keys (use only 'a' through 'z' and lower case)\n    keys = ['the','a','there','anaswe','any',\n            'by','their']\n    output = ['Not present in trie',\n              'Present in trie']\n \n    # Trie object\n    t = Trie()\n \n    # Construct trie\n    for key in keys:\n        t.insert(key)\n \n    # Search for different keys\n    print('{} ---- {}'.format('the',output[t.search('the')]))\n    print('{} ---- {}'.format('these',output[t.search('these')]))\n    print('{} ---- {}'.format('their',output[t.search('their')]))\n    print('{} ---- {}'.format('thaw',output[t.search('thaw')]))\n \nif __name__ == '__main__':\n    main()\n \n# This code is contributed by Atul Kumar (www.facebook.com/atul.kr.007)\n"], "Optimal Strategy for a Game | DP-31 -  ": ["# Python3 code to implement the approach \n  \ndef optimalStrategyOfGame(arr, n): \n    memo = {} \n  \n    # recursive top down memoized solution \n    def solve(i, j): \n        if i > j or i >= n or j < 0: \n            return 0\n  \n        k = (i, j) \n        if k in memo: \n            return memo[k] \n  \n        # if the user chooses ith coin, the opponent can choose from i+1th or jth coin. \n        # if he chooses i+1th coin, user is left with [i+2,j] range. \n        # if opp chooses jth coin, then user is left with [i+1,j-1] range to choose from. \n        # Also opponent tries to choose \n        # in such a way that the user has minimum value left. \n        option1 = arr[i] + min(solve(i+2, j), solve(i+1, j-1)) \n  \n        # if user chooses jth coin, opponent can choose ith coin or j-1th coin. \n        # if opp chooses ith coin,user can choose in range [i+1,j-1]. \n        # if opp chooses j-1th coin, user can choose in range [i,j-2]. \n        option2 = arr[j] + min(solve(i+1, j-1), solve(i, j-2)) \n  \n        # since the user wants to get maximum money \n        memo[k] = max(option1, option2) \n        return memo[k] \n  \n    return solve(0, n-1) \n  \n    \n# Driver Code \narr1 = [8, 15, 3, 7] \nn = len(arr1) \nprint(optimalStrategyOfGame(arr1, n)) \n  \narr2 = [2, 2, 2, 2] \nn = len(arr2) \nprint(optimalStrategyOfGame(arr2, n)) \n  \narr3 = [20, 30, 2, 2, 2, 10] \nn = len(arr3) \nprint(optimalStrategyOfGame(arr3, n)) \n  \n# This code is contributed \n# by sahilshelangia\n", "# Python3 program to find out maximum \n# value from a given sequence of coins \n  \n# Returns optimal value possible that \n# a player can collect from an array \n# of coins of size n. Note than n \n# must be even \n  \n  \ndef optimalStrategyOfGame(arr, n): \n  \n    # Create a table to store \n    # solutions of subproblems \n    table = [[0 for i in range(n)] \n             for i in range(n)] \n  \n    # Fill table using above recursive \n    # formula. Note that the table is \n    # filled in diagonal fashion \n    # (similar to http://goo.gl / PQqoS), \n    # from diagonal elements to \n    # table[0][n-1] which is the result. \n    for gap in range(n): \n        for j in range(gap, n): \n            i = j - gap \n  \n            # Here x is value of F(i + 2, j), \n            # y is F(i + 1, j-1) and z is \n            # F(i, j-2) in above recursive \n            # formula \n            x = 0\n            if((i + 2) <= j): \n                x = table[i + 2][j] \n            y = 0\n            if((i + 1) <= (j - 1)): \n                y = table[i + 1][j - 1] \n            z = 0\n            if(i <= (j - 2)): \n                z = table[i][j - 2] \n            table[i][j] = max(arr[i] + min(x, y), \n                              arr[j] + min(y, z)) \n    return table[0][n - 1] \n  \n  \n# Driver Code \narr1 = [8, 15, 3, 7] \nn = len(arr1) \nprint(optimalStrategyOfGame(arr1, n)) \n  \narr2 = [2, 2, 2, 2] \nn = len(arr2) \nprint(optimalStrategyOfGame(arr2, n)) \n  \narr3 = [20, 30, 2, 2, 2, 10] \nn = len(arr3) \nprint(optimalStrategyOfGame(arr3, n)) \n  \n# This code is contributed \n# by sahilshelangia \n"], "Find the winner in nim-game -  ": ["# Python3 program to find nim-game winner\n \n# Function to find winner of NIM-game\ndef findWinner(A, n):\n \n    res = 0\n    for i in range(n):\n        res ^= A[i]\n \n    # case when Alice is winner\n    if (res == 0 or n % 2 == 0):\n        return 'Alice'\n \n    # when Bob is winner\n    else:\n        return 'Bob'\n \n# Driver code\nA = [ 1, 4, 3, 5 ]\nn = len(A)\nprint('Winner = ', findWinner(A, n))\n \n# This code is contributed by Anant Agarwal.\n"], "Variation in Nim Game -  ": ["# Python3 program for the  \n# variation in nim game \n  \n# Function to return final \n# grundy Number(G) of game \ndef solve(p, n): \n    G = 0\n    for i in range(n): \n  \n        # if pile size is odd  \n        if (p[i] % 2 != 0):  \n              \n            # We XOR pile size+1 \n            G ^= (p[i] + 1)  \n          \n        # if pile size is even \n        else:  \n  \n            # We XOR pile size-1 \n            G ^= (p[i] - 1)  \n      \n    return G \n  \n# Driver code \n  \n# Game with 3 piles \nn = 3\n  \n# pile with different sizes \np = [32, 49, 58] \n  \n# Function to return result of game \nres = solve(p, n) \n  \nif (res == 0): # if G is zero \n    print('Player 2 wins') \n      \nelse: # if G is non zero \n    print('Player 1 wins') \n      \n# This code is contributed by Anant Agarwal. \n"], "Minimax Algorithm in Game Theory | Set 5 (Zobrist Hashing) -  ": ["# A program to illustrate Zobrist Hashing Algorithm\n# python code implementation\nimport random\n \n# mt19937 mt(01234567);\n  \n# Generates a Random number from 0 to 2^64-1\ndef randomInt():\n    min = 0\n    max = pow(2, 64)\n    return random.randint(min, max)\n  \n# This function associates each piece with\n# a number\ndef indexOf(piece):\n    if (piece=='P'):\n        return 0\n    elif (piece=='N'):\n        return 1\n    elif (piece=='B'):\n        return 2\n    elif (piece=='R'):\n        return 3\n    elif (piece=='Q'):\n        return 4\n    elif (piece=='K'):\n        return 5\n    elif (piece=='p'):\n        return 6\n    elif (piece=='n'):\n        return 7\n    elif (piece=='b'):\n        return 8\n    elif (piece=='r'):\n        return 9\n    elif (piece=='q'):\n        return 10\n    elif (piece=='k'):\n        return 11\n    else:\n        return -1\n  \n# Initializes the table\ndef initTable():\n    # 8x8x12 array\n    ZobristTable = [[[randomInt() for k in range(12)] for j in range(8)] for i in range(8)]\n    return ZobristTable\n  \n# Computes the hash value of a given board\ndef computeHash(board, ZobristTable):\n    h = 0\n    for i in range(8):\n        for j in range(8):\n            if (board[i][j] != '-'):\n                piece = indexOf(board[i][j])\n                h ^= ZobristTable[i][j][piece]\n    return h\n  \n# Main Function\n# Uppercase letters are white pieces\n# Lowercase letters are black pieces\nboard = [\n    '---K----',\n    '-R----Q-',\n    '--------',\n    '-P----p-',\n    '-----p--',\n    '--------',\n    'p---b--q',\n    '----n--k'\n]\n \nZobristTable = initTable()\n \nhashValue = computeHash(board, ZobristTable)\nprint('The hash value is     : ' + str(hashValue))\n \n#Move the white king to the left\npiece = board[0][3]\n \nboard[0] = list(board[0])\nboard[0][3] = '-'\nboard[0] = ''.join(board[0])\n \nhashValue ^= ZobristTable[0][3][indexOf(piece)]\n \nboard[0] = list(board[0])\nboard[0][2] = piece\nboard[0] = ''.join(board[0])\nhashValue ^= ZobristTable[0][2][indexOf(piece)]\n \n \nprint('The new hash value is : ' + str(hashValue))\n \n# Undo the white king move\npiece = board[0][2]\n \nboard[0] = list(board[0])\nboard[0][2] = '-'\nboard[0] = ''.join(board[0])\n \nhashValue ^= ZobristTable[0][2][indexOf(piece)]\n \nboard[0] = list(board[0])\nboard[0][3] = piece\nboard[0] = ''.join(board[0])\nhashValue ^= ZobristTable[0][3][indexOf(piece)]\n \nprint('The old hash value is : ' + str(hashValue))\n"], "Minimax Algorithm in Game Theory | Set 4 (Alpha-Beta Pruning) -  ": ["# Python3 program to demonstrate \n# working of Alpha-Beta Pruning \n \n# Initial values of Alpha and Beta \nMAX, MIN = 1000, -1000\n \n# Returns optimal value for current player \n#(Initially called for root and maximizer) \ndef minimax(depth, nodeIndex, maximizingPlayer, \n            values, alpha, beta): \n  \n    # Terminating condition. i.e \n    # leaf node is reached \n    if depth == 3: \n        return values[nodeIndex] \n \n    if maximizingPlayer: \n      \n        best = MIN\n \n        # Recur for left and right children \n        for i in range(0, 2): \n             \n            val = minimax(depth + 1, nodeIndex * 2 + i, \n                          False, values, alpha, beta) \n            best = max(best, val) \n            alpha = max(alpha, best) \n \n            # Alpha Beta Pruning \n            if beta <= alpha: \n                break\n          \n        return best \n      \n    else:\n        best = MAX\n \n        # Recur for left and \n        # right children \n        for i in range(0, 2): \n          \n            val = minimax(depth + 1, nodeIndex * 2 + i, \n                            True, values, alpha, beta) \n            best = min(best, val) \n            beta = min(beta, best) \n \n            # Alpha Beta Pruning \n            if beta <= alpha: \n                break\n          \n        return best \n      \n# Driver Code \nif __name__ == '__main__': \n  \n    values = [3, 5, 6, 9, 1, 2, 0, -1]  \n    print('The optimal value is :', minimax(0, 0, True, values, MIN, MAX)) \n     \n# This code is contributed by Rituraj Jain\n"], "Finding optimal move in Tic-Tac-Toe using Minimax Algorithm in Game Theory -  ": ["# Python3 program to find the next optimal move for a player  \nplayer, opponent = 'x', 'o' \n  \n# This function returns true if there are moves  \n# remaining on the board. It returns false if  \n# there are no moves left to play.  \ndef isMovesLeft(board) :  \n  \n    for i in range(3) : \n        for j in range(3) : \n            if (board[i][j] == '_') : \n                return True \n    return False\n  \n# This is the evaluation function as discussed  \n# in the previous article ( http://goo.gl/sJgv68 )  \ndef evaluate(b) :  \n    \n    # Checking for Rows for X or O victory.  \n    for row in range(3) :      \n        if (b[row][0] == b[row][1] and b[row][1] == b[row][2]) :         \n            if (b[row][0] == player) : \n                return 10\n            elif (b[row][0] == opponent) : \n                return -10\n  \n    # Checking for Columns for X or O victory.  \n    for col in range(3) : \n       \n        if (b[0][col] == b[1][col] and b[1][col] == b[2][col]) : \n          \n            if (b[0][col] == player) :  \n                return 10\n            elif (b[0][col] == opponent) : \n                return -10\n  \n    # Checking for Diagonals for X or O victory.  \n    if (b[0][0] == b[1][1] and b[1][1] == b[2][2]) : \n      \n        if (b[0][0] == player) : \n            return 10\n        elif (b[0][0] == opponent) : \n            return -10\n  \n    if (b[0][2] == b[1][1] and b[1][1] == b[2][0]) : \n      \n        if (b[0][2] == player) : \n            return 10\n        elif (b[0][2] == opponent) : \n            return -10\n  \n    # Else if none of them have won then return 0  \n    return 0\n  \n# This is the minimax function. It considers all  \n# the possible ways the game can go and returns  \n# the value of the board  \ndef minimax(board, depth, isMax) :  \n    score = evaluate(board) \n  \n    # If Maximizer has won the game return his/her  \n    # evaluated score  \n    if (score == 10) :  \n        return score \n  \n    # If Minimizer has won the game return his/her  \n    # evaluated score  \n    if (score == -10) : \n        return score \n  \n    # If there are no more moves and no winner then  \n    # it is a tie  \n    if (isMovesLeft(board) == False) : \n        return 0\n  \n    # If this maximizer's move  \n    if (isMax) :      \n        best = -1000 \n  \n        # Traverse all cells  \n        for i in range(3) :          \n            for j in range(3) : \n               \n                # Check if cell is empty  \n                if (board[i][j]=='_') : \n                  \n                    # Make the move  \n                    board[i][j] = player  \n  \n                    # Call minimax recursively and choose  \n                    # the maximum value  \n                    best = max( best, minimax(board, \n                                              depth + 1, \n                                              not isMax) ) \n  \n                    # Undo the move  \n                    board[i][j] = '_'\n        return best \n  \n    # If this minimizer's move  \n    else : \n        best = 1000 \n  \n        # Traverse all cells  \n        for i in range(3) :          \n            for j in range(3) : \n               \n                # Check if cell is empty  \n                if (board[i][j] == '_') : \n                  \n                    # Make the move  \n                    board[i][j] = opponent  \n  \n                    # Call minimax recursively and choose  \n                    # the minimum value  \n                    best = min(best, minimax(board, depth + 1, not isMax)) \n  \n                    # Undo the move  \n                    board[i][j] = '_'\n        return best \n  \n# This will return the best possible move for the player  \ndef findBestMove(board) :  \n    bestVal = -1000 \n    bestMove = (-1, -1)  \n  \n    # Traverse all cells, evaluate minimax function for  \n    # all empty cells. And return the cell with optimal  \n    # value.  \n    for i in range(3) :      \n        for j in range(3) : \n          \n            # Check if cell is empty  \n            if (board[i][j] == '_') :  \n              \n                # Make the move  \n                board[i][j] = player \n  \n                # compute evaluation function for this  \n                # move.  \n                moveVal = minimax(board, 0, False)  \n  \n                # Undo the move  \n                board[i][j] = '_' \n  \n                # If the value of the current move is  \n                # more than the best value, then update  \n                # best/  \n                if (moveVal > bestVal) :                 \n                    bestMove = (i, j) \n                    bestVal = moveVal \n  \n    print('The value of the best Move is :', bestVal) \n    print() \n    return bestMove \n# Driver code \nboard = [ \n    [ 'x', 'o', 'x' ],  \n    [ 'o', 'o', 'x' ],  \n    [ '_', '_', '_' ]  \n] \n  \nbestMove = findBestMove(board)  \n  \nprint('The Optimal Move is :')  \nprint('ROW:', bestMove[0], ' COL:', bestMove[1]) \n  \n# This code is contributed by divyesh072019\n"], "Introduction to Evaluation Function of Minimax Algorithm in Game Theory -  ": ["# Python3 program to compute evaluation \n# function for Tic Tac Toe Game. \n \n# Returns a value based on who is winning \n# b[3][3] is the Tic-Tac-Toe board \ndef evaluate(b): \n  \n    # Checking for Rows for X or O victory. \n    for row in range(0, 3): \n      \n        if b[row][0] == b[row][1] and b[row][1] == b[row][2]: \n          \n            if b[row][0] == 'x':\n                return 10\n            else if b[row][0] == 'o': \n                return -10\n \n    # Checking for Columns for X or O victory. \n    for col in range(0, 3): \n      \n        if b[0][col] == b[1][col] and b[1][col] == b[2][col]: \n          \n            if b[0][col]=='x':\n                return 10\n            else if b[0][col] == 'o': \n                return -10\n \n    # Checking for Diagonals for X or O victory. \n    if b[0][0] == b[1][1] and b[1][1] == b[2][2]: \n      \n        if b[0][0] == 'x': \n            return 10\n        else if b[0][0] == 'o': \n            return -10\n      \n    if b[0][2] == b[1][1] and b[1][1] == b[2][0]: \n      \n        if b[0][2] == 'x': \n            return 10\n        else if b[0][2] == 'o': \n            return -10\n      \n    # Else if none of them have won then return 0 \n    return 0\n  \n# Driver code \nif __name__ == '__main__': \n  \n    board = [['x', '_', 'o'], \n             ['_', 'x', 'o'], \n             ['_', '_', 'x']] \n      \n    value = evaluate(board) \n    print('The value of this board is', value) \n \n# This code is contributed by Rituraj Jain\n"], "Minimax Algorithm in Game Theory | Set 1 (Introduction) -  ": ["# A simple Python3 program to find\n# maximum score that\n# maximizing player can get\nimport math\n \ndef minimax (curDepth, nodeIndex,\n             maxTurn, scores, \n             targetDepth):\n \n    # base case : targetDepth reached\n    if (curDepth == targetDepth): \n        return scores[nodeIndex]\n     \n    if (maxTurn):\n        return max(minimax(curDepth + 1, nodeIndex * 2, \n                    False, scores, targetDepth), \n                   minimax(curDepth + 1, nodeIndex * 2 + 1, \n                    False, scores, targetDepth))\n     \n    else:\n        return min(minimax(curDepth + 1, nodeIndex * 2, \n                     True, scores, targetDepth), \n                   minimax(curDepth + 1, nodeIndex * 2 + 1, \n                     True, scores, targetDepth))\n     \n# Driver code\nscores = [3, 5, 2, 9, 12, 5, 23, 23]\n \ntreeDepth = math.log(len(scores), 2)\n \nprint('The optimal value is : ', end = '')\nprint(minimax(0, 0, True, scores, treeDepth))\n \n# This code is contributed\n# by rootshadow\n"], "Combinatorial Game Theory | Set 4 (Sprague - Grundy Theorem) -  ": ["'''  Game Description- \n 'A game is played between two players and there are N piles \n of stones such that each pile has certain number of stones. \n On his/her turn, a player selects a pile and can take any \n non-zero number of stones upto 3 (i.e- 1,2,3) \n The player who cannot move is considered to lose the game \n (i.e., one who take the last stone is the winner). \n Can you find which player wins the game if both players play \n optimally (they don't make any mistake)? ' \n   \n A Dynamic Programming approach to calculate Grundy Number \n and Mex and find the Winner using Sprague - Grundy Theorem.\n  \n     piles[] -> Array having the initial count of stones/coins \n            in each piles before the game has started. \n   n       -> Number of piles \n   \n   Grundy[] -> Array having the Grundy Number corresponding to \n             the initial position of each piles in the game \n   \n   The piles[] and Grundy[] are having 0-based indexing'''\n \nPLAYER1 = 1\nPLAYER2 = 2  \n \n# A Function to calculate Mex of all\n# the values in that set \ndef calculateMex(Set): \n  \n    Mex = 0; \n   \n    while (Mex in Set): \n        Mex += 1\n   \n    return (Mex)\n \n# A function to Compute Grundy Number of 'n' \ndef calculateGrundy(n, Grundy): \n \n    Grundy[0] = 0\n    Grundy[1] = 1\n    Grundy[2] = 2\n    Grundy[3] = 3\n   \n    if (Grundy[n] != -1): \n        return (Grundy[n])\n     \n    # A Hash Table \n    Set = set()\n   \n    for i in range(1, 4):\n        Set.add(calculateGrundy(n - i, \n                                Grundy))\n     \n    # Store the result \n    Grundy[n] = calculateMex(Set)\n   \n    return (Grundy[n])\n  \n# A function to declare the winner of the game \ndef declareWinner(whoseTurn, piles, Grundy, n): \n \n    xorValue = Grundy[piles[0]]; \n   \n    for i in range(1, n):\n        xorValue = (xorValue ^ \n                    Grundy[piles[i]]) \n   \n    if (xorValue != 0): \n     \n        if (whoseTurn == PLAYER1): \n            print('Player 1 will win\\n'); \n        else:\n            print('Player 2 will win\\n'); \n    else:\n     \n        if (whoseTurn == PLAYER1): \n            print('Player 2 will win\\n'); \n        else:\n            print('Player 1 will win\\n'); \n     \n# Driver code\nif __name__=='__main__':\n     \n    # Test Case 1 \n    piles = [ 3, 4, 5 ] \n    n = len(piles) \n   \n    # Find the maximum element \n    maximum = max(piles)\n   \n    # An array to cache the sub-problems so that \n    # re-computation of same sub-problems is avoided \n    Grundy = [-1 for i in range(maximum + 1)]; \n   \n    # Calculate Grundy Value of piles[i] and store it \n    for i in range(n):\n        calculateGrundy(piles[i], Grundy); \n   \n    declareWinner(PLAYER1, piles, Grundy, n); \n   \n    ''' Test Case 2 \n    int piles[] = {3, 8, 2}; \n    int n = sizeof(piles)/sizeof(piles[0]); \n   \n   \n    int maximum = *max_element (piles, piles + n); \n   \n    // An array to cache the sub-problems so that \n    // re-computation of same sub-problems is avoided \n    int Grundy [maximum + 1]; \n    memset(Grundy, -1, sizeof (Grundy)); \n   \n    // Calculate Grundy Value of piles[i] and store it \n    for (int i=0; i<=n-1; i++) \n        calculateGrundy(piles[i], Grundy); \n   \n    declareWinner(PLAYER2, piles, Grundy, n);   '''\n \n# This code is contributed by rutvik_56\n"], "Combinatorial Game Theory | Set 3 (Grundy Numbers/Numbers and Mex) -  ": ["''' A recursive Python3 program to find Grundy Number for \na game which is like a one-pile version of Nim. \nGame Description : The game starts with a pile of n stones, \nand the player to move may take any positive number of stones.  \nThe last player to move wins. Which player wins the game? '''\n  \n# A Function to calculate Mex of all the values in \n# that set. \ndef calculateMex(Set): \n    Mex = 0\n  \n    while (Mex in Set): \n        Mex += 1\n  \n    return (Mex) \n  \n# A function to Compute Grundy Number of 'n' \n# Only this function varies according to the game \ndef calculateGrundy( n): \n    if (n == 0): \n        return (0) \n  \n    Set = set() # A Hash Table \n  \n    for i in range(n): \n        Set.add(calculateGrundy(i)); \n  \n    return (calculateMex(Set)) \n  \n# Driver program to test above functions \nn = 10; \nprint(calculateGrundy(n)) \n  \n# This code is contributed by ANKITKUMAR34 \n", "# A recursive Python3 program to find Grundy Number  \n# for a game which is one-pile version of Nim.  \n# Game Description : The game starts with a pile  \n# of n stones, and the player to move may take  \n# any positive number of stones up to 3 only.  \n# The last player to move wins. \n  \n  \n   \n# A function to Compute Grundy Number of 'n'  \n# Only this function varies according to the game  \ndef calculateGrundy(n):  \n  \n    if 0 <= n <= 3: \n        return n \n      \n    else: \n        return (n%(3+1)); \n        \n     \n   \n# Driver program to test above functions  \nif __name__ == '__main__':  \n   \n    n = 10 \n    print(calculateGrundy(n))  \n      \n# This code is contributed by rahulnamdevrn27 \n", "# A recursive Python3 program to  \n# find Grundy Number for a game.  \n# Game Description : The game starts with a number- 'n'  \n# and the player to move divides the number- 'n' with 2, 3  \n# or 6 and then take the floor. If the integer becomes 0,  \n# it is removed. The last player to move wins. \n  \n# A Function to calculate Mex  \n# of all the values in that set.  \ndef calculateMex(Set):  \n   \n    Mex = 0 \n    while Mex in Set:  \n        Mex += 1\n  \n    return Mex  \n   \n# A function to Compute Grundy Number of 'n'  \n# Only this function varies according to the game  \ndef calculateGrundy(n):  \n   \n    if n == 0: \n        return 0 \n  \n    Set = set() # A Hash Table  \n  \n    Set.add(calculateGrundy(n // 2))  \n    Set.add(calculateGrundy(n // 3))  \n    Set.add(calculateGrundy(n // 6))  \n  \n    return (calculateMex(Set))  \n   \n# Driver program to test above functions  \nif __name__ == '__main__':  \n   \n    n = 10 \n    print(calculateGrundy(n))  \n      \n# This code is contributed by Rituraj Jain \n"], "Combinatorial Game Theory | Set 2 (Game of Nim) -  ": ["# A Python3 program to implement Game of Nim. The program\n# assumes that both players are playing optimally\nimport random\n \nCOMPUTER = 1\nHUMAN = 2\n \n# A Structure to hold the two parameters of a move\n \n# move has two parameters-\n# 1) pile_index = The index of pile from which stone is\n#                    going to be removed\n# 2) stones_removed = Number of stones removed from the\n#                        pile indexed = pile_index */\n \n \nclass move:\n \n    def __init__(self):\n \n        self.pile_index = 0\n        self.stones_removed = 0\n \n \n# piles[] -> Array having the initial count of stones/coins\n#            in each piles before the game has started.\n# n     -> Number of piles\n \n# The piles[] are having 0-based indexing\n \n# A function to output the current game state.\ndef showPiles(piles, n):\n    print('Current Game Status -> ')\n    print(*piles)\n \n# A function that returns True if game has ended and\n# False if game is not yet over\ndef gameOver(piles, n):\n    for i in range(n):\n        if (piles[i] != 0):\n            return False\n \n    return True\n \n# A function to declare the winner of the game\ndef declareWinner(whoseTurn):\n    if (whoseTurn == COMPUTER):\n        print('\\nHUMAN won')\n    else:\n        print('\\nCOMPUTER won')\n    return\n \n \n# A function to calculate the Nim-Sum at any point\n# of the game.\ndef calculateNimSum(piles, n):\n    nimsum = piles[0]\n    for i in range(1, n):\n        nimsum = nimsum ^ piles[i]\n    return nimsum\n \n# A function to make moves of the Nim Game\ndef makeMove(piles, n, moves):\n    nim_sum = calculateNimSum(piles, n)\n \n    # The player having the current turn is on a winning\n    # position. So he/she/it play optimally and tries to make\n    # Nim-Sum as 0\n    if (nim_sum != 0):\n        for i in range(n):\n \n            # If this is not an illegal move\n            # then make this move.\n            if ((piles[i] ^ nim_sum) < piles[i]):\n \n                moves.pile_index = i\n                moves.stones_removed = piles[i]-(piles[i] ^ nim_sum)\n                piles[i] = (piles[i] ^ nim_sum)\n                break\n \n    # The player having the current turn is on losing\n    # position, so he/she/it can only wait for the opponent\n    # to make a mistake(which doesn't happen in this program\n    # as both players are playing optimally). He randomly\n    # choose a non-empty pile and randomly removes few stones\n    # from it. If the opponent doesn't make a mistake,then it\n    # doesn't matter which pile this player chooses, as he is\n    # destined to lose this game.\n \n    # If you want to input yourself then remove the rand()\n    # functions and modify the code to take inputs.\n    # But remember, you still won't be able to change your\n    # fate/prediction.\n    else:\n        # Create an array to hold indices of non-empty piles\n        non_zero_indices = [None for _ in range(n)]\n        count = 0\n        for i in range(n):\n            if (piles[i] > 0):\n                non_zero_indices[count] = i\n                count += 1\n \n        moves.pile_index = int(random.random() * (count))\n        moves.stones_removed = 1 + \\\n            int(random.random() * (piles[moves.pile_index]))\n        piles[moves.pile_index] -= moves.stones_removed\n \n        if (piles[moves.pile_index] < 0):\n            piles[moves.pile_index] = 0\n \n    return\n \n# A C function to play the Game of Nim\ndef playGame(piles, n, whoseTurn):\n    print('\\nGAME STARTS')\n    moves = move()\n \n    while (gameOver(piles, n) == False):\n        showPiles(piles, n)\n        makeMove(piles, n, moves)\n \n        if (whoseTurn == COMPUTER):\n \n            print('COMPUTER removes', moves.stones_removed,\n                  'stones from pile at index ', moves.pile_index)\n            whoseTurn = HUMAN\n \n        else:\n            print('HUMAN removes', moves.stones_removed,\n                  'stones from pile at index', moves.pile_index)\n            whoseTurn = COMPUTER\n \n    showPiles(piles, n)\n    declareWinner(whoseTurn)\n    return\n \ndef knowWinnerBeforePlaying(piles, n, whoseTurn):\n    print('Prediction before playing the game -> ', end='')\n    if (calculateNimSum(piles, n) != 0):\n \n        if (whoseTurn == COMPUTER):\n            print('COMPUTER will win')\n        else:\n            print('HUMAN will win')\n \n    else:\n \n        if (whoseTurn == COMPUTER):\n            print('HUMAN will win')\n        else:\n            print('COMPUTER will win')\n \n    return\n \n# Driver program to test above functions\n \n# Test Case 1\npiles = [3, 4, 5]\nn = len(piles)\n \n# We will predict the results before playing\n# The COMPUTER starts first\nknowWinnerBeforePlaying(piles, n, COMPUTER)\n \n# Let us play the game with COMPUTER starting first\n# and check whether our prediction was right or not\nplayGame(piles, n, COMPUTER)\n \n# This code is contributed by phasing17\n"], "Check whether a given point lies inside a triangle or not -  ": ["# Python program for the above approach\n \n# Function to check if the point is inside\n# the triangle or not\ndef isInsideTriangle(A, B, C, P):\n \n    # Calculate the barycentric coordinates\n    # of point P with respect to triangle ABC\n    denominator = ((B[1] - C[1]) * (A[0] - C[0]) +\n                   (C[0] - B[0]) * (A[1] - C[1]))\n    a = ((B[1] - C[1]) * (P[0] - C[0]) +\n         (C[0] - B[0]) * (P[1] - C[1])) / denominator\n    b = ((C[1] - A[1]) * (P[0] - C[0]) +\n         (A[0] - C[0]) * (P[1] - C[1])) / denominator\n    c = 1 - a - b\n \n    # Check if all barycentric coordinates\n    # are non-negative\n    if a >= 0 and b >= 0 and c >= 0:\n        return 'Inside'\n    else:\n        return 'Outside'\n \n \n# Driver Code\nA = (0, 0)\nB = (10, 30)\nC = (20, 0)\nP = (10, 15)\n \n# Call the isInsideTriangle function with\n# the given inputs\nresult = isInsideTriangle(A, B, C, P)\n \n# Print the result\nprint(result)\n"], "Given n line segments, find if any two segments intersect -  ": [], "Convex Hull using Graham Scan -  ": ["# A Python3 program to find convex hull of a set of points. Refer \n# https://www. .org/orientation-3-ordered-points/\n# for explanation of orientation()\n \nfrom functools import cmp_to_key\n \n# A class used to store the x and y coordinates of points\nclass Point:\n    def __init__(self, x = None, y = None):\n        self.x = x\n        self.y = y\n \n# A global point needed for sorting points with reference\n# to the first point\np0 = Point(0, 0)\n \n# A utility function to find next to top in a stack\ndef nextToTop(S):\n    return S[-2]\n \n# A utility function to return square of distance\n# between p1 and p2\ndef distSq(p1, p2):\n    return ((p1.x - p2.x) * (p1.x - p2.x) +\n            (p1.y - p2.y) * (p1.y - p2.y))\n \n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are collinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p, q, r):\n    val = ((q.y - p.y) * (r.x - q.x) -\n           (q.x - p.x) * (r.y - q.y))\n    if val == 0:\n        return 0  # collinear\n    elif val > 0:\n        return 1  # clock wise\n    else:\n        return 2  # counterclock wise\n \n# A function used by cmp_to_key function to sort an array of\n# points with respect to the first point\ndef compare(p1, p2):\n   \n    # Find orientation\n    o = orientation(p0, p1, p2)\n    if o == 0:\n        if distSq(p0, p2) >= distSq(p0, p1):\n            return -1\n        else:\n            return 1\n    else:\n        if o == 2:\n            return -1\n        else:\n            return 1\n \n# Prints convex hull of a set of n points.\ndef convexHull(points, n):\n   \n    # Find the bottommost point\n    ymin = points[0].y\n    min = 0\n    for i in range(1, n):\n        y = points[i].y\n \n        # Pick the bottom-most or choose the left\n        # most point in case of tie\n        if ((y < ymin) or\n            (ymin == y and points[i].x < points[min].x)):\n            ymin = points[i].y\n            min = i\n \n    # Place the bottom-most point at first position\n    points[0], points[min] = points[min], points[0]\n \n    # Sort n-1 points with respect to the first point.\n    # A point p1 comes before p2 in sorted output if p2\n    # has larger polar angle (in counterclockwise\n    # direction) than p1\n    p0 = points[0]\n    points = sorted(points, key=cmp_to_key(compare))\n \n    # If two or more points make same angle with p0,\n    # Remove all but the one that is farthest from p0\n    # Remember that, in above sorting, our criteria was\n    # to keep the farthest point at the end when more than\n    # one points have same angle.\n    m = 1  # Initialize size of modified array\n    for i in range(1, n):\n       \n        # Keep removing i while angle of i and i+1 is same\n        # with respect to p0\n        while ((i < n - 1) and\n        (orientation(p0, points[i], points[i + 1]) == 0)):\n            i += 1\n \n        points[m] = points[i]\n        m += 1  # Update size of modified array\n \n    # If modified array of points has less than 3 points,\n    # convex hull is not possible\n    if m < 3:\n        return\n \n    # Create an empty stack and push first three points\n    # to it.\n    S = []\n    S.append(points[0])\n    S.append(points[1])\n    S.append(points[2])\n \n    # Process remaining n-3 points\n    for i in range(3, m):\n       \n        # Keep removing top while the angle formed by\n        # points next-to-top, top, and points[i] makes\n        # a non-left turn\n        while ((len(S) > 1) and\n        (orientation(nextToTop(S), S[-1], points[i]) != 2)):\n            S.pop()\n        S.append(points[i])\n \n    # Now stack has the output points,\n    # print contents of stack\n    while S:\n        p = S[-1]\n        print('(' + str(p.x) + ', ' + str(p.y) + ')')\n        S.pop()\n \n# Driver Code\ninput_points = [(0, 3), (1, 1), (2, 2), (4, 4),\n                (0, 0), (1, 2), (3, 1), (3, 3)]\npoints = []\nfor point in input_points:\n    points.append(Point(point[0], point[1]))\nn = len(points)\nconvexHull(points, n)\n \n# This code is contributed by Kevin Joshi\n"], "Convex Hull using Jarvis' Algorithm or Wrapping -  ": ["# Python3 program to find convex hull of a set of points. Refer  \n# https://www. .org/orientation-3-ordered-points/ \n# for explanation of orientation() \n  \n# point class with x, y as point  \nclass Point: \n    def __init__(self, x, y): \n        self.x = x \n        self.y = y \n  \ndef Left_index(points): \n      \n    ''' \n    Finding the left most point \n    '''\n    minn = 0\n    for i in range(1,len(points)): \n        if points[i].x < points[minn].x: \n            minn = i \n        elif points[i].x == points[minn].x: \n            if points[i].y > points[minn].y: \n                minn = i \n    return minn \n  \ndef orientation(p, q, r): \n    ''' \n    To find orientation of ordered triplet (p, q, r).  \n    The function returns following values  \n    0 --> p, q and r are collinear  \n    1 --> Clockwise  \n    2 --> Counterclockwise  \n    '''\n    val = (q.y - p.y) * (r.x - q.x) - \\ \n          (q.x - p.x) * (r.y - q.y) \n  \n    if val == 0: \n        return 0\n    elif val > 0: \n        return 1\n    else: \n        return 2\n  \ndef convexHull(points, n): \n      \n    # There must be at least 3 points  \n    if n < 3: \n        return\n  \n    # Find the leftmost point \n    l = Left_index(points) \n  \n    hull = [] \n      \n    ''' \n    Start from leftmost point, keep moving counterclockwise  \n    until reach the start point again. This loop runs O(h)  \n    times where h is number of points in result or output.  \n    '''\n    p = l \n    q = 0\n    while(True): \n          \n        # Add current point to result  \n        hull.append(p) \n  \n        ''' \n        Search for a point 'q' such that orientation(p, q,  \n        x) is counterclockwise for all points 'x'. The idea  \n        is to keep track of last visited most counterclock-  \n        wise point in q. If any point 'i' is more counterclock-  \n        wise than q, then update q.  \n        '''\n        q = (p + 1) % n \n  \n        for i in range(n): \n              \n            # If i is more counterclockwise  \n            # than current q, then update q  \n            if(orientation(points[p],  \n                           points[i], points[q]) == 2): \n                q = i \n  \n        ''' \n        Now q is the most counterclockwise with respect to p  \n        Set p as q for next iteration, so that q is added to  \n        result 'hull'  \n        '''\n        p = q \n  \n        # While we don't come to first point \n        if(p == l): \n            break\n  \n    # Print Result  \n    for each in hull: \n        print(points[each].x, points[each].y) \n  \n# Driver Code \npoints = [] \npoints.append(Point(0, 3)) \npoints.append(Point(2, 2)) \npoints.append(Point(1, 1)) \npoints.append(Point(2, 1)) \npoints.append(Point(3, 0)) \npoints.append(Point(0, 0)) \npoints.append(Point(3, 3)) \n  \nconvexHull(points, len(points)) \n  \n# This code is contributed by  \n# Akarsh Somani, IIIT Kalyani \n"], "How to check if a given point lies inside or outside a polygon? -  ": ["class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \nclass line:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n \ndef onLine(l1, p):\n    # Check whether p is on the line or not\n    if (\n        p.x <= max(l1.p1.x, l1.p2.x)\n        and p.x >= min(l1.p1.x, l1.p2.x)\n        and (p.y <= max(l1.p1.y, l1.p2.y) and p.y >= min(l1.p1.y, l1.p2.y))\n    ):\n        return True\n    return False\n \ndef direction(a, b, c):\n    val = (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y)\n    if val == 0:\n        # Collinear\n        return 0\n    elif val < 0:\n        # Anti-clockwise direction\n        return 2\n    # Clockwise direction\n    return 1\n \ndef isIntersect(l1, l2):\n    # Four direction for two lines and points of other line\n    dir1 = direction(l1.p1, l1.p2, l2.p1)\n    dir2 = direction(l1.p1, l1.p2, l2.p2)\n    dir3 = direction(l2.p1, l2.p2, l1.p1)\n    dir4 = direction(l2.p1, l2.p2, l1.p2)\n \n    # When intersecting\n    if dir1 != dir2 and dir3 != dir4:\n        return True\n \n    # When p2 of line2 are on the line1\n    if dir1 == 0 and onLine(l1, l2.p1):\n        return True\n \n    # When p1 of line2 are on the line1\n    if dir2 == 0 and onLine(l1, l2.p2):\n        return True\n \n    # When p2 of line1 are on the line2\n    if dir3 == 0 and onLine(l2, l1.p1):\n        return True\n \n    # When p1 of line1 are on the line2\n    if dir4 == 0 and onLine(l2, l1.p2):\n        return True\n \n    return False\n \ndef checkInside(poly, n, p):\n    # When polygon has less than 3 edge, it is not polygon\n    if n < 3:\n        return False\n \n    # Create a point at infinity, y is same as point p\n    exline = line(p, Point(9999, p.y))\n    count = 0\n    i = 0\n    while True:\n        # Forming a line from two consecutive points of poly\n        side = line(poly[i], poly[(i + 1) % n])\n        if isIntersect(side, exline):\n            # If side is intersects ex\n            if (direction(side.p1, p, side.p2) == 0):\n                return onLine(side, p);\n            count += 1\n         \n        i = (i + 1) % n;\n        if i == 0:\n            break\n \n    # When count is odd\n    return count & 1;\n \n \n# Driver code\npolygon = [  Point( 0, 0 ), Point( 10, 0 ), Point( 10, 10 ), Point( 0, 10 ) ];\np = Point( 5, 3 );\nn = 4;\n \n# Function call\nif (checkInside(polygon, n, p)):\n    print('Point is inside.')\nelse:\n    print('Point is outside.')\n"], "How to check if two given line segments intersect? -  ": ["# A Python3 program to find if 2 given line segments intersect or not \n  \nclass Point: \n    def __init__(self, x, y): \n        self.x = x \n        self.y = y \n  \n# Given three collinear points p, q, r, the function checks if  \n# point q lies on line segment 'pr'  \ndef onSegment(p, q, r): \n    if ( (q.x <= max(p.x, r.x)) and (q.x >= min(p.x, r.x)) and \n           (q.y <= max(p.y, r.y)) and (q.y >= min(p.y, r.y))): \n        return True\n    return False\n  \ndef orientation(p, q, r): \n    # to find the orientation of an ordered triplet (p,q,r) \n    # function returns the following values: \n    # 0 : Collinear points \n    # 1 : Clockwise points \n    # 2 : Counterclockwise \n      \n    # See https://www. .org/orientation-3-ordered-points/amp/  \n    # for details of below formula.  \n      \n    val = (float(q.y - p.y) * (r.x - q.x)) - (float(q.x - p.x) * (r.y - q.y)) \n    if (val > 0): \n          \n        # Clockwise orientation \n        return 1\n    elif (val < 0): \n          \n        # Counterclockwise orientation \n        return 2\n    else: \n          \n        # Collinear orientation \n        return 0\n  \n# The main function that returns true if  \n# the line segment 'p1q1' and 'p2q2' intersect. \ndef doIntersect(p1,q1,p2,q2): \n      \n    # Find the 4 orientations required for  \n    # the general and special cases \n    o1 = orientation(p1, q1, p2) \n    o2 = orientation(p1, q1, q2) \n    o3 = orientation(p2, q2, p1) \n    o4 = orientation(p2, q2, q1) \n  \n    # General case \n    if ((o1 != o2) and (o3 != o4)): \n        return True\n  \n    # Special Cases \n  \n    # p1 , q1 and p2 are collinear and p2 lies on segment p1q1 \n    if ((o1 == 0) and onSegment(p1, p2, q1)): \n        return True\n  \n    # p1 , q1 and q2 are collinear and q2 lies on segment p1q1 \n    if ((o2 == 0) and onSegment(p1, q2, q1)): \n        return True\n  \n    # p2 , q2 and p1 are collinear and p1 lies on segment p2q2 \n    if ((o3 == 0) and onSegment(p2, p1, q2)): \n        return True\n  \n    # p2 , q2 and q1 are collinear and q1 lies on segment p2q2 \n    if ((o4 == 0) and onSegment(p2, q1, q2)): \n        return True\n  \n    # If none of the cases \n    return False\n  \n# Driver program to test above functions: \np1 = Point(1, 1) \nq1 = Point(10, 1) \np2 = Point(1, 2) \nq2 = Point(10, 2) \n  \nif doIntersect(p1, q1, p2, q2): \n    print('Yes') \nelse: \n    print('No') \n  \np1 = Point(10, 0) \nq1 = Point(0, 10) \np2 = Point(0, 0) \nq2 = Point(10,10) \n  \nif doIntersect(p1, q1, p2, q2): \n    print('Yes') \nelse: \n    print('No') \n  \np1 = Point(-5,-5) \nq1 = Point(0, 0) \np2 = Point(1, 1) \nq2 = Point(10, 10) \n  \nif doIntersect(p1, q1, p2, q2): \n    print('Yes') \nelse: \n    print('No') \n      \n# This code is contributed by Ansh Riyal \n"], "Closest Pair of Points | O(nlogn) Implementation -  ": ["# Python Equivalent\nimport math\n \n# A structure to represent a Point in 2D plane\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n# Needed to sort array of points according to X coordinate\ndef compareX(a, b):\n    p1,  p2 = a, b\n    return (p1.x != p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n \n# Needed to sort array of points according to Y coordinate\ndef compareY(a, b):\n    p1,  p2 = a, b\n    return (p1.y != p2.y) * (p1.y - p2.y) + (p1.x - p2.x)\n \n# A utility function to find the distance between two points\ndef dist(p1, p2):\n    return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)\n \n# A Brute Force method to return the smallest distance between two points\n# in P[] of size n\ndef bruteForce(P, n):\n    min = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            if dist(P[i], P[j]) < min:\n                min = dist(P[i], P[j])\n    return min\n \n# A utility function to find a minimum of two float values\ndef min(x, y):\n    return x if x < y else y\n \n# A utility function to find the distance between the closest points of\n# strip of a given size. All points in strip[] are sorted according to\n# y coordinate. They all have an upper bound on minimum distance as d.\n# Note that this method seems to be a O(n^2) method, but it's a O(n)\n# method as the inner loop runs at most 6 times\ndef stripClosest(strip, size, d):\n    min = d  # Initialize the minimum distance as d\n \n    # Pick all points one by one and try the next points till the difference\n    # between y coordinates is smaller than d.\n    # This is a proven fact that this loop runs at most 6 times\n    for i in range(size):\n        for j in range(i+1, size):\n            if (strip[j].y - strip[i].y) < min:\n                if dist(strip[i],strip[j]) < min:\n                    min = dist(strip[i], strip[j])\n \n    return min\n \n# A recursive function to find the smallest distance. The array Px contains\n# all points sorted according to x coordinates and Py contains all points\n# sorted according to y coordinates\ndef closestUtil(Px, Py, n):\n    # If there are 2 or 3 points, then use brute force\n    if n <= 3:\n        return bruteForce(Px, n)\n \n    # Find the middle point\n    mid = n // 2\n    midPoint = Px[mid]\n \n \n    # Divide points in y sorted array around the vertical line.\n    # Assumption: All x coordinates are distinct.\n    Pyl = [None] * mid   # y sorted points on left of vertical line\n    Pyr = [None] * (n-mid)  # y sorted points on right of vertical line\n    li = ri = 0  # indexes of left and right subarrays\n    for i in range(n):\n        if ((Py[i].x < midPoint.x or (Py[i].x == midPoint.x and Py[i].y < midPoint.y)) and li<mid):\n            Pyl[li] = Py[i]\n            li += 1\n        else:\n            Pyr[ri] = Py[i]\n            ri += 1\n \n    # Consider the vertical line passing through the middle point\n    # calculate the smallest distance dl on left of middle point and\n    # dr on right side\n    dl = closestUtil(Px, Pyl, mid)\n    dr = closestUtil(Px[mid:], Pyr, n-mid)\n \n    # Find the smaller of two distances\n    d = min(dl, dr)\n \n    # Build an array strip[] that contains points close (closer than d)\n    # to the line passing through the middle point\n    strip = [None] * n\n    j = 0\n    for i in range(n):\n        if abs(Py[i].x - midPoint.x) < d:\n            strip[j] = Py[i]\n            j += 1\n \n    # Find the closest points in strip.  Return the minimum of d and closest\n    # distance is strip[]\n    return stripClosest(strip, j, d)\n \n# The main function that finds the smallest distance\n# This method mainly uses closestUtil()\ndef closest(P, n):\n    Px = P\n    Py = P\n    Px.sort(key=lambda x:x.x)\n    Py.sort(key=lambda x:x.y)\n \n    # Use recursive function closestUtil() to find the smallest distance\n    return closestUtil(Px, Py, n)\n \n# Driver program to test above functions\nif __name__ == '__main__':\n    P = [Point(2, 3), Point(12, 30), Point(40, 50), Point(5, 1), Point(12, 10), Point(3, 4)]\n    n = len(P)\n    print('The smallest distance is', closest(P, n))\n"], "Pattern Searching | Set 6 (Efficient Construction of Finite Automata) -  ": ["''' A Python3 program to answer queries to check whether   \nthe substrings are palindrome or not efficiently '''\nNO_OF_CHARS = 256\n  \n''' This function builds the TF table  \nwhich represents Finite Automata for a  \ngiven pattern '''\n  \n  \ndef computeTransFun(pat, M, TF): \n  \n    lps = 0\n  \n    # Fill entries in first row \n    for x in range(NO_OF_CHARS): \n        TF[0][x] = 0\n    TF[0][ord(pat[0])] = 1\n  \n    # Fill entries in other rows \n    for i in range(1, M+1): \n  \n        # Copy values from row at index lps \n        for x in range(NO_OF_CHARS): \n            TF[i][x] = TF[lps][x] \n  \n        if (i < M): \n            # Update the entry corresponding to this character \n            TF[i][ord(pat[i])] = i + 1\n  \n            # Update lps for next row to be filled \n  \n            lps = TF[lps][ord(pat[i])] \n  \n# Prints all occurrences of pat in txt \n  \n  \ndef search(pat, txt): \n    M = len(pat) \n    N = len(txt) \n    TF = [[0 for i in range(NO_OF_CHARS)] for j in range(M + 1)] \n    computeTransFun(pat, M, TF) \n  \n    # process text over FA. \n    j = 0\n    for i in range(N): \n        j = TF[j][ord(txt[i])] \n        if (j == M): \n            print('pattern found at index', i - M + 1) \n  \n  \n# Driver code \ntxt = 'ACACACACAGAAGA ACACAGAACACAGA GEEKS'\npat = 'ACACAGA'\nsearch(pat, txt) \n  \n# This code is contributed by divyeshrabadiya07 \n"], "Finite Automata algorithm for Pattern Searching -  ": ["# Python program for Finite Automata \n# Pattern searching Algorithm\n \nNO_OF_CHARS = 256\n \ndef getNextState(pat, M, state, x):\n    '''\n    calculate the next state \n    '''\n \n    # If the character c is same as next character \n      # in pattern, then simply increment state\n \n    if state < M and x == ord(pat[state]):\n        return state+1\n \n    i=0\n    # ns stores the result which is next state\n \n    # ns finally contains the longest prefix \n     # which is also suffix in 'pat[0..state-1]c'\n \n     # Start from the largest possible value and \n      # stop when you find a prefix which is also suffix\n    for ns in range(state,0,-1):\n        if ord(pat[ns-1]) == x:\n            while(i<ns-1):\n                if pat[i] != pat[state-ns+1+i]:\n                    break\n                i+=1\n            if i == ns-1:\n                return ns \n    return 0\n \ndef computeTF(pat, M):\n    '''\n    This function builds the TF table which \n    represents Finite Automata for a given pattern\n    '''\n    global NO_OF_CHARS\n \n    TF = [[0 for i in range(NO_OF_CHARS)]\\\n          for _ in range(M+1)]\n \n    for state in range(M+1):\n        for x in range(NO_OF_CHARS):\n            z = getNextState(pat, M, state, x)\n            TF[state][x] = z\n \n    return TF\n \ndef search(pat, txt):\n    '''\n    Prints all occurrences of pat in txt\n    '''\n    global NO_OF_CHARS\n    M = len(pat)\n    N = len(txt)\n    TF = computeTF(pat, M)    \n \n    # Process txt over FA.\n    state=0\n    for i in range(N):\n        state = TF[state][ord(txt[i])]\n        if state == M:\n            print('Pattern found at index: {}'.\\\n                   format(i-M+1))\n \n# Driver program to test above function            \ndef main():\n    txt = 'AABAACAADAABAAABAA'\n    pat = 'AABA'\n    search(pat, txt)\n \nif __name__ == '__main__':\n    main()\n \n# This code is contributed by Atul Kumar\n"], "Manacher's Algorithm - Linear Time Longest Palindromic Substring - Part 4 -  ": ["# Python program to implement Manacher's Algorithm \n   \ndef findLongestPalindromicString(text): \n    N = len(text) \n    if N == 0: \n        return\n    N = 2*N+1    # Position count \n    L = [0] * N \n    L[0] = 0\n    L[1] = 1\n    C = 1     # centerPosition \n    R = 2     # centerRightPosition \n    i = 0    # currentRightPosition \n    iMirror = 0     # currentLeftPosition \n    maxLPSLength = 0\n    maxLPSCenterPosition = 0\n    start = -1\n    end = -1\n    diff = -1\n   \n    # Uncomment it to print LPS Length array \n    # printf('%d %d ', L[0], L[1]); \n    for i in range(2,N): \n       \n        # get currentLeftPosition iMirror for currentRightPosition i \n        iMirror = 2*C-i \n        L[i] = 0\n        diff = R - i \n        # If currentRightPosition i is within centerRightPosition R \n        if diff > 0: \n            L[i] = min(L[iMirror], diff) \n   \n        # Attempt to expand palindrome centered at currentRightPosition i \n        # Here for odd positions, we compare characters and \n        # if match then increment LPS Length by ONE \n        # If even position, we just increment LPS by ONE without \n        # any character comparison \n        try: \n            while ((i + L[i]) < N and (i - L[i]) > 0) and \\ \n                    (((i + L[i] + 1) % 2 == 0) or \\ \n                    (text[(i + L[i] + 1) // 2] == text[(i - L[i] - 1) // 2])): \n                L[i]+=1\n        except Exception as e: \n            pass\n   \n        if L[i] > maxLPSLength:        # Track maxLPSLength \n            maxLPSLength = L[i] \n            maxLPSCenterPosition = i \n   \n        # If palindrome centered at currentRightPosition i \n        # expand beyond centerRightPosition R, \n        # adjust centerPosition C based on expanded palindrome. \n        if i + L[i] > R: \n            C = i \n            R = i + L[i] \n   \n    # Uncomment it to print LPS Length array \n    # printf('%d ', L[i]); \n    start = (maxLPSCenterPosition - maxLPSLength) // 2\n    end = start + maxLPSLength - 1\n    print ('LPS of string is ' + text + ' : ',text[start:end+1]) \n   \n# Driver program \ntext1 = 'babcbabcbaccba'\nfindLongestPalindromicString(text1) \n   \ntext2 = 'abaaba'\nfindLongestPalindromicString(text2) \n   \ntext3 = 'abababa'\nfindLongestPalindromicString(text3) \n   \ntext4 = 'abcbabcbabcba'\nfindLongestPalindromicString(text4) \n   \ntext5 = 'forgeeksskeegfor'\nfindLongestPalindromicString(text5) \n   \ntext6 = 'caba'\nfindLongestPalindromicString(text6) \n   \ntext7 = 'abacdfgdcaba'\nfindLongestPalindromicString(text7) \n   \ntext8 = 'abacdfgdcabba'\nfindLongestPalindromicString(text8) \n   \ntext9 = 'abacdedcaba'\nfindLongestPalindromicString(text9) \n   \n# This code is contributed by BHAVYA JAIN \n"], "Manacher's Algorithm - Linear Time Longest Palindromic Substring - Part 3 -  ": ["# Python program to implement Manacher's Algorithm \n   \ndef findLongestPalindromicString(text): \n    N = len(text) \n    if N == 0: \n        return\n    N = 2*N+1    # Position count \n    L = [0] * N \n    L[0] = 0\n    L[1] = 1\n    C = 1     # centerPosition \n    R = 2     # centerRightPosition \n    i = 0    # currentRightPosition \n    iMirror = 0     # currentLeftPosition \n    maxLPSLength = 0\n    maxLPSCenterPosition = 0\n    start = -1\n    end = -1\n    diff = -1\n   \n    # Uncomment it to print LPS Length array \n    # printf('%d %d ', L[0], L[1]); \n    for i in range(2,N): \n       \n        # get currentLeftPosition iMirror for currentRightPosition i \n        iMirror = 2*C-i \n        L[i] = 0\n        diff = R - i \n        # If currentRightPosition i is within centerRightPosition R \n        if diff > 0: \n            L[i] = min(L[iMirror], diff) \n   \n        # Attempt to expand palindrome centered at currentRightPosition i \n        # Here for odd positions, we compare characters and \n        # if match then increment LPS Length by ONE \n        # If even position, we just increment LPS by ONE without \n        # any character comparison \n        try: \n            while ((i+L[i]) < N and (i-L[i]) > 0) and \\ \n                    (((i+L[i]+1) % 2 == 0) or \\ \n                    (text[(i+L[i]+1)//2] == text[(i-L[i]-1)//2])): \n                L[i]+=1\n        except Exception as e: \n            pass\n   \n        if L[i] > maxLPSLength:        # Track maxLPSLength \n            maxLPSLength = L[i] \n            maxLPSCenterPosition = i \n   \n        # If palindrome centered at currentRightPosition i \n        # expand beyond centerRightPosition R, \n        # adjust centerPosition C based on expanded palindrome. \n        if i + L[i] > R: \n            C = i \n            R = i + L[i] \n   \n    # Uncomment it to print LPS Length array \n    # printf('%d ', L[i]); \n    start = (maxLPSCenterPosition - maxLPSLength) // 2\n    end = start + maxLPSLength - 1\n    print ('LPS of string is ' + text + ' : ',text[start:end+1]) \n   \n# Driver program \ntext1 = 'babcbabcbaccba'\nfindLongestPalindromicString(text1) \n   \ntext2 = 'abaaba'\nfindLongestPalindromicString(text2) \n   \ntext3 = 'abababa'\nfindLongestPalindromicString(text3) \n   \ntext4 = 'abcbabcbabcba'\nfindLongestPalindromicString(text4) \n   \ntext5 = 'forgeeksskeegfor'\nfindLongestPalindromicString(text5) \n   \ntext6 = 'caba'\nfindLongestPalindromicString(text6) \n   \ntext7 = 'abacdfgdcaba'\nfindLongestPalindromicString(text7) \n   \ntext8 = 'abacdfgdcabba'\nfindLongestPalindromicString(text8) \n   \ntext9 = 'abacdedcaba'\nfindLongestPalindromicString(text9) \n   \n# This code is contributed by BHAVYA JAIN \n"], "KMP Algorithm for Pattern Searching -  ": ["# Python3 program for KMP Algorithm\n \n \ndef KMPSearch(pat, txt):\n    M = len(pat)\n    N = len(txt)\n \n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0]*M\n    j = 0  # index for pat[]\n \n    # Preprocess the pattern (calculate lps[] array)\n    computeLPSArray(pat, M, lps)\n \n    i = 0  # index for txt[]\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n \n        if j == M:\n            print('Found pattern at index ' + str(i-j))\n            j = lps[j-1]\n \n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n \n \n# Function to compute LPS array\ndef computeLPSArray(pat, M, lps):\n    len = 0  # length of the previous longest prefix suffix\n \n    lps[0] = 0  # lps[0] is always 0\n    i = 1\n \n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if len != 0:\n                len = lps[len-1]\n \n                # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n \n \n# Driver code\nif __name__ == '__main__':\n    txt = 'ABABDABACDABABCABAB'\n    pat = 'ABABCABAB'\n    KMPSearch(pat, txt)\n \n# This code is contributed by Bhavya Jain\n"], "Z algorithm (Linear time pattern searching Algorithm) -  ": ["# Python3 program that implements Z algorithm\n# for pattern searching\n \n# Fills Z array for given string str[]\ndef getZarr(string, z):\n    n = len(string)\n \n    # [L,R] make a window which matches\n    # with prefix of s\n    l, r, k = 0, 0, 0\n    for i in range(1, n):\n \n        # if i>R nothing matches so we will calculate.\n        # Z[i] using naive way.\n        if i > r:\n            l, r = i, i\n \n            # R-L = 0 in starting, so it will start\n            # checking from 0'th index. For example,\n            # for 'ababab' and i = 1, the value of R\n            # remains 0 and Z[i] becomes 0. For string\n            # 'aaaaaa' and i = 1, Z[i] and R become 5\n            while r < n and string[r - l] == string[r]:\n                r += 1\n            z[i] = r - l\n            r -= 1\n        else:\n \n            # k = i-L so k corresponds to number which\n            # matches in [L,R] interval.\n            k = i - l\n \n            # if Z[k] is less than remaining interval\n            # then Z[i] will be equal to Z[k].\n            # For example, str = 'ababab', i = 3, R = 5\n            # and L = 2\n            if z[k] < r - i + 1:\n                z[i] = z[k]\n \n            # For example str = 'aaaaaa' and i = 2, \n            # R is 5, L is 0\n            else:\n \n                # else start from R and check manually\n                l = i\n                while r < n and string[r - l] == string[r]:\n                    r += 1\n                z[i] = r - l\n                r -= 1\n \n# prints all occurrences of pattern \n# in text using Z algo\ndef search(text, pattern):\n \n    # Create concatenated string 'P$T'\n    concat = pattern + '$' + text\n    l = len(concat)\n \n    # Construct Z array\n    z = [0] * l\n    getZarr(concat, z)\n \n    # now looping through Z array for matching condition\n    for i in range(l):\n \n        # if Z[i] (matched region) is equal to pattern\n        # length we got the pattern\n        if z[i] == len(pattern):\n            print('Pattern found at index', \n                      i - len(pattern) - 1)\n \n# Driver Code\nif __name__ == '__main__':\n    text = 'GEEKS FOR GEEKS'\n    pattern = 'GEEK'\n    search(text, pattern)\n \n# This code is contributed by\n# sanjeev2552\n"], "Sum over Subsets | Dynamic Programming -  ": ["# Python 3 program\n# for brute force\n# approach of SumOverSubsets DP\n \n# function to print the\n# sum over subsets value\ndef SumOverSubsets(a, n):\n \n    # array to store\n    # the SumOverSubsets\n    sos = [0] * (1 << n)\n     \n    # iterate for all possible x\n    for x in range(0,(1 << n)): \n     \n        # iterate for all\n        # possible bitwise subsets\n        for i in range(0,(1 << n)):  \n     \n            # if i is a bitwise subset of x\n            if ((x & i) == i):\n                sos[x] += a[i]\n             \n     \n     \n    # printa all the subsets\n    for i in range(0,(1 << n)): \n        print(sos[i],end = ' ')\n \n \n# Driver Code\na = [7, 12, 14, 16]\nn = 2\nSumOverSubsets(a, n)\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# Python program for sub-optimal\n# approach of SumOverSubsets DP\n \n# function to print sum over subsets value\ndef SumOverSubsets(a, n):\n    sos = [0]*(1 << n)\n \n    # iterate for all possible x\n    for x in range((1 << n)):\n        sos[x] = a[0]\n         \n        # iterate for the bitwise subsets only\n        i = x\n \n        while i > 0:\n          sos[x] += a[i]\n          i = ((i - 1) & x)\n \n  # print all the subsets\n    for i in range(1<<n):\n        print(sos[i], end = ' ')\n \n# Driver Code\nif __name__ == '__main__':\n    a = [7, 12, 14, 16]\n    n = 2\n    SumOverSubsets(a, n)\n \n# This code is contributed by mohit kumar 29.\n"], "Maximum height of Tree when any Node can be considered as Root -  ": ["# Python3 code to find the maximum path length \n# considering any node as root \ninn = [0] * 100\nout = [0] * 100\n  \n# function to pre-calculate the array inn[] \n# which stores the maximum height when travelled \n# via branches \ndef dfs1(v, u, parent): \n    global inn, out \n      \n    # initially every node has 0 height \n    inn[u] = 0\n  \n    # traverse in the subtree of u \n    for child in v[u]: \n  \n        # if child is same as parent \n        if (child == parent): \n            continue\n  \n        # dfs called \n        dfs1(v, child, u) \n  \n        # recursively calculate the max height \n        inn[u] = max(inn[u], 1 + inn[child]) \n  \n# function to pre-calculate the array out[] \n# which stores the maximum height when traveled \n# via parent \ndef dfs2(v, u, parent): \n    global inn, out \n      \n    # stores the longest and second \n    # longest branches \n    mx1, mx2 = -1, -1\n  \n    # traverse in the subtrees of u \n    for child in v[u]: \n        if (child == parent): \n            continue\n  \n        # compare and store the longest \n        # and second longest \n        if (inn[child] >= mx1): \n            mx2 = mx1 \n            mx1 = inn[child] \n  \n        elif (inn[child] > mx2): \n            mx2 = inn[child] \n  \n    # traverse in the subtree of u \n    for child in v[u]: \n        if (child == parent): \n            continue\n  \n        longest = mx1 \n  \n        # if longest branch has the node, then \n        # consider the second longest branch \n        if (mx1 == inn[child]): \n            longest = mx2 \n  \n        # recursively calculate out[i] \n        out[child] = 1 + max(out[u], 1 + longest) \n  \n        # dfs function call \n        dfs2(v, child, u) \n  \n# function to print all the maximum heights \n# from every node \ndef printHeights(v, n): \n    global inn, out \n      \n    # traversal to calculate inn[] array \n    dfs1(v, 1, 0) \n  \n    # traversal to calculate out[] array \n    dfs2(v, 1, 0) \n  \n    # print all maximum heights \n    for i in range(1, n + 1): \n        print('The maximum height when node', i, 'is considered as root is', max(inn[i], out[i])) \n  \n# Driver Code \nif __name__ == '__main__': \n    n = 11\n    v = [[] for i in range(n + 1)] \n  \n    # initialize the tree given in the diagram \n    v[1].append(2) \n    v[2].append(1) \n    v[1].append(3) \n    v[3].append(1) \n    v[1].append(4) \n    v[4].append(1) \n    v[2].append(5) \n    v[5].append(2) \n    v[2].append(6) \n    v[6].append(2) \n    v[3].append(7) \n    v[7].append(3) \n    v[7].append(10) \n    v[10].append(7) \n    v[7].append(11) \n    v[11].append(7) \n    v[4].append(8) \n    v[8].append(4) \n    v[4].append(9) \n    v[9].append(4) \n  \n    # function to print the maximum height from every node \n    printHeights(v, n) \n  \n# This code is contributed by mohit kumar 29.\n"], "An arithmetic expression is given by a string array A of size N. Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each string may be an integer or an operator. Problem Constraints 1 <= N <= 105 Input Format The only argument given is string array A. Output Format Return the value of arithmetic expression formed using reverse Polish Notation. Example Input Input 1: A = [\"2\", \"1\", \"+\", \"3\", \"*\"] Input 2: A = [\"4\", \"13\", \"5\", \"/\", \"+\"] Example Output Output 1: 9 Output 2: 6 Example Explanation Explaination 1: starting from backside: * : () * () 3 : () * (3) + : (() + ()) * (3) 1 : (() + (1)) * (3) 2 : ((2) + (1)) * (3) ((2) + (1)) * (3) = 9 Explaination 2: + : () + () / : () + (() / ()) 5 : () + (() / (5)) 13 : () + ((13) / (5)) 4 : (4) + ((13) / (5)) (4) + ((13) / (5)) = 6": "from operator import *\nfrom itertools import starmap \nclass Solution:\n    # @param A : list of strings\n    # @return an integer\n    def evalRPN(self, A):\n        D = dict(zip(\"+-*/\", [add, sub, mul, floordiv]))\n        S = []\n        for a in A:\n            if a in D:\n                x, y = S.pop(), S.pop()\n                S.append(D[a](y, x)) \n            else:\n                S.append(int(a))\n        return S[0]\n\n\n\n", "Check if an array can be divided into pairs whose sum is divisible by k -  ": ["# A Python3 program to check if arr[0..n-1]\n# can be divided in pairs such that\n# every pair is divisible by k\ndef canPairs(nums, n, k):\n    # Array with odd length\n    # cannot be divided\n    if (n % 2 == 1):\n        return False\n \n    # Initialize count = 0\n    count = 0\n \n    vis = [-1] * n\n \n    for i in range(0,n):\n        for j in range(i+1,n):\n            if ((nums[i] + nums[j]) % k == 0 and vis[i] == -1 and vis[j] == -1):\n                # if pair is divisible increment\n                # the count and mark elements\n                # as visited\n                count+=1\n                vis[i] = 1\n                vis[j] = 1\n                 \n    if (count == n / 2):\n        return True\n    else:\n        return False\n \n# Driver code\narr = [ 92, 75, 65, 48, 45, 35 ]\nk = 10\nn = len(arr)\n \n# Function call\nif(canPairs(arr, n, k)):\n    print('True')\nelse:\n    print('False')\n \n# This code is contributed by akashish__\n", "# Python3 program to check if\n# arr[0..n-1] can be divided\n# in pairs such that every\n# pair is divisible by k.\nfrom collections import defaultdict\n \n# Returns true if arr[0..n-1] can be\n# divided into pairs with sum\n# divisible by k.\n \n \ndef canPairs(arr, n, k):\n \n    # An odd length array cannot\n    # be divided into pairs\n    if (n & 1):\n        return 0\n \n    # Create a frequency array to\n    # count occurrences of all\n    # remainders when divided by k.\n    freq = defaultdict(lambda: 0)\n \n    # Count occurrences of all remainders\n    for i in range(0, n):\n        freq[((arr[i] % k) + k) % k] += 1\n \n    # Traverse input array and use\n    # freq[] to decide if given array\n    # can be divided in pairs\n    for i in range(0, n):\n \n        # Remainder of current element\n        rem = ((arr[i] % k) + k) % k\n \n        # If remainder with current element\n        # divides k into two halves.\n        if (2 * rem == k):\n \n            # Then there must be even occurrences\n            # of such remainder\n            if (freq[rem] % 2 != 0):\n                return 0\n \n        # If remainder is 0, then there\n        # must be two elements with 0 remainder\n        else if (rem == 0):\n            if (freq[rem] & 1):\n                return 0\n \n            # Else number of occurrences of\n            # remainder must be equal to\n            # number of occurrences of\n            # k - remainder\n        else if (freq[rem] != freq[k - rem]):\n             return 0\n \n    return 1\n \n \n# Driver code\narr = [92, 75, 65, 48, 45, 35]\nk = 10\nn = len(arr)\n \n# Function call\nif (canPairs(arr, n, k)):\n    print('True')\nelse:\n    print('False')\n \n# This code is contributed by Stream_Cipher\n", "# Function to check if a list can be divided into pairs whose sum is divisible by k\ndef canPairs(nums, k):\n    # If the size of the list is odd, return False\n    if len(nums) % 2 != 0:\n        return False\n \n    # Create a frequency list of size k\n    freq = [0] * k\n \n    for i in nums:\n        y = i % k\n        # If the complement of the current element's remainder exists in the frequency list, decrement its count\n        if freq[(k - y) % k] != 0:\n            freq[(k - y) % k] -= 1\n        # Otherwise, increment the count of the current element's remainder\n        else:\n            freq[y] += 1\n \n    # Check if all elements in the frequency list are 0\n    for i in freq:\n        if i != 0:\n            return False\n \n    return True\n \n# Driver code\narr = [92, 75, 65, 48, 45, 35]\nk = 10\n \n# Function call\nif canPairs(arr, k):\n    print('True')\nelse:\n    print('False')\n"], "Find four elements that sum to a given value (4Sum) | Set 2 -  ": ["# Python3 program to find 4 elements\n# with given sum\n \n# The following structure is needed\n# to store pair sums in aux[]\n \n \nclass pairSum:\n \n    def __init__(self):\n        # Index (int A[]) of first element in pair\n        self.first = ''\n \n        # Index of second element in pair\n        self.sec = ''\n \n        # Sum of the pair\n        self.sum = ''\n \n \n# Function to check if two given pairs\n# have any common element or not\ndef noCommon(a, b):\n    if (a.first == b.first or a.first == b.sec or a.sec == b.first or a.sec == b.sec):\n        return False\n \n    return True\n \n \n# The function finds four\n# elements with given sum X\ndef findFourElements(myArr, sum):\n \n    length = len(myArr)\n \n    # Create an auxiliary array to\n    # store all pair sums\n    size = ((length * (length - 1)) // 2)\n    aux = [None for _ in range(size)]\n \n    # Generate all possible pairs\n    # from A[] and store sums\n    # of all possible pairs in aux[]\n    k = 0\n    for i in range(length - 1):\n        for j in range(i + 1, length):\n            aux[k] = pairSum()\n            aux[k].sum = myArr[i] + myArr[j]\n            aux[k].first = i\n            aux[k].sec = j\n            k += 1\n \n    # Sort the aux[] array using\n    # library function for sorting\n    aux.sort(key=lambda x: x.sum)\n \n    # Now start two index variables\n    # from two corners of array\n    # and move them toward each other.\n    i = 0\n    j = size - 1\n    while (i < size and j >= 0):\n        if ((aux[i].sum + aux[j].sum == sum)\n                and noCommon(aux[i], aux[j])):\n            print(myArr[aux[i].first], myArr[aux[i].sec],\n                  myArr[aux[j].first], myArr[aux[j].sec], sep=', ')\n            return\n \n        elif (aux[i].sum + aux[j].sum < sum):\n            i += 1\n        else:\n            j -= 1\n \n \n# Driver Code\narr = [10, 20, 30, 40, 1, 2]\nX = 91\n \n# Function call\nfindFourElements(arr, X)\n \n \n# This code is contributed by phasing17\n", "# A hashing based Python program to find if there are\n# four elements with given summ.\n \n# The function finds four elements with given summ X\n \n \ndef findFourElements(arr, n, X):\n \n    # Store summs of all pairs in a hash table\n    mp = {}\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            mp[arr[i] + arr[j]] = [i, j]\n \n    # Traverse through all pairs and search\n    # for X - (current pair summ).\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            summ = arr[i] + arr[j]\n \n            # If X - summ is present in hash table,\n            if (X - summ) in mp:\n \n                # Making sure that all elements are\n                # distinct array elements and an element\n                # is not considered more than once.\n                p = mp[X - summ]\n                if (p[0] != i and p[0] != j and p[1] != i and p[1] != j):\n                    print(arr[i], ', ', arr[j], ', ',\n                          arr[p[0]], ', ', arr[p[1]], sep='')\n                    return\n \n \n# Driver code\narr = [10, 20, 30, 40, 1, 2]\nn = len(arr)\nX = 91\n \n# Function call\nfindFourElements(arr, n, X)\n \n# This is code is contributed by shubhamsingh10\n", "# Python3 program to find four  \n# elements with the given sum\n \n# Function to find 4 elements that\n# add up to given sum \ndef fourSum(X, arr, Map, N):\n     \n    temp = [0 for i in range(N)]\n     \n    # Iterate from 0 to length of arr \n    for i in range(N - 1):\n         \n        # Iterate from i + 1 to length of arr\n        for j in range(i + 1, N):\n             \n            # Store curr_sum = arr[i] + arr[j] \n            curr_sum = arr[i] + arr[j]\n \n            # Check if X - curr_sum if present \n            # in map \n            if (X - curr_sum) in Map:\n                 \n                # Store pair having map value \n                # X - curr_sum \n                p = Map[X - curr_sum]\n \n                if (p[0] != i and p[1] != i and\n                    p[0] != j and p[1] != j and\n                    temp[p[0]] == 0 and temp[p[1]] == 0 and\n                    temp[i] == 0 and temp[j] == 0):\n                         \n                    # Print the output \n                    print(arr[i], ',', arr[j], ',', \n                          arr[p[0]], ',', arr[p[1]], \n                          sep = '')\n                           \n                    temp[p[1]] = 1\n                    temp[i] = 1\n                    temp[j] = 1\n                    break\n \n# Function for two Sum \ndef twoSum(nums, N):\n     \n    Map = {}\n     \n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            Map[nums[i] + nums[j]] = []\n            Map[nums[i] + nums[j]].append(i)\n            Map[nums[i] + nums[j]].append(j)\n \n    return Map\n \n# Driver code\narr = [ 10, 20, 30, 40, 1, 2 ]\nn = len(arr)\nX = 91\nMap = twoSum(arr, n)\n \n# Function call \nfourSum(X, arr, Map, n)\n \n# This code is contributed by avanitrachhadiya2155\n"], "Given two unsorted arrays, find all pairs whose sum is x -  ": ["# Python 3 program to find all  \n# pairs in both arrays whose  \n# sum is equal to given value x \n  \n# Function to print all pairs  \n# in both arrays whose sum is \n# equal to given value x \ndef findPairs(arr1, arr2, n, m, x): \n  \n    for i in range(0, n): \n        for j in range(0, m): \n            if (arr1[i] + arr2[j] == x): \n                print(arr1[i], arr2[j]) \n  \n# Driver code \narr1 = [1, 2, 3, 7, 5, 4] \narr2 = [0, 7, 4, 3, 2, 1] \nn = len(arr1) \nm = len(arr2) \nx = 8\nfindPairs(arr1, arr2, n, m, x) \n  \n# This code is contributed by Smitha Dinesh Semwal \n", "A = [ 1, 2, 1, 3, 4 ]; \n  \ndef heapify(n, i): \n    rootLargest = i; \n    lchild = 2 * i; \n    rchild = (2 * i) + 1; \n  \n    if (lchild < n and A[lchild] > A[rootLargest]): \n        rootLargest = lchild; \n  \n    if (rchild < n and A[rchild] > A[rootLargest]): \n        rootLargest = rchild; \n  \n    if (rootLargest != i): \n        t = A[i]; \n        A[i] = A[rootLargest]; \n        A[rootLargest] = t; \n        # Recursion \n        heapify(n, rootLargest); \n      \n  \n  \ndef binarySearch(l, r, x): \n    while (l <= r): \n        m = l + (r - l) // 2; \n  \n        if (A[m] == x): \n            return m; \n  \n        if (A[m] < x): \n            l = m + 1; \n  \n        else: \n            r = m - 1; \n      \n    return -1; \n  \nif __name__ == '__main__': \n  \n    B = [ 3, 1, 5, 1, 2 ]; \n  \n    K = 8; \n  \n    n = len(A); \n      \n    # Building the heap \n    for i in range(n// 2 - 1,0, -1): \n        heapify(n, i); \n  \n    for i in range(n): \n        temp = K - B[i]; \n        if (binarySearch(0, n - 1, temp - 1) != -1): \n            print('\\nFound the elements.'); \n            break; \n          \n# This code is contributed by Rajput-Ji \n", "# Python3 program to find all  \n# pair in both arrays whose  \n# sum is equal to given value x \n  \n# Function to find all pairs  \n# in both arrays whose sum is \n# equal to given value x \ndef findPairs(arr1, arr2, n, m, x): \n  \n    # Insert all elements of  \n    # first array in a hash \n    s = set() \n    for i in range (0, n): \n        s.add(arr1[i]) \n  \n    # Subtract sum from second  \n    # array elements one by one  \n    # and check it's present in \n    # array first or not \n    for j in range(0, m): \n        if ((x - arr2[j]) in s): \n            print((x - arr2[j]), '', arr2[j]) \n  \n# Driver code \narr1 = [1, 0, -4, 7, 6, 4] \narr2 = [0, 2, 4, -3, 2, 1] \nx = 8\n  \nn = len(arr1) \nm = len(arr2) \nfindPairs(arr1, arr2, n, m, x) \n  \n# This code is contributed  \n# by ihritik \n"], "Find number of pairs (x, y) in an array such that x^y > y^x -  ": ["def countPairsBruteForce(X, Y, m, n): \n    ans = 0\n    for i in range(m): \n        for j in range(n): \n            if (pow(X[i], Y[j]) > pow(Y[j], X[i])): \n                ans += 1\n    return ans \n", "# Python3 program to find the number \n# of pairs (x, y) in an array \n# such that x^y > y^x \nimport bisect \n  \n# Function to return count of pairs \n# with x as one element of the pair. \n# It mainly looks for all values in Y \n# where x ^ Y[i] > Y[i] ^ x \n  \n  \ndef count(x, Y, n, NoOfY): \n  \n    # If x is 0, then there cannot be \n    # any value in Y such that \n    # x^Y[i] > Y[i]^x \n    if x == 0: \n        return 0\n  \n    # If x is 1, then the number of pairs \n    # is equal to number of zeroes in Y \n    if x == 1: \n        return NoOfY[0] \n  \n    # Find number of elements in Y[] with \n    # values greater than x, bisect.bisect_right \n    # gets address of first greater element \n    # in Y[0..n-1] \n    idx = bisect.bisect_right(Y, x) \n    ans = n - idx \n  \n    # If we have reached here, then x must be greater than 1, \n    # increase number of pairs for y=0 and y=1 \n    ans += NoOfY[0] + NoOfY[1] \n  \n    # Decrease number of pairs \n    # for x=2 and (y=4 or y=3) \n    if x == 2: \n        ans -= NoOfY[3] + NoOfY[4] \n  \n    # Increase number of pairs \n    # for x=3 and y=2 \n    if x == 3: \n        ans += NoOfY[2] \n  \n    return ans \n  \n# Function to return count of pairs (x, y) \n# such that x belongs to X, \n# y belongs to Y and x^y > y^x \n  \n  \ndef count_pairs(X, Y, m, n): \n  \n    # To store counts of 0, 1, 2, 3, \n    # and 4 in array Y \n    NoOfY = [0] * 5\n    for i in range(n): \n        if Y[i] < 5: \n            NoOfY[Y[i]] += 1\n  \n    # Sort Y so that we can do binary search in it \n    Y.sort() \n    total_pairs = 0  # Initialize result \n  \n    # Take every element of X and \n    # count pairs with it \n    for x in X: \n        total_pairs += count(x, Y, n, NoOfY) \n  \n    return total_pairs \n  \n  \n# Driver Code \nif __name__ == '__main__': \n  \n    X = [2, 1, 6] \n    Y = [1, 5] \n    print('Total pairs = ', \n          count_pairs(X, Y, len(X), len(Y))) \n  \n# This code is contributed by shaswatd673 \n", "# Function to count pairs where an element  \n# from X is greater than an element from Y \ndef count_pairs(X, Y): \n    if len(X) == 0 or len(Y) == 0: \n        return 0\n    if len(X) == 1: \n        return sum(1 for y in Y if y < X[0]) \n    if len(Y) == 1: \n        return sum(1 for x in X if x > Y[0]) \n    X_left, X_right = X[:len(X)//2], X[len(X)//2:] \n    Y_left, Y_right = Y[:len(Y)//2], Y[len(Y)//2:] \n    count = 0\n    count += count_pairs(X_left, Y_left) \n    count += count_pairs(X_left, Y_right) \n    count += count_pairs(X_right, Y_left) \n    count += count_pairs(X_right, Y_right) \n    return count \n  \nX = [2, 1, 6] \nY = [1, 5] \nprint(count_pairs(X, Y)) \n"], "Find the element that appears once in a sorted array -  ": ["# Python3 program to find the element that\n# appears only once\n \n# A Linear Search based function to find\n# the element that appears only once\n \n \ndef search(arr, n):\n \n    ans = -1\n    for i in range(0, n, 2):\n        if (arr[i] != arr[i + 1]):\n            ans = arr[i]\n            break\n    if(arr[n-2] != arr[n-1]):\n        ans = arr[n-1]\n \n    # ans = -1 if no such element is present.\n    print('The required element is', ans)\n \n \n# Driver code\narr = [1, 1, 2, 4, 4, 5, 5, 6, 6]\nLen = len(arr)\n \nsearch(arr, Len)\n \n# This code is contributed by divyesh072019\n", "# Python3 program to find the element that\n# appears only once\n \n# A XOR based function to find\n# the element that appears only once\ndef search(arr, n) :\n \n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n \n    print('The required element is', XOR)\n \n# Driver code\narr = [ 1, 1, 2, 4, 4, 5, 5, 6, 6 ]\nLen = len(arr)\n \nsearch(arr, Len)\n \n# This code is contributed by divyesh072019\n", "def search(nums):\n    # A Binary Search based method to find the element\n    # that appears only once\n    start = 0;\n    end = len(nums)-1;\n    mid = 0;\n \n    # For Edge Cases\n    if (len(nums) == 1): # If only one element is in the array\n        return nums[0];\n \n    if (nums[start] != nums[start + 1]): # If the first element\n                                        # is the element that\n                                        # appears only once\n        return nums[start];\n \n    if (nums[end] != nums[end - 1]): # If Last element is the element\n                                    # that appears only once\n        return nums[end];\n \n    # Binary Search\n    while (start <= end):\n        mid = start + (end - start) // 2;\n         \n        # CASE 1\n        if (nums[mid] != nums[mid - 1] and nums[mid] != nums[mid + 1]):\n           \n            return nums[mid];\n        # CASE 2 and CASE 3\n        elif((nums[mid] == nums[mid + 1] and mid % 2 == 0) or (nums[mid] == nums[mid - 1] and mid % 2 != 0)):\n            start = mid + 1;\n             \n        # CASE 4 and CASE 5\n        else:\n            end = mid - 1;\n     \n    # If no such element found\n    return -1;\n \n# Driver code\nif __name__ == '__main__':\n    arr = [ 1, 1, 2, 4, 4, 5, 5, 6, 6 ];\n \n    element = search(arr);\n \n    if (element != -1):\n        print('The required element is ' , element);\n    else:\n        print('There is no such element');\n \n# This code is contributed by umadevi9616 \n", "# Python3 program to find the element that\n# appears only once\n \n# function to find element using dictionary\n \n \ndef search(arr):\n    # taking dictionary to store frequency\n    freq = {}\n \n    # iterating over array\n    for i in arr:\n        # storing frequency\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n \n    # iterating over dictionary\n    for key, value in freq.items():\n        # if element found\n        if value == 1:\n            # printing element\n            print(key)\n            break\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [1, 1, 2, 4, 4, 5, 5, 6, 6]\n \n    search(arr)\n", "# Python3 program to find the element that\n# appears only once\n  \n# function to find element using stack\ndef singleNonDuplicate(nums):\n    # Declaring an empty list to act as a stack for storing elements\n    stack = []\n \n    # Traversing linearly over the entire array\n    for num in nums:\n        # Checking if the stack is empty or if the current array element is not equal to the stack's top element\n        if not stack or num != stack[-1]:\n            # Pushing the element into the stack if the conditions are satisfied\n            stack.append(num)\n        else:\n            # If the condition doesn't match, it means the current element is a duplicate of the top element in the stack\n            # So, popping the top element from the stack effectively removes the pair from the stack\n            stack.pop()\n \n    # The remaining element in the stack is the element that appears only once\n    return stack[-1]\n \n# Driver code\nif __name__ == '__main__':\n    # Declaring a list\n    arr = [1, 1, 2, 4, 4, 5, 5, 6, 6]\n \n    # Calling the function\n    print(singleNonDuplicate(arr))\n"], "First element occurring k times in an array -  ": ["# Python3 implementation to \n# find first element \n# occurring k times\n \n# function to find the \n# first element occurring \n# k number of times\ndef firstElement(arr, n, k):\n \n    # dictionary to count\n    # occurrences of \n    # each element\n    for i in arr:\n      count=0\n      for j in arr:\n        if i==j:\n          count=count+1\n      if count == k:\n        return i\n             \n    # no element occurs k times\n    return -1\n \n# Driver Code\nif __name__=='__main__':\n \n    arr = [1, 7, 4, 3, 4, 8, 7];\n    n = len(arr)\n    k = 2\n    print(firstElement(arr, n, k))\n \n# This code is contributed by Arpit Jain\n", "# Python3 implementation to \n# find first element \n# occurring k times\n \n# function to find the \n# first element occurring \n# k number of times\ndef firstElement(arr, n, k):\n \n    # dictionary to count\n    # occurrences of \n    # each element\n    count_map = {};\n    for i in range(0, n):\n        if(arr[i] in count_map.keys()):\n            count_map[arr[i]] += 1\n        else:\n            count_map[arr[i]] = 1\n        i += 1\n     \n    for i in range(0, n): \n         \n        # if count of element == k ,\n        # then it is the required\n        # first element \n        if (count_map[arr[i]] == k):\n            return arr[i]\n        i += 1\n             \n    # no element occurs k times\n    return -1\n \n# Driver Code\nif __name__=='__main__':\n \n    arr = [1, 7, 4, 3, 4, 8, 7];\n    n = len(arr)\n    k = 2\n    print(firstElement(arr, n, k))\n \n# This code is contributed \n# by Abhishek Sharma\n"], "Allocate Minimum Number of Pages from N books to M students -  ": ["# Python3 program for optimal allocation of pages\n \n# Utility function to check if\n# current minimum value is feasible or not.\n \n \ndef isPossible(arr, n, m, curr_min):\n    studentsRequired = 1\n    curr_sum = 0\n \n    # iterate over all books\n    for i in range(n):\n \n        # check if current number of pages are\n        # greater than curr_min that means\n        # we will get the result after\n        # mid no. of pages\n        if (arr[i] > curr_min):\n            return False\n \n        # count how many students are required\n        # to distribute curr_min pages\n        if (curr_sum + arr[i] > curr_min):\n \n            # increment student count\n            studentsRequired += 1\n \n            # update curr_sum\n            curr_sum = arr[i]\n \n            # if students required becomes greater\n            # than given no. of students, return False\n            if (studentsRequired > m):\n                return False\n \n        # else update curr_sum\n        else:\n            curr_sum += arr[i]\n \n    return True\n \n# function to find minimum pages\n \n \ndef findPages(arr, n, m):\n \n    sum = 0\n \n    # return -1 if no. of books is\n    # less than no. of students\n    if (n < m):\n        return -1\n \n    # Count total number of pages\n    for i in range(n):\n        sum += arr[i]\n \n    # initialize start as 0 pages and\n    # end as total pages\n    start, end = 0, sum\n    result = 10**9\n \n    # traverse until start <= end\n    while (start <= end):\n \n        # check if it is possible to distribute\n        # books by using mid as current minimum\n        mid = (start + end) // 2\n        if (isPossible(arr, n, m, mid)):\n \n            # update result to current distribution\n              # as it's the best we have found till now.\n            result = mid\n \n            # as we are finding minimum and books\n            # are sorted so reduce end = mid -1\n            # that means\n            end = mid - 1\n \n        else:\n            # if not possible means pages should be\n            # increased so update start = mid + 1\n            start = mid + 1\n \n    # at-last return minimum no. of pages\n    return result\n \n# Driver Code\n \n \n# Number of pages in books\narr = [12, 34, 67, 90]\nn = len(arr)\nm = 2   # No. of students\n \nprint('Minimum number of pages = ',\n      findPages(arr, n, m))\n \n# This code is contributed by Mohit Kumar\n"], "Median of two sorted arrays of same size -  ": ["# A Simple Merge based O(n) Python 3 solution \n# to find median of two sorted lists\n \n# This function returns median of ar1[] and ar2[].\n# Assumptions in this function:\n# Both ar1[] and ar2[] are sorted arrays\n# Both have n elements\ndef getMedian( ar1, ar2 , n):\n    i = 0 # Current index of i/p list ar1[]\n     \n    j = 0 # Current index of i/p list ar2[]\n     \n    m1 = -1\n    m2 = -1\n     \n    # Since there are 2n elements, median\n    # will be average of elements at index\n    # n-1 and n in the array obtained after\n    # merging ar1 and ar2\n    count = 0\n    while count < n + 1:\n        count += 1\n         \n        # Below is to handle case where all\n        # elements of ar1[] are smaller than\n        # smallest(or first) element of ar2[]\n        if i == n:\n            m1 = m2\n            m2 = ar2[0]\n            break\n         \n        # Below is to handle case where all \n        # elements of ar2[] are smaller than\n        # smallest(or first) element of ar1[]\n        elif j == n:\n            m1 = m2\n            m2 = ar1[0]\n            break\n        # equals sign because if two \n        # arrays have some common elements \n        if ar1[i] <= ar2[j]:\n            m1 = m2 # Store the prev median\n            m2 = ar1[i]\n            i += 1\n        else:\n            m1 = m2 # Store the prev median\n            m2 = ar2[j]\n            j += 1\n    return (m1 + m2)/2\n \n# Driver code to test above function\nar1 = [1, 12, 15, 26, 38]\nar2 = [2, 13, 17, 30, 45]\nn1 = len(ar1)\nn2 = len(ar2)\nif n1 == n2:\n    print('Median is ', getMedian(ar1, ar2, n1))\nelse:\n    print('Doesn't work for arrays of unequal size')\n \n# This code is contributed by 'Sharad_Bhardwaj'.\n", "# Python program for above approach\n \n# function to return median of the arrays\n# both are sorted & of same size\ndef getMedian(ar1, ar2, n):\n    i, j = n - 1, 0\n \n    # while loop to swap all smaller numbers to arr1\n    while(ar1[i] > ar2[j] and i > -1 and j < n):\n        ar1[i], ar2[j] = ar2[j], ar1[i]\n        i -= 1\n        j += 1\n \n    ar1.sort()\n    ar2.sort()\n \n    return (ar1[-1] + ar2[0]) >> 1\n \n \n# Driver program\nif __name__ == '__main__':\n    ar1 = [1, 12, 15, 26, 38]\n    ar2 = [2, 13, 17, 30, 45]\n \n    n1, n2 = len(ar1), len(ar2)\n \n    if(n1 == n2):\n        print('Median is', getMedian(ar1, ar2, n1))\n    else:\n        print('Doesn't work for arrays of unequal size')\n \n# This code is contributed by saitejagampala\n"], "Sort elements by frequency -  ": ["# Python3 program that performs the following\n# operations: Sort elements by frequency. If two elements\n# have same count, then put the elements that appears first\n \n# Used for sorting\n \n \nclass ele:\n    def __init__(self):\n \n        self.count = 0\n        self.index = 0\n        self.val = 0\n \n \ndef mycomp(a):\n    return a.val\n \n# Used for sorting by frequency. And if frequency is same,\n# then by appearance\n \n \ndef mycomp2(a):\n    # using negative value for a.index\n    # since the sorting should be in\n    # descending order\n    return (a.count, -a.index)\n \n \ndef sortByFrequency(arr, n):\n    element = [None for _ in range(n)]\n    for i in range(n):\n \n        element[i] = ele()\n \n        # Fill Indexes\n        element[i].index = i\n \n        # Initialize counts as 0\n        element[i].count = 0\n \n        # Fill values in structure\n        # elements\n        element[i].val = arr[i]\n \n    # Sort the structure elements according to value,\n    # we used stable sort so relative order is maintained.\n    #\n    element.sort(key=mycomp)\n \n    # initialize count of first element as 1\n    element[0].count = 1\n \n    # Count occurrences of remaining elements\n    for i in range(1, n):\n \n        if (element[i].val == element[i - 1].val):\n            element[i].count += element[i - 1].count + 1\n \n            # Set count of previous element as -1, we are\n            #  doing this because we'll again sort on the\n            #  basis of counts (if counts are equal than on\n            # the basis of index)*/\n            element[i - 1].count = -1\n \n            # Retain the first index (Remember first index\n            #  is always present in the first duplicate we\n            #  used stable sort. */\n            element[i].index = element[i - 1].index\n \n        # Else If previous element is not equal to current\n        #  so set the count to 1\n        else:\n            element[i].count = 1\n \n    # Now we have counts and first index for each element\n    # so now sort on the basis of count and in case of tie\n    # use index to sort.*/\n    element.sort(key=mycomp2)\n \n    index = 0\n    for i in range(n - 1, -1, -1):\n        if (element[i].count != -1):\n            for j in range(element[i].count):\n                arr[index] = element[i].val\n                index += 1\n \n \n# Driver code\narr = [2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8]\nn = len(arr)\n \n# Function call\nsortByFrequency(arr, n)\n \nprint(*arr)\n \n# This code is contributed by phasing17\n", "# Python3 program for above approach\n \nfrom collections import defaultdict\n \n# Sort by Frequency\n \n \ndef sortByFreq(arr, n):\n    # arr -> Array to be sorted\n    # n   -> Length of Array\n \n    # d is a hashmap(referred as dictionary in python)\n    d = defaultdict(lambda: 0)\n    for i in range(n):\n        d[arr[i]] += 1\n \n    # Sorting the array 'arr' where key\n    # is the function based on which\n    # the array is sorted\n    # While sorting we want to give\n    # first priority to Frequency\n    # Then to value of item\n    arr.sort(key=lambda x: (-d[x], x), reverse = True) \n    #require Updation:- reverse = True, to sort an array in descending order (Jayesh Verma)\n    return (arr)\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8]\n    n = len(arr)\n \n    # Function call\n    solution = sortByFreq(arr, n)\n    print(*solution)\n", "# Python code to implement the approach\nclass Tree:\n    element = None\n \n    # to handle ties\n    first_index = None\n    count = None\n \n \nBST = Tree()\n \n# This code is contributed by phasing17\n", "from collections import defaultdict\nfrom queue import PriorityQueue\n \nclass Compare:\n    def __init__(self, freq, val):\n        self.freq = freq\n        self.val = val\n \n    def __lt__(self, other):\n        if self.freq == other.freq:\n            return self.val < other.val\n        return self.freq > other.freq\n \ndef solve(arr):\n    n = len(arr)\n    mpp = defaultdict(int)\n    for a in arr:\n        mpp[a] += 1\n    max_heap = PriorityQueue()\n    for key, value in mpp.items():\n        max_heap.put(Compare(value, key))\n \n    i = 0\n    while not max_heap.empty():\n        item = max_heap.get()\n        freq = item.freq\n        val = item.val\n        for _ in range(freq):\n            arr[i] = val\n            i += 1\n    return arr\n \nvec = [2, 5, 2, 8, 5, 6, 8, 8]\nprint(solve(vec))\n"], "Merge two sorted arrays -  ": ["# Python program to merge two sorted arrays/\ndef mergeArrays(arr1, arr2, n1, n2, arr3):\n    i = 0\n    j = 0\n    k = 0\n \n    # traverse the arr1 and insert its element in arr3\n    while(i < n1):\n        arr3[k] = arr1[i]\n        k += 1\n        i += 1\n \n    # now traverse arr2 and insert in arr3\n    while(j < n2):\n        arr3[k] = arr2[j]\n        k += 1\n        j += 1\n \n    # sort the whole array arr3\n    arr3.sort()\n \n \n# Driver code\nif __name__ == '__main__':\n    arr1 = [1, 3, 5, 7]\n    n1 = len(arr1)\n \n    arr2 = [2, 4, 6, 8]\n    n2 = len(arr2)\n \n    arr3 = [0 for i in range(n1+n2)]\n    mergeArrays(arr1, arr2, n1, n2, arr3)\n \n    print('Array after merging')\n    for i in range(n1 + n2):\n        print(arr3[i], end=' ')\n \n# This code is contributed by Tapesh(tapeshdua420)\n", "# Python program to merge\n# two sorted arrays\n \n# Merge arr1[0..n1-1] and \n# arr2[0..n2-1] into \n# arr3[0..n1+n2-1]\ndef mergeArrays(arr1, arr2, n1, n2):\n    arr3 = [None] * (n1 + n2)\n    i = 0\n    j = 0\n    k = 0\n \n    # Traverse both array\n    while i < n1 and j < n2:\n     \n        # Check if current element \n        # of first array is smaller \n        # than current element of \n        # second array. If yes, \n        # store first array element \n        # and increment first array\n        # index. Otherwise do same \n        # with second array\n        if arr1[i] < arr2[j]:\n            arr3[k] = arr1[i]\n            k = k + 1\n            i = i + 1\n        else:\n            arr3[k] = arr2[j]\n            k = k + 1\n            j = j + 1\n     \n \n    # Store remaining elements\n    # of first array\n    while i < n1:\n        arr3[k] = arr1[i];\n        k = k + 1\n        i = i + 1\n \n    # Store remaining elements \n    # of second array\n    while j < n2:\n        arr3[k] = arr2[j];\n        k = k + 1\n        j = j + 1\n    print('Array after merging')\n    for i in range(n1 + n2):\n        print(str(arr3[i]), end = ' ')\n \n# Driver code\narr1 = [1, 3, 5, 7]\nn1 = len(arr1)\n \narr2 = [2, 4, 6, 8]\nn2 = len(arr2)\nmergeArrays(arr1, arr2, n1, n2);\n \n# This code is contributed\n# by ChitraNayal\n", "# Python program to merge two sorted arrays\n# using maps\nimport bisect\n \n# Function to merge arrays\ndef mergeArrays(a, b, n, m):\n    # Declaring a map.\n    # using map as a inbuilt tool\n    # to store elements in sorted order.\n    mp=[]\n     \n    # Inserting values to a map.\n    for i in range(n):\n        bisect.insort(mp, a[i])\n         \n    for i in range(m):\n        bisect.insort(mp, b[i])\n     \n    # Printing keys of the map.\n    for i in mp:\n        print(i,end=' ')\n         \n# Driver code\narr1 = [1, 3, 5, 7]\narr2 = [2, 4, 6, 8]\nsize = len(arr1)\nsize1 = len(arr2)\n \n# Function call\nmergeArrays(arr1, arr2, size, size1)\n \n# This code is contributed by Pushpesh Raj\n"], "Find a pair of elements swapping which makes sum of two arrays same -  ": ["# Python code naive solution to find a pair swapping\n# which makes sum of lists sum.\n \n# Function to calculate sum of elements of list\ndef getSum(X):\n    sum=0\n    for i in X:\n        sum+=i\n    return sum\n \n# Function to prints elements to be swapped\ndef findSwapValues(A,B):\n    # Calculation if sums from both lists\n    sum1=getSum(A)\n    sum2=getSum(B)\n \n    # Boolean variable used to reduce further iterations\n    # after the pair is found\n    k=False\n \n    # Lool for val1 and val2, such that\n    # sumA - val1 + val2 = sumB -val2 + val1\n    val1,val2=0,0\n    for i in A:\n        for j in B:\n            newsum1=sum1-i+j\n            newsum2=sum2-j+i\n             \n            if newsum1 ==newsum2:\n                val1=i\n                val2=j\n                # Set to True when pair is found\n                k=True\n                break\n        # If k is True, it means pair is found.\n        # So, no further iterations.\n        if k==True:\n            break\n    print (val1,val2)\n    return\n \n \n# Driver code\nA=[4,1,2,1,1,2]\nB=[3,6,3,3]\n \n# Call to function\nfindSwapValues(A,B)\n \n# code contributed by sachin bisht\n", "# Python Code for naive implementation\n \n# Function to calculate sum of elements of list\ndef getSum(X):\n    sum=0\n    for i in X:\n        sum+=i\n    return sum\n \n# Function to calculate : a-b = (sumA - sumB) / 2\ndef getTarget(A,B):\n \n    #Calculations of sums from both lists\n    sum1=getSum(A)\n    sum2=getSum(B)\n \n    # Because the target must be an integer\n    if( (sum1-sum2)%2!=0):\n        return 0\n    return (sum1-sum2)//2\n \n \ndef findSwapValues(A,B):\n    target=getTarget(A,B)\n    if target==0:\n        return\n \n    # Boolean variable used to reduce further iterations\n    # after the pair is found\n    flag=False\n \n    # Look for val1 and val2, such that\n    # val1 - val2 = (sumA -sumB) /2\n    val1,val2=0,0\n    for i in A:\n        for j in B:\n             \n            if i-j == target:\n                val1=i\n                val2=j\n                # Set to True when pair is found\n                flag=True\n                break\n        if flag==True:\n            break\n    print (val1,val2)\n    return\n \n \n# Driver code\nA=[4,1,2,1,1,2]\nB=[3,6,3,3]\n \n# Call to function\nfindSwapValues(A,B)\n \n# code contributed by sachin bisht\n", "# Python code for optimized implementation\n \n#Returns sum of elements in list\ndef getSum(X):\n    sum=0\n    for i in X:\n        sum+=i\n    return sum\n \n# Finds value of\n# a - b = (sumA - sumB) / 2\ndef getTarget(A,B):\n    # Calculations of sumd from both lists\n    sum1=getSum(A)\n    sum2=getSum(B)\n \n    # Because that target must be an integer\n    if( (sum1-sum2)%2!=0):\n        return 0\n    return (sum1-sum2)//2\n \n# Prints elements to be swapped\ndef findSwapValues(A,B):\n    # Call for sorting the lists\n    A.sort()\n    B.sort()\n \n    #Note that target can be negative\n    target=getTarget(A,B)\n \n    # target 0 means, answer is not possible\n    if(target==0):\n        return\n    i,j=0,0\n    while(i<len(A) and j<len(B)):\n        diff=A[i]-B[j]\n        if diff == target:\n            print (A[i],B[j])\n            return\n        # Look for a greater value in list A\n        elif diff <target:\n            i+=1\n        # Look for a greater value in list B\n        else:\n            j+=1\n \nA=[4,1,2,1,1,2]\nB=[3,6,3,3]\n \nfindSwapValues(A,B)\n \n#code contributed by sachin bisht\n", "# Python Code for the above approach\ndef findSwapValues(a, m, b, n):\n \n    # initialize 2 dictionary. dictionary takes operations (i.e. search,\n    # insert, delete) in O(1) time on an average.\n    x, y = {}, {}\n \n    s1, s2 = 0, 0\n \n    # Determining sum s1 of the elements of array\n    # a[], and simultaneously inserting the array in the dictionary x\n    for i in range(m):\n        s1 += a[i]\n        x[a[i]] = x.get(a[i], 0) + 1\n \n    # Determining sum s2 of the elements of array\n    # b[], and simultaneously inserting the array in the dictionary y\n    for i in range(n):\n        s2 += b[i]\n        y[b[i]] = y.get(b[i], 0) + 1\n \n    if (s1 - s2) % 2:  # Checking if difference between the two arrays sums is even or not\n        print('No such values exist.')\n        return\n \n    for p in x:\n        q = ((s2 - s1)//2) + p\n        if q in y:  # Finding q for a given p in O(1) time.\n            print(p, q)\n            return\n    print('No such values exist.')\n \n \nif __name__ == '__main__':\n    a = [4, 1, 2, 1, 1, 2]\n    b = [1, 6, 3, 3]\n    m = len(a)\n    n = len(b)\n    findSwapValues(a, m, b, n)\n# This Code is Contributed by Vivek Maddeshiya\n"], "K-th Element of Two Sorted Arrays -  ": ["# Program to find kth element\n# from two sorted arrays\n \n \ndef kth(arr1, arr2, m, n, k):\n \n    sorted1 = [0] * (m + n)\n    i = 0\n    j = 0\n    d = 0\n    while (i < m and j < n):\n \n        if (arr1[i] < arr2[j]):\n            sorted1[d] = arr1[i]\n            i += 1\n        else:\n            sorted1[d] = arr2[j]\n            j += 1\n        d += 1\n \n    while (i < m):\n        sorted1[d] = arr1[i]\n        d += 1\n        i += 1\n    while (j < n):\n        sorted1[d] = arr2[j]\n        d += 1\n        j += 1\n    return sorted1[k - 1]\n \n \n# Driver code\narr1 = [2, 3, 6, 7, 9]\narr2 = [1, 4, 8, 10]\nk = 5\nprint(kth(arr1, arr2, 5, 4, k))\n \n# This code is contributed by Smitha Dinesh Semwal\n", "# Python3 Program to find kth element \n# from two sorted arrays\n \ndef find(A, B, m, n, k_req):    \n    i, j, k = 0, 0, 0\n \n    # Keep taking smaller of the current\n    # elements of two sorted arrays and\n    # keep incrementing k\n    while i < len(A) and j < len(B):\n        if A[i] < B[j]:\n            k += 1\n            if k == k_req:\n                return A[i]\n            i += 1\n        else:\n            k += 1\n            if k == k_req:\n                return B[j]        \n            j += 1\n \n    # If array B[] is completely traversed\n    while i < len(A):\n        k += 1\n        if k == k_req:\n                return A[i]\n        i += 1\n \n \n    # If array A[] is completely traversed\n    while j < len(B):\n        k += 1\n        if k == k_req:\n                return B[j]\n        j += 1\n \n# driver code\nA = [2, 3, 6, 7, 9]\nB = [1, 4, 8, 10]\nk = 5;\nprint(find(A, B, 5, 4, k))\n# time complexity of O(k)\n", "# Python program to find k-th element from two sorted arrays\ndef kth(arr1, arr2, n, m, k):\n \n    if n == 1 or m == 1:\n        if m == 1:\n            arr2, arr1 = arr1, arr2\n            m = n\n        if k == 1:\n            return min(arr1[0], arr2[0])\n        elif k == m + 1:\n            return max(arr1[0], arr2[0])\n        else:\n            if arr2[k - 1] < arr1[0]:\n                return arr2[k - 1]\n            else:\n                return max(arr1[0], arr2[k - 2])\n \n    mid1 = (n - 1)//2\n    mid2 = (m - 1)//2\n \n    if mid1+mid2+1 < k:\n        if arr1[mid1] < arr2[mid2]:\n            return kth(arr1[mid1 + 1:], arr2, n - mid1 - 1, m, k - mid1 - 1)\n        else:\n            return kth(arr1, arr2[mid2 + 1:], n, m - mid2 - 1, k - mid2 - 1)\n    else:\n        if arr1[mid1] < arr2[mid2]:\n            return kth(arr1, arr2[:mid2 + 1], n, mid2 + 1, k)\n        else:\n            return kth(arr1[:mid1 + 1], arr2, mid1 + 1, m, k)\n \n \nif __name__ == '__main__':\n    arr1 = [2, 3, 6, 7, 9]\n    arr2 = [1, 4, 8, 10]\n    k = 5\n    print(kth(arr1, arr2, 5, 4, k))\n \n# This code is contributed by harshitkap00r\n", "# Python3 program to find kth element from\n# two sorted arrays\ndef kth(arr1, arr2, m, n, k, st1 = 0, st2 = 0):\n     \n    # In case we have reached end of array 1\n    if (st1 == m):\n        return arr2[st2 + k - 1]\n \n    # In case we have reached end of array 2\n    if (st2 == n):\n        return arr1[st1 + k - 1]\n \n    # k should never reach 0 or exceed sizes\n    # of arrays\n    if (k == 0 or k > (m - st1) + (n - st2)):\n        return -1\n         \n    # Compare first elements of arrays and return\n    if (k == 1):\n        if(arr1[st1] < arr2[st2]):\n            return arr1[st1]\n        else:\n            return arr2[st2]\n \n    curr = int(k / 2)\n \n    # Size of array 1 is less than k / 2\n    if(curr - 1 >= m - st1):\n \n        # Last element of array 1 is not kth\n        # We can directly return the (k - m)th\n        # element in array 2\n        if (arr1[m - 1] < arr2[st2 + curr - 1]):\n            return arr2[st2 + (k - (m - st1) - 1)]\n        else:\n            return kth(arr1, arr2, m, n, \n                       k - curr, st1, st2 + curr)\n \n    # Size of array 2 is less than k / 2\n    if (curr - 1 >= n - st2):\n        if (arr2[n - 1] < arr1[st1 + curr - 1]):\n            return arr1[st1 + (k - (n - st2) - 1)]\n        else:\n            return kth(arr1, arr2, m, n, \n                       k - curr,st1 + curr, st2)\n    else:\n         \n        # Normal comparison, move starting index\n        # of one array k / 2 to the right\n        if (arr1[curr + st1 - 1] < arr2[curr + st2 - 1]):\n            return kth(arr1, arr2, m, n, k - curr,\n                       st1 + curr, st2)\n        else:\n            return kth(arr1, arr2, m, n, k - curr,\n                       st1, st2 + curr)\n \n# Driver code\narr1 = [ 2, 3, 6, 7, 9 ]\narr2 = [ 1, 4, 8, 10 ]\nk = 5\n \nprint(kth(arr1, arr2, 5, 4, k))\n \n# This code is contributed by avanitrachhadiya2155\n", "# Python3 Program to find kth element from two\n# sorted arrays. Time Complexity: O(log k)\ndef kth(arr1, m, arr2, n, k):\n     \n    if (k > (m + n) or k < 1):\n        return -1\n     \n    # Let m <= n\n    if (m > n):\n        return kth(arr2, n, arr1, m, k)\n     \n    # Check if arr1 is empty returning \n    # k-th element of arr2\n    if (m == 0):\n        return arr2[k - 1]\n     \n    # Check if k = 1 return minimum of \n    # first two elements of both\n    # arrays\n    if (k == 1):\n        return min(arr1[0], arr2[0])\n         \n    # Now the divide and conquer part\n    i = min(m, k // 2)\n    j = min(n, k // 2)\n     \n    if (arr1[i - 1] > arr2[j - 1]):\n         \n        # Now we need to find only \n        # k-j th element since we\n        # have found out the lowest j\n        return kth(arr1, m, arr2[j:], n - j, k - j)\n    else:\n         \n        # Now we need to find only\n        # k-i th element since we\n        # have found out the lowest i\n        return kth(arr1[i:], m - i, arr2, n, k - i)\n \n# Driver code\narr1 = [ 2, 3, 6, 7, 9 ]\narr2 = [ 1, 4, 8, 10 ]\nm = len(arr1)\nn = len(arr2)\nk = 5\n \nans = kth(arr1, m, arr2, n, k)\n \nif (ans == -1):\n    print('Invalid query')\nelse:\n    print(ans)\n \n# This code is contributed by Shubham Singh\n", "# Python Program to find kth element \n# from two sorted arrays\n \n# Function to find K-th min\ndef kth(a , b , n , m , k):\n \n    # Declaring a min heap\n    pq = [];\n \n    # Pushing elements for\n    # array a to min-heap\n    for i in range(n):\n        pq.append(a[i]);\n \n    # Pushing elements for\n    # array b to min-heap\n    for i in range(m):\n        pq.append(b[i]);\n \n    pq = sorted(pq, reverse = True)\n     \n    # Popping-out K-1 elements\n    while (k > 1):\n        k -= 1;\n        pq.pop();\n    return pq.pop();\n \n# Driver Code\narr1 = [ 2, 3, 6, 7, 9 ];\narr2 = [ 1, 4, 8, 10 ];\nk = 5;\nprint(kth(arr1, arr2, 5, 4, k));\n \n# This code is contributed by Saurabh Jaiswal\n", "# Python program to find the kth element\nmaxN = 10**10 # the maximum value in the array possible.\n \ndef upperBound(a, low, high, element):\n    while(low < high):\n        middle = low + (high - low)//2\n        if(a[middle] > element):\n            high = middle\n        else:\n            low = middle + 1\n    return low\n \ndef kthElement(arr1, arr2, n, m, k):\n    left = 1\n    right = maxN # The range of where ans can lie.\n    ans = 10**15 # We have to find min of all\n    # the ans so take .\n     \n    # using binary search to check all possible values of\n    # kth element\n    while (left <= right):\n        mid = (left + right) // 2\n        up_cnt = upperBound(arr1,0, n, mid)\n        up_cnt += upperBound(arr2, 0, m, mid)\n         \n        if (up_cnt >= k):\n            ans = min(ans, mid) # find the min of all answers.\n            right= mid - 1 # Try to find a smaller answer.\n        else:\n            left = mid + 1 # Current mid is too small so\n            # shift right.\n    return ans\n \n# Driver code\n# Example 1\nn = 5\nm = 7\nk = 7\narr1 = [100, 112, 256, 349, 770]\narr2 = [72, 86, 113, 119, 265, 445, 892]\nprint(kthElement(arr1, arr2, n, m, k))\n \n# This code is contributed by Shubham Singh\n"], "Reverse an Array in groups of given size -  ": ["# Python 3 program to reverse every \n# sub-array formed by consecutive k\n# elements\n \n# Function to reverse every sub-array\n# formed by consecutive k elements\ndef reverse(arr, n, k):\n    i = 0\n     \n    while(i<n):\n     \n        left = i \n \n        # To handle case when k is not\n        # multiple of n\n        right = min(i + k - 1, n - 1) \n \n        # Reverse the sub-array [left, right]\n        while (left < right):\n             \n            arr[left], arr[right] = arr[right], arr[left]\n            left+= 1;\n            right-=1\n        i+= k\n     \n# Driver code\narr = [1, 2, 3, 4, 5, 6,\n                   7, 8] \n \nk = 3\nn = len(arr) \nreverse(arr, n, k)\n \nfor i in range(0, n):\n        print(arr[i], end =' ')\n         \n# This code is contributed by Smitha Dinesh Semwal\n", "# Function to reverse subarrays of size k in an array\n# Nikunj Sonigara\ndef reverse(arr, n, k):\n    j = 0\n    i = k\n \n    # Reverse subarrays of size k until the end of the array is reached\n    while i < n:\n        # Reverse the subarray from arr[j] to arr[i-1]\n        reverse_array(arr, j, i - 1)\n \n        # Move to the next subarray of size k\n        i += k\n        j += k\n \n    # Reverse the remaining subarray of size less than k\n    reverse_array(arr, j, n - 1)\n \n \n# Function to reverse an array from index start to end\ndef reverse_array(arr, start, end):\n    while start < end:\n        arr[start], arr[end] = arr[end], arr[start]\n        start += 1\n        end -= 1\n \n \n# Driver code\nif __name__ == '__main__':\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    k = 3\n    n = len(arr)\n \n    # Reverse subarrays of size k in the array\n    reverse(arr, n, k)\n \n    # Print the reversed array\n    print(*arr)\n"], "Find an element in array such that sum of left array is equal to sum of right array -  ": ["# Python 3 Program to find an element\n# such that sum of right side element\n# is equal to sum of left side\n \n# Function to Find an element in\n# an array such that left and right\n# side sums are equal\n \n \ndef findElement(arr, n):\n    for i in range(1, n):\n        leftSum = sum(arr[0:i])\n        rightSum = sum(arr[i+1:])\n        if(leftSum == rightSum):\n            return arr[i]\n    return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # Case 1\n    arr = [1, 4, 2, 5]\n    n = len(arr)\n    print(findElement(arr, n))\n \n    # Case 2\n    arr = [2, 3, 4, 1, 4, 5]\n    n = len(arr)\n    print(findElement(arr, n))\n \n# This code is contributed by Bhanu Teja Kodali\n", "# Python 3 Program to find an element \n# such that sum of right side element \n# is equal to sum of left side\n \n# Function for Finds an element in \n# an array such that left and right\n# side sums are equal \ndef findElement(arr, n) :\n     \n    # Forming prefix sum array from 0 \n    prefixSum = [0] * n\n    prefixSum[0] = arr[0]\n    for i in range(1, n) :\n        prefixSum[i] = prefixSum[i - 1] + arr[i]\n \n    # Forming suffix sum array from n-1\n    suffixSum = [0] * n\n    suffixSum[n - 1] = arr[n - 1]\n    for i in range(n - 2, -1, -1) :\n        suffixSum[i] = suffixSum[i + 1] + arr[i]\n \n    # Find the point where prefix \n    # and suffix sums are same.\n    for i in range(1, n - 1, 1) :\n        if prefixSum[i] == suffixSum[i] :\n            return arr[i]\n         \n    return -1\n \n# Driver Code\nif __name__ == '__main__' :\n     \n    arr = [ 1, 4, 2, 5]\n    n = len(arr)\n    print(findElement(arr, n))\n \n# This code is contributed by ANKITRAI1\n", "# Python 3 Program to find an element \n# such that sum of right side element \n# is equal to sum of left side\n \n# Function to compute partition\ndef findElement(arr, size) :\n \n    right_sum, left_sum = 0, 0\n \n    # Computing right_sum\n    for i in range(1, size) :\n        right_sum += arr[i]\n \n    i, j = 0, 1\n \n    # Checking the point of partition \n    # i.e. left_Sum == right_sum \n    while j < size :\n        right_sum -= arr[j]\n        left_sum += arr[i]\n \n        if left_sum == right_sum :\n            return arr[i + 1]\n \n        j += 1\n        i += 1\n \n    return -1\n \n# Driver Code\nif __name__ == '__main__' :\n     \n    arr = [ 2, 3, 4, 1, 4, 5]\n    n = len(arr)\n    print(findElement(arr, n))\n \n# This code is contributed by ANKITRAI1\n", "# Python3 program to find an element\n# such that sum of right side element\n# is equal to sum of left side\n \n# Function to compute partition\ndef findElement(arr, size):\n   \n    # Maintains left cumulative sum\n    left_sum = 0;\n \n    # Maintains right cumulative sum\n    right_sum = 0;\n    i = 0; j = -1;\n    j = size - 1;\n     \n    while(i < j):\n        if(i < j):\n            left_sum += arr[i];\n            right_sum += arr[j];\n \n            # Keep moving i towards center \n            # until left_sum is found \n            # lesser than right_sum\n            while (left_sum < right_sum and\n                   i < j):\n                i += 1;\n                left_sum += arr[i];\n \n            # Keep moving j towards center\n            # until right_sum is found \n            # lesser than left_sum\n            while (right_sum < left_sum and\n                   i < j):\n                j -= 1;\n                right_sum += arr[j];\n            j -= 1\n            i += 1\n    if (left_sum == right_sum && i == j):\n        return arr[i];\n    else:\n        return -1;\n \n# Driver code\nif __name__ == '__main__':\n   \n    arr = [2, 3, 4, \n           1, 4, 5];\n    size = len(arr);\n    print(findElement(arr, size));\n \n# This code is contributed by shikhasingrajput\n", "# Function to find equilibrium point\n# a: input array\n# n: size of array\ndef equilibriumPoint(a, n):\n \n    # Here we define two pointers to the array -> start =\n    # 0, end = n-1 Two variables to take care of sum ->\n    # left_sum = 0, right_sum = 0\n    i,start,end,left_sum,right_sum = 0,0,n - 1,0,0\n \n    for i in range(n):\n \n        # if the equilibrium element is found our start\n        # will be equal to end variable and left_sum will\n        # be equal right_sum => return the equilibrium\n        # element\n        if (start == end and right_sum == left_sum):\n            return a[start]\n \n        # if start is equal to end variable but left_sum is\n        # not equal right_sum => no equilibrium element\n        # return -1\n        if (start == end):\n            return -1\n \n        # if left_sum > right_sum => add the current end\n        # element to the right_sum and decrement end\n        if (left_sum > right_sum):\n            right_sum += a[end]\n            end -= 1\n \n        # if right_sum < left_sum => add the current start\n        # element to the left_sum and increment start\n        elif (right_sum > left_sum):\n            left_sum += a[start]\n            start += 1\n         \n        #     if left_sum is equal right_sum but start is not\n        # equal to end => we are still in the middle of\n        # algorithm even though we found that left_sum is\n        # equal right_sum we haven't got that one required\n        # equilibrium element (So, in this case add the\n        # current end element to the right_sum and\n        # decrement end (or) add the current start element\n        # to the left_sum and increment start, to make our\n        # algorithm continue further)\n        else:\n            right_sum += a[end]\n            end -= 1\n \n    # When there is only one element in array our algorithm\n    # exits without entering for loop So we can check if our\n    # functions enters the loop if not we can directly\n    # return the value as answer\n    if (not i):\n        return a[0]\n \n# Driver code\narr = [ 2, 3, 4, 1, 4, 5 ]\nsize = len(arr)\nprint(equilibriumPoint(arr, size))\n \n# This code is contributed by Shinjanpatra\n", "def sum(A):\n    result = 0\n    for item in A:\n        result += item\n    return result\n \ndef equilibriumPoint(A, N):\n    index = N // 2\n    left_sum = sum(A[:index])\n    right_sum = sum(A[index+1:])\n     \n    if left_sum == right_sum:\n        return A[index]\n     \n    elif left_sum > right_sum:\n        while(index >= 0):\n            left_sum -= A[index-1]\n            right_sum += A[index]\n            index -= 1\n            if right_sum > left_sum:\n                return -1\n            elif left_sum == right_sum:\n                return A[index]\n     \n    elif right_sum > left_sum:\n        while(index <= N-1):\n            left_sum += A[index]\n            right_sum -= A[index+1]\n            index += 1\n            if left_sum > right_sum:\n                return -1\n            elif left_sum == right_sum:\n                return A[index]\n     \n    else:\n        return -1\n     \n \n# Driver code\narr = [ 2, 3, 4, 1, 4, 5 ]\nsize = len(arr)\nprint(equilibriumPoint(arr, size))\n                 \n            \n"], "Given an integer array A of non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Problem Constraints 1 <= |A| <= 100000 Input Format The only argument given is integer array A. Output Format Return the total water it is able to trap after raining. Example Input Input 1: A = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] Input 2: A = [1, 2] Example Output Output 1: 6 Output 2: 0 Example Explanation Explanation 1: In this case, 6 units of rain water (blue section) are being trapped. Explanation 2: No water is trapped.": "class Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def trap(self, A):\n        left_max, right_max=0, 0\n        l=0\n        h=len(A)-1\n        water=0\n        while(l<=h):\n            if A[l]<A[h]:\n                if A[l]>left_max:\n                    left_max=A[l]\n                else:\n                    water+=left_max-A[l]\n                l+=1\n            else:\n                if A[h]>right_max:\n                    right_max=A[h]\n                else:\n                    water+=right_max-A[h]\n                h-=1\n        return water\n                    \n\n\n", "Program to count leaf nodes in a binary tree -  ": ["# Python program to count leaf nodes in Binary Tree\n \n# A Binary tree node\nclass Node:\n     \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data \n        self.left = None\n        self.right = None\n \n# Function to get the count of leaf nodes in binary tree\ndef getLeafCount(node):\n    if node is None:\n        return 0\n    if(node.left is None and node.right is None):\n        return 1\n    else:\n        return getLeafCount(node.left) + getLeafCount(node.right)\n \n \n# Driver program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\n \nprint ('Leaf count of the tree is %d' %(getLeafCount(root)))\n \n#This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"], "Implement a stack using singly linked list -  ": ["# python3 program to Implement a stack\n# using singly linked list\n \nclass Node:\n \n    # Class to create nodes of linked list\n    # constructor initializes node automatically\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass Stack:\n \n    # head is default NULL\n    def __init__(self):\n        self.head = None\n \n    # Checks if stack is empty\n    def isempty(self):\n        if self.head == None:\n            return True\n        else:\n            return False\n \n    # Method to add data to the stack\n    # adds to the start of the stack\n    def push(self, data):\n \n        if self.head == None:\n            self.head = Node(data)\n \n        else:\n            newnode = Node(data)\n            newnode.next = self.head\n            self.head = newnode\n \n    # Remove element that is the current head (start of the stack)\n    def pop(self):\n \n        if self.isempty():\n            return None\n \n        else:\n            # Removes the head node and makes\n            # the preceding one the new head\n            poppednode = self.head\n            self.head = self.head.next\n            poppednode.next = None\n            return poppednode.data\n \n    # Returns the head node data\n    def peek(self):\n \n        if self.isempty():\n            return None\n \n        else:\n            return self.head.data\n \n    # Prints out the stack\n    def display(self):\n \n        iternode = self.head\n        if self.isempty():\n            print('Stack Underflow')\n \n        else:\n \n            while(iternode != None):\n \n                print(iternode.data, end = '')\n                iternode = iternode.next\n                if(iternode != None):\n                    print(' -> ', end = '')\n            return\n \n \n# Driver code\nif __name__ == '__main__':\n  MyStack = Stack()\n   \n  MyStack.push(11)\n  MyStack.push(22)\n  MyStack.push(33)\n  MyStack.push(44)\n \n  # Display stack elements\n  MyStack.display()\n \n  # Print top element of stack\n  print('\\nTop element is ', MyStack.peek())\n \n  # Delete top elements of stack\n  MyStack.pop()\n  MyStack.pop()\n \n  # Display stack elements\n  MyStack.display()\n \n  # Print top element of stack\n  print('\\nTop element is ', MyStack.peek())\n \n# This code is contributed by Mathew George\n"], "Queue - Linked List Implementation -  ": ["# Python3 program to demonstrate linked list\n# based implementation of queue\n \n# A linked list (LL) node\n# to store a queue entry\n \n \nclass Node:\n \n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n# A class to represent a queue\n \n# The queue, front stores the front node\n# of LL and rear stores the last node of LL\n \n \nclass Queue:\n \n    def __init__(self):\n        self.front = self.rear = None\n \n    def isEmpty(self):\n        return self.front == None\n \n    # Method to add an item to the queue\n    def EnQueue(self, item):\n        temp = Node(item)\n \n        if self.rear == None:\n            self.front = self.rear = temp\n            return\n        self.rear.next = temp\n        self.rear = temp\n \n    # Method to remove an item from queue\n    def DeQueue(self):\n \n        if self.isEmpty():\n            return\n        temp = self.front\n        self.front = temp.next\n \n        if(self.front == None):\n            self.rear = None\n \n \n# Driver Code\nif __name__ == '__main__':\n    q = Queue()\n    q.EnQueue(10)\n    q.EnQueue(20)\n    q.DeQueue()\n    q.DeQueue()\n    q.EnQueue(30)\n    q.EnQueue(40)\n    q.EnQueue(50)\n    q.DeQueue()\n    print('Queue Front : ' + str(q.front.data if q.front != None else -1))\n    print('Queue Rear : ' + str(q.rear.data if q.rear != None else -1))\n"], "Merge two sorted linked lists -  ": ["# Python program for the above approach\n# link list node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n         \n \n# return a newnode\ndef newNode(key):\n    return Node(key)\n \n \n# driver code\n#let us create two sorted linked lists to test the above\n#function. Created lists shall be\n#a: 5->10->15->40\n#b: 2->3->20\na = Node(5)\na.next = Node(10)\na.next.next = Node(15)\na.next.next.next = Node(40)\n \nb = Node(2)\nb.next = Node(3)\nb.next.next = Node(20)\n \nv = []\nwhile(a is not None):\n    v.append(a.key)\n    a = a.next\n \nwhile(b is not None):\n    v.append(b.key)\n    b = b.next\n \nv.sort()\nresult = Node(-1)\ntemp = result\nfor i in range(len(v)):\n    result.next = Node(v[i])\n    result = result.next\n \ntemp = temp.next\nprint('Resultant Merge Linked List is : ')\nwhile(temp is not None):\n    print(temp.key, end=' ')\n    temp = temp.next\n \n# THIS CODE IS CONTRIBUTED BY KIRTI AGARWAL(KIRTIAGARWAL23121999)\n", "''' Python program to merge two\nsorted linked lists '''\n \n \n# Linked List Node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \n# Create & Handle List operations\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n \n    # Method to display the list\n    def printList(self):\n        temp = self.head\n        while temp:\n            print(temp.data, end=' ')\n            temp = temp.next\n \n    # Method to add element to list\n    def addToList(self, newData):\n        newNode = Node(newData)\n        if self.head is None:\n            self.head = newNode\n            return\n \n        last = self.head\n        while last.next:\n            last = last.next\n \n        last.next = newNode\n \n \n# Function to merge the lists\n# Takes two lists which are sorted\n# joins them to get a single sorted list\ndef mergeLists(headA, headB):\n \n    # A dummy node to store the result\n    dummyNode = Node(0)\n \n    # Tail stores the last node\n    tail = dummyNode\n    while True:\n \n        # If any of the list gets completely empty\n        # directly join all the elements of the other list\n        if headA is None:\n            tail.next = headB\n            break\n        if headB is None:\n            tail.next = headA\n            break\n \n        # Compare the data of the lists and whichever is smaller is\n        # appended to the last of the merged list and the head is changed\n        if headA.data <= headB.data:\n            tail.next = headA\n            headA = headA.next\n        else:\n            tail.next = headB\n            headB = headB.next\n \n        # Advance the tail\n        tail = tail.next\n \n    # Returns the head of the merged list\n    return dummyNode.next\n \n \n# Create 2 lists\nlistA = LinkedList()\nlistB = LinkedList()\n \n# Add elements to the list in sorted order\nlistA.addToList(5)\nlistA.addToList(10)\nlistA.addToList(15)\n \nlistB.addToList(2)\nlistB.addToList(3)\nlistB.addToList(20)\n \n# Call the merge function\nlistA.head = mergeLists(listA.head, listB.head)\n \n# Display merged list\nprint('Merged Linked List is:')\nlistA.printList()\n \n''' This code is contributed\nby Debidutta Rath '''\n", "# Python3 program merge two sorted linked\n# in third linked list using recursive.\n \n# Node class\n \n \nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \n# Constructor to initialize the node object\nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # Method to print linked list\n    def printList(self):\n        temp = self.head\n \n        while temp:\n            print(temp.data, end=' ')\n            temp = temp.next\n \n    # Function to add of node at the end.\n    def append(self, new_data):\n        new_node = Node(new_data)\n \n        if self.head is None:\n            self.head = new_node\n            return\n        last = self.head\n \n        while last.next:\n            last = last.next\n        last.next = new_node\n \n \n# Function to merge two sorted linked list.\ndef mergeLists(head1, head2):\n \n    # create a temp node NULL\n    temp = None\n \n    # List1 is empty then return List2\n    if head1 is None:\n        return head2\n \n    # if List2 is empty then return List1\n    if head2 is None:\n        return head1\n \n    # If List1's data is smaller or\n    # equal to List2's data\n    if head1.data <= head2.data:\n \n        # assign temp to List1's data\n        temp = head1\n \n        # Again check List1's data is smaller or equal List2's\n        # data and call mergeLists function.\n        temp.next = mergeLists(head1.next, head2)\n \n    else:\n        # If List2's data is greater than or equal List1's\n        # data assign temp to head2\n        temp = head2\n \n        # Again check List2's data is greater or equal List's\n        # data and call mergeLists function.\n        temp.next = mergeLists(head1, head2.next)\n \n    # return the temp list.\n    return temp\n \n \n# Driver Function\nif __name__ == '__main__':\n \n    # Create linked list :\n    list1 = LinkedList()\n    list1.append(5)\n    list1.append(10)\n    list1.append(15)\n \n    # Create linked list 2 :\n    list2 = LinkedList()\n    list2.append(2)\n    list2.append(3)\n    list2.append(20)\n \n    # Create linked list 3\n    list3 = LinkedList()\n \n    # Merging linked list 1 and linked list 2\n    # in linked list 3\n    list3.head = mergeLists(list1.head, list2.head)\n \n    print('Merged Linked List is:')\n    list3.printList()\n \n \n# This code is contributed by 'Shriaknt13'.\n", "# Given two sorted linked lists consisting of N and M nodes\n# respectively. The task is to merge both of the list\n# (in-place) and return head of the merged list.\n \n# Link list Node\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n \n# Function to reverse a given Linked List using\n# Recursion\ndef reverse_list(head):\n    if head.next is None:\n        return head\n    rest = reverse_list(head.next)\n    head.next.next = head\n    head.next = None\n    return rest\n \n# Given two non-empty linked lists 'a' and 'b'\ndef sorted_merge(a, b):\n    # Reverse Linked List 'a'\n    a = reverse_list(a)\n \n    # Reverse Linked List 'b'\n    b = reverse_list(b)\n \n    # Initialize head of resultant list\n    head = None\n \n    # Traverse both lists while both of them\n    # have nodes.\n    while a is not None and b is not None:\n        # If a's current value is greater than or equal\n        # to b's current value.\n        if a.key >= b.key:\n            # Store next of current Node in first list\n            temp = a.next\n            # Add 'a' at the front of resultant list\n            a.next = head\n            # Make 'a' - head of the result list\n            head = a\n            # Move ahead in first list\n            a = temp\n        # If b's value is greater. Below steps are\n        # similar to above (Only 'a' is replaced with\n        # 'b')\n        else:\n            temp = b.next\n            b.next = head\n            head = b\n            b = temp\n \n    # If second list reached end, but first list has\n    # nodes. Add remaining nodes of first list at the\n    # beginning of result list\n    while a is not None:\n        temp = a.next\n        a.next = head\n        head = a\n        a = temp\n \n    # If first list reached end, but second list has\n    # nodes. Add remaining nodes of second list at the\n    # beginning of result list\n    while b is not None:\n        temp = b.next\n        b.next = head\n        head = b\n        b = temp\n \n    # Return the head of the result list\n    return head\n \n# Function to print Nodes in a given linked list\ndef print_list(node):\n    while node is not None:\n        print(node.key, end=' ')\n        node = node.next\n    print()\n \n# Utility function to create a new node with\n# given key\ndef new_node(key):\n    temp = Node(key)\n    return temp\n \n# Test\n \n# Start with the empty list\nres = None\n \n# Let us create two sorted linked lists to test\n# the above functions. Created lists shall be\n#   a: 5.10.15.40\n#   b: 2.3.20\na = new_node(5)\na.next = new_node(10)\na.next.next = new_node(15)\na.next.next.next = new_node(40)\n \nb = new_node(2)\nb.next = new_node(3)\nb.next.next = new_node(20)\n \n# merge 2 sorted linked lists\nres = sorted_merge(a, b)\n \nprint('Merged Linked List is:')\nprint_list(res)\n \n# This code is contributed by lokesh\n"], "Detect and Remove Loop in a Linked List -  ": ["# Python program to detect and remove loop in linked list\n \n# Node class \nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    def detectAndRemoveLoop(self):\n        slow_p = fast_p = self.head\n         \n        while(slow_p and fast_p and fast_p.next):\n            slow_p = slow_p.next\n            fast_p = fast_p.next.next\n \n            # If slow_p and fast_p meet at some point then\n            # there is a loop\n            if slow_p == fast_p:\n                self.removeLoop(slow_p)\n         \n                # Return 1 to indicate that loop is found\n                return 1\n         \n        # Return 0 to indicate that there is no loop\n        return 0\n \n    # Function to remove loop\n    # loop_node --> pointer to one of the loop nodes\n    # head --> Pointer to the start node of the linked list\n    def removeLoop(self, loop_node):\n        ptr1 = loop_node\n        ptr2 = loop_node\n         \n        # Count the number of nodes in loop\n        k = 1\n        while(ptr1.next != ptr2):\n            ptr1 = ptr1.next\n            k += 1\n \n        # Fix one pointer to head\n        ptr1 = self.head\n         \n        # And the other pointer to k nodes after head\n        ptr2 = self.head\n        for i in range(k):\n            ptr2 = ptr2.next\n \n        # Move both pointers at the same place\n        # they will meet at loop starting node\n        while(ptr2 != ptr1):\n            ptr1 = ptr1.next\n            ptr2 = ptr2.next\n \n        # Get pointer to the last node\n        while(ptr2.next != ptr1):\n            ptr2 = ptr2.next\n \n        # Set the next node of the loop ending node\n        # to fix the loop\n        ptr2.next = None\n \n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    # Utility function to print the LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(temp.data, end = ' ')\n            temp = temp.next\n \n \n# Driver program\nllist = LinkedList()\nllist.push(10)\nllist.push(4)\nllist.push(15)\nllist.push(20)\nllist.push(50)\n \n# Create a loop for testing\nllist.head.next.next.next.next.next = llist.head.next.next\n \nllist.detectAndRemoveLoop()\n \nprint('Linked List after removing loop')\nllist.printList()\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "# Python program to detect and remove loop\n \n# Node class\n \n \nclass Node:\n \n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass LinkedList:\n \n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n \n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n \n    def detectAndRemoveLoop(self):  \n      if self.head is None:\n          return\n      if self.head.next is None:\n          return\n      slow_p = self.head\n      fast_p = self.head\n          \n      while(slow_p and fast_p and fast_p.next):\n          slow_p = slow_p.next\n          fast_p = fast_p.next.next\n \n          # If slow_p and fast_p meet at some point then\n          # there is a loop\n          if slow_p == fast_p:\n            slow_p = self.head\n              # Finding the beginning of the loop\n            while (slow_p.next != fast_p.next):\n              slow_p = slow_p.next\n              fast_p = fast_p.next\n \n                # Sinc fast.next is the looping point\n            fast_p.next = None  # Remove loop\n \n    # Utility function to print the LinkedList\n \n    def printList(self):\n        temp = self.head\n        while(temp):\n            print(temp.data, end = ' ')\n            temp = temp.next\n \n \n# Driver program\nllist = LinkedList()\nllist.head = Node(50)\nllist.head.next = Node(20)\nllist.head.next.next = Node(15)\nllist.head.next.next.next = Node(4)\nllist.head.next.next.next.next = Node(10)\n \n# Create a loop for testing\nllist.head.next.next.next.next.next = llist.head.next.next\n \nllist.detectAndRemoveLoop()\n \nprint('Linked List after removing loop')\nllist.printList()\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n"], "Rotate a Linked List -  ": ["# Python program for the above approach. \n  \n# Structure for a linked list node  \nclass Node: \n    def __init__(self,data): \n        self.data = data \n        self.next = None\n          \n# Function to rotate a linked list. \ndef rotate(head,k): \n    # let us consider the example \n    #  10->20->30->40->50->60 - k=4 \n    # initialising 2 nodes temp and last \n    last = head \n    temp = head \n      \n    # if head is null or k==0 no rotation is required \n    if head == None or k == 0: \n        return head \n          \n    # Making last point to the last-node of the given \n    # linked list in this case 60 \n    while last.next != None: \n        last = last.next\n          \n    # Rotating the linked list k times, one rotation at a time. \n    while k: \n        # Make head point to next of head \n        # so in the example given above head becomes 20 \n        head = head.next\n          \n        # Making next of temp as NULL \n        # In the above example :10->NULL \n        temp.next = None\n          \n        # Making temp as last node \n        # (head)20->30->40->50->60->10(last) \n        last.next = temp \n        last = temp \n          \n        # Point temp to head again for next rotation \n        temp = head \n        k -= 1\n    return head \n      \ndef printList(head): \n    temp = head \n    while temp: \n        print(temp.data, end = ' ') \n        temp = temp.next\n    print() \n      \ndef push(head,new_data): \n    # allocate node and put data in it \n    new_node = Node(new_data) \n      \n    # link the old list of the new node \n    new_node.next = head \n      \n    # move the head to point to the new node \n    head = new_node \n    return head \n      \nhead = None\n# create a list 10->20->30->40->50->60 \nfor i in range(60,0,-10): \n    head = push(head,i) \n      \nprint('Given linked list: ') \nprintList(head) \nhead = rotate(head,4) \n  \nprint('Rotated linked list: ') \nprintList(head) \n  \n# This code is contributed by hardikkushwaha.\n"], "Find the first non-repeating character from a stream of characters -  ": ["def FirstNonRepeating(A):\n        # Code here\n        list = [] \n        mp = {}\n        ans = ''\n \n        for ch in A:\n            if ch not in mp:  # new character visited first time\n                list.append(ch)\n                mp[ch] = 1\n            else:\n                # any repeated character encountered\n                if ch in list:\n                    list.remove(ch)\n            ans += list[0] if list else '#'\n \n        return ans\nl = ' andgeeksquizfor'\nans1 = FirstNonRepeating(l)\nprint(ans1)\n", "# A Python program to find first non-repeating character from\n# a stream of characters\nMAX_CHAR = 256\n \ndef findFirstNonRepeating():\n \n    # inDLL[x] contains pointer to a DLL node if x is present\n    # in DLL. If x is not present, then inDLL[x] is NULL\n    inDLL = [] * MAX_CHAR\n \n    # repeated[x] is true if x is repeated two or more times.\n    # If x is not seen so far or x is seen only once. then\n    # repeated[x] is false\n    repeated = [False] * MAX_CHAR\n \n    # Let us consider following stream and see the process\n    stream = 'geekforgeekandgeeksandquizfor'\n    for i in range(len(stream)):\n        x = stream[i]\n        print ('Reading ' + x + ' from stream')\n \n        # We process this character only if it has not occurred\n        # or occurred only once. repeated[x] is true if x is\n        # repeated twice or more.s\n        if not repeated[ord(x)]:\n \n            # If the character is not in DLL, then add this\n            # at the end of DLL\n            if not x in inDLL:\n                inDLL.append(x)\n            else:\n                inDLL.remove(x)\n                repeated[ord(x)] = True\n \n        if len(inDLL) != 0:\n            print ('First non-repeating character so far is ')\n            print (str(inDLL[0]))\n \n# Driver program\nfindFirstNonRepeating()\n \n# This code is contributed by BHAVYA JAIN\n"], "Design a stack that supports getMin() in O(1) time and O(1) extra space -  ": ["# Class to make a Node\nclass Node:\n    # Constructor which assign argument to nade's value\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n \n    # This method returns the string representation of the object.\n    def __str__(self):\n        return 'Node({})'.format(self.value)\n \n    # __repr__ is same as __str__\n    __repr__ = __str__\n \n \nclass Stack:\n    # Stack Constructor initialise top of stack and counter.\n    def __init__(self):\n        self.top = None\n        self.count = 0\n        self.minimum = None\n \n    # This method returns the string representation of the object (stack).\n    def __str__(self):\n        temp = self.top\n        out = []\n        while temp:\n            out.append(str(temp.value))\n            temp = temp.next\n        out = '\\n'.join(out)\n        return ('Top {} \\n\\nStack :\\n{}'.format(self.top, out))\n \n    # __repr__ is same as __str__\n    __repr__ = __str__\n \n    # This method is used to get minimum element of stack\n    def getMin(self):\n        if self.top is None:\n            return 'Stack is empty'\n        else:\n            print('Minimum Element in the stack is: {}' .format(self.minimum))\n \n    # Method to check if Stack is Empty or not\n \n    def isEmpty(self):\n        # If top equals to None then stack is empty\n        if self.top == None:\n            return True\n        else:\n            # If top not equal to None then stack is empty\n            return False\n \n    # This method returns length of stack\n    def __len__(self):\n        self.count = 0\n        tempNode = self.top\n        while tempNode:\n            tempNode = tempNode.next\n            self.count += 1\n        return self.count\n \n    # This method returns top of stack\n    def peek(self):\n        if self.top is None:\n            print('Stack is empty')\n        else:\n            if self.top.value < self.minimum:\n                print('Top Most Element is: {}' .format(self.minimum))\n            else:\n                print('Top Most Element is: {}' .format(self.top.value))\n \n    # This method is used to add node to stack\n    def push(self, value):\n        if self.top is None:\n            self.top = Node(value)\n            self.minimum = value\n \n        elif value < self.minimum:\n            temp = (2 * value) - self.minimum\n            new_node = Node(temp)\n            new_node.next = self.top\n            self.top = new_node\n            self.minimum = value\n        else:\n            new_node = Node(value)\n            new_node.next = self.top\n            self.top = new_node\n        print('Number Inserted: {}' .format(value))\n \n    # This method is used to pop top of stack\n    def pop(self):\n        if self.top is None:\n            print('Stack is empty')\n        else:\n            removedNode = self.top.value\n            self.top = self.top.next\n            if removedNode < self.minimum:\n                print('Top Most Element Removed :{} ' .format(self.minimum))\n                self.minimum = ((2 * self.minimum) - removedNode)\n            else:\n                print('Top Most Element Removed : {}' .format(removedNode))\n \n \n# Driver program to test above class\nif __name__ == '__main__':\n   \n  stack = Stack()\n   \n  # Function calls\n  stack.push(3)\n  stack.push(5)\n  stack.getMin()\n  stack.push(2)\n  stack.push(1)\n  stack.getMin()\n  stack.pop()\n  stack.getMin()\n  stack.pop()\n  stack.peek()\n \n# This code is contributed by Blinkii\n", "# Python program for the above approach\nclass MinStack:\n   \n    # initialize your data structure here.\n    def __init__(self):\n        self.s = []\n \n    class Node:\n        def __init__(self, val, Min):\n            self.val = val\n            self.min = Min\n \n    def push(self, x):\n        if not self.s:\n            self.s.append(self.Node(x, x))\n        else:\n            Min = min(self.s[-1].min, x)\n            self.s.append(self.Node(x, Min))\n \n    def pop(self):\n        return self.s.pop().val\n \n    def top(self):\n        return self.s[-1].val\n \n    def getMin(self):\n        return self.s[-1].min\n \ns = MinStack()\n \n# Function calls\ns.push(-1)\ns.push(10)\ns.push(-4)\ns.push(0)\nprint(s.getMin())\nprint(s.pop())\nprint(s.pop())\nprint(s.getMin())\n \n# This code is contributed by lokesh\n"], "Implement Stack using Queues -  ": ["# Program to implement a stack using\n# two queue\nfrom _collections import deque\n \n \nclass Stack:\n \n    def __init__(self):\n \n        # Two inbuilt queues\n        self.q1 = deque()\n        self.q2 = deque()\n \n    def push(self, x):\n \n        # Push x first in empty q2\n        self.q2.append(x)\n \n        # Push all the remaining\n        # elements in q1 to q2.\n        while (self.q1):\n            self.q2.append(self.q1.popleft())\n \n        # swap the names of two queues\n        self.q1, self.q2 = self.q2, self.q1\n \n    def pop(self):\n \n        # if no elements are there in q1\n        if self.q1:\n            self.q1.popleft()\n \n    def top(self):\n        if (self.q1):\n            return self.q1[0]\n        return None\n \n    def size(self):\n        return len(self.q1)\n \n \n# Driver Code\nif __name__ == '__main__':\n    s = Stack()\n    s.push(1)\n    s.push(2)\n    s.push(3)\n \n    print('current size: ', s.size())\n    print(s.top())\n    s.pop()\n    print(s.top())\n    s.pop()\n    print(s.top())\n \n    print('current size: ', s.size())\n \n# This code is contributed by PranchalK\n", "# Program to implement a stack using\n# two queue\nfrom _collections import deque\n \n \nclass Stack:\n \n    def __init__(self):\n \n        # Two inbuilt queues\n        self.q1 = deque()\n        self.q2 = deque()\n \n    def push(self, x):\n        self.q1.append(x)\n \n    def pop(self):\n        # if no elements are there in q1\n        if (not self.q1):\n            return\n        # Leave one element in q1 and push others in q2\n        while(len(self.q1) != 1):\n            self.q2.append(self.q1.popleft())\n \n        # swap the names of two queues\n        self.q1, self.q2 = self.q2, self.q1\n \n    def top(self):\n        # if no elements are there in q1\n        if (not self.q1):\n            return\n        # Leave one element in q1 and push others in q2\n        while(len(self.q1) != 1):\n            self.q2.append(self.q1.popleft())\n \n        # Pop the only left element from q1 to q2\n        top = self.q1[0]\n        self.q2.append(self.q1.popleft())\n \n        # swap the names of two queues\n        self.q1, self.q2 = self.q2, self.q1\n \n        return top\n \n    def size(self):\n        return len(self.q1)\n \n \n# Driver Code\nif __name__ == '__main__':\n    s = Stack()\n    s.push(1)\n    s.push(2)\n    s.push(3)\n \n    print('current size: ', s.size())\n    print(s.top())\n    s.pop()\n    print(s.top())\n    s.pop()\n    print(s.top())\n \n    print('current size: ', s.size())\n \n# This code is contributed by jainlovely450\n", "from _collections import deque\n \n# Stack Class that acts as a queue\n \n \nclass Stack:\n    def __init__(self):\n        self.q = deque()\n \n    # Push operation\n    def push(self, data):\n        # Get previous size of queue\n        s = len(self.q)\n \n        # Push the current element\n        self.q.append(data)\n \n        # Pop all the previous elements and put them after\n        # current element\n        for i in range(s):\n            self.q.append(self.q.popleft())\n \n    # Removes the top element\n    def pop(self):\n        if (not self.q):\n            print('No elements')\n        else:\n            self.q.popleft()\n \n    # Returns top of stack\n    def top(self):\n        if (not self.q):\n            return\n        return self.q[0]\n \n    def size(self):\n        return len(self.q)\n \n \nif __name__ == '__main__':\n    st = Stack()\n    st.push(1)\n    st.push(2)\n    st.push(3)\n    print('current size: ', st.size())\n    print(st.top())\n    st.pop()\n    print(st.top())\n    st.pop()\n    print(st.top())\n    print('current size: ', st.size())\n", "from _collections import deque\n \n# Stack Class that acts as a queue\n \n \nclass Stack:\n    def __init__(self):\n        self.q = deque()\n \n    # Push operation\n    def push(self, data, c):\n \n        # Push the current element\n        self.q.append(data)\n \n        # Return if size becomes 0\n        if c <= 0:\n            return\n \n        # Store and then pop the current front\n        x = self.q.popleft()\n \n        # Decrement size by 1 in every recursion\n        c = c-1\n        self.push(x, c)\n \n    # Removes the top element\n    def pop(self):\n        if (not self.q):\n            print('No elements')\n        else:\n            self.q.popleft()\n \n    # Returns top of stack\n    def top(self):\n        if (not self.q):\n            return\n        return self.q[0]\n \n    def size(self):\n        return len(self.q)\n \n \nif __name__ == '__main__':\n    st = Stack()\n    st.push(1, st.size())\n    st.push(2, st.size())\n    st.push(3, st.size())\n    print('current size: ', st.size())\n    print(st.top())\n    st.pop()\n    print(st.top())\n    st.pop()\n    print(st.top())\n    print('current size: ', st.size())\n \n# This code is contributed by Susobhan Akhuli\n", "# Python Program to implement a stack\n# using dequeue\n \nfrom collections import deque\n \n# Define the Stack class\nclass Stack:\n    def __init__(self):\n        # Create an empty dequeue\n        self.dequeue = deque()\n \n    def push(self, item):\n        # Append the item to the end of the dequeue\n        self.dequeue.append(item)\n \n    def pop(self):\n        # Remove and return the item from the end of the dequeue\n        return self.dequeue.pop()\n     \n    def size(self):\n          # Return size of dequeue\n        return len(self.dequeue)\n \n    def is_empty(self):\n        # Return True if the dequeue is empty, and False otherwise\n        return not self.dequeue\n \n    def top(self):\n        # Return the item at the top of the stack without removing it.\n        if self.is_empty():\n            # If the stack is empty, return None\n            return None\n        else:\n            # Return the last item in the dequeue\n            return self.dequeue[-1]\n \nif __name__ == '__main__':\n    st = Stack()\n    st.push(1)\n    st.push(2)\n    st.push(3)\n    print('current size:', st.size())\n    print(st.top())\n    st.pop()\n    print(st.top())\n    st.pop()\n    print(st.top())\n    print('current size:', st.size())\n \n# This code is contributed by Susobhan Akhuli\n"], "Queue using Stacks -  ": ["# Python3 program to implement Queue using \n# two stacks with costly enQueue() \n \nclass Queue: \n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n \n    def enQueue(self, x):\n         \n        # Move all elements from s1 to s2 \n        while len(self.s1) != 0: \n            self.s2.append(self.s1[-1]) \n            self.s1.pop()\n \n        # Push item into self.s1 \n        self.s1.append(x) \n \n        # Push everything back to s1 \n        while len(self.s2) != 0: \n            self.s1.append(self.s2[-1]) \n            self.s2.pop()\n \n    # Dequeue an item from the queue \n    def deQueue(self):\n         \n            # if first stack is empty \n        if len(self.s1) == 0: \n            return -1;\n     \n        # Return top of self.s1 \n        x = self.s1[-1] \n        self.s1.pop() \n        return x\n \n# Driver code \nif __name__ == '__main__':\n    q = Queue()\n    q.enQueue(1) \n    q.enQueue(2) \n    q.enQueue(3) \n \n    print(q.deQueue())\n    print(q.deQueue())\n    print(q.deQueue())\n \n# This code is contributed by PranchalK \n", "# Python3 program to implement Queue using \n# two stacks with costly deQueue()\n \nclass Queue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n \n    # EnQueue item to the queue\n    def enQueue(self, x):\n        self.s1.append(x)\n \n    # DeQueue item from the queue\n    def deQueue(self):\n \n        # if both the stacks are empty\n        if len(self.s1) == 0 and len(self.s2) == 0:\n            return -1\n \n        # if s2 is empty and s1 has elements\n        elif len(self.s2) == 0 and len(self.s1) > 0:\n            while len(self.s1):\n                temp = self.s1.pop()\n                self.s2.append(temp)\n            return self.s2.pop()\n \n        else:\n            return self.s2.pop()\n \n    # Driver code\nif __name__ == '__main__':\n    q = Queue()\n    q.enQueue(1)\n    q.enQueue(2)\n    q.enQueue(3)\n \n    print(q.deQueue())\n    print(q.deQueue())\n    print(q.deQueue())\n \n# This code is contributed by Pratyush Kumar \n", "# Python3 program to implement Queue using  \n# one stack and recursive call stack. \nclass Queue:\n    def __init__(self):\n        self.s = []\n         \n    # Enqueue an item to the queue \n    def enQueue(self, data):\n        self.s.append(data)\n         \n    # Dequeue an item from the queue \n    def deQueue(self):\n        # Return if queue is empty\n        if len(self.s) <= 0:\n            return -1\n         \n        # pop an item from the stack\n        x = self.s[len(self.s) - 1]\n        self.s.pop()\n         \n        # if stack become empty\n        # return the popped item\n        if len(self.s) <= 0:\n            return x\n             \n        # recursive call\n        item = self.deQueue()\n         \n        # push popped item back to\n        # the stack\n        self.s.append(x)\n         \n        # return the result of \n        # deQueue() call\n        return item\n     \n# Driver code  \nif __name__ == '__main__':\n    q = Queue()\n    q.enQueue(1)\n    q.enQueue(2)\n    q.enQueue(3)\n     \n    print(q.deQueue())\n    print(q.deQueue())\n    print(q.deQueue())  \n     \n# This code is contributed by iArman\n"], "Largest Rectangular Area in a Histogram using Segment Tree -  ": ["# Python3 program for range minimum  \n# query using segment tree\n \n# modified to return index of minimum instead of minimum itself\n# for further reference link\n# https://www. .org/segment-tree-set-1-range-minimum-query/\n \n#-------------------------------------------------------------------------\nfrom math import ceil,log2;  \n   \n# A utility function to get  \n# minimum of two numbers  \ndef minVal(hist,x, y) :\n    if x==-1:\n        return y\n    if y==-1:\n        return x\n    return x if (hist[x] < hist[y]) else y;  \n   \n# A utility function to get the  \n# middle index from corner indexes.  \ndef getMid(s, e) : \n    return s + (e - s) // 2;  \n   \n''' A recursive function to get the  \nminimum value in a given range  \nof array indexes. The following  \nare parameters for this function.  \n   \n    st --> Pointer to segment tree  \n    index --> Index of current node in the  \n        segment tree. Initially 0 is  \n        passed as root is always at index 0  \n    ss & se --> Starting and ending indexes  \n                of the segment represented  \n                by current node, i.e., st[index]  \n    qs & qe --> Starting and ending indexes of query range '''\ndef RMQUtil( hist,st, ss, se, qs, qe, index) : \n   \n    # If segment of this node is a part  \n    # of given range, then return  \n    # the min of the segment  \n    if (qs <= ss and qe >= se) : \n        return st[index];  \n   \n    # If segment of this node  \n    # is outside the given range  \n    if (se < qs or ss > qe) : \n        return -1;  \n   \n    # If a part of this segment  \n    # overlaps with the given range  \n    mid = getMid(ss, se);  \n    return minVal(hist,RMQUtil(hist,st, ss, mid, qs,  \n                          qe, 2 * index + 1),  \n                  RMQUtil(hist,st, mid + 1, se, \n                          qs, qe, 2 * index + 2));  \n   \n# Return minimum of elements in range  \n# from index qs (query start) to  \n# qe (query end). It mainly uses RMQUtil()  \ndef RMQ( hist,st, n, qs, qe) :  \n   \n    # Check for erroneous input values  \n    if (qs < 0 or qe > n - 1 or qs > qe) : \n       \n        print('Invalid Input');  \n        return -1;  \n       \n    return RMQUtil(hist,st, 0, n - 1, qs, qe, 0);  \n   \n# A recursive function that constructs  \n# Segment Tree for array[ss..se].  \n# si is index of current node in segment tree st  \ndef constructSTUtil(hist, ss, se, st, si) : \n   \n    # If there is one element in array,  \n    # store it in current node of  \n    # segment tree and return  \n    if (ss == se) : \n   \n        st[si] = ss;  \n        return st[si];  \n   \n    # If there are more than one elements,  \n    # then recur for left and right subtrees  \n    # and store the minimum of two values in this node  \n    mid = getMid(ss, se);  \n    st[si] = minVal(hist,constructSTUtil(hist, ss, mid, \n                                    st, si * 2 + 1), \n                    constructSTUtil(hist, mid + 1, se, \n                                    st, si * 2 + 2));  \n       \n    return st[si];  \n   \n'''Function to construct segment tree  \nfrom given array. This function allocates  \nmemory for segment tree and calls constructSTUtil() \nto fill the allocated memory '''\ndef constructST( hist, n) : \n   \n    # Allocate memory for segment tree  \n   \n    # Height of segment tree  \n    x = (int)(ceil(log2(n)));  \n   \n    # Maximum size of segment tree  \n    max_size = 2 * (int)(2**x) - 1;  \n    \n    st = [0] * (max_size);  \n   \n    # Fill the allocated memory st  \n    constructSTUtil(hist, 0, n - 1, st, 0);  \n   \n    # Return the constructed segment tree  \n    return st;  \n   \n \n#----------------------------------------------------------------\n \n# main program\n# Python3 program using Divide and Conquer\n# to find maximum rectangular area under a histogram\n \n \ndef max_area_histogram(hist):\n    area=0\n    #initialize area\n     \n    st = constructST(hist, len(hist))\n    # construct the segment tree\n     \n    try:\n        # try except block is generally used in this way\n        # to suppress all type of exceptions raised.\n         \n        def fun(left,right):\n             \n        # this function 'fun' calculates area\n        # recursively between indices left and right\n             \n            nonlocal area\n             \n            # global area won't work here as\n            # variable area is defined inside function\n            # not in main().\n              \n            if left==right:\n                return\n            # the recursion has reached end\n              \n             \n            index = RMQ(hist,st, len(hist), left, right-1)\n            # RMQ function returns index \n            # of minimum value\n            # in the range of [left,right-1]\n            # can also be found by using min() but\n            # results in O(n) instead of O(log n) for traversing\n             \n            area=max(area,hist[index]*(right-left))\n            # calculate area with minimum above\n             \n            fun(index+1,right)\n            fun(left,index)\n            # initiate further recursion\n              \n            return\n                  \n        fun(0,len(hist))\n        # initializes the recursion\n         \n        return(area)\n        # return the max area to calling function\n        # in this case 'print'\n          \n    except:\n        pass\n     \n# Driver Code \nhist = [6, 2, 5, 4, 5, 1, 6] \nprint('Maximum area is',  \n       max_area_histogram(hist)) \n   \n# This code is contributed  \n# by Vishnudev C.\n"], "Next Greater Element (NGE) for every element in given Array -  ": ["# Python3 code\nclass Solution:\n    def nextLargerElement(self, arr, n):\n        # code here\n        s = []\n        for i in range(len(arr)):\n            while s and s[-1].get('value') < arr[i]:\n                d = s.pop()\n                arr[d.get('ind')] = arr[i]\n            s.append({'value': arr[i], 'ind': i})\n        while s:\n            d = s.pop()\n            arr[d.get('ind')] = -1\n        return arr\n \n \nif __name__ == '__main__':\n    print(Solution().nextLargerElement([6, 8, 0, 1, 3], 5))\n"], "Merge Overlapping Intervals -  ": ["# Python3 program for merging overlapping intervals\ndef mergeIntervals(intervals):\n    # Sort the array on the basis of start values of intervals.\n    intervals.sort()\n    stack = []\n    # insert first interval into stack\n    stack.append(intervals[0])\n    for i in intervals[1:]:\n        # Check for overlapping interval,\n        # if interval overlap\n        if stack[-1][0] <= i[0] <= stack[-1][-1]:\n            stack[-1][-1] = max(stack[-1][-1], i[-1])\n        else:\n            stack.append(i)\n \n    print('The Merged Intervals are :', end=' ')\n    for i in range(len(stack)):\n        print(stack[i], end=' ')\n \n \narr = [[6, 8], [1, 9], [2, 4], [4, 7]]\nmergeIntervals(arr)\n", "# Python program to merge overlapping Intervals in\n# O(n Log n) time and O(1) extra space\n \n \ndef mergeIntervals(arr):\n \n    # Sorting based on the increasing order\n    # of the start intervals\n    arr.sort(key=lambda x: x[0])\n \n    # Stores index of last element\n    # in output array (modified arr[])\n    index = 0\n \n    # Traverse all input Intervals starting from\n    # second interval\n    for i in range(1, len(arr)):\n \n        # If this is not first Interval and overlaps\n        # with the previous one, Merge previous and\n        # current Intervals\n        if (arr[index][1] >= arr[i][0]):\n            arr[index][1] = max(arr[index][1], arr[i][1])\n        else:\n            index = index + 1\n            arr[index] = arr[i]\n \n    print('The Merged Intervals are :', end=' ')\n    for i in range(index+1):\n        print(arr[i], end=' ')\n \n \n# Driver code\narr = [[6, 8], [1, 9], [2, 4], [4, 7]]\nmergeIntervals(arr)\n"], "Find the maximum subset XOR of a given set -  ": ["# Python program to find  \n# maximum XOR subset \n  \n# Number of bits to  \n# represent int \nINT_BITS=32\n   \n# Function to return \n# maximum XOR subset \n# in set[] \ndef maxSubarrayXOR(set,n): \n  \n    # Initialize index of \n    # chosen elements \n    index = 0\n   \n    # Traverse through all \n    # bits of integer  \n    # starting from the most \n    # significant bit (MSB) \n    for i in range(INT_BITS-1,-1,-1): \n      \n        # Initialize index of \n        # maximum element and \n        # the maximum element \n        maxInd = index \n        maxEle = -2147483648\n        for j in range(index,n): \n          \n            # If i'th bit of set[j] \n            # is set and set[j] is  \n            # greater than max so far. \n            if ( (set[j] & (1 << i)) != 0 \n                     and set[j] > maxEle ): \n                  \n                maxEle = set[j] \n                maxInd = j \n          \n        # If there was no  \n        # element with i'th \n        # bit set, move to \n        # smaller i \n        if (maxEle ==-2147483648): \n            continue\n   \n        # Put maximum element \n        # with i'th bit set  \n        # at index 'index' \n        temp=set[index] \n        set[index]=set[maxInd] \n        set[maxInd]=temp \n   \n        # Update maxInd and  \n        # increment index \n        maxInd = index \n   \n        # Do XOR of set[maxIndex] \n        # with all numbers having \n        # i'th bit as set. \n        for j in range(n): \n          \n            # XOR set[maxInd] those \n            # numbers which have the \n            # i'th bit set \n            if (j != maxInd and\n               (set[j] & (1 << i)) != 0): \n                set[j] = set[j] ^ set[maxInd] \n          \n   \n        # Increment index of \n        # chosen elements \n        index=index + 1\n      \n   \n    # Final result is  \n    # XOR of all elements \n    res = 0\n    for i in range(n): \n        res =res ^ set[i] \n    return res \n  \n# Driver code \n  \nset= [9, 8, 5] \nn =len(set) \n  \nprint('Max subset XOR is ',end='') \nprint(maxSubarrayXOR(set, n)) \n  \n# This code is contributed \n# by Anant Agarwal. \n"], "Find the Number Occurring Odd Number of Times -  ": ["# Python program to find the element occurring\n# odd number of times\n     \n# function to find the element occurring odd\n# number of times\ndef getOddOccurrence(arr, arr_size):\n     \n    for i in range(0,arr_size):\n        count = 0\n        for j in range(0, arr_size):\n            if arr[i] == arr[j]:\n                count+=1\n             \n        if (count % 2 != 0):\n            return arr[i]\n         \n    return -1\n     \n     \n# driver code \narr = [2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2 ]\nn = len(arr)\nprint(getOddOccurrence(arr, n))\n \n# This code has been contributed by \n# Smitha Dinesh Semwal\n", "# Python3 program to find the element  \n# occurring odd number of times \n  \n# function to find the element \n# occurring odd number of times \ndef getOddOccurrence(arr,size):\n      \n    # Defining HashMap in C++\n    Hash=dict()\n  \n    # Putting all elements into the HashMap \n    for i in range(size):\n        Hash[arr[i]]=Hash.get(arr[i],0) + 1;\n     \n    # Iterate through HashMap to check an element\n    # occurring odd number of times and return it\n    for i in Hash:\n \n        if(Hash[i]% 2 != 0):\n            return i\n    return -1\n \n  \n# Driver code\narr=[2, 3, 5, 4, 5, 2, 4,3, 5, 2, 4, 4, 2]\nn = len(arr)\n  \n# Function calling \nprint(getOddOccurrence(arr, n)) \n \n# This code is contributed by mohit kumar\n", "# Python program to find the element occurring odd number of times\n \ndef getOddOccurrence(arr):\n \n    # Initialize result\n    res = 0\n     \n    # Traverse the array\n    for element in arr:\n        # XOR with the result\n        res = res ^ element\n \n    return res\n \n# Test array\narr = [ 2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2]\n \nprint('%d' % getOddOccurrence(arr))\n"], "Check if a given number is sparse or not -  ": ["# Python Code to Check if a given\n# number is sparse or not\ndef isSparse(n):\n    if (n == 1):\n        return true\n    global prev\n    while(n > 0):\n        prev = n & 1\n        n = n >> 1\n        curr = n & 1\n        if(prev == curr and prev == 1):\n            return False\n        prev = curr\n \n    return True\n \n# Driver code\nn = 100\nif (isSparse(n)):\n    print('Sparse')\n \nelse:\n    print('Not Sparse')\n \n# This code is contributed by karandeep1234\n", "# Python program to check\n# if n is sparse or not\n \n# Return true if n is\n# sparse, else false\n \n \ndef checkSparse(n):\n \n    # n is not sparse if there is set\n    # in AND of n and n/2\n    if (n & (n >> 1)):\n        return 0\n \n    return 1\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Function call\n    print(checkSparse(72))\n    print(checkSparse(12))\n    print(checkSparse(2))\n    print(checkSparse(30))\n \n# This code is contributed\n# by Anant Agarwal.\n"], "Length of the Longest Consecutive 1s in Binary Representation -  ": ["# Python program to find\n# length of the longest\n# consecutive 1s in\n# binary representation of\n# a number.\n \ndef maxConsecutiveOnes(x):\n \n    # Initialize result\n    count = 0\n  \n    # Count the number of iterations to\n    # reach x = 0.\n    while (x!=0):\n     \n        # This operation reduces length\n        # of every sequence of 1s by one.\n        x = (x & (x << 1))\n  \n        count=count+1\n     \n    return count\n \n# Driver code\n \nprint(maxConsecutiveOnes(14))\nprint(maxConsecutiveOnes(222))\n \n# This code is contributed\n# by Anant Agarwal.\n", "# Python program to find the length of the longest\n# consecutive 1s in binary representation of\n# a number.\n \ndef main():\n    num = 222\n \n    # Convert the integer to its binary representation as a string\n    binary = format(num, '032b')\n    count = 0\n    max_count = 0\n \n    # Loop through the binary string to find the longest consecutive 1s\n    for i in range(len(binary)):\n        if binary[i] == '1':\n            count += 1\n            if count > max_count:\n                max_count = count\n        else:\n            count = 0\n \n    # Print the result\n    print('The length of the longest consecutive 1s in the binary representation is:', max_count)\n \nif __name__ == '__main__':\n    main()\n"], "Count total set bits in first N Natural Numbers (all numbers from 1 to N) -  ": ["# A simple program to count set bits\n# in all numbers from 1 to n.\n \n# Returns count of set bits present in all\n# numbers from 1 to n\n \n \ndef countSetBits(n):\n \n    # initialize the result\n    bitCount = 0\n \n    for i in range(1, n + 1):\n        bitCount += countSetBitsUtil(i)\n \n    return bitCount\n \n \n# A utility function to count set bits\n# in a number x\ndef countSetBitsUtil(x):\n \n    if (x <= 0):\n        return 0\n    return (0 if int(x % 2) == 0 else 1) + countSetBitsUtil(int(x / 2))\n \n \n# Driver program\nif __name__ == '__main__':\n    n = 4\n    print('Total set bit count is', countSetBits(n))\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# Function which counts set bits from 0 to n\ndef countSetBits(n):\n    i = 0\n \n    # ans store sum of set bits from 0 to n\n    ans = 0\n \n    # while n greater than equal to 2^i\n    while ((1 << i) <= n):\n \n        # This k will get flipped after\n        # 2^i iterations\n        k = 0\n \n        # change is iterator from 2^i to 1\n        change = 1 << i\n \n        # This will loop from 0 to n for\n        # every bit position\n        for j in range(0, n+1):\n            ans += k\n \n            if change == 1:\n \n                #  When change = 1 flip the bit\n                k = not k\n \n                # again set change to 2^i\n                change = 1 << i\n \n            else:\n                change -= 1\n \n        # increment the position\n        i += 1\n \n    return ans\n \n \n# Driver code\nif __name__ == '__main__':\n \n    n = 17\n    print(countSetBits(n))\n \n# This code is contributed by ANKITRAI1\n", "# A O(Logn) complexity program to count\n# set bits in all numbers from 1 to n\n \n'''\n/* Returns position of leftmost set bit.\nThe rightmost position is considered\nas 0 */\n'''\n \n \ndef getLeftmostBit(n):\n \n    m = 0\n    while (n > 1):\n \n        n = n >> 1\n        m += 1\n \n    return m\n \n \n'''\n/* Given the position of previous leftmost\nset bit in n (or an upper bound on\nleftmost position) returns the new\nposition of leftmost set bit in n */\n'''\n \n \ndef getNextLeftmostBit(n, m):\n \n    temp = 1 << m\n    while (n < temp):\n        temp = temp >> 1\n        m -= 1\n \n    return m\n \n# The main recursive function used by countSetBits()\n# def _countSetBits(n, m)\n \n# Returns count of set bits present in\n# all numbers from 1 to n\n \n \ndef countSetBits(n):\n \n    # Get the position of leftmost set\n    # bit in n. This will be used as an\n    # upper bound for next set bit function\n    m = getLeftmostBit(n)\n \n    # Use the position\n    return _countSetBits(n, m)\n \n \ndef _countSetBits(n, m):\n \n    # Base Case: if n is 0, then set bit\n    # count is 0\n    if (n == 0):\n        return 0\n \n    # /* get position of next leftmost set bit */\n    m = getNextLeftmostBit(n, m)\n \n    # If n is of the form 2^x-1, i.e., if n\n    # is like 1, 3, 7, 15, 31, .. etc,\n    # then we are done.\n    # Since positions are considered starting\n    # from 0, 1 is added to m\n    if (n == (1 << (m + 1)) - 1):\n        return ((m + 1) * (1 << m))\n \n    # update n for next recursive call\n    n = n - (1 << m)\n    return (n + 1) + countSetBits(n) + m * (1 << (m - 1))\n \n \n# Driver code\nn = 17\nprint('Total set bit count is', countSetBits(n))\n \n# This code is contributed by rathbhupendra\n", "def getSetBitsFromOneToN(N):\n    two = 2\n    ans = 0\n    n = N\n    while(n != 0)\n    {\n        ans += int(N / two) * (two >> 1)\n        if((N & (two - 1)) > (two >> 1) - 1):\n            ans += (N & (two - 1)) - (two >> 1) + 1\n        two <<= 1\n        n >>= 1\n    }\n    return ans\n \n# This code is contributed by avanitrachhadiya2155\n", "def findLargestPower(n):\n \n    x = 0\n    while ((1 << x) <= n):\n        x += 1\n    return x - 1\n \n \ndef countSetBits(n):\n \n    if (n <= 1):\n        return n\n    x = findLargestPower(n)\n    return (x * pow(2, (x - 1))) + (n - pow(2, x) + 1) + countSetBits(n - pow(2, x))\n \n \nN = 17\nprint(countSetBits(N))\n \n# This code is contributed by shivanisinghss2110\n", "def get_left_most_set_bit(n):\n    left_most_set_bit_indx = 0\n \n    while n > 0:\n        left_most_set_bit_indx += 1\n        n >>= 1\n \n    return left_most_set_bit_indx\n \n \ndef total_set_bits_from_1_to_n(n):\n    left_most_set_bit_indx = get_left_most_set_bit(n)\n    total_rep = 0\n    mod = 0\n    nearest_pow = 0\n    total_set_bit_count = 0\n    add_remaining = 0\n    curr = 0  # denotes the number of set bits at index i\n \n    for i in range(1, left_most_set_bit_indx + 1):\n        nearest_pow = pow(2, i)\n        if nearest_pow > n:\n            last_pow = pow(2, i-1)\n            mod = n % last_pow\n            total_set_bit_count += mod + 1\n \n        else:\n            if i == 1 and n % 2 == 1:\n                total_rep = (n + 1) / nearest_pow\n                mod = nearest_pow % 2\n                add_remaining = 0\n            else:\n                total_rep = int(n / nearest_pow)\n                mod = n % nearest_pow\n                add_remaining = int(\n                    mod - (nearest_pow / 2) + 1) if mod >= nearest_pow / 2 else 0\n \n            curr = int(total_rep * (nearest_pow / 2) + add_remaining)\n            total_set_bit_count += curr\n \n    return total_set_bit_count\n \n \n# Driver code\nif __name__ == '__main__':\n    print(total_set_bits_from_1_to_n(4))\n    print(total_set_bits_from_1_to_n(17))\n    print(total_set_bits_from_1_to_n(30))\n \n    # This code is contributed by tssovi.\n", "def total_set_bits_from_1_to_n(n):\n    total_set_bit_count = 0\n \n    # Loop through numbers from 1 to n (inclusive)\n    for number in range(1, n+1):\n        # Convert the number to its binary representation and count the set bits (ones)\n        total_set_bit_count += bin(number).count('1')\n \n    # Return the total count of set bits from 1 to n\n    return total_set_bit_count\n \n \ndef main():\n    # Test cases to demonstrate the function\n    print('Total set bits from 1 to 4:', total_set_bits_from_1_to_n(4))\n    print('Total set bits from 1 to 17:', total_set_bits_from_1_to_n(17))\n    print('Total set bits from 1 to 30:', total_set_bits_from_1_to_n(30))\n \n \nif __name__ == '__main__':\n    main()\n \n \n# This code is contributed by akshitaguprzj3\n"], "Swap all odd and even bits -  ": ["# Python program to swap even and\n# odd bits of a given number\n \n# Function to swap even\n# and odd bits\ndef swapBits(x):\n   \n    # Get all even bits of x\n    even_bits = x & 0xAAAAAAAA\n \n    # Get all odd bits of x\n    odd_bits = x & 0x55555555\n     \n    # Right shift even bits\n    even_bits >>= 1\n     \n    # Left shift odd bits\n    odd_bits <<= 1\n    for i in range(0,32,2):\n        i_bit = (x >> 1) & 1; # find i th bit\n        i_1_bit = (x >> (i + 1)) & 1; # find i+1 th bit\n         \n        x = x - (i_bit << i) # remove i_bit\n        - (i_1_bit << (i + 2)) # remove i+1 th bit\n        + (i_bit << (i + 1)) # put i_bit at i+1 location\n        + (i_1_bit << i); # put i+1 bit at i location\n     \n    # Combine even and odd bits\n    return (even_bits | odd_bits) \n \n# Driver code\nif __name__ == '__main__':\n    x = 23; # 00010111\n \n    # Output is 43 (00101011)\n    print(swapBits(x));\n \n \n# This code is contributed by Rajput-Ji \n", "# Python 3 program to swap even \n# and odd bits of a given number\n \n# Function for swapping even \n# and odd bits\ndef swapBits(x) :\n     \n    # Get all even bits of x\n    even_bits = x & 0xAAAAAAAA\n \n    # Get all odd bits of x\n    odd_bits = x & 0x55555555\n     \n    # Right shift even bits\n    even_bits >>= 1\n     \n    # Left shift odd bits\n    odd_bits <<= 1\n \n    # Combine even and odd bits\n    return (even_bits | odd_bits) \n \n \n# Driver program\n# 00010111\nx = 23\n \n# Output is 43 (00101011)\nprint(swapBits(x))\n \n \n# This code is contributed \n# by Nikita Tiwari.\n"], "Rotate bits of a number -  ": ["# Python3 code to \n# rotate bits of number\n \nINT_BITS = 32\n \n# Function to left\n# rotate n by d bits\ndef leftRotate(n, d):\n \n    # In n<<d, last d bits are 0.\n    # To put first 3 bits of n at \n    # last, do bitwise or of n<<d\n    # with n >>(INT_BITS - d) \n    return (n << d)|(n >> (INT_BITS - d))\n \n# Function to right\n# rotate n by d bits\ndef rightRotate(n, d):\n \n    # In n>>d, first d bits are 0.\n    # To put last 3 bits of at \n    # first, do bitwise or of n>>d\n    # with n <<(INT_BITS - d) \n    return (n >> d)|(n << (INT_BITS - d)) & 0xFFFFFFFF\n \n# Driver program to\n# test above functions \nn = 16\nd = 2\n \nprint('Left Rotation of',n,'by'\n      ,d,'is',end=' ')\nprint(leftRotate(n, d))\n \nprint('Right Rotation of',n,'by'\n     ,d,'is',end=' ')\nprint(rightRotate(n, d))\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "SHORT_SIZE = 16\n \n# function to rotate the given unsigned short\n# in the left direction\ndef leftRotate(x, d):\n \n    return (x << d) | (x >> (SHORT_SIZE - d))\n \n  # function to rotate the given unsigned short\n# in the right direction\ndef rightRotate(x, d):\n \n    return (x >> d) | (x << (SHORT_SIZE - d)) & 0xDDDDDF\n \n# Driver program to test above functions\n# Test case\nn = 28\nd = 2\n \nprint('Left Rotation of',n,'by'\n      ,d,'is',end=' ')\nprint(leftRotate(n, d))\n \nprint('Right Rotation of',n,'by'\n     ,d,'is',end=' ')\nprint(rightRotate(n, d))\n \n# This code is contributed by shivanisinghss2110\n"], "Program to find whether a given number is power of 2 -  ": ["# Python3 Program to find\n# whether a no is\n# power of two\nimport math\n \n# Function to check\n# Log base 2\n \n \ndef Log2(x):\n    if x == 0:\n        return false\n \n    return (math.log10(x) /\n            math.log10(2))\n \n# Function to check\n# if x is power of 2\n \n \ndef isPowerOfTwo(n):\n    return (math.ceil(Log2(n)) ==\n            math.floor(Log2(n)))\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # Function call\n    if(isPowerOfTwo(31)):\n        print('Yes')\n    else:\n        print('No')\n \n    if(isPowerOfTwo(64)):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed\n# by mits\n", "# Python program to check if given\n# number is power of 2 or not\n \n# Function to check if x is power of 2\n \n \ndef isPowerOfTwo(n):\n    if (n == 0):\n        return False\n    while (n != 1):\n        if (n % 2 != 0):\n            return False\n        n = n // 2\n \n    return True\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Function call\n    if(isPowerOfTwo(31)):\n        print('Yes')\n    else:\n        print('No')\n    if(isPowerOfTwo(64)):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed by Danish Raza\n", "# Python3 program to check if given\n# number is power of 2 or not\n \n# Function to check if x is power of 2\n \n \ndef isPowerOfTwo(n):\n    cnt = 0\n    while n > 0:\n        if n & 1 == 1:\n            cnt = cnt + 1\n        n = n >> 1\n \n    if cnt == 1:\n        return 1\n    return 0\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Function call\n    if(isPowerOfTwo(31)):\n        print('Yes')\n    else:\n        print('No')\n \n    if(isPowerOfTwo(64)):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed by devendra salunke\n", "# Python3 program for the above approach\n \n# Function to check if x is power of 2\n \n \ndef isPowerOfTwo(x):\n \n    # First x in the below expression\n    # is for the case when x is 0\n    return (x and (not(x & (x - 1))))\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Function call\n    if(isPowerOfTwo(31)):\n        print('Yes')\n    else:\n        print('No')\n \n    if(isPowerOfTwo(64)):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed by Danish Raza\n", "# Python program of the above approach\n \n# Function to check if x is power of 2*/\n \n \ndef isPowerofTwo(n):\n \n    if (n == 0):\n        return 0\n    if ((n & (~(n - 1))) == n):\n        return 1\n    return 0\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Function call\n    if(isPowerofTwo(30)):\n        print('Yes')\n    else:\n        print('No')\n \n    if(isPowerofTwo(128)):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed by shivanisinghss2110\n"], "Set the K-th bit of a given number -  ": ["# Python implementation\n# to set the kth bit\n# of the given number\n \n# function to set\n# the kth bit\ndef setKthBit(n,k):\n \n    # kth bit of n is being\n    # set by this operation\n    return ((1 << k) | n)\n     \n# Driver code\n \nn = 10\nk = 2\n \nprint('Kth bit set number = ',\n          setKthBit(n, k))\n \n# This code is contributed\n# by Anant Agarwal.\n"], "Toggle bits in the given range -  ": ["# Python implementation\n# to toggle bits in\n# the given range\n \n# function to toggle bits\n# in the given range\n \n \ndef toggleBitsFromLToR(n, l, r):\n \n    # calculating a number\n    # 'num' having 'r'\n    # number of bits and\n    # bits in the range l\n    # to r are the only set bits\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1)\n \n    # toggle bits in the\n    # range l to r in 'n'\n    # Besides this, we can calculate num as: num=(1<<r)-l .\n \n    # and return the number\n    return (n ^ num)\n \n# Driver code\n \n \nn = 50\nl = 2\nr = 5\n \nprint(toggleBitsFromLToR(n, l, r))\n \n# This code is contributed\n# by Anant Agarwal.\n", "# Python3 implementation to toggle bits in\n# the given range\n \n# Function to toggle bits in the given range\ndef toggleBitsFromLToR(N, L, R):\n \n    res = N\n    for i in range(L, R + 1):\n \n        # Set bit\n        if ((N & (1 << (i - 1))) != 0):\n \n            # XOR will set 0 to already set\n            # bits(a^a=0)\n            res = res ^ (1 << (i - 1))\n \n        # unset bits\n        else:\n            # OR will set'0'bits to 1\n            res = res | (1 << (i - 1))\n \n    return res\n \n# Driver code\nn = 50\nl = 2\nr = 5\nprint(toggleBitsFromLToR(n, l, r))\n \n# This code is contributed by phasing17\n"], "Check whether K-th bit is set or not -  ": ["# Python3 code to check if k-th bit\n# of a given number is set or not\n \n \ndef isKthBitSet(n, k):\n    if n & (1 << k):\n        print('SET')\n    else:\n        print('NOT SET')\n \n \n# Driver code\nif __name__ == '__main__':\n    n = 5\n    k = 1\n \n    # Function call\n    isKthBitSet(n, k)\n \n# This code is contributed by 'Sharad_Bhardwaj'.\n", "# PHP program to check if k-th bit of\n# a given number is set or not using\n# right shift operator.\n \n \ndef isKthBitSet(n, k):\n    if ((n >> k) and 1):\n        print('SET')\n    else:\n        print('NOT SET')\n \n \n# Driver code\nif __name__ == '__main__':\n    n, k = 5, 1\n \n    # Function call\n    isKthBitSet(n, k)\n \n# This code contributed by\n# PrinciRaj1992\n"], "Position of rightmost different bit -  ": ["# Python implementation\n# to find the position\n# of rightmost different bit\n \nimport math\n \n# Function to find the position of\n# rightmost set bit in 'n'\n \n \ndef getRightMostSetBit(n):\n    if (n == 0):\n        return 0\n \n    return math.log2(n & -n) + 1\n \n \n# Function to find the position of\n# rightmost different bit in the\n# binary representations of 'm' and 'n'\ndef posOfRightMostDiffBit(m, n):\n \n    # position of rightmost different\n    # bit\n    return getRightMostSetBit(m ^ n)\n \n \n# Driver code\nif __name__ == '__main__':\n    m = 52\n    n = 4\n \n    # Function call\n    print('position = ', int(posOfRightMostDiffBit(m, n)))\n \n# This code is contributed\n# by Anant Agarwal.\n", "# Python3 implementation to find the\n# position of rightmost different\n# bit in two number.\nfrom math import floor, log10\n \n# Function to find rightmost different\n# bit in two numbers.\n \n \ndef posOfRightMostDiffBit(m, n):\n \n    return floor(log10(pow(m ^ n, 2))) + 2\n \n \n# Driver code\nif __name__ == '__main__':\n \n    m, n = 52, 4\n \n    # Function call\n    print('Position = ',\n          posOfRightMostDiffBit(m, n))\n \n# This code is contributed by mohit kumar 29\n"], "Position of rightmost set bit -  ": ["# Python Code for Position\n# of rightmost set bit\n \nimport math\n \n \ndef getFirstSetBitPos(n):\n \n    return math.log2(n & -n)+1\n \n# driver code\n \n \nn = 18\nprint(int(getFirstSetBitPos(n)))\n \n# This code is contributed\n# by Anant Agarwal.\n", "# Python3 program to find the\n# position of first rightmost\n# set bit in a given number\nimport math\n \n# Function to find rightmost\n# set bit in given number.\n \n \ndef getFirstSetBitPos(n):\n \n    return int(math.log2(n & -n) + 1)\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    n = 18\n    print(getFirstSetBitPos(n))\n \n# This code is contributed by nirajgusain5.\n", "# Python3 program to find\n# the first rightmost set\n# bit using XOR operator\n \n# function to find the\n# rightmost set bit\n \n \ndef PositionRightmostSetbit(n):\n \n    # Position variable initialize\n    # with 1 m variable is used\n    # to check the set bit\n    position = 1\n    m = 1\n \n    while (not(n & m)):\n \n        # left shift\n        m = m << 1\n        position += 1\n \n    return position\n \n \n# Driver Code\nn = 18\n \n# function call\nprint(PositionRightmostSetbit(n))\n \n# This code is contributed\n# by Smitha\n", "# Python 3 implementation of above approach\n \nINT_SIZE = 32\n \n \ndef Right_most_setbit(num):\n \n    pos = 1\n \n    # counting the position of first set bit\n    for i in range(INT_SIZE):\n        if not(num & (1 << i)):\n            pos += 1\n        else:\n            break\n \n    return pos\n \n \nif __name__ == '__main__':\n \n    num = 18\n    pos = Right_most_setbit(num)\n    print(pos)\n \n# This code is contributed by ANKITRAI1\n", "# Python program for above approach\n \n# Program to find position of\n# rightmost set bit\n \n \ndef PositionRightmostSetbit(n):\n    p = 1\n \n    # Iterate till number>0\n    while(n > 0):\n \n        # Checking if last bit is set\n        if(n & 1):\n            return p\n \n        # Increment position and right shift number\n        p += 1\n        n = n >> 1\n \n    # set bit not found.\n    return -1\n \n \n# Driver Code\nn = 18\n# Function call\npos = PositionRightmostSetbit(n)\nif(pos != -1):\n    print(pos)\nelse:\n    print(0)\n \n# This code is contributed by rohitsingh07052.\n"], "Program to generate all possible valid IP addresses from given string -  ": ["# Python3 code to check valid possible IP\n \n# Function checks whether IP digits\n# are valid or not.\ndef is_valid(ip):\n \n    # Splitting by '.'\n    ip = ip.split('.')\n     \n    # Checking for the corner cases\n    for i in ip:\n        if (len(i) > 3 or int(i) < 0 or\n                          int(i) > 255):\n            return False\n        if len(i) > 1 and int(i) == 0:\n            return False\n        if (len(i) > 1 and int(i) != 0 and\n            i[0] == '0'):\n            return False\n             \n    return True\n \n# Function converts string to IP address\ndef convert(s):\n     \n    sz = len(s)\n \n    # Check for string size\n    if sz > 12:\n        return []\n    snew = s\n    l = []\n \n    # Generating different combinations.\n    for i in range(1, sz - 2):\n        for j in range(i + 1, sz - 1):\n            for k in range(j + 1, sz):\n                snew = snew[:k] + '.' + snew[k:]\n                snew = snew[:j] + '.' + snew[j:]\n                snew = snew[:i] + '.' + snew[i:]\n                 \n                # Check for the validity of combination\n                if is_valid(snew):\n                    l.append(snew)\n                     \n                snew = s\n                 \n    return l \n \n# Driver code         \nA = '25525511135'\nB = '25505011535'\n \nprint(convert(A))\nprint(convert(B))\n", "# Python program to generate all possible\n# valid IP addresses from given string\n \nans = []\n \ndef is_valid(ip):\n    ip = ip + '.'\n    i, j = 0, 0\n    while i < len(ip):\n        s = ''\n        while ip[j] != '.':\n            s = s + ip[j]\n            j += 1\n        num = int(s)\n        if len(s) > 3 or num < 0 or num > 255:\n            return False\n        if len(s) > 1 and num == 0:\n            return False\n        if len(s) > 1 and num != 0 and s[0] == '0':\n            return False\n        i = j + 1\n        j = i\n    return True\n \ndef create_ip_from_dp(dp, r, c, s, res):\n    if r == 0:\n        res += s\n        ans.append(res)\n        return\n    for i in range(1, 4):\n        if c + i < len(s) and is_valid(s) and dp[r - 1] == 1:\n            create_ip_from_dp(dp, r - 1, c + i, s, res + s + '.')\n \ndef restore_ip_addresses(s):\n    n = len(s)\n    if n < 4 or n > 12:\n        return ans\n \n    # Initialize the dp array\n    dp = [[-1 for j in range(n)] for i in range(4)]\n \n    for i in range(4):\n        for j in range(n - 1, -1, -1):\n            if i == 0:\n                sub = s[j:]\n                if is_valid(sub):\n                    dp[i][j] = 1\n                elif j < n - 3:\n                    break\n            else:\n                if j <= n - i:\n                    for k in range(1, 4):\n                        if j + k <= n:\n                            temp = s[j:j + k]\n                            if is_valid(temp):\n                                if j + k < n and dp[i - 1][j + k] == 1:\n                                    dp[i][j] = 1\n                                    break\n \n    if dp[3][0] == 0:\n        return ans\n \n    # Call function create_ip_from_dp\n    create_ip_from_dp(dp, 3, 0, s, '')\n    return ans\n \n# Driver Code\nif __name__ == '__main__':\n    # Function call\n    ans = restore_ip_addresses('25525511135')\n    print(ans)\n \n#This code is contributed by rudra1807raj\n", "# Python code for the above approach\ndef solve(s, i, j, level, temp, res):\n \n    if (i == (j + 1) and level == 5):\n        res.append(temp[1:])\n \n    # Digits of a number ranging 0-255 can lie only between\n    # 0-3\n    k = i\n    while(k < i + 3 and k <= j):\n         \n        ad = s[i: k + 1]\n \n        # Return if string starting with '0' or it is\n        # greater than 255.\n        if ((s[i] == '0' and len(ad) > 1) or int(ad) > 255):\n            return\n \n        # Recursively call for another level.\n        solve(s, k + 1, j, level + 1, temp + '.' + ad, res)    \n \n        k += 1\n \n# driver code\ns = '25525511135'\nn = len(s)\nans = []\nsolve(s, 0, n - 1, 1, '', ans)\nfor s in ans:\n    print(s)\n \n# This code is contributed by shinjanpatra\n"], "Printing all solutions in N-Queen Problem -  ": ["''' Python3 program to solve N Queen Problem using \nbacktracking '''\n \n \nresult = []\n \n# A utility function to print solution\n \n \n''' A utility function to check if a queen can \nbe placed on board[row][col]. Note that this \nfunction is called when 'col' queens are \nalready placed in columns from 0 to col -1. \nSo we need to check only left side for \nattacking queens '''\n \n \ndef isSafe(board, row, col):\n \n    # Check this row on left side\n    for i in range(col):\n        if (board[row][i]):\n            return False\n \n    # Check upper diagonal on left side\n    i = row\n    j = col\n    while i >= 0 and j >= 0:\n        if(board[i][j]):\n            return False\n        i -= 1\n        j -= 1\n \n    # Check lower diagonal on left side\n    i = row\n    j = col\n    while j >= 0 and i < 4:\n        if(board[i][j]):\n            return False\n        i = i + 1\n        j = j - 1\n \n    return True\n \n \n''' A recursive utility function to solve N \nQueen problem '''\n \n \ndef solveNQUtil(board, col):\n    ''' base case: If all queens are placed \n    then return true '''\n    if (col == 4):\n        v = []\n        for i in board:\n          for j in range(len(i)):\n            if i[j] == 1:\n              v.append(j+1)\n        result.append(v)\n        return True\n \n    ''' Consider this column and try placing \n    this queen in all rows one by one '''\n    res = False\n    for i in range(4):\n \n        ''' Check if queen can be placed on \n        board[i][col] '''\n        if (isSafe(board, i, col)):\n \n            # Place this queen in board[i][col]\n            board[i][col] = 1\n \n            # Make result true if any placement\n            # is possible\n            res = solveNQUtil(board, col + 1) or res\n \n            ''' If placing queen in board[i][col] \n            doesn't lead to a solution, then \n            remove queen from board[i][col] '''\n            board[i][col] = 0  # BACKTRACK\n \n    ''' If queen can not be place in any row in \n        this column col then return false '''\n    return res\n \n \n''' This function solves the N Queen problem using \nBacktracking. It mainly uses solveNQUtil() to \nsolve the problem. It returns false if queens \ncannot be placed, otherwise return true and \nprints placement of queens in the form of 1s. \nPlease note that there may be more than one \nsolutions, this function prints one of the \nfeasible solutions.'''\n \n \ndef solveNQ(n):\n    result.clear()\n    board = [[0 for j in range(n)]\n             for i in range(n)]\n    solveNQUtil(board, 0)\n    result.sort()\n    return result\n \n \n# Driver Code\nn = 4\nres = solveNQ(n)\nprint(res)\n \n# This code is contributed by YatinGupta\n", "# Python program for above approach\nimport math\n \nresult = []\n \n# Program to solve N-Queens Problem\n \n \ndef solveBoard(board, row, rowmask,\n               ldmask, rdmask):\n \n    n = len(board)\n \n    # All_rows_filled is a bit mask\n    # having all N bits set\n    all_rows_filled = (1 << n) - 1\n \n    # If rowmask will have all bits set, means\n    # queen has been placed successfully\n    # in all rows and board is displayed\n    if (rowmask == all_rows_filled):\n        v = []\n        for i in board:\n            for j in range(len(i)):\n                if i[j] == 'Q':\n                    v.append(j+1)\n        result.append(v)\n \n    # We extract a bit mask(safe) by rowmask,\n    # ldmask and rdmask. all set bits of 'safe'\n    # indicates the safe column index for queen\n    # placement of this iteration for row index(row).\n    safe = all_rows_filled & (~(rowmask |\n                                ldmask | rdmask))\n \n    while (safe > 0):\n \n        # Extracts the right-most set bit\n        # (safe column index) where queen\n        # can be placed for this row\n        p = safe & (-safe)\n        col = (int)(math.log(p)/math.log(2))\n        board[row][col] = 'Q'\n \n        # This is very important:\n        # we need to update rowmask, ldmask and rdmask\n        # for next row as safe index for queen placement\n        # will be decided by these three bit masks.\n \n        # We have all three rowmask, ldmask and\n        # rdmask as 0 in beginning. Suppose, we are placing\n        # queen at 1st column index at 0th row. rowmask, ldmask\n        # and rdmask will change for next row as below:\n \n        # rowmask's 1st bit will be set by OR operation\n        # rowmask = 00000000000000000000000000000010\n \n        # ldmask will change by setting 1st\n        # bit by OR operation  and left shifting\n        # by 1 as it has to block the next column\n        # of next row because that will fall on left diagonal.\n        # ldmask = 00000000000000000000000000000100\n \n        # rdmask will change by setting 1st bit\n        # by OR operation and right shifting by 1\n        # as it has to block the previous column\n        # of next row because that will fall on right diagonal.\n        # rdmask = 00000000000000000000000000000001\n \n        # these bit masks will keep updated in each\n        # iteration for next row\n        solveBoard(board, row+1, rowmask | p,\n                   (ldmask | p) << 1, (rdmask | p) >> 1)\n \n        # Reset right-most set bit to 0 so, next\n        # iteration will continue by placing the queen\n        # at another safe column index of this row\n        safe = safe & (safe-1)\n \n        # Backtracking, replace 'Q' by ' '\n        board[row][col] = ' '\n \n# Program to print board\n \n \ndef printBoard(board):\n    for row in board:\n        print('|' + '|'.join(row) + '|')\n \n# Driver Code\n \n \ndef main():\n \n    n = 4  # board size\n    board = []\n \n    for i in range(n):\n        row = []\n        for j in range(n):\n            row.append(' ')\n        board.append(row)\n \n    rowmask = 0\n    ldmask = 0\n    rdmask = 0\n    row = 0\n \n    # Function Call\n    result.clear()\n    solveBoard(board, row, rowmask, ldmask, rdmask)\n    result.sort()\n    print(result)\n \n \nif __name__ == '__main__':\n    main()\n \n# This code is contributed by Nikhil Vinay\n", "class NQueenProblem:\n     \n    def print_board(board):\n        count = 0\n        for row in board:\n            for el in row:\n                if el == 1:\n                    count += 1\n        # Not a valid solution\n        if count != len(board):\n            return\n \n        # Print the matrix\n        for row in board:\n            for el in row:\n                print(el, end=' ')\n            print()\n \n    def validate(board, i, j):\n        # Validate rows\n        for c in range(j):\n            if board[i] == 1:\n                return False\n \n        # Validate columns\n        for r in range(i):\n            if board[r][j] == 1:\n                return False\n \n        # Validate diagonals to right up corner\n        r, c = i, j\n        while c >= 0 and r >= 0:\n            if board[r] == 1:\n                return False\n            r -= 1\n            c -= 1\n \n        # Validate diagonals to left up corner\n        r, c = i, j\n        while c < len(board) and r >= 0:\n            if board[r] == 1:\n                return False\n            r -= 1\n            c += 1\n \n        return True\n \n    def n_queen(n):\n        solutions = []  # Store all valid solutions\n        board = [[0] * n for _ in range(n)]\n \n        stack = []  # Stack to simulate recursive calls\n        row, col = 0, 0\n \n        while True:\n            # Try to place a queen in the current row\n            while col < n:\n                if NQueenProblem.validate(board, row, col):\n                    board[row][col] = 1\n                    stack.append((row, col))\n                    col = 0\n                    break\n                col += 1\n            else:\n                if not stack:  # No valid placement found and no backtrack is possible\n                    break\n                row, col = stack.pop()\n                board[row][col] = 0\n                col += 1\n                continue\n \n            if row == n - 1:\n                # A valid solution is found\n                solution = [row[:] for row in board]\n                solutions.append(solution)\n                board[row][col] = 0\n                col += 1\n                continue\n \n            row += 1\n \n        for solution in solutions:\n            NQueenProblem.print_board(solution)\n            print()\n \nNQueenProblem.n_queen(4)\n      \n# This code is contributed by guptapratik\n"], "How to print maximum number of A's using given four keys -  ": ["# A recursive Python3 program to print maximum \n# number of A's using following four keys\n \n# A recursive function that returns \n# the optimal length string for N keystrokes\n \ndef findoptimal(N):\n     \n    # The optimal string length is \n    # N when N is smaller than\n    if N<= 6:\n        return N\n \n    # Initialize result \n    maxi = 0\n \n    # TRY ALL POSSIBLE BREAK-POINTS \n    # For any keystroke N, we need\n    # to loop from N-3 keystrokes \n    # back to 1 keystroke to find \n    # a breakpoint 'b' after which we \n    # will have Ctrl-A, Ctrl-C and then \n    # only Ctrl-V all the way.\n    for b in range(N-3, 0, -1):\n        curr =(N-b-1)*findoptimal(b)\n        if curr>maxi:\n            maxi = curr\n     \n    return maxi\n# Driver program\nif __name__=='__main__':\n     \n \n# for the rest of the array we will\n# reply on the previous \n# entries to compute new ones \n    for n in range(1, 21):\n        print('Maximum Number of As with ', n, 'keystrokes is ', findoptimal(n))\n        \n# this code is contributed by sahilshelangia\n", "# A Dynamic Programming based Python program \n# to find maximum number of A's\n# that can be printed using four keys \n \n# this function returns the optimal \n# length string for N keystrokes\ndef findoptimal(N):\n \n    # The optimal string length is \n    # N when N is smaller than 7\n    if (N <= 6):\n        return N\n \n    # An array to store result of \n    # subproblems\n    screen = [0]*N\n \n    # Initializing the optimal lengths \n    # array for until 6 input\n    # strokes.\n     \n    for n in range(1, 7):\n        screen[n-1] = n\n \n    # Solve all subproblems in bottom manner\n    for n in range(7, N + 1):\n     \n        # Initialize length of optimal \n        # string for n keystrokes\n        screen[n-1] = 0\n \n        # For any keystroke n, we need to \n        # loop from n-3 keystrokes\n        # back to 1 keystroke to find a breakpoint\n        # 'b' after which we\n        # will have ctrl-a, ctrl-c and then only \n        # ctrl-v all the way.\n        for b in range(n-3, 0, -1):\n         \n            # if the breakpoint is at b'th keystroke then\n            # the optimal string would have length\n            # (n-b-1)*screen[b-1];\n            curr = (n-b-1)*screen[b-1]\n            if (curr > screen[n-1]):\n                screen[n-1] = curr\n         \n    return screen[N-1]\n \n# Driver program\nif __name__ == '__main__':\n \n    # for the rest of the array we \n    # will reply on the previous\n    # entries to compute new ones\n    for N in range(1, 21):\n        print('Maximum Number of A's with ', N, ' keystrokes is ',\n                findoptimal(N))\n \n# this code is contributed by\n# ChitraNayal\n", "# A Dynamic Programming based Python3 program \n# to find maximum number of A's\n# that can be printed using four keys \n \n# this function returns the optimal \n# length string for N keystrokes\ndef findoptimal(N):\n \n    # The optimal string length is \n    # N when N is smaller than 7\n    if (N <= 6):\n        return N\n \n    # An array to store result of \n    # subproblems\n    screen = [0] * N\n \n    # Initializing the optimal lengths \n    # array for until 6 input\n    # strokes.\n     \n    for n in range(1, 7):\n        screen[n - 1] = n\n \n    # Solve all subproblems in bottom manner\n    for n in range(7, N + 1):\n         \n        # for any keystroke n, we will need to choose between:-\n        # 1. pressing Ctrl-V once after copying the\n        # A's obtained by n-3 keystrokes.\n \n        # 2. pressing Ctrl-V twice after copying the A's\n        # obtained by n-4 keystrokes.\n \n        # 3. pressing Ctrl-V thrice after copying the A's\n        # obtained by n-5 keystrokes.\n        screen[n - 1] = max(2 * screen[n - 4], \n                        max(3 * screen[n - 5], \n                            4 * screen[n - 6]));\n         \n    return screen[N - 1]\n \n# Driver Code\nif __name__ == '__main__':\n \n    # for the rest of the array we \n    # will reply on the previous\n    # entries to compute new ones\n    for N in range(1, 21):\n        print('Maximum Number of A's with ', N,\n              ' keystrokes is ', findoptimal(N))\n \n# This code is contributed by ashutosh450\n"], "Recursively remove all adjacent duplicates -  ": ["# Python Program for above approach\n \n# Recursively removes adjacent\n# duplicates from str and\n# returns new string. las_removed\n# is a pointer to\n# last_removed character\n \n \ndef removeDuplicates(s, ch):\n \n    # If length of string is 1 or 0\n    if (len(s) <= 1):\n        return s\n \n    i = 0\n    while (i < len(s)):\n        if (i + 1 < len(s) and s[i] == s[i + 1]):\n            j = i\n            while (j + 1 < len(s) and s[j] == s[j + 1]):\n                j += 1\n \n            lastChar = s[i - 1] if(i > 0) else ch\n \n            remStr = removeDuplicates(s[j + 1: len(s)], lastChar)\n \n            s = s[0: i]\n            k, l = len(s), 0\n \n            # Recursively remove all the adjacent\n            # characters formed by removing the\n            # adjacent characters\n            while (len(remStr) > 0 and len(s) > 0\n                   and remStr[0] == s[len(s) - 1]):\n \n                # Have to check whether this is the\n                # repeated character that matches the\n                # last char of the parent String\n                while (len(remStr) > 0\n                       and remStr[0] != ch\n                       and remStr[0] == s[len(s) - 1]):\n                    remStr = remStr[1: len(remStr)+1]\n \n                s = s[0: len(s) - 1]\n \n            s = s + remStr\n            i = j\n \n        else:\n            i += 1\n \n    return s\n \n \n# Driver Code\nstr1 = 'mississipie'\nprint(removeDuplicates(str1, ' '))\n \nstr2 = 'ocvvcolop'\nprint(removeDuplicates(str2, ' '))\n \n# This code is contributed by shinjanpatra\n", "# code\nimport re\ndef remove(s):\n  groups = [(match.group() for match in re.finditer(r'(.)\\1*',s))]\n  s=''\n  for i in groups:\n    if len(i)>1:\n        continue\n    s+=i\n  return s\ndef rremove(s):\n  ps=''\n  while len(ps)!=len(s):\n    ps=s\n    s=remove(s)\n  return s\n \n# Driver Code\nstr1 = 'geeksforgeek'\nprint(rremove(str1))\n  \nstr2 = 'abccbccba'\nprint(rremove(str2))\n", "class Solution:\n    def rremove(self, S):\n        new = [i for i in S]  # Convert the string to a list\n        st = []  # Initialize an empty stack\n        i = 0  # Initialize the index variable\n \n        while i < len(S):\n            # Check if stack is not empty and top of stack is the same as S[i]\n            if st and st[-1] == S[i]:\n                # Remove consecutive characters equal to the top of the stack\n                while i < len(S) and S[i] == st[-1]:\n                    i += 1\n                st.pop()\n \n            # If S[i] is different from top of the stack, push it onto the stack\n            if i < len(S):\n                st.append(S[i])\n                i += 1\n \n        # Check if resulting string is the same as original string\n        if new == st:\n            return ''.join(new)  # Return the resulting string\n \n        # Recursively call rremove with the resulting string as input\n        else:\n            return self.rremove(''.join(st))\n \n \n# Example usage:\ns = Solution()\ninput_string = ' s'\n \n# Function call\noutput_string = s.rremove(input_string)\nprint('Output:', output_string)\n"], "Longest Common Prefix using Word by Word Matching -  ": ["# A python3 Program to find the longest \n# common prefix\n \n# A Utility Function to find the common \n# prefix between strings- str1 and str2\ndef commonPrefixUtil(str1, str2):\n \n    result = '';\n    n1 = len(str1)\n    n2 = len(str2)\n \n    # Compare str1 and str2\n    i = 0\n    j = 0\n    while i <= n1 - 1 and j <= n2 - 1:\n     \n        if (str1[i] != str2[j]):\n            break\n             \n        result += str1[i]\n        i += 1\n        j += 1\n \n    return (result)\n \n# A Function that returns the longest \n# common prefix from the array of strings\ndef commonPrefix (arr, n):\n \n    prefix = arr[0]\n \n    for i in range (1, n):\n        prefix = commonPrefixUtil(prefix, arr[i])\n \n    return (prefix)\n \n# Driver Code\nif __name__ =='__main__':\n \n    arr = [' ', 'geeks',\n                    'geek', 'geezer']\n    n = len(arr)\n \n    ans = commonPrefix(arr, n)\n \n    if (len(ans)):\n        print ('The longest common prefix is -',\n                ans);\n    else:\n        print('There is no common prefix')\n \n# This code is contributed by ita_c\n", "# A function to find the longest common prefix in a list of strings\ndef longest_common_prefix(arr):\n    # Check if the input list is empty\n    if not arr:\n        # If the list is empty, return an empty string\n        return ''\n    # Sort the input list of strings\n    arr.sort()\n    # Initialize the prefix to an empty string\n    prefix = ''\n    # Loop through the first string of the sorted list\n    for i in range(len(arr[0])):\n        # Check if the current character is the same in all strings in the list\n        if all(x[i] == arr[0][i] for x in arr):\n            # If the current character is the same in all strings, add it to the prefix\n            prefix += arr[0][i]\n        else:\n            # If the current character is not the same in all strings, break the loop\n            break\n    # Return the prefix\n    return prefix\n \n# A sample list of strings\narr = [' ', 'geeks', 'geek', 'geezer']\n# Print the longest common prefix\nprint('The longest common prefix is: ', longest_common_prefix(arr))\n"], "Convert a sentence into its equivalent mobile numeric keypad sequence -  ": ["# Python3 implementation to convert\n# a sentence into its equivalent\n# mobile numeric keypad sequence\n \n# Function which computes the\n# sequence\n \n \ndef printSequence(arr, input):\n \n    # length of input string\n    n = len(input)\n    output = ''\n \n    for i in range(n):\n \n        # checking for space\n        if(input[i] == ' '):\n            output = output + '0'\n        else:\n            # calculating index for each\n            # character\n            position = ord(input[i]) - ord('A')\n            output = output + arr[position]\n    # output sequence\n    return output\n \n \n# Driver code\nstr = ['2', '22', '222',\n       '3', '33', '333',\n       '4', '44', '444',\n       '5', '55', '555',\n       '6', '66', '666',\n       '7', '77', '777', '7777',\n       '8', '88', '888',\n       '9', '99', '999', '9999']\n \ninput = ' '\nprint(printSequence(str, input))\n \n# This code is contributed by upendra bartwal\n"], "Check if a string is substring of another -  ": ["# Python3 program to check if\n# a string is substring of other.\n \n# Returns true if s1 is substring of s2\n \n \ndef isSubstring(s1, s2):\n    M = len(s1)\n    N = len(s2)\n \n    # A loop to slide pat[] one by one\n    for i in range(N - M + 1):\n \n        # For current index i,\n        # check for pattern match\n        for j in range(M):\n            if (s2[i + j] != s1[j]):\n                break\n \n        if j + 1 == M:\n            return i\n \n    return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n    s1 = 'for'\n    s2 = ' '\n    res = isSubstring(s1, s2)\n    if res == -1:\n        print('Not present')\n    else:\n        print('Present at index ' + str(res))\n \n# This code is contributed by ChitraNayal\n", "# Python3 program to check if\n# a string is substring of other.\n \n# Checks if s1 is a substring of s2\n \n \ndef isSubstring(s1, s2):\n    if s1 in s2:\n        return s2.index(s1)\n    return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n    s1 = 'for'\n    s2 = ' '\n    res = isSubstring(s1, s2)\n    if res == -1:\n        print('Not present')\n    else:\n        print('Present at index ' + str(res))\n \n# This code is contributed by phasing17\n"], "Write your own atoi() -  ": ["def main():\n    strn1 = '12546'\n    val = int(strn1)\n    print('String value = ', strn1)\n    print('Integer value = ', val)\n \n    strn2 = ' '\n    try:\n        val = int(strn2)\n    except ValueError:\n        val = 0\n        print('String value = ', strn2)\n        print('Integer value = ', val)\n \n \nif __name__ == '__main__':\n    main()\n", "# Python program for implementation of atoi\n \n# A simple atoi() function\n \n \ndef myAtoi(string):\n    res = 0\n \n    # Iterate through all characters of\n    #  input string and update result\n    for i in range(len(string)):\n        res = res * 10 + (ord(string[i]) - ord('0'))\n \n    return res\n \n \n# Driver program\nstring = '89789'\n \n# Function call\nprint(myAtoi(string))\n \n# This code is contributed by BHAVYA JAIN\n", "# Python program for implementation of atoi\n \n# A simple atoi() function\n \n \ndef myAtoi(string):\n    res = 0\n    # initialize sign as positive\n    sign = 1\n    i = 0\n \n    # if number is negative then update sign\n    if string[0] == '-':\n        sign = -1\n        i += 1\n \n    # Iterate through all characters\n    # of input string and update result\n    for j in range(i, len(string)):\n        res = res*10+(ord(string[j])-ord('0'))\n \n    return sign * res\n \n \n# Driver code\nstring = '-123'\n \n# Function call\nprint(myAtoi(string))\n \n# This code is contributed by BHAVYA JAIN\n", "# A simple Python3 program for\n# implementation of atoi\nimport sys\n \n \ndef myAtoi(Str):\n \n    sign, base, i = 1, 0, 0\n \n    # If whitespaces then ignore.\n    while (Str[i] == ' '):\n        i += 1\n \n    # Sign of number\n    if (Str[i] == '-' or Str[i] == '+'):\n        sign = 1 - 2 * (Str[i] == '-')\n        i += 1\n \n    # Checking for valid input\n    while (i < len(Str) and\n           Str[i] >= '0' and Str[i] <= '9'):\n \n        # Handling overflow test case\n        if (base > (sys.maxsize // 10) or\n            (base == (sys.maxsize // 10) and\n                (Str[i] - '0') > 7)):\n            if (sign == 1):\n                return sys.maxsize\n            else:\n                return -(sys.maxsize)\n \n        base = 10 * base + (ord(Str[i]) - ord('0'))\n        i += 1\n \n    return base * sign\n \n \n# Driver Code\nStr = list(' -123')\n \n# Functional Code\nval = myAtoi(Str)\n \nprint(val)\n \n# This code is contributed by divyeshrabadiya07\n"], "Length of the longest substring without repeating characters -  ": ["# Python3 program to find the length\n# of the longest substring without\n# repeating characters\n \n# This function returns true if all\n# characters in str[i..j] are\n# distinct, otherwise returns false\n \n \ndef areDistinct(str, i, j):\n \n    # Note : Default values in visited are false\n    visited = [0] * (256)\n \n    for k in range(i, j + 1):\n        if (visited[ord(str[k])] == True):\n            return False\n \n        visited[ord(str[k])] = True\n \n    return True\n \n# Returns length of the longest substring\n# with all distinct characters.\n \n \ndef longestUniqueSubsttr(str):\n \n    n = len(str)\n \n    # Result\n    res = 0\n \n    for i in range(n):\n        for j in range(i, n):\n            if (areDistinct(str, i, j)):\n                res = max(res, j - i + 1)\n \n    return res\n \n \n# Driver code\nif __name__ == '__main__':\n \n    str = ' '\n    print('The input is ', str)\n \n    len = longestUniqueSubsttr(str)\n    print('The length of the longest '\n          'non-repeating character substring is ', len)\n \n# This code is contributed by mohit kumar 29\n", "# Python3 program to find the\n# length of the longest substring\n# without repeating characters\n \n \ndef longestUniqueSubsttr(str):\n \n    n = len(str)\n \n    # Result\n    res = 0\n \n    for i in range(n):\n \n        # Note : Default values in\n        # visited are false\n        visited = [0] * 256\n \n        for j in range(i, n):\n \n            # If current character is visited\n            # Break the loop\n            if (visited[ord(str[j])] == True):\n                break\n \n            # Else update the result if\n            # this window is larger, and mark\n            # current character as visited.\n            else:\n                res = max(res, j - i + 1)\n                visited[ord(str[j])] = True\n \n        # Remove the first character of previous\n        # window\n        visited[ord(str[i])] = False\n \n    return res\n \n \n# Driver code\nstr = ' '\nprint('The input is ', str)\n \nlen = longestUniqueSubsttr(str)\nprint('The length of the longest '\n      'non-repeating character substring is ', len)\n \n# This code is contributed by sanjoy_62\n", "def is_valid(s, mid):\n    # Count the frequency of each character in the pattern\n    count = [0] * 256\n    found = False\n \n    # Stores the number of distinct characters in a substring of size mid\n    distinct = 0\n \n    for i in range(len(s)):\n        count[ord(s[i])] += 1\n        if count[ord(s[i])] == 1:\n            distinct += 1\n        if i >= mid:\n            count[ord(s[i - mid])] -= 1\n            if count[ord(s[i - mid])] == 0:\n                distinct -= 1\n        if i >= mid - 1:\n            # Substring of length mid found which contains all the unique characters\n            if distinct == mid:\n                found = True\n \n    return found\n \ndef longest_unique_substring(s):\n    length = len(s)\n    ans = float('inf')\n \n    # Lower bound and Upper Bound for Binary Search\n    low_bound = 1\n    high_bound = length\n \n    # Applying Binary Search on answer\n    while low_bound <= high_bound:\n        mid = (low_bound + high_bound) // 2\n \n        # If a substring of length mid is found which contains all unique characters\n        # then update low_bound, otherwise update high_bound\n        if is_valid(s, mid):\n            ans = mid\n            low_bound = mid + 1\n        else:\n            high_bound = mid - 1\n \n    return ans\n \n# Driver code\nif __name__ == '__main__':\n    input_str = ' '\n    print('The input string is', input_str)\n    length = longest_unique_substring(input_str)\n    print('The length of the longest non-repeating character substring is', length)\n \n     \n# This code is contributed by shivamgupta310570\n", "import math\n \n \ndef longestUniqueSubsttr(s):\n    # if string length is 0\n    if len(s) == 0:\n        return 0\n \n    # if string length 1\n    if len(s) == 1:\n        return 1\n \n    # if string length is more than 2\n    maxLength = 0\n    visited = [False] * 256\n \n    # left and right pointer of sliding window\n    left, right = 0, 0\n    while right < len(s):\n \n        # if character is visited\n        if visited[ord(s[right])]:\n \n            # The left pointer moves to the right while\n            # marking visited characters as false until the\n            # repeating character is no longer part of the\n            # current window.\n            while visited[ord(s[right])]:\n \n                visited[ord(s[left])] = False\n                left += 1\n \n        visited[ord(s[right])] = True\n \n        # The length of the current window (right - left + 1)\n        # is calculated and the answer is updated accordingly.\n        maxLength = max(maxLength, right - left + 1)\n        right += 1\n \n    return maxLength\n \n \n# Driver Code\nstring = ' '\nprint('The input string is', string)\nlength = longestUniqueSubsttr(string)\nprint('The length of the longest non-repeating character substring is', length)\n", "# Python3 program to find the length\n# of the longest substring\n# without repeating characters\n \n \ndef longestUniqueSubsttr(string):\n \n    # last index of every character\n    last_idx = {}\n    max_len = 0\n \n    # starting index of current\n    # window to calculate max_len\n    start_idx = 0\n \n    for i in range(0, len(string)):\n \n        # Find the last index of str[i]\n        # Update start_idx (starting index of current window)\n        # as maximum of current value of start_idx and last\n        # index plus 1\n        if string[i] in last_idx:\n            start_idx = max(start_idx, last_idx[string[i]] + 1)\n \n        # Update result if we get a larger window\n        max_len = max(max_len, i-start_idx + 1)\n \n        # Update last index of current char.\n        last_idx[string[i]] = i\n \n    return max_len\n \n \n# Driver program to test the above function\nstring = ' '\nprint('The input string is ' + string)\nlength = longestUniqueSubsttr(string)\nprint('The length of the longest non-repeating character' +\n      ' substring is ' + str(length))\n"], "Remove duplicates from a given string -  ": ["string=' '\np=''\nfor char in string:\n    if char not in p:\n        p=p+char\nprint(p)\nk=list(' ')\n", "# Python program to create a unique string using unordered_map\n \n# access time in unordered_map on is O(1) generally if no collisions occur\n# and therefore it helps us check if an element exists in a string in O(1)\n# time complexity with constant space.\ndef removeDuplicates(s, n):\n    exists = {}\n    index = 0\n    ans = ''\n \n    for i in range(0, n):\n        if s[i] not in exists or exists[s[i]] == 0:\n            s[index] = s[i]\n            print(s[index], end='')\n            index += 1\n            exists[s[i]] = 1\n \n# driver code\ns = ' '\ns1 = list(s)\nn = len(s1)\nremoveDuplicates(s1, n)\n"], "Check whether two Strings are anagram of each other -  ": ["# Python3 implementation of the approach\n# Function that returns True if a and b\n# are anagarams of each other\n \n \ndef isAnagram(a, b):\n \n    # Check if length of both strings is same or not\n    if (len(a) != len(b)):\n        return False\n \n    # Create a HashMap containing Character as Key and\n    # Integer as Value. We will be storing character as\n    # Key and count of character as Value.\n    map = {}\n    # Loop over all character of String a and put in\n    # HashMap.\n    for i in range(len(a)):\n        # Check if HashMap already contain current\n        # character or not\n        if (a[i] in map):\n            # If contains increase count by 1 for that\n            # character\n            map[a[i]] += 1\n \n        else:\n            # else set that character in map and set\n            # count to 1 as character is encountered\n            # first time\n            map[a[i]] = 1\n \n    # Now loop over String b\n    for i in range(len(b)):\n        # Check if current character already exists in\n        # HashMap/map\n        if (b[i] in map):\n            # If contains reduce count of that\n            # character by 1 to indicate that current\n            # character has been already counted as\n            # idea here is to check if in last count of\n            # all characters in last is zero which\n            # means all characters in String a are\n            # present in String b.\n            map[b[i]] -= 1\n        else:\n            return False\n \n    # Extract all keys of HashMap/map\n    keys = map.keys()\n    # Loop over all keys and check if all keys are 0.\n    # If so it means it is anagram.\n    for key in keys:\n        if (map[key] != 0):\n            return False\n \n    # Returning True as all keys are zero\n    return True\n \n \n# Driver code\nstr1 = 'gram'\nstr2 = 'arm'\n \n# Function call\nif (isAnagram(str1, str2)):\n    print('The two strings are anagram of each other')\nelse:\n    print('The two strings are not anagram of each other')\n \n \n# This code is contributed by shinjanpatra\n"], "Converting Roman Numerals to Decimal lying between 1 to 3999 -  ": [], "Reverse words in a given string -  ": ["# Python3 program to reverse a string\n \n# Function to reverse each word in the string\n \n \ndef reverse_word(s, start, end):\n    while start < end:\n        s[start], s[end] = s[end], s[start]\n        start = start + 1\n        end -= 1\n \n \ns = 'i like this program very much'\n \n# Convert string to list to use it as a char array\ns = list(s)\nstart = 0\nwhile True:\n \n    # We use a try catch block because for\n    # the last word the list.index() function\n    # returns a ValueError as it cannot find\n    # a space in the list\n    try:\n        # Find the next space\n        end = s.index(' ', start)\n \n        # Call reverse_word function\n        # to reverse each word\n        reverse_word(s, start, end - 1)\n \n        # Update start variable\n        start = end + 1\n \n    except ValueError:\n \n        # Reverse the last word\n        reverse_word(s, start, len(s) - 1)\n        break\n \n# Reverse the entire list\ns.reverse()\n \n# Convert the list back to\n# string using string.join() function\ns = ''.join(s)\n \nprint(s)\n \n# Solution contributed by Prem Nagdeo\n", "# Python3 program to reverse a string\n \n# Reverse the letters\n# of the word\ndef reverse(str, start, end):\n    # Temporary variable\n    # to store character\n    temp = ''\n    str1 = ''\n \n    while (start <= end):\n        # Swapping the first\n        # and last character\n        temp = str[start]\n        str[start] = str[end]\n        str[end] = temp\n        start+=1\n        end-=1\n    return str1.join(str)\n \ndef reverseWords(s):\n     \n    word_begin = -1\n \n    #  temp is for word boundary \n    i = 0\n \n    # STEP 1 of the above algorithm \n    while (i < len(s)):\n \n        ''' This condition is to make sure that the\n                string start with valid character (not\n                space) only '''\n        if ((word_begin == -1) and (s[i] != ' ')):\n            word_begin = i\n        if (word_begin != -1 and ((i + 1 == len(s)) or (s[i + 1] == ' '))):\n            s = reverse(list(s), word_begin, i)\n            word_begin = -1\n        i+=1\n    ''' End of while '''\n \n    # STEP 2 of the above algorithm \n    s = reverse(list(s), 0, (len(s) - 1))\n    return s\n \n# Driver Code\ns = 'i like this program very much'\n \n# Function call\np = reverseWords(list(s))\nprint(p)\n \n# This code is contributed by akashish__\n", "# Python3 program to reverse a string\n# s = input()\ns = 'i like this program very much'\nwords = s.split(' ')\nstring = []\nfor word in words:\n    string.insert(0, word)\n \n \nprint(' '.join(string))\n \n# Solution proposed bu Uttam\n", "# Python3 code to reverse a string\n \n# Reverse the string\n \n \ndef RevString(s, l):\n \n    # Check if number of words is even\n    if l % 2 == 0:\n \n        # Find the middle word\n        j = int(l/2)\n \n        # Starting from the middle\n        # start swapping words\n        # at jth position and l-1-j position\n        while(j <= l - 1):\n            s[j], s[l - j - 1] = s[l - j - 1], s[j]\n            j += 1\n \n    # Check if number of words is odd\n    else:\n \n        # Find the middle word\n        j = int(l/2 + 1)\n \n        # Starting from the middle\n        # start swapping the words\n        # at jth position and l-1-j position\n        while(j <= l - 1):\n            s[j], s[l - 1 - j] = s[l - j - 1], s[j]\n            j += 1\n \n        # return the reversed sentence\n        return s\n \n \n# Driver Code\ns = 'i like this program very much '\nstring = s.split(' ')\nstring = RevString(string, len(string))\nprint(' '.join(string))\n", "# Python code for the above approach\n \ndef reverse_words(s):\n    left = 0\n    i = 0\n    s = list(s)\n    n = len(s)\n     \n    while(s[i] == ' '):\n        i = i+1\n         \n    left = i\n     \n    while(i < n):\n        if(i+1 == n or s[i] == ' '):\n            j = i-1\n            if i+1 == n:\n                j = j+1\n             \n            while left < j:\n                s[left], s[j] = s[j], s[left]\n                left = left+1\n                j = j-1\n             \n            left = i + 1\n         \n        if(i > left and s[left] == ' '):\n            left = i\n         \n        i = i+1\n    s = ''.join(s)\n    s = s[::-1]\n    return s\n \ns1 = 'i like this program very much'\ns1 = reverse_words(s1)\nprint(s1)\n     \n# This Code is contributed by Yash Agarwal(yashagarwal2852002)\n", "# python code to reverse words in a given string\n \n# input string\nstring = 'i like this program very much'\n \n# spliting words in the given string\n# using slicing reverse the words\ns = string.split()[::-1]\n \n# joining the reversed string and\n# printing the output\nprint(' '.join(s))\n", "def reverseString(s):\n    ans = ''\n    temp = ''\n    for ch in s:\n        if ch == ' ':\n            if temp:\n                ans = temp + ' ' + ans\n            temp = ''\n        else:\n            temp += ch\n \n    if temp:\n        ans = temp + ' ' + ans\n \n    if ans and ans[-1] == ' ':\n        ans = ans[:-1]\n \n    return ans\n \nif __name__ == '__main__':\n    s1 = ' Welcome to Geeks For Geeks '\n    print('Before reversing length of string:', len(s1))\n    ans1 = reverseString(s1)\n    print('After reversing length of string:', len(ans1))\n    print('\\'' + ans1 + '\\'')\n \n    s2 = ' I Love Python Programming     '\n    print('Before reversing length of string:', len(s2))\n    ans2 = reverseString(s2)\n    print('After reversing length of string:', len(ans2))\n    print('\\'' + ans2 + '\\'')\n"], "Find the first repeated character in a string -  ": ["def firstRepeating(str):\n    n = len(str)\n     \n    ans = ''\n    index = float('inf')\n     \n    for i in range(n):\n        temp = str[i]\n        # Checking that character in temp repeats or not by running a for loop\n        for j in range(i+1, n):\n            if str[j] == temp:\n                # if the index where it repeated is less than the index of the previously \n                # repeated character then store this character in ans variable \n                # and its index where it repeated in index variable\n                if j < index:\n                    index = j\n                    ans = str[j]\n     \n    return ans\n     \n# Driver method to test above method \nif __name__ == '__main__':\n    str = ' '\n    print(firstRepeating(str))\n", "# Python program to find the first \n# repeated character in a string \ndef firstRepeatedChar(str): \n \n    h = {} # Create empty hash \n \n    # Traverse each characters in string \n    # in lower case order \n    for ch in str: \n \n        # If character is already present \n        # in hash, return char \n        if ch in h: \n            return ch; \n \n        # Add ch to hash \n        else: \n            h[ch] = 0\n \n    return ''\n \n \n# Driver code \nprint(firstRepeatedChar(' ')) \n", "def first_rep_char(s):\n    '''\n    Function to find the first repeated character in a string\n    '''\n    # Create a dictionary to store the count of characters\n    char_count = {}\n \n    # Iterate through each character in the string\n    for ch in s:\n        # If the character is already in the dictionary, it means it is repeated\n        if ch in char_count:\n            return ch\n        else:\n            # Increment the count of the character in the dictionary\n            char_count[ch] = 1\n \n    # If no character is repeated, return '-1'\n    return '-1'\n \n \nif __name__ == '__main__':\n    str = ' '\n \n    # Call the function to find the first repeated character\n    print(first_rep_char(str))\n"], "Check if all rows of a matrix are circular rotations of each other -  ": ["# Python3 program to check if all rows \n# of a matrix are rotations of each other \n \nMAX = 1000\n \n# Returns true if all rows of mat[0..n-1][0..n-1] \n# are rotations of each other. \ndef isPermutedMatrix(mat, n) :\n     \n    # Creating a string that contains \n    # elements of first row. \n    str_cat = ''\n    for i in range(n) :\n        str_cat = str_cat + '-' + str(mat[0][i])\n \n    # Concatenating the string with itself \n    # so that substring search operations \n    # can be performed on this \n    str_cat = str_cat + str_cat\n \n    # Start traversing remaining rows \n    for i in range(1, n) :\n         \n        # Store the matrix into vector \n        # in the form of strings \n        curr_str = ''\n         \n        for j in range(n) :\n            curr_str = curr_str + '-' + str(mat[i][j])\n \n        # Check if the current string is present \n        # in the concatenated string or not \n        if (str_cat.find(curr_str)) : \n            return True\n             \n    return False\n \n# Driver code \nif __name__ == '__main__' :\n    n = 4\n    mat = [[1, 2, 3, 4], \n           [4, 1, 2, 3], \n           [3, 4, 1, 2], \n           [2, 3, 4, 1]] \n     \n    if (isPermutedMatrix(mat, n)):\n        print('Yes')\n    else :\n        print('No')\n         \n# This code is contributed by Ryuga\n"], "Find median in row wise sorted matrix -  ": ["# Python program to find median of matrix\n# sorted row wise\n \nfrom bisect import bisect_right as upper_bound\n \nMAX = 100;\n \n# Function to find median in the matrix\ndef binaryMedian(m, r, d):\n    mi = m[0][0]\n    mx = 0\n    for i in range(r):\n        if m[i][0] < mi:\n            mi = m[i][0]\n        if m[i][d-1] > mx :\n            mx =  m[i][d-1]\n     \n    desired = (r * d + 1) // 2\n     \n    while (mi < mx):\n        mid = mi + (mx - mi) // 2\n        place = [0];\n         \n        # Find count of elements smaller than or equal to mid\n        for i in range(r):\n             j = upper_bound(m[i], mid)\n             place[0] = place[0] + j\n        if place[0] < desired:\n            mi = mid + 1\n        else:\n            mx = mid\n    print ('Median is', mi)\n    return   \n     \n# Driver code\nr, d = 3, 3\n \nm = [ [1, 3, 5], [2, 6, 9], [3, 6, 9]]\nbinaryMedian(m, r, d)\n \n# This code is contributed by Sachin BIsht\n", "# import library for min heap\nimport heapq\nfrom typing import List\n \n# Node class\n    # contains the value of the current node\n    # contains the row number of the current node\n    # in the matrix\n    # contains the column number of the current\n    # node in the matrix\nclass Node:\n    def __init__(self, data: int, row: int, col: int):\n        self.data = data\n        self.row = row\n        self.col = col\n    def __lt__(self, other):\n        return self.data < other.data\n \n# Solution class contains the main logic to find median\nclass Solution:\n    # median function\n    def median(self, matrix, R, C):\n        # minheap is a priority queue implemented using min\n        # heap data structure. It stores the nodes in\n        # ascending order based on their values.\n        minheap = []\n        # count variable to keep track of the\n        # number of nodes processed so far\n        count = 0\n        # median variable to store the median value in the\n        # end medianindex is the index of the median in the\n        # matrix\n        median = -1\n        medianindex = (R * C) // 2\n \n        # Push the first elements of each row in the min\n        # heap\n        for i in range(R):\n            temp = Node(matrix[i][0], i, 0)\n            heapq.heappush(minheap, temp)\n \n        # Repeat until we reach the medianindex\n        while count <= medianindex:\n            top = heapq.heappop(minheap) # remove the node with\n                                  # the smallest value from\n                                  # the min heap\n            row = top.row\n            col = top.col\n            median = top.data\n \n            count += 1\n            # if the current node is not the last element\n            # in its row, push the next element from the\n            # same row into the min heap\n            if col + 1 < C:\n                col += 1\n                temp = Node(matrix[row][col], row, col)\n                heapq.heappush(minheap, temp)\n \n        return median\n \n# Main class contains the main method\nif __name__ == '__main__':\n    r = 3\n    c = 3\n    matrix = [[1, 3, 5], [2, 6, 9], [3, 6, 9]]\n \n    obj = Solution()\n    print(obj.median(matrix, r, c))\n"], "Print all palindromic paths from top left to bottom right in a matrix -  ": ["# Python 3 program to print all  \n# palindromic paths from top left \n# to bottom right in a grid. \n  \ndef isPalin(str): \n  \n    l = len(str) // 2\n    for i in range( l) : \n        if (str[i] != str[len(str) - i - 1]): \n            return False\n          \n    return True\n  \n# i and j are row and column  \n# indexes of current cell  \n# (initially these are 0 and 0). \ndef palindromicPath(str, a, i, j, m, n): \n          \n    # If we have not reached bottom  \n    # right corner, keep exploring \n    if (j < m - 1 or i < n - 1) : \n        if (i < n - 1): \n            palindromicPath(str + a[i][j], a,  \n                            i + 1, j, m, n) \n        if (j < m - 1): \n            palindromicPath(str + a[i][j], a,  \n                            i, j + 1, m, n)  \n  \n    # If we reach bottom right corner,  \n    # we check if the path used is \n    # palindrome or not. \n    else : \n        str = str + a[n - 1][m - 1] \n        if isPalin(str): \n            print(str) \n  \n# Driver code  \nif __name__ == '__main__': \n      \n    arr = [[ 'a', 'a', 'a', 'b' ], \n           ['b', 'a', 'a', 'a' ], \n           [ 'a', 'b', 'b', 'a' ]] \n    str = '' \n    palindromicPath(str, arr, 0, 0, 4, 3) \n  \n# This code is contributed  \n# by ChitraNayal \n"], "Search in a row wise and column wise sorted matrix -  ": ["# Python program to search an element in row-wise\n# and column-wise sorted matrix\n \n# Searches the element x in mat[][]. If the\n# element is found, then prints its position\n# and returns true, otherwise prints 'not found'\n# and returns false\n \n \ndef search(mat, n, x):\n    if(n == 0):\n        return -1\n \n    # Traverse through the matrix\n    for i in range(n):\n        for j in range(n):\n \n            # If the element is found\n            if(mat[i][j] == x):\n                print('Element found at (', i, ',', j, ')')\n                return 1\n \n    print(' Element not found')\n    return 0\n \n \n# Driver code\nif __name__ == '__main__':\n    mat = [[10, 20, 30, 40], [15, 25, 35, 45],\n           [27, 29, 37, 48], [32, 33, 39, 50]]\n \n    # Function call\n    search(mat, 4, 29)\n \n# This code is contributed by rag2127\n", "# Python3 program to search an element\n# in row-wise and column-wise sorted matrix\n \n# Searches the element x in mat[][]. If the\n# element is found, then prints its position\n# and returns true, otherwise prints 'not found'\n# and returns false\n \n \ndef search(mat, n, x):\n \n    i = 0\n \n    # set indexes for top right element\n    j = n - 1\n    while (i < n and j >= 0):\n \n        if (mat[i][j] == x):\n \n            print('Element found at ', i, ', ', j)\n            return 1\n \n        if (mat[i][j] > x):\n            j -= 1\n \n        # if mat[i][j] < x\n        else:\n            i += 1\n \n    print('Element not found')\n    return 0  # if (i == n || j == -1 )\n \n \n# Driver Code\nif __name__ == '__main__':\n    mat = [[10, 20, 30, 40],\n           [15, 25, 35, 45],\n           [27, 29, 37, 48],\n           [32, 33, 39, 50]]\n \n    # Function call\n    search(mat, 4, 29)\n \n# This code is contributed by Anant Agarwal.\n", "def search_element(mat, x):\n    for i in range(len(mat)):\n        for j in range(len(mat[0])):\n            if mat[i][j] == x:\n                return f'Found at ({i}, {j})'\n    return 'Element not found'\n         \nmat = [\n    [10, 20, 30, 40],\n    [15, 25, 35, 45],\n    [27, 29, 37, 48],\n    [32, 33, 39, 50]\n]\n \nx = 29\nprint(search_element(mat, x))  # Output: Found at (2, 1)\n \nx = 100\nprint(search_element(mat, x))  # Output: Element not found\n"], "Rotate Matrix Elements -  ": ["def rotate_matrix(matrix):\n    n = len(matrix)\n     \n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n     \n    # Reverse the columns\n    for i in range(n):\n        for j, k in zip(range(n//2), range(n-1, n//2-1, -1)):\n            matrix[j][i], matrix[k][i] = matrix[k][i], matrix[j][i]\n \ndef print_matrix(matrix):\n    for row in matrix:\n        print(' '.join(str(elem) for elem in row))\n \nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint('Original matrix:')\nprint_matrix(matrix)\nrotate_matrix(matrix)\nprint('Rotated matrix:')\nprint_matrix(matrix)\n"], "Sort an array according to the order defined by another array -  ": ["'''A Python 3  program to sort an array \naccording to the order defined by \nanother array'''\n \n'''A Binary Search based function to find \nindex of FIRST occurrence of x in arr[].\nIf x is not present, then it returns -1 '''\n \n \ndef first(arr, low, high, x, n):\n    if (high >= low):\n        mid = low + (high - low) // 2  # (low + high)/2\n        if ((mid == 0 or x > arr[mid-1]) and arr[mid] == x):\n            return mid\n        if (x > arr[mid]):\n            return first(arr, (mid + 1), high, x, n)\n        return first(arr, low, (mid - 1), x, n)\n \n    return -1\n \n# Sort A1[0..m-1] according to the order\n# defined by A2[0..n-1].\n \n \ndef sortAccording(A1, A2, m, n):\n    '''The temp array is used to store a copy\n    of A1[] and visited[] is used mark the \n    visited elements in temp[].'''\n    temp = [0] * m\n    visited = [0] * m\n \n    for i in range(0, m):\n        temp[i] = A1[i]\n        visited[i] = 0\n \n    # Sort elements in temp\n    temp.sort()\n \n    # for index of output which is sorted A1[]\n    ind = 0\n \n    '''Consider all elements of A2[], find\n    them in temp[] and copy to A1[] in order.'''\n    for i in range(0, n):\n \n        # Find index of the first occurrence\n        # of A2[i] in temp\n        f = first(temp, 0, m-1, A2[i], m)\n \n        # If not present, no need to proceed\n        if (f == -1):\n            continue\n \n        # Copy all occurrences of A2[i] to A1[]\n        j = f\n        while (j < m and temp[j] == A2[i]):\n            A1[ind] = temp[j]\n            ind = ind + 1\n            visited[j] = 1\n            j = j + 1\n \n    # Now copy all items of temp[] which are\n    # not present in A2[]\n    for i in range(0, m):\n        if (visited[i] == 0):\n            A1[ind] = temp[i]\n            ind = ind + 1\n \n# Utility function to print an array\n \n \ndef printArray(arr, n):\n    for i in range(0, n):\n        print(arr[i], end=' ')\n    print('')\n \n \n# Driver program to test above function.\nA1 = [2, 1, 2, 5, 7, 1, 9, 3, 6, 8, 8]\nA2 = [2, 1, 8, 3]\nm = len(A1)\nn = len(A2)\nprint('Sorted array is ')\nsortAccording(A1, A2, m, n)\nprintArray(A1, m)\n \n \n# This code is contributed by Nikita Tiwari.\n", "from collections import Counter\n \n# Function to sort arr1\n# according to arr2\n \n \ndef solve(arr1, arr2):\n    # Our output array\n    res = []\n \n    # Counting Frequency of each\n    # number in arr1\n    f = Counter(arr1)\n \n    # Iterate over arr2 and append all\n    # occurrences of element of\n    # arr2 from arr1\n    for e in arr2:\n \n        # Appending element 'e',\n        # f[e] number of times\n        res.extend([e]*f[e])\n \n        # Count of 'e' after appending is zero\n        f[e] = 0\n \n    # Remaining numbers in arr1 in sorted\n    # order (Numbers with non-zero frequency)\n    rem = list(sorted(filter(\n        lambda x: f[x] != 0, f.keys())))\n \n    # Append them also\n    for e in rem:\n        res.extend([e]*f[e])\n \n    return res\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr1 = [2, 1, 2, 5, 7, 1, 9, 3, 6, 8, 8]\n    arr2 = [2, 1, 8, 3]\n    print(*solve(arr1, arr2))\n", "# A python program to sort an array according to the order\n# defined by another array\nimport functools\n \n# function that sorts the first array based on order of\n# them in second array\ndef sortA1ByA2(arr1, arr2):\n \n    # map to store the indices of second array\n    # so that we can easily judge the position of two\n    # elements in first array\n    index = {}\n \n    for i in range(len(arr2)):\n        # Consider only first occurrence of element\n        if arr2[i] not in index.keys():\n            # Assign value of i+1\n            index[arr2[i]] = i + 1\n \n    def cmp(a, b):\n         \n        # If both a and b are not present in the second array, \n        # sort them in ascending order\n        if a not in index.keys() and b not in index.keys():\n            return a-b\n         \n        # If only b is present in the second array, b comes before a\n        if a not in index.keys():\n            return 1\n         \n        # If only a is present in the second array, a comes before b\n        if b not in index.keys():\n            return -1\n         \n        # If both a and b are present in the second array,\n        # sort them according to their respective indices\n        return index[a]-index[b]\n         \n    arr1.sort(key=functools.cmp_to_key(cmp))\n \n \narr1 = [ 2, 1, 2, 5, 7, 1, 9, 3, 6, 8, 8, 7, 5, 6, 9, 7, 5 ]\narr2 = [ 2, 1, 8, 3, 4, 1 ]\n \nsortA1ByA2(arr1, arr2)\n \n# printing the array\nprint('Sorted array is ')\nfor i in range(len(arr1)):\n    print(arr1[i], end = ' ')\n     \n# The code is contributed by Nidhi goel. \n"], "Print all subarrays with 0 sum -  ": ["# User defined pair class\nclass Pair :\n    first = 0\n    second = 0\n    def __init__(self, a,  b) :\n        self.first = a\n        self.second = b\nclass GFG :\n    @staticmethod\n    def  findSubArrays( arr,  n) :\n       \n        # Array to store all the start and end\n        # indices of subarrays with 0 sum\n        out =  []\n        i = 0\n        while (i < n) :\n            prefix = 0\n            j = i\n            while (j < n) :\n                prefix += arr[j]\n                if (prefix == 0) :\n                    out.append(Pair(i, j))\n                j += 1\n            i += 1\n        return out\n       \n    # Function to print all subarrays with 0 sum\n    @staticmethod\n    def print( out) :\n        i = 0\n        while (i < len(out)) :\n            p = out[i]\n            print('Subarray found from Index ' + str(p.first) + ' to ' + str(p.second))\n            i += 1\n             \n    # Driver code\n    @staticmethod\n    def main( args) :\n       \n        # Given array\n        arr = [6, 3, -1, -3, 4, -2, 2, 4, 6, -12, -7]\n        n = len(arr)\n         \n        # Function Call\n        out = GFG.findSubArrays(arr, n)\n         \n        # if we didn't find any subarray with 0 sum,\n        # then subarray doesn't exists\n        if (len(out) == 0) :\n            print('No subarray exists')\n        else :\n            GFG.print(out)\n     \n \nif __name__=='__main__':\n    GFG.main([])\n     \n    # This code is contributed by aadityaburujwale.\n", "# Python3 program to print all subarrays\n# in the array which has sum 0\n \n# Function to get all subarrays\n# in the array which has sum 0\ndef findSubArrays(arr,n):\n \n    # create a python dict\n    hashMap = {}\n     \n    # create a python list \n    # equivalent to ArrayList\n    out = []\n     \n    # tracker for sum of elements\n    sum1 = 0\n    for i in range(n):\n         \n        # increment sum by element of array\n        sum1 += arr[i]\n         \n        # if sum is 0, we found a subarray starting \n        # from index 0 and ending at index i\n        if sum1 == 0:\n            out.append((0, i))\n        al = []\n         \n        # If sum already exists in the map \n        # there exists at-least one subarray \n        # ending at index i with 0 sum \n        if sum1 in hashMap:\n             \n            # map[sum] stores starting index \n            # of all subarrays\n            al = hashMap.get(sum1)\n            for it in range(len(al)):\n                out.append((al[it] + 1, i))\n        al.append(i)\n        hashMap[sum1] = al\n    return out\n \n# Utility function to print\n# all subarrays with sum 0 \ndef printOutput(output):\n    for i in output:\n        print ('Subarray found from Index ' +\n                str(i[0]) + ' to ' + str(i[1]))\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [6, 3, -1, -3, 4, -2, \n              2, 4, 6, -12, -7]\n    n = len(arr)\n    out = findSubArrays(arr, n)\n     \n    # if we did not find any subarray with 0 sum, \n    # then subarray does not exists \n    if (len(out) == 0):\n        print ('No subarray exists')\n    else:\n        printOutput (out) \n \n# This code is contributed by Vikas Chitturi\n", "def find_subarrays(arr):\n    out = []\n     \n    # Dictionary to store the starting index of all subarrays with the same sum\n    sums = {0: [-1]}\n    current_sum = 0\n     \n    # Loop through the array\n    for i, num in enumerate(arr):\n        current_sum += num\n        if current_sum in sums:\n            indices = sums[current_sum]\n            for j in indices:\n                # Add found subarray range to the output list\n                out.append((j + 1, i))\n         \n        # Add the current index to the sum's list of indices\n        if current_sum in sums:\n            sums[current_sum].append(i)\n        else:\n            sums[current_sum] = [i]\n     \n    return out\n \ndef print_subarrays(subarrays):\n    for start, end in subarrays:\n        print(f'Subarray found from Index {start} to {end}')\n \ndef main():\n    arr = [6, 3, -1, -3, 4, -2, 2, 4, 6, -12, -7]\n     \n    # Find subarrays with the same sum\n    subarrays = find_subarrays(arr)\n     \n    if not subarrays:\n        print('No subarray exists')\n    else:\n        print_subarrays(subarrays)  # Print the found subarray ranges\n \nif __name__ == '__main__':\n    main()\n     \n# This code is contributed by akshitaguprzj3\n"], "Given a string A, containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. Return 0 / 1 ( 0 for false, 1 for true ) for this problem. Note: The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not. Problem Constraints 1 <= |A| <= 106 Input Format The first and only argument is a string A. Output Format Return an integer, 0 / 1 ( 0 for false, 1 for true ) Example Input Input 1:A = \"()[]{}\" Input 2:A = \"([)]\" Example Output Output 1:1 Output 1:0": "class Solution:\r\n    # @param A : string\r\n    # @return an integer\r\n    def isValid(self, A):\r\n        stack = []\r\n        for a in A:\r\n            if a == '(' or a == '[' or a == '{':\r\n                stack.append(a)\r\n            else:\r\n                if len(stack) == 0:\r\n                    return 0\r\n                elif (stack[-1] == '(' and a == ')') or (stack[-1] == '[' and a == ']') or (stack[-1] == '{' and a == '}'):\r\n                    stack.pop()\r\n                else:\r\n                    return 0\r\n        if len(stack) != 0:\r\n            return 0\r\n        return 1", "Red-Black Trees | Top-Down Insertion -  ": ["# Python 3 implementation for Top-Down\n# Red-Black Tree Insertion creating\n# a red black tree and storing an\n# English sentence into it using Top\n# down insertion approach\n \n# Class for performing\n# RBTree operations\nclass RbTree:\n \n    Root = None\n \n    # Function to calculate\n    # the height of the tree\n    def HeightT(self,Root):\n \n        lefth, righth=0, 0\n \n        if (Root == None or (Root.children == None and Root.children[1] == None)):\n            return 0\n        lefth = self.HeightT(Root.children[0])\n        righth = self.HeightT(Root.children[1])\n \n        return (max(lefth, righth) + 1)\n \n    # Function to check if\n    # dir is equal to 0\n    @staticmethod\n    def check(dir):\n        return 1 if dir == 0 else 0\n \n    # Function to check if a\n    # node's color is red or not\n    @staticmethod\n    def isRed(Node):\n        return Node != None and Node.color=='R'\n \n    # Function to perform\n    # single rotation\n    def SingleRotate(self, Node, dir):\n \n        temp = Node.children[self.check(dir)]\n        Node.children[self.check(dir)] = temp.children[dir]\n        temp.children[dir] = Node\n        self.Root.color = 'R'\n        temp.color = 'B'\n \n        return temp\n \n    # Function to perform double rotation\n    def DoubleRotate(self, Node, dir):\n \n        Node.children[self.check(dir)] = self.SingleRotate(Node.children[self.check(dir)], self.check(dir))\n        return self.SingleRotate(Node, dir)\n \n    # Function to insert a new\n    # node with given data\n    def Insert(self, tree, data):\n \n        if (tree.Root == None):\n \n            tree.Root = TreeNode(data)\n            if (tree.Root == None):\n                return None\n        else:\n \n            # A temporary root\n            temp = TreeNode('')\n \n            # Grandparent and Parent\n            g, t=None,None\n            p, q=None,None\n \n            dir = 0; last = 0\n \n            t = temp\n \n            g = p = None\n \n            t.children[1] = tree.Root\n \n            q = t.children[1]\n            while (True):\n \n                if (q == None):\n \n                    # Inserting root node\n                    q = TreeNode(data)\n                    p.children[dir] = q\n \n                # Sibling is red\n                elif (self.isRed(q.children[0]) and self.isRed(q.children[1])):\n \n                    # Recoloring if both\n                    # children are red\n                    q.color = 'R'\n                    q.children[0].color = 'B'\n                    q.children[1].color = 'B'\n \n                if (self.isRed(q) and self.isRed(p)):\n \n                    # Resolving red-red\n                    # violation\n                    dir2=0\n                    if (t.children[1] == g):\n                        dir2 = 1\n                    else:\n                        dir2 = 0\n \n                    # If children and parent\n                    # are left-left or\n                    # right-right of grand-parent\n                    if (q == p.children[last]):\n                        t.children[dir2] = self.SingleRotate(g, 1 if last == 0 else 0)\n \n                    # If they are opposite\n                    # childs i.e left-right\n                    # or right-left\n                    else:\n                        t.children[dir2] = self.DoubleRotate(g,1 if last == 0 else 0)\n \n                # Checking for correct\n                # position of node\n                if (q.data==data):\n                    break\n                last = dir\n \n                # Finding the path to\n                # traverse [Either left\n                # or right ]\n                dir = 1 if q.data<data else 0\n \n                if (g != None):\n                    t = g\n \n                # Rearranging pointers\n                g = p\n                p = q\n                q = q.children[dir]\n \n            tree.Root = temp.children[1]\n \n        # Assign black color\n        # to the root node\n        tree.Root.color = 'B'\n \n        return tree.Root\n \n    # Print nodes at each\n    # level in level order\n    # traversal\n    def PrintLevel(self, root, i):\n        if (root == None):\n            return\n \n        if (i == 1):\n            print('| {} | {} |'.format(root.data,root.color),end='')\n \n            if (root.children[0] != None): \n                print(' {} |'.format(root.children[0].data),end='')\n            else:\n                print(' None |',end='')\n            if (root.children[1] != None):\n                print(' {} |'.format(root.children[1].data),end='')\n            else:\n                print(' None |',end='')\n \n            return\n \n        self.PrintLevel(root.children[0], i - 1)\n        self.PrintLevel(root.children[1], i - 1)\n \n    # Utility Function to perform \n    # level order traversal\n    def LevelOrder(self, root):\n \n        for i in range(self.HeightT(root) + 1):\n            self.PrintLevel(root, i)\n            print('\\n')\n \n# Class for representing\n# a node of the tree\nclass TreeNode: \n    def __init__(self, data):\n \n        # Color R- Red\n        # and B - Black\n        self.data = data\n        self.color = 'R'\n        self.children = [None,None]\n \n# Driver Code\nif __name__=='__main__':\n    # Tree Node Representation\n    # -------------------------------------------\n    # DATA | COLOR | LEFT CHILD | RIGHT CHILD |\n    # -------------------------------------------\n    Tree = RbTree()\n    Sentence, Word='',''\n    Sentence = 'old is gold'\n    Word_Array = Sentence.split()\n \n    for i in range(len(Word_Array)):\n        Tree.Root = Tree.Insert(Tree, Word_Array[i])\n \n    # Print Level Order Traversal\n    print('The Level Order Traversal the tree is:')\n    Tree.LevelOrder(Tree.Root)\n    print('\\nInserting a word in the tree:')\n    Word = 'forever'\n    Tree.Root = Tree.Insert(Tree, Word)\n \n    Tree.LevelOrder(Tree.Root)\n# This code is contributed by Amartya Ghosh\n"], "Deletion in Red-Black Tree -  ": [], "C Program for Red Black Tree Insertion -  ": [], "Insertion in Red-Black Tree -  ": [], "Palindrome pair in an array of words (or strings) -  ": ["# Python3 program to find if  \n# there is a pair that \n# can form a palindrome. \n  \n# Utility function to check  \n# if a string is a palindrome \ndef isPalindrome(st): \n  \n    length = len(st) \n  \n    # Compare each character  \n    # from starting with its  \n    # corresponding character from last \n    for i in range(length // 2): \n        if (st[i] != st[length - i - 1]): \n            return False\n  \n    return True\n  \n# Function to check if a  \n# palindrome pair exists \ndef checkPalindromePair(vect): \n  \n    # Consider each pair one by one \n    for i in range(len(vect) - 1): \n        for j in range(i + 1, len(vect)): \n              \n            # Concatenate both strings \n            check_str = vect[i] + vect[j] \n  \n            # Check if the concatenated  \n            # string is palindrome \n            if (isPalindrome(check_str)): \n                return True\n  \n            # Check for other combination  \n            # of the two strings \n            check_str = vect[j] + vect[i] \n            if (isPalindrome(check_str)): \n                return True\n    return False\n    \n# Driver code \nif __name__ == '__main__': \n    \n    vect = ['geekf', 'geeks', 'or', \n            'keeg', 'abc', 'bc'] \n      \n    if checkPalindromePair(vect): \n        print('Yes') \n    else: \n        print ('No') \n    \n# This code is contributed by Chitranayal\n", "from typing import List\n  \n# Trie node class \nclass TrieNode: \n    # Constructor \n    def __init__(self): \n        self.children = [None]*26\n        self.pos = []  # To store palindromic positions in str \n        self.id = None\n        self.isLeaf = False  # isLeaf is True if the node represents end of a word \n  \n# Utility function to check if a string is a palindrome \ndef isPalindrome(s: str, i: int, j: int) -> bool: \n    \n    # Compare each character from starting with \n    # its corresponding character from last \n    while i < j: \n        if s[i] != s[j]: \n            return False\n        i += 1\n        j -= 1\n    return True\n  \n# If not present, inserts reverse of key into Trie. If the key is prefix of a Trie node, just mark leaf node \ndef insert(root: TrieNode, key: str, id: int) -> None: \n    pCrawl = root \n  \n    # Start traversing word from the last \n    for level in range(len(key)-1, -1, -1): \n        # If it is not available in Trie, then store it \n        index = ord(key[level]) - ord('a') \n        if not pCrawl.children[index]: \n            pCrawl.children[index] = TrieNode() \n  \n        # If current word is palindrome till this level, store index of current word. \n        if isPalindrome(key, 0, level): \n            pCrawl.pos.append(id) \n  \n        pCrawl = pCrawl.children[index] \n    pCrawl.id = id\n    pCrawl.pos.append(id) \n  \n    # Mark last node as leaf \n    pCrawl.isLeaf = True\n  \n# Returns true if key presents in Trie, else false \ndef search(root: TrieNode, key: str, id: int) -> None: \n    pCrawl = root \n    for level in range(len(key)): \n        index = ord(key[level]) - ord('a') \n  \n        # If it is present also check up to which index it is palindrome \n        if pCrawl.id is not None and pCrawl.id != id and isPalindrome(key, level, len(key)-1): \n            l = [id, pCrawl.id] \n            result.append(l) \n  \n        # If not present then return \n        if not pCrawl.children[index]: \n            return\n  \n        pCrawl = pCrawl.children[index] \n  \n    for i in pCrawl.pos: \n        if i == id: \n            continue\n        l = [id, i] \n        result.append(l) \n  \n# Function to check if a palindrome pair exists \ndef checkPalindromePair(vect: List[str]) -> bool: \n    # Construct Trie \n    root = TrieNode() \n    for i in range(len(vect)): \n        insert(root, vect[i], i) \n  \n    # Search for different keys \n    global result \n    result = [] \n    for i in range(len(vect)): \n        search(root, vect[i], i) \n  \n        if len(result) > 0: \n            return True\n  \n    return False\n  \n# Driver code \nvect = ['geekf', 'geeks', 'or', 'keeg', 'abc', 'bc'] \n  \nif checkPalindromePair(vect) == True: \n    print('Yes') \nelse: \n    print('No') \n", "def function(wordlist): \n  #storing word in reverse format along with their indices. \n    \n    hashmap_reverse = {word[::-1]: index for index, word in enumerate(wordlist)} \n    ans = [] \n    #enumerating over all words and for each character of them \n    for index, word in enumerate(wordlist): \n        for i in range(len(word)): \n          #extracting left and right of them  \n            left, right = word[:i+1], word[i+1:] \n            #checking if left exists and is palindrome and also right is present in map \n            #this is to make sure the best edge case described holds. \n              \n            if not len(left) == 0 and left == left[::-1] and right in hashmap_reverse and hashmap_reverse[right] != index: \n                ans.append([hashmap_reverse[right], index]) \n                \n            #normal case. \n            if right == right[::-1] and left in hashmap_reverse and hashmap_reverse[left] != index: \n                ans.append([index, hashmap_reverse[left]]) \n    if len(ans)>0: \n        return True\n    return False\n    \n    \nwords = ['geekf', 'geeks', 'or','keeg', 'abc', 'bc'] \nprint(function(words))\n"], "Minimum XOR Value Pair -  ": ["# Python program to find minimum\n# XOR value in an array.\n \n# Function to find minimum XOR pair\ndef minXOR(arr, n):\n     \n    # Sort given array\n    arr.sort();\n \n    min_xor = 999999\n    val = 0\n \n    # calculate min xor of \n    # consecutive pairs\n    for i in range (0, n-1):\n        for j in range (i+1, n-1):\n             \n            # update minimum xor value\n            # if required\n            val = arr[i] ^ arr[j]\n            min_xor = min(min_xor, val)\n    return min_xor\n \n# Driver program\narr = [ 9, 5, 3 ]\nn = len(arr)\n \nprint(minXOR(arr, n))\n \n# This code is contributed by Sam007.\n", "import sys    \n \n# Function to find minimum XOR pair\ndef minXOR(arr, n):\n     \n    # Sort given array\n    arr.sort()\n  \n    minXor =  int(sys.float_info.max)\n    val = 0\n  \n    # calculate min xor of consecutive pairs\n    for i in range(0,n-1):\n        val = arr[i] ^ arr[i + 1];\n        minXor = min(minXor, val);\n     \n    return minXor\n \n# Driver program\narr = [9, 5, 3]\nn = len(arr)\nprint(minXOR(arr, n))\n  \n# This code is contributed by Sam007.\n", "# class for the basic Trie Node \nclass TrieNode:\n    def __init__(self):\n \n        # Child array with 0 and 1 \n        self.child = [None]*2\n \n        # meant for the lead Node \n        self.value = None\n \nclass Trie:\n \n    def __init__(self):\n        # initialise the root Node \n        self.root = self.getNode()\n \n    def getNode(self):\n        # get a new Trie Node \n        return TrieNode()\n \n    # inserts a new element \n    def insert(self,key):\n        temp = self.root\n  \n        # 32 bit valued binary digit \n        for i in range(31,-1,-1):\n \n            # finding the bit at ith position\n            curr = (key>>i)&(1)\n \n            # if the child is None create one\n            if(temp.child[curr] is None):\n                temp.child[curr] = self.getNode()\n            temp = temp.child[curr]\n \n        # add value to the leaf node \n        temp.value = key\n \n    # traverse the trie and xor with the most similar element\n    def xorUtil(self,key):\n        temp = self.root \n \n        # 32 bit valued binary digit \n        for i in range(31,-1,-1):\n \n            # finding the bit at ith position\n            curr = (key>>i)&1\n \n            # traverse for the same bit\n            if(temp.child[curr] is not None):\n                temp = temp.child[curr]\n \n            # traverse if the same bit is not set in trie\n              elif (temp.child[1-curr] is not None):\n                temp = temp.child[1-curr]\n \n        # return with the xor of the value \n        return temp.value^key\n             \n         \ndef minXor(arr):\n \n        # set m to a large number\n        m = 2**30\n \n        # initialize Trie\n        trie = Trie()\n \n        # insert the first element\n        trie.insert(arr[0])\n \n        # for each element in the array\n        for i in range(1,len(arr)):\n \n            # find the minimum xor value\n            m = min(m,trie.xorUtil(arr[i]))\n             \n            # insert the new element\n            trie.insert(arr[i])\n        return m \n \n# Driver Code \nif __name__=='__main__':\n    sample = [9,5,3]\n    print(minXor(sample))\n \n#code contributed by Shushant Kumar    \n"], "Boggle using Trie -  ": ["# Python program for Boggle game\nclass TrieNode:\n \n    # Trie node class\n    def __init__(self):\n        self.children = [None] * 26\n \n        # isEndOfWord is True if node represent the end of the word\n        self.isEndOfWord = False\n \nM = 3\nN = 3\nclass Boogle:\n \n    # Trie data structure class\n    def __init__(self):\n        self.root = self.getNode()\n \n    def getNode(self):\n \n        # Returns new trie node (initialized to NULLs)\n        return TrieNode()\n \n    def _charToIndex(self, ch):\n \n        # private helper function\n        # Converts key current character into index\n        # use only 'A' through 'Z' and upper case\n        return ord(ch) - ord('A')\n \n    def insert(self, key):\n \n        # If not present, inserts key into trie\n        # If the key is prefix of trie node,\n        # just marks leaf node\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n \n            # if current character is not present\n            if not pCrawl.children[index]:\n \n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n            # print('h', self.root.children)\n \n        # mark last node as leaf\n        pCrawl.isEndOfWord = True\n \n \ndef is_Safe(i, j, vis):\n    return 0 <= i < M and 0 <= j < N and not vis[i][j]\n \ndef search_word(root, boggle, i, j, vis, string):\n    if root.isEndOfWord:\n        print(string)\n \n    if is_Safe(i, j, vis):\n        vis[i][j] = True\n        for K in range(26):\n            if root.children[K] is not None:\n                ch = chr(K+ord('A'))\n                 \n                # Recursively search reaming character of word\n                # in trie for all 8 adjacent cells of boggle[i][j]\n                if is_Safe(i + 1, j + 1, vis) and boggle[i + 1][j + 1] == ch:\n                    search_word(root.children[K], boggle,\n                                i + 1, j + 1, vis, string + ch)\n                if is_Safe(i, j + 1, vis) and boggle[i][j + 1] == ch:\n                    search_word(root.children[K], boggle,\n                                i, j + 1, vis, string + ch)\n                if is_Safe(i - 1, j + 1, vis) and boggle[i - 1][j + 1] == ch:\n                    search_word(root.children[K], boggle,\n                                i - 1, j + 1, vis, string + ch)\n                if is_Safe(i + 1, j, vis) and boggle[i + 1][j] == ch:\n                    search_word(root.children[K], boggle,\n                                i + 1, j, vis, string + ch)\n                if is_Safe(i + 1, j - 1, vis) and boggle[i + 1][j - 1] == ch:\n                    search_word(root.children[K], boggle,\n                                i + 1, j - 1, vis, string + ch)\n                if is_Safe(i, j - 1, vis) and boggle[i][j - 1] == ch:\n                    search_word(root.children[K], boggle,\n                                i, j - 1, vis, string + ch)\n                if is_Safe(i - 1, j - 1, vis) and boggle[i - 1][j - 1] == ch:\n                    search_word(root.children[K], boggle,\n                                i - 1, j - 1, vis, string + ch)\n                if is_Safe(i - 1, j, vis) and boggle[i - 1][j] == ch:\n                    search_word(root.children[K], boggle,\n                                i - 1, j, vis, string + ch)\n                vis[i][j] = False\n \n \ndef char_int(ch):\n   \n    # private helper function\n    # Converts key current character into index\n    # use only 'A' through 'Z' and upper case\n    return ord(ch) - ord('A')\n \n \ndef findWords(boggle, root):\n   \n    # Mark all characters as not visited\n    visited = [[False for i in range(N)] for i in range(M)]\n \n    pChild = root\n \n    string = ''\n \n    # traverse all matrix elements\n    for i in range(M):\n        for j in range(N):\n            # we start searching for word in dictionary\n            # if we found a character which is child\n            # of Trie root\n            if pChild.children[char_int(boggle[i][j])]:\n                # print('h')\n                string = string + boggle[i][j]\n                search_word(pChild.children[char_int(boggle[i][j])],\n                            boggle, i, j, visited, string)\n                string = ''\n \ndictionary = ['GEEKS', 'FOR', 'QUIZ', 'GEE']\n \n# root Node of trie\nt = Boogle()\n \n# insert all words of dictionary into trie\nn = len(dictionary)\nfor i in range(n):\n \n    t.insert(dictionary[i])\nroot = t.root\nboggle = [['G', 'I', 'Z'],\n          ['U', 'E', 'K'],\n          ['Q', 'S', 'E']]\n \n# print(root.children)\nfindWords(boggle, root)\n \n# This code is contributed by Yashwant Kumar\n", "# Python code addition \n \ndef exist(board, word, r, c):\n    for i in range(r):\n        for j in range(c):\n            if board[i][j] == word[0] and search(board, word, 0, i, j, r, c):\n                return True\n    return False\n \ndef search(board, word, length, i, j, r, c):\n    if i < 0 or i >= r or j < 0 or j >= c:\n        return False\n \n    if board[i][j] != word[length]:\n        return False\n \n    if length == len(word) - 1:\n        return True\n \n    ch = board[i][j]\n    board[i][j] = '@'\n \n    ans = search(board, word, length+1, i-1, j, r, c) or \\\n          search(board, word, length+1, i+1, j, r, c) or \\\n          search(board, word, length+1, i, j-1, r, c) or \\\n          search(board, word, length+1, i, j+1, r, c) or \\\n          search(board, word, length+1, i-1, j+1, r, c) or \\\n          search(board, word, length+1, i-1, j-1, r, c) or \\\n          search(board, word, length+1, i+1, j-1, r, c) or \\\n          search(board, word, length+1, i+1, j+1, r, c)\n \n    board[i][j] = ch\n    return ans\n \ndef word_boggle(board, dictionary):\n    r, c = 3, 3\n \n    temp = []\n    st = set(dictionary)\n    n = len(st)\n \n    dict = []\n    for s in st:\n        dict.append(s)\n \n    for i in range(n):\n        if exist(board, dict[i], r, c):\n            temp.append(dict[i])\n \n    return temp\n \n \nif __name__ == '__main__':\n    dictionary = ['GEEKS', 'FOR', 'QUIZ', 'GEE']\n \n    boggle = [['G', 'I', 'Z'],\n              ['U', 'E', 'K'],\n              ['Q', 'S', 'E']]\n \n    ans = word_boggle(boggle, dictionary)\n \n    if len(ans) == 0:\n        print('-1')\n    else:\n        ans.sort()\n        print(' '.join(ans))\n         \n# The code is contributed by Nidhi goel.\n"], "Auto-complete feature using Trie -  ": ["# Python3 program to demonstrate auto-complete\n# feature using Trie data structure.\n# Note: This is a basic implementation of Trie\n# and not the most optimized one.\n \n \nclass TrieNode():\n    def __init__(self):\n        # Initialising one node for trie\n        self.children = {}\n        self.last = False\n \n \nclass Trie():\n    def __init__(self):\n \n        # Initialising the trie structure.\n        self.root = TrieNode()\n \n    def formTrie(self, keys):\n \n        # Forms a trie structure with the given set of strings\n        # if it does not exists already else it merges the key\n        # into it by extending the structure as required\n        for key in keys:\n            self.insert(key)  # inserting one key to the trie.\n \n    def insert(self, key):\n \n        # Inserts a key into trie if it does not exist already.\n        # And if the key is a prefix of the trie node, just\n        # marks it as leaf node.\n        node = self.root\n \n        for a in key:\n            if not node.children.get(a):\n                node.children[a] = TrieNode()\n \n            node = node.children[a]\n \n        node.last = True\n \n    def suggestionsRec(self, node, word):\n \n        # Method to recursively traverse the trie\n        # and return a whole word.\n        if node.last:\n            print(word)\n \n        for a, n in node.children.items():\n            self.suggestionsRec(n, word + a)\n \n    def printAutoSuggestions(self, key):\n \n        # Returns all the words in the trie whose common\n        # prefix is the given key thus listing out all\n        # the suggestions for autocomplete.\n        node = self.root\n \n        for a in key:\n            # no string in the Trie has this prefix\n            if not node.children.get(a):\n                return 0\n            node = node.children[a]\n \n        # If prefix is present as a word, but\n        # there is no subtree below the last\n        # matching node.\n        if not node.children:\n            return -1\n \n        self.suggestionsRec(node, key)\n        return 1\n \n \n# Driver Code\nkeys = ['hello', 'dog', 'hell', 'cat', 'a',\n        'hel', 'help', 'helps', 'helping']  # keys to form the trie structure.\nkey = 'h'  # key for autocomplete suggestions.\n \n# creating trie object\nt = Trie()\n \n# creating the trie structure with the\n# given set of strings.\nt.formTrie(keys)\n \n# autocompleting the given key using\n# our trie structure.\ncomp = t.printAutoSuggestions(key)\n \nif comp == -1:\n    print('No other strings found with this prefix\\n')\nelif comp == 0:\n    print('No string found with this prefix\\n')\n \n# This code is contributed by amurdia and muhammedrijnas\n"], "Longest Common Prefix using Trie -  ": ["# Python 3 program to find the longest common prefix\nALPHABET_SIZE = 26\nindexs = 0\nclass TrieNode:\n    # constructor\n    def __init__(self):\n        self.isLeaf = False\n        self.children = [None]*ALPHABET_SIZE\n \n# Function to facilitate insertion in Trie\n# If not present, insert the node in the Trie\ndef insert(key, root):\n    pCrawl = root\n    for level in range(len(key)):\n        index = ord(key[level]) - ord('a')\n        if pCrawl.children[index] == None:\n            pCrawl.children[index] = TrieNode()\n        pCrawl = pCrawl.children[index]\n    pCrawl.isLeaf = True\n \n# Function to construct Trie\ndef constructTrie(arr, n, root):\n    for i in range(n):\n        insert(arr[i], root)\n \n# Counts and returns number of children of the node\ndef countChildren(node):\n    count = 0\n    for i in range(ALPHABET_SIZE):\n        if node.children[i] != None:\n            count +=1\n            # Keeping track of diversion in the trie\n            global indexs\n            indexs = i\n    return count\n     \n# Perform walk on trie and return longest common prefix \ndef walkTrie(root):\n    pCrawl = root\n    prefix = ''\n    while(countChildren(pCrawl) == 1 and pCrawl.isLeaf == False):\n        pCrawl = pCrawl.children[indexs]\n        prefix += chr(97 + indexs)\n    return prefix or -1\n \n# Function that returns longest common prefix \ndef commonPrefix(arr, n, root):\n    constructTrie(arr, n, root)\n    return walkTrie(root)\n \n# Driver code to test the code\nn = 4\narr = [' ', 'geeks', 'geek', 'geezer']\nroot = TrieNode()\nprint(commonPrefix(arr,n, root))\n \n# This code is Contributed by Akshay Jain (DA-IICT)\n"], "Counting the number of words in a Trie -  ": ["# Python implementation to count words in a trie\n     \n# Alphabet size (# of symbols)\nfrom pickle import NONE\n \nALPHABET_SIZE = 26\n \n# Trie node\nclass TrieNode:\n         \n    def __init__(self):\n        # isLeaf is true if the node represents\n        # end of a word\n        self.isLeaf = False\n        self.children = [None for i in range(ALPHABET_SIZE)]\n     \n \nroot = TrieNode()\n         \n# If not present, inserts key into trie\n# If the key is prefix of trie node, just\n# marks leaf node\ndef insert(key):\n \n    length = len(key)\n     \n    pCrawl = root\n     \n    for level in range(length):\n \n        index = ord(key[level]) - ord('a')\n        if (pCrawl.children[index] == None):\n            pCrawl.children[index] = TrieNode()\n         \n        pCrawl = pCrawl.children[index]\n         \n    # mark last node as leaf\n    pCrawl.isLeaf = True\n \n     \n# Function to count number of words\ndef wordCount(root):\n \n    result = 0\n     \n    # Leaf denotes end of a word\n    if (root.isLeaf == True):\n        result += 1\n         \n    for i in range(ALPHABET_SIZE):    \n        if (root.children[i] != None):\n            result += wordCount(root.children[i])\n         \n    return result\n     \n# Driver Program\n \n# Input keys (use only 'a' through 'z'\n# and lower case)\nkeys = ['the', 'a', 'there', 'answer', 'any', 'by', 'bye', 'their'];\n \nroot = TrieNode()\n \n# Construct Trie\nfor i in range(len(keys)):\n    insert(keys[i])\n     \nprint(wordCount(root))\n \n# This code is contributed by shinjanpatra\n"], "Print unique rows in a given Binary matrix -  ": ["# Given a binary matrix of M X N of\n# integers, you need to return only\n# unique rows of binary array\nROW = 4\nCOL = 5\n \n# The main function that prints\n# all unique rows in a given matrix.\ndef findUniqueRows(M):\n     \n    # Traverse through the matrix\n    for i in range(ROW):\n        flag = 0\n \n        # Check if there is similar column\n        # is already printed, i.e if i and\n        # jth column match.\n        for j in range(i):\n            flag = 1\n \n            for k in range(COL):\n                if (M[i][k] != M[j][k]):\n                    flag = 0\n \n            if (flag == 1):\n                break\n \n        # If no row is similar\n        if (flag == 0):\n             \n            # Print the row\n            for j in range(COL):\n                print(M[i][j], end = ' ')\n                 \n            print()    \n \n# Driver Code\nif __name__ == '__main__':\n     \n    M = [ [ 0, 1, 0, 0, 1 ],\n          [ 1, 0, 1, 1, 0 ],\n          [ 0, 1, 0, 0, 1 ],\n          [ 1, 0, 1, 0, 0 ] ]\n \n    findUniqueRows(M)\n \n# This code is contributed by mohit kumar 29\n", "# Given a binary matrix of M X N of integers, \n# you need to return only unique rows of binary array \nROW = 4\nCOL = 5\n \n# print the column represented as integers\ndef Print(p):\n \n    for i in range(COL):\n        print(p % 2 ,end = ' ')\n        p = int(p//2)\n    print('')\n \nclass BST:\n \n    def __init__(self,data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n    # Insert function definition. \n    def Insert(self,root, value): \n \n        if(not root): \n            # Insert the first node, if root is NULL. \n            return BST(value) \n         \n        #if the value is present\n        if(value == root.data):\n            return root\n     \n        # Insert data. \n        if(value > root.data): \n            # Insert right node data, if the 'value' \n            # to be inserted is greater than 'root' node data. \n             \n            # Process right nodes. \n            root.right = self.Insert(root.right, value)\n        else:\n            # Insert left node data, if the 'value' \n            # to be inserted is greater than 'root' node data. \n             \n            # Process left nodes. \n            root.left = self.Insert(root.left, value)\n         \n        # Return 'root' node, after insertion. \n        return root \n \n    # Inorder traversal function. \n    # This gives data in sorted order. \n    def Inorder(self,root): \n        if(not root): \n            return\n        self.Inorder(root.left); \n        Print( root.data ); \n        self.Inorder(root.right)\n \n# convert array to decimal\ndef convert(arr):\n    sum=0\n     \n    for i in range(COL):\n        sum+=pow(2,i)*arr[i]\n    return sum\n \n \n# The main function that prints \n# all unique rows in a given matrix.\ndef findUniqueRows(M):\n     \n    b,root =BST(0),None\n     \n    #Traverse through the matrix\n    for i in range(ROW):\n        #insert the row into BST\n        root = b.Insert(root,convert(M[i]))\n     \n    #print \n    b.Inorder(root)\n \n# Driver Code\nM = [[0, 1, 0, 0, 1], \n     [1, 0, 1, 1, 0], \n     [0, 1, 0, 0, 1], \n     [1, 0, 1, 0, 0]]\n \nfindUniqueRows(M)\n \n# This code is contributed by shinjanpatra\n", "class Node:\n    def __init__(self):\n        self.isEndOfCol = False\n        self.child = [None, None]\n \ndef newNode():\n    temp = Node()\n    return temp\n \ndef insert(root, M, row, col):\n    '''Insert a row of binary values into the trie.\n    If the row is already in the trie, return False.\n    Otherwise, return True.\n    '''\n    if root is None:\n        root = newNode()\n \n    if col < COL:\n        return insert(root.child[M[row][col]], M, row, col+1)\n    else:\n        if not root.isEndOfCol:\n            root.isEndOfCol = True\n            return True\n        return False\n \ndef printRow(row):\n    # Print a row of binary values\n    for i in row:\n        print(i, end=' ')\n    print()\n \ndef findUniqueRows(M):\n    # Find and print unique rows in a matrix of binary values\n    unique_rows = []\n    for i in range(ROW):\n        if not any(M[i] == row for row in unique_rows):\n            unique_rows.append(M[i])\n    for row in unique_rows:\n        printRow(row)\n# Number of rows and columns in the matrix\nROW = 4\nCOL = 5\n \n# Example matrix of binary values\nM = [[0, 1, 0, 0, 1], \n     [1, 0, 1, 1, 0], \n     [0, 1, 0, 0, 1], \n     [1, 0, 1, 0, 0]]\n \n# Find and print unique rows in the matrix\nfindUniqueRows(M)\n \n# This code is contributed by Vikram_Shirsat\n", "# Python3 code to print unique row in a \n# given binary matrix\n \ndef printArray(matrix):\n \n    rowCount = len(matrix)\n    if rowCount == 0:\n        return\n \n    columnCount = len(matrix[0])\n    if columnCount == 0:\n        return\n \n    row_output_format = ' '.join(['%s'] * columnCount)\n \n    printed = {}\n \n    for row in matrix:\n        routput = row_output_format % tuple(row)\n        if routput not in printed:\n            printed[routput] = True\n            print(routput)\n \n# Driver Code\nmat = [[0, 1, 0, 0, 1], \n       [1, 0, 1, 1, 0], \n       [0, 1, 0, 0, 1],\n       [1, 1, 1, 0, 0]]\n \nprintArray(mat)\n \n# This code is contributed by myronwalker\n"], "Shortest path in a Binary Maze -  ": ["# Python3 code to implement the approach\nimport sys\n \n# User defined Pair class\nclass Pair:\n    def __init__(self, x, y):\n        self.first = x\n        self.second = y\n \n# Check if it is possible to go to (x, y) from the current\n# position. The function returns false if the cell has\n# value 0 or already visited\ndef isSafe(mat, visited, x, y):\n    return (x >= 0 and x < len(mat) and y >= 0 and y < len(mat[0]) and mat[x][y] == 1 and (not visited[x][y]))\n \ndef findShortestPath(mat, visited, i, j, x, y, min_dist, dist):\n    if (i == x and j == y):\n        min_dist = min(dist, min_dist)\n        return min_dist\n \n    # set (i, j) cell as visited\n    visited[i][j] = True\n     \n    # go to the bottom cell\n    if (isSafe(mat, visited, i + 1, j)):\n        min_dist = findShortestPath(\n            mat, visited, i + 1, j, x, y, min_dist, dist + 1)\n \n    # go to the right cell\n    if (isSafe(mat, visited, i, j + 1)):\n        min_dist = findShortestPath(\n            mat, visited, i, j + 1, x, y, min_dist, dist + 1)\n \n    # go to the top cell\n    if (isSafe(mat, visited, i - 1, j)):\n        min_dist = findShortestPath(\n            mat, visited, i - 1, j, x, y, min_dist, dist + 1)\n \n    # go to the left cell\n    if (isSafe(mat, visited, i, j - 1)):\n        min_dist = findShortestPath(\n            mat, visited, i, j - 1, x, y, min_dist, dist + 1)\n \n    # backtrack: remove (i, j) from the visited matrix\n    visited[i][j] = False\n    return min_dist\n \n# Wrapper over findShortestPath() function\ndef findShortestPathLength(mat, src, dest):\n    if (len(mat) == 0 or mat[src.first][src.second] == 0\n            or mat[dest.first][dest.second] == 0):\n        return -1\n \n    row = len(mat)\n    col = len(mat[0])\n \n    # construct an `M \u00d7 N` matrix to keep track of visited\n    # cells\n    visited = []\n    for i in range(row):\n        visited.append([None for _ in range(col)])\n \n    dist = sys.maxsize\n    dist = findShortestPath(mat, visited, src.first,\n                            src.second, dest.first, dest.second, dist, 0)\n \n    if (dist != sys.maxsize):\n        return dist\n    return -1\n \n# Driver code\nmat = [[1, 0, 1, 1, 1, 1, 0, 1, 1, 1],\n       [1, 0, 1, 0, 1, 1, 1, 0, 1, 1],\n       [1, 1, 1, 0, 1, 1, 0, 1, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0, 0, 1],\n       [1, 1, 1, 0, 1, 1, 1, 0, 1, 0],\n       [1, 0, 1, 1, 1, 1, 0, 1, 0, 0],\n       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n       [1, 0, 1, 1, 1, 1, 0, 1, 1, 1],\n       [1, 1, 0, 0, 0, 0, 1, 0, 0, 1]\n       ]\n \nsrc = Pair(0, 0)\ndest = Pair(3, 4)\ndist = findShortestPathLength(mat, src, dest)\nif (dist != -1):\n    print('Shortest Path is', dist)\n \nelse:\n    print('Shortest Path doesn't exist')\n \n# This code is contributed by phasing17\n", "# Python program to find the shortest\n# path between a given source cell \n# to a destination cell.\n \nfrom collections import deque\nROW = 9\nCOL = 10\n \n# To store matrix cell coordinates\nclass Point:\n    def __init__(self,x: int, y: int):\n        self.x = x\n        self.y = y\n \n# A data structure for queue used in BFS\nclass queueNode:\n    def __init__(self,pt: Point, dist: int):\n        self.pt = pt  # The coordinates of the cell\n        self.dist = dist  # Cell's distance from the source\n \n# Check whether given cell(row,col)\n# is a valid cell or not\ndef isValid(row: int, col: int):\n    return (row >= 0) and (row < ROW) and\n                   (col >= 0) and (col < COL)\n \n# These arrays are used to get row and column \n# numbers of 4 neighbours of a given cell \nrowNum = [-1, 0, 0, 1]\ncolNum = [0, -1, 1, 0]\n \n# Function to find the shortest path between \n# a given source cell to a destination cell. \ndef BFS(mat, src: Point, dest: Point):\n     \n    # check source and destination cell \n    # of the matrix have value 1 \n    if mat[src.x][src.y]!=1 or mat[dest.x][dest.y]!=1:\n        return -1\n     \n    visited = [[False for i in range(COL)] \n                       for j in range(ROW)]\n     \n    # Mark the source cell as visited \n    visited[src.x][src.y] = True\n     \n    # Create a queue for BFS \n    q = deque()\n     \n    # Distance of source cell is 0\n    s = queueNode(src,0)\n    q.append(s) #  Enqueue source cell\n     \n    # Do a BFS starting from source cell \n    while q:\n \n        curr = q.popleft() # Dequeue the front cell\n         \n        # If we have reached the destination cell, \n        # we are done \n        pt = curr.pt\n        if pt.x == dest.x and pt.y == dest.y:\n            return curr.dist\n         \n        # Otherwise enqueue its adjacent cells \n        for i in range(4):\n            row = pt.x + rowNum[i]\n            col = pt.y + colNum[i]\n             \n            # if adjacent cell is valid, has path  \n            # and not visited yet, enqueue it.\n            if (isValid(row,col) and\n               mat[row][col] == 1 and\n                not visited[row][col]):\n                visited[row][col] = True\n                Adjcell = queueNode(Point(row,col),\n                                    curr.dist+1)\n                q.append(Adjcell)\n     \n    # Return -1 if destination cannot be reached \n    return -1\n \n# Driver code\ndef main():\n    mat = [[ 1, 0, 1, 1, 1, 1, 0, 1, 1, 1 ],\n           [ 1, 0, 1, 0, 1, 1, 1, 0, 1, 1 ], \n           [ 1, 1, 1, 0, 1, 1, 0, 1, 0, 1 ], \n           [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ], \n           [ 1, 1, 1, 0, 1, 1, 1, 0, 1, 0 ], \n           [ 1, 0, 1, 1, 1, 1, 0, 1, 0, 0 ], \n           [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 ], \n           [ 1, 0, 1, 1, 1, 1, 0, 1, 1, 1 ], \n           [ 1, 1, 0, 0, 0, 0, 1, 0, 0, 1 ]]\n    source = Point(0,0)\n    dest = Point(3,4)\n     \n    dist = BFS(mat,source,dest)\n     \n    if dist!=-1:\n        print('Shortest Path is',dist)\n    else:\n        print('Shortest Path doesn't exist')\nmain()\n \n# This code is contributed by stutipathak31jan\n"], "Merge K sorted linked lists | Set 1 -  ": ["# Python3 program to merge k\n# sorted arrays of size n each\n \n# A Linked List node\n \n \nclass Node:\n \n    def __init__(self, x):\n \n        self.data = x\n        self.next = None\n \n# Function to print nodes in\n# a given linked list\n \n \ndef printList(node):\n \n    while (node != None):\n        print(node.data,\n              end=' ')\n        node = node.next\n \n# The main function that\n# takes an array of lists\n# arr[0..last] and generates\n# the sorted output\n \n \ndef mergeKLists(arr, last):\n \n    # Traverse form second\n    # list to last\n    for i in range(1, last + 1):\n        while (True):\n            # head of both the lists,\n            # 0 and ith list.\n            head_0 = arr[0]\n            head_i = arr[i]\n \n            # Break if list ended\n            if (head_i == None):\n                break\n \n            # Smaller than first\n            # element\n            if (head_0.data >=\n                    head_i.data):\n                arr[i] = head_i.next\n                head_i.next = head_0\n                arr[0] = head_i\n            else:\n                # Traverse the first list\n                while (head_0.next != None):\n                    # Smaller than next\n                    # element\n                    if (head_0.next.data >=\n                            head_i.data):\n                        arr[i] = head_i.next\n                        head_i.next = head_0.next\n                        head_0.next = head_i\n                        break\n                    # go to next node\n                    head_0 = head_0.next\n                    # if last node\n                    if (head_0.next == None):\n                        arr[i] = head_i.next\n                        head_i.next = None\n                        head_0.next = head_i\n                        head_0.next.next = None\n                        break\n    return arr[0]\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Number of linked\n    # lists\n    k = 3\n \n    # Number of elements\n    # in each list\n    n = 4\n \n    # an array of pointers\n    # storing the head nodes\n    # of the linked lists\n    arr = [None for i in range(k)]\n \n    arr[0] = Node(1)\n    arr[0].next = Node(3)\n    arr[0].next.next = Node(5)\n    arr[0].next.next.next = Node(7)\n \n    arr[1] = Node(2)\n    arr[1].next = Node(4)\n    arr[1].next.next = Node(6)\n    arr[1].next.next.next = Node(8)\n \n    arr[2] = Node(0)\n    arr[2].next = Node(9)\n    arr[2].next.next = Node(10)\n    arr[2].next.next.next = Node(11)\n \n    # Merge all lists\n    head = mergeKLists(arr, k - 1)\n \n    printList(head)\n \n# This code is contributed by Mohit Kumar 29\n", "# Python3 program to merge k sorted\n# arrays of size n each\n \n# A Linked List node\nclass Node:\n \n    def __init__(self):\n \n        self.data = 0\n        self.next = None\n \n# Function to print nodes in a\n# given linked list\ndef printList(node):\n \n    while (node != None):\n        print(node.data, end=' ')\n        node = node.next\n \n# Takes two lists sorted in increasing order,\n# and merge their nodes together to make one\n# big sorted list. Below function takes\n# O(Log n) extra space for recursive calls,\n# but it can be easily modified to work with\n# same time and O(1) extra space\ndef SortedMerge(a, b):\n \n    result = None\n \n    # Base cases\n    if (a == None):\n        return(b)\n    elif (b == None):\n        return(a)\n \n    # Pick either a or b, and recur\n    if (a.data <= b.data):\n        result = a\n        result.next = SortedMerge(a.next, b)\n    else:\n        result = b\n        result.next = SortedMerge(a, b.next)\n \n    return result\n \n# The main function that takes an array of lists\n# arr[0..last] and generates the sorted output\ndef mergeKLists(arr, last):\n \n    # Repeat until only one list is left\n    while (last != 0):\n        i = 0\n        j = last\n \n        # (i, j) forms a pair\n        while (i < j):\n \n            # Merge List i with List j and store\n            # merged list in List i\n            arr[i] = SortedMerge(arr[i], arr[j])\n \n            # Consider next pair\n            i += 1\n            j -= 1\n \n            # If all pairs are merged, update last\n            if (i >= j):\n                last = j\n \n    return arr[0]\n \n# Utility function to create a new node.\ndef newNode(data):\n \n    temp = Node()\n    temp.data = data\n    temp.next = None\n    return temp\n \n \n# Driver code\nif __name__ == '__main__':\n \n    # Number of linked lists\n    k = 3\n \n    # Number of elements in each list\n    n = 4\n \n    # An array of pointers storing the\n    # head nodes of the linked lists\n    arr = [0 for i in range(k)]\n \n    arr[0] = newNode(1)\n    arr[0].next = newNode(3)\n    arr[0].next.next = newNode(5)\n    arr[0].next.next.next = newNode(7)\n \n    arr[1] = newNode(2)\n    arr[1].next = newNode(4)\n    arr[1].next.next = newNode(6)\n    arr[1].next.next.next = newNode(8)\n \n    arr[2] = newNode(0)\n    arr[2].next = newNode(9)\n    arr[2].next.next = newNode(10)\n    arr[2].next.next.next = newNode(11)\n \n    # Merge all lists\n    head = mergeKLists(arr, k - 1)\n \n    printList(head)\n \n# This code is contributed by rutvik_56\n", "# Python program to merge k sorted arrays of size n each\n \n# A Linked List node\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n \n# Function to merge K sorted linked lists\ndef mergeKLists(arr, K):\n    from queue import PriorityQueue\n \n    # Create a priority queue\n    pq = PriorityQueue()\n \n    # Push the first elements of all linked lists into the priority queue\n    for i in range(K):\n        if arr[i] is not None:\n            pq.put((arr[i].data, i))\n \n    head = Node(None)\n    curr = head\n \n    # Merge the linked lists\n    while not pq.empty():\n        val, i = pq.get()\n        curr.next = Node(val)\n        curr = curr.next\n        if arr[i].next is not None:\n            pq.put((arr[i].next.data, i))\n            arr[i] = arr[i].next\n \n    return head.next\n \n# Function to print nodes in a given linked list\ndef printList(node):\n    while node is not None:\n        print(node.data, end=' ')\n        node = node.next\n    print()\n \n# Driver program to test the functions\nif __name__ == '__main__':\n    k = 3  # Number of linked lists\n    n = 4  # Number of elements in each list\n \n    # An array of pointers storing the head nodes\n    # of the linked lists\n    arr = [None] * k\n \n    arr[0] = Node(1)\n    arr[0].next = Node(3)\n    arr[0].next.next = Node(5)\n    arr[0].next.next.next = Node(7)\n \n    arr[1] = Node(2)\n    arr[1].next = Node(4)\n    arr[1].next.next = Node(6)\n    arr[1].next.next.next = Node(8)\n \n    arr[2] = Node(0)\n    arr[2].next = Node(9)\n    arr[2].next.next = Node(10)\n    arr[2].next.next.next = Node(11)\n \n    head = mergeKLists(arr, k)\n \n    print('Merged Linked List:')\n    printList(head)\n \n# This code is contributed by shivamgupta310570\n"], "Median of Stream of Running Integers using STL -  ": ["# python3 program to find med in\n# stream of running integers\nfrom heapq import *\n \n# function to calculate med of stream\ndef printMedians(arr, n):\n    # max heap to store the smaller half elements\n    s = []\n    # min heap to store the greater half elements\n    g = []\n \n    heapify(s)\n    heapify(g)\n \n    med = arr[0]\n    heappush(s, arr[0])\n \n    print(med)\n \n    # reading elements of stream one by one\n    for i in range(1, n):\n        x = arr[i]\n \n        # case1(left side heap has more elements)\n        if len(s) > len(g):\n            if x < med:\n                heappush(g, heappop(s))\n                heappush(s, x)\n            else:\n                heappush(g, x)\n            med = (nlargest(1, s)[0] + nsmallest(1, g)[0])/2\n \n        # case2(both heaps are balanced)\n        elif len(s) == len(g):\n            if x < med:\n                heappush(s, x)\n                med = nlargest(1, s)[0]\n            else:\n                heappush(g, x)\n                med = nsmallest(1, g)[0]\n \n        # case3(right side heap has more elements)\n        else:\n            if x > med:\n                heappush(s, heappop(g))\n                heappush(g, x)\n            else:\n                heappush(s, x)\n            med = (nlargest(1, s)[0] + nsmallest(1, g)[0])/2\n \n        print(med)\n \n# Driver program to test above functions\narr = [5, 15, 10, 20, 3]\nprintMedians(arr, len(arr))\n \n# This code is contributed by cavi4762.\n"], "Egg Dropping Puzzle | DP-11 -  ": ["import sys\n \n# Function to get minimum number of trials\n# needed in worst case with n eggs and k floors\n \n \ndef eggDrop(n, k):\n \n    # If there are no floors, then no trials\n    # needed. OR if there is one floor, one\n    # trial needed.\n    if (k == 1 or k == 0):\n        return k\n \n    # We need k trials for one egg\n    # and k floors\n    if (n == 1):\n        return k\n \n    min = sys.maxsize\n \n    # Consider all droppings from 1st\n    # floor to kth floor and return\n    # the minimum of these values plus 1.\n    for x in range(1, k + 1):\n \n        res = max(eggDrop(n - 1, x - 1),\n                  eggDrop(n, k - x))\n        if (res < min):\n            min = res\n \n    return min + 1\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    n = 2\n    k = 10\n    print('Minimum number of trials in worst case with',\n          n, 'eggs and', k, 'floors is', eggDrop(n, k))\n \n# This code is contributed by ita_c\n", "# Python3 program for the above approach\nINT_MAX = 32767\n \n# Function to get minimum number of trials needed in worst\n# case with n eggs and k floors\n \n \ndef eggDrop(n, k):\n    # A 2D table where entry eggFloor[i][j] will represent minimum\n    # number of trials needed for i eggs and j floors.\n    eggFloor = [[0 for x in range(k + 1)] for x in range(n + 1)]\n \n    # We need one trial for one floor and0 trials for 0 floors\n    for i in range(1, n + 1):\n        eggFloor[i][1] = 1\n        eggFloor[i][0] = 0\n \n    # We always need j trials for one egg and j floors.\n    for j in range(1, k + 1):\n        eggFloor[1][j] = j\n \n    # Fill rest of the entries in table using optimal substructure\n    # property\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            eggFloor[i][j] = INT_MAX\n            for x in range(1, j + 1):\n                res = 1 + max(eggFloor[i-1][x-1], eggFloor[i][j-x])\n                if res < eggFloor[i][j]:\n                    eggFloor[i][j] = res\n \n    # eggFloor[n][k] holds the result\n    return eggFloor[n][k]\n \n \n# Driver code\nif __name__ == '__main__':\n  n = 2\n  k = 36\n  print('Minimum number of trials in worst case with ' + str(n) + ' eggs and '\n        + str(k) + ' floors is ' + str(eggDrop(n, k)))\n \n# This code is contributed by Bhavya Jain\n", "# Python3 program for the above approach\n \nimport sys\n \nMAX = 1000\n \nmemo = [[-1 for i in range(MAX)] for j in range(MAX)]\n \n \ndef solveEggDrop(n, k):\n \n    if (memo[n][k] != -1):\n        return memo[n][k]\n \n    if (k == 1 or k == 0):\n        return k\n \n    if (n == 1):\n        return k\n \n    min = sys.maxsize\n    res = 0\n \n    for x in range(1, k+1):\n        res = max(solveEggDrop(n - 1, x - 1), solveEggDrop(n, k - x))\n        if (res < min):\n            min = res\n \n    memo[n][k] = min + 1\n    return min + 1\n \n \n# Driver code\nif __name__ == '__main__':\n    n = 2\n    k = 36\n    print('Minimum number of trials in worst case with ' , n, ' eggs and ', k, ' floors is ', solveEggDrop(n, k))\n \n# This code is contributed by gauravrajput1\n", "def minTrials(n, k):\n    # Initialize 2D array of size (k+1) * (n+1).\n    dp = [[0 for x in range(n + 1)] for y in range(k + 1)]\n    m = 0 # Number of moves\n    while dp[m][n] < k:\n        m += 1\n        for x in range(1, n + 1):\n            dp[m][x] = 1 + dp[m - 1][x - 1] + dp[m - 1][x]\n    return m\n \n# Driver code\nn, k = 2, 36\nprint('Minimum number of trials in worst case with', n, 'eggs and', k, 'floors is', minTrials(n, k))\n", "# Python implementation for the above approach.\n \n \ndef minTrials(n, k):\n    # Initialize array of size (n+1) and m as moves.\n    dp = [0 for i in range(n+1)]\n    m = 0\n    while dp[n] < k:\n        m += 1\n        for x in range(n, 0, -1):\n            dp[x] += 1 + dp[x - 1]\n    return m\n \n \n# Driver code\nn, k = 2, 36\nprint('Minimum number of trials in worst case with',\n      n, 'eggs and', k, 'floors is', minTrials(n, k))\n \n# This code is contributed by Amit Mangal.\n"], "Count number of ways to cover a distance -  ": ["# A naive recursive Python3 program \n# to count number of ways to cover\n# a distance with 1, 2 and 3 steps\n \n# Returns count of ways to \n# cover 'dist'\ndef printCountRec(dist):\n     \n    # Base cases\n    if dist < 0:\n        return 0\n         \n    if dist == 0:\n        return 1\n \n    # Recur for all previous 3 and       \n   # add the results\n    return (printCountRec(dist-1) +\n            printCountRec(dist-2) +\n            printCountRec(dist-3))\n \n# Driver code\ndist = 4\nprint(printCountRec(dist))\n# This code is contributed by Anant Agarwal.\n", "# A Dynamic Programming based on Python3\n# program to count number of ways to \n# cover a distance with 1, 2 and 3 steps\n \ndef printCountDP(dist):\n    count = [0] * (dist + 1)\n     \n    # Initialize base values. There is\n    # one way to cover 0 and 1 distances\n    # and two ways to cover 2 distance\n    count[0] = 1\n    if dist >= 1 :\n        count[1] = 1\n    if dist >= 2 :\n        count[2] = 2\n     \n    # Fill the count array in bottom\n    # up manner\n    for i in range(3, dist + 1):\n        count[i] = (count[i-1] +\n                   count[i-2] + count[i-3])\n         \n    return count[dist];\n \n# driver program\ndist = 4;\nprint( printCountDP(dist))\n \n# This code is contributed by Sam007.\n", "# A Dynamic Programming based C++ program to count number of ways\ndef prCountDP( dist):\n \n        # Create the array of size 3.\n        ways = [0]*3\n        n = dist\n         \n        # Initialize the bases cases\n        ways[0] = 1\n        ways[1] = 1\n        ways[2] = 2\n         \n        # Run a loop from 3 to n\n        # Bottom up approach to fill the array\n        for i in range(3, n + 1):\n            ways[i % 3] = ways[(i - 1) % 3] + ways[(i - 2) % 3] + ways[(i - 3) % 3]\n         \n        return ways[n % 3]\n  \n# driver program\ndist = 4\nprint(prCountDP(dist))\n \n# This code is contributed by shivanisinghss2110\n"], "Partition a set into two subsets such that the difference of subset sums is minimum -  ": ["# Python3 program for the\n# above approach\n \n \n# Function to find the minimum sum\n \n \ndef findMinRec(arr, i, sumCalculated,\n               sumTotal):\n \n    # If we have reached last element.\n    # Sum of one subset is sumCalculated,\n    # sum of other subset is sumTotal-\n    # sumCalculated.  Return absolute\n    # difference of two sums.\n    if (i == 0):\n        return abs((sumTotal - sumCalculated) -\n                   sumCalculated)\n \n    # For every item arr[i], we have two choices\n    # (1) We do not include it first set\n    # (2) We include it in first set\n    # We return minimum of two choices\n    return min(findMinRec(arr, i - 1,\n                          sumCalculated+arr[i - 1],\n                          sumTotal),\n               findMinRec(arr, i - 1,\n                          sumCalculated, sumTotal))\n \n# Returns minimum possible\n# difference between sums\n# of two subsets\n \n \ndef findMin(arr,  n):\n \n    # Compute total sum\n    # of elements\n    sumTotal = 0\n    for i in range(n):\n        sumTotal += arr[i]\n \n    # Compute result using\n    # recursive function\n    return findMinRec(arr, n,\n                      0, sumTotal)\n \n \n# Driver code\nif __name__ == '__main__':\n \n    arr = [3, 1, 4, 2, 2, 1]\n    n = len(arr)\n    print('The minimum difference ' +\n          'between two sets is ',\n          findMin(arr, n))\n \n# This code is contributed by Chitranayal\n", "# A Recursive Python3 program to solve\n# minimum sum partition problem.\nimport sys\n \n# Returns the minimum value of the\n# difference of the two sets.\n \n \ndef findMin(a, n):\n \n    su = 0\n \n    # Calculate sum of all elements\n    su = sum(a)\n \n    # Create an 2d list to store\n    # results of subproblems\n    dp = [[0 for i in range(su + 1)]\n          for j in range(n + 1)]\n \n    # Initialize first column as true.\n    # 0 sum is possible\n    # with all elements.\n    for i in range(n + 1):\n        dp[i][0] = True\n \n    # Initialize top row, except dp[0][0],\n    # as false. With 0 elements, no other\n    # sum except 0 is possible\n    for j in range(1, su + 1):\n        dp[0][j] = False\n \n    # Fill the partition table in\n    # bottom up manner\n    for i in range(1, n + 1):\n        for j in range(1, su + 1):\n \n            # If i'th element is excluded\n            dp[i][j] = dp[i - 1][j]\n \n            # If i'th element is included\n            if a[i - 1] <= j:\n                dp[i][j] |= dp[i - 1][j - a[i - 1]]\n \n    # Initialize difference\n    # of two sums.\n    diff = sys.maxsize\n \n    # Find the largest j such that dp[n][j]\n    # is true where j loops from sum/2 t0 0\n    for j in range(su // 2, -1, -1):\n        if dp[n][j] == True:\n            diff = su - (2 * j)\n            break\n \n    return diff\n \n \n# Driver code\na = [3, 1, 4, 2, 2, 1]\nn = len(a)\n \nprint('The minimum difference between '\n      '2 sets is ', findMin(a, n))\n \n# This code is contributed by Tokir Manva\n", "def minDifference(arr, n):\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n    y = sum // 2 + 1\n \n    # dp[i] gives whether is it possible to get i as\n    # sum of elements dd is helper variable we use dd\n    # to ignoring duplicates\n    dp = [False for i in range(y)]\n    dd = [False for i in range(y)]\n \n    # Initialising dp and dd\n \n    # sum = 0 is possible\n    dp[0] = True  # let dp array is used for storing\n    # previous values and dd array is used to\n    # store current values\n    for i in range(n):\n \n        # updating dd[k] as True if k can be formed\n        # using elements from 1 to i+1\n        for j in range(y):\n            if (j + arr[i] < y and dp[j]):\n                dd[j + arr[i]] = True\n \n        # updating dd\n        for j in range(y):\n            if (dd[j]):\n                dp[j] = True\n            dd[j] = False  # reset dd\n \n    # checking the number from sum/2 to 1 which is\n    # possible to get as sum\n    for i in range(y-1, 0, -1):\n        if (dp[i]):\n            return (sum - 2 * i)\n \n        # since i is possible to form then another\n        # number is sum-i so mindifference is sum-i-i\n    return 0\n \n \nif __name__ == '__main__':\n \n    arr = [1, 6, 11, 5]\n    n = len(arr)\n    print('The Minimum difference of 2 sets is ', minDifference(arr, n))\n \n# This code is contributed by umadevi9616\n"], "Cutting a Rod | DP-13 -  ": ["#  A recursive solution for Rod cutting problem\n \n#  Returns the best obtainable price for a rod of length n\n#   and price[] as prices of different pieces \ndef cutRod(price, index, n):\n     \n    #  base case\n    if index == 0:\n        return n*price[0]\n     \n    #   At any index we have 2 options either\n    #   cut the rod of this length or not cut \n    #   it\n    notCut = cutRod(price,index - 1,n)\n    cut = float('-inf')\n    rod_length = index + 1\n \n    if (rod_length <= n):\n         \n        cut = price[index]+cutRod(price,index,n - rod_length)\n   \n    return max(notCut, cut)\n \n#  Driver program to test above functions \narr = [ 1, 5, 8, 9, 10, 17, 17, 20 ]\nsize = len(arr)\nprint('Maximum Obtainable Value is ',cutRod(arr, size - 1, size))\n \n# This code is contributed by Vivek Maddeshiya\n", "# A memoization solution for Rod cutting problem\n \n # Returns the best obtainable price for \n  # a rod of length n and price[] as \n  # prices of different pieces\ndef cutRoad(price,index,n,dp):\n   \n    # base case\n    if(index == 0):\n        return n*price[0]\n    if(dp[index][n] != -1):\n        return dp[index][n]\n       \n    # At any index we have 2 options either \n    # cut the rod of this length or not cut it\n    notCut = cutRoad(price,index-1,n,dp)\n    cut = -5\n    rod_length = index + 1\n    if(rod_length <= n):\n        cut = price[index] + cutRoad(price,index,n-rod_length,dp)\n    dp[index][n] = max(notCut,cut)\n    return dp[index][n]\n \n# Driver program to test above functions\nif __name__ == '__main__':\n    arr = [1,5,8,9,10,17,17,20]\n    size = len(arr)\n    dp = []\n    temp = []\n    for i in range(0,size+1):\n        temp.append(-1)\n    for i in range(0,size):\n        dp.append(temp)\n    # print(dp)\n    print('Maximum Obtainable Value is :',end=' ')\n    print(cutRoad(arr,size-1,size,dp))\n", "# A Dynamic Programming solution for Rod cutting problem\nINT_MIN = -32767\n \n# Returns the best obtainable price for a rod of length n and\n# price[] as prices of different pieces\ndef cutRod(price, n):\n    val = [0 for x in range(n+1)]\n    val[0] = 0\n \n    # Build the table val[] in bottom up manner and return\n    # the last entry from the table\n    for i in range(1, n+1):\n        max_val = INT_MIN\n        for j in range(i):\n             max_val = max(max_val, price[j] + val[i-j-1])\n        val[i] = max_val\n \n    return val[n]\n \n# Driver program to test above functions\narr = [1, 5, 8, 9, 10, 17, 17, 20]\nsize = len(arr)\nprint('Maximum Obtainable Value is ' + str(cutRod(arr, size)))\n \n# This code is contributed by Bhavya Jain\n", "# Python program for above approach\n \n# Global Array for\n# the purpose of memoization.\nt = [[0 for i in range(9)] for j in range(9)]\n \n# A recursive program, using ,\n# memoization, to implement the\n# rod cutting problem(Top-Down).\ndef un_kp(price, length, Max_len, n):\n \n    # The maximum price will be zero,\n    # when either the length of the rod\n    # is zero or price is zero.\n    if (n == 0 or Max_len == 0):\n        return 0;\n     \n \n    # If the length of the rod is less\n    # than the maximum length, Max_lene will\n    # consider it.Now depending\n    # upon the profit,\n    # either Max_lene we will take\n    # it or discard it.\n    if (length[n - 1] <= Max_len):\n        t[n][Max_len] = max(price[n - 1] + un_kp(price, length, Max_len - length[n - 1], n),\n                un_kp(price, length, Max_len, n - 1));\n     \n \n    # If the length of the rod is\n    # greater than the permitted size,\n    # Max_len we will not consider it.\n    else:\n        t[n][Max_len] = un_kp(price, length, Max_len, n - 1);\n     \n \n    # Max_lene Max_lenill return the maximum\n    # value obtained, Max_lenhich is present\n    # at the nth roMax_len and Max_length column.\n    return t[n][Max_len];\n \n \nif __name__ == '__main__':\n \n    price = [1, 5, 8, 9, 10, 17, 17, 20 ];\n    n =len(price);\n    length = [0]*n;\n    for i in range(n):\n        length[i] = i + 1;\n     \n    Max_len = n;\n    print('Maximum obtained value is ' ,un_kp(price, length, n, Max_len));\n \n# This code is contributed by gauravrajput1 \n", "#  Python program for above approach\n \n \ndef cutRod(prices, n):\n    mat = [[0 for i in range(n+1)]for j in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i == 1:\n                mat[i][j] = j*prices[i-1]\n            else:\n                if i > j:\n                    mat[i][j] = mat[i-1][j]\n                else:\n                    mat[i][j] = max(prices[i-1]+mat[i][j-i], mat[i-1][j])\n    return mat[n][n]\n \n \nprices = [1, 5, 8, 9, 10, 17, 17, 20]\nn = len(prices)\n \nprint('Maximum obtained value is ', cutRod(prices, n))\n \n# This Code is Contributed By Vivek Maddeshiya\n"], "Box Stacking Problem | DP-22 -  ": ["# Dynamic Programming implementation\n# of Box Stacking problem\nclass Box:\n     \n    # Representation of a box\n    def __init__(self, h, w, d):\n        self.h = h\n        self.w = w\n        self.d = d\n \n    def __lt__(self, other):\n        return self.d * self.w < other.d * other.w\n \ndef maxStackHeight(arr, n):\n \n    # Create an array of all rotations of \n    # given boxes. For example, for a box {1, 2, 3}, \n    # we consider three instances{{1, 2, 3},\n    # {2, 1, 3}, {3, 1, 2}}\n    rot = [Box(0, 0, 0) for _ in range(3 * n)]\n    index = 0\n \n    for i in range(n):\n \n        # Copy the original box\n        rot[index].h = arr[i].h\n        rot[index].d = max(arr[i].d, arr[i].w)\n        rot[index].w = min(arr[i].d, arr[i].w)\n        index += 1\n \n        # First rotation of the box\n        rot[index].h = arr[i].w\n        rot[index].d = max(arr[i].h, arr[i].d)\n        rot[index].w = min(arr[i].h, arr[i].d)\n        index += 1\n \n        # Second rotation of the box\n        rot[index].h = arr[i].d\n        rot[index].d = max(arr[i].h, arr[i].w)\n        rot[index].w = min(arr[i].h, arr[i].w)\n        index += 1\n \n    # Now the number of boxes is 3n\n    n *= 3\n \n    # Sort the array 'rot[]' in non-increasing \n    # order of base area\n    rot.sort(reverse = True)\n \n    # Uncomment following two lines to print \n    # all rotations \n    # for i in range(n):\n    #     print(rot[i].h, 'x', rot[i].w, 'x', rot[i].d)\n \n    # Initialize msh values for all indexes\n    # msh[i] --> Maximum possible Stack Height \n    # with box i on top\n    msh = [0] * n\n \n    for i in range(n):\n        msh[i] = rot[i].h\n \n    # Compute optimized msh values\n    # in bottom up manner\n    for i in range(1, n):\n        for j in range(0, i):\n            if (rot[i].w < rot[j].w and\n                rot[i].d < rot[j].d):\n                if msh[i] < msh[j] + rot[i].h:\n                    msh[i] = msh[j] + rot[i].h\n \n    maxm = -1\n    for i in range(n):\n        maxm = max(maxm, msh[i])\n \n    return maxm\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [Box(4, 6, 7), Box(1, 2, 3),\n           Box(4, 5, 6), Box(10, 12, 32)]\n    n = len(arr)\n    print('The maximum possible height of stack is',\n           maxStackHeight(arr, n))\n \n# This code is contributed by vibhu4agarwal\n", "# Dynamic Programming top-down implementation of Box\n# Stacking problem\n \nclass Box:\n    def __init__(self, length, width, height):\n        self.length = length\n        self.width = width\n        self.height = height\n \n# dp array\ndp = [-1]*303\n \ndef findMaxHeight(boxes, bottom_box_index, index):\n \n    # base case\n    if index < 0:\n        return 0\n \n    if dp[index] != -1:\n        return dp[index]\n \n    maximumHeight = 0\n \n    # recurse\n    for i in range(index, -1, -1):\n \n        # if there is no bottom box\n        if bottom_box_index == -1 or (boxes[i].length < boxes[bottom_box_index].length \n            and boxes[i].width < boxes[bottom_box_index].width):\n \n            maximumHeight = max(maximumHeight, findMaxHeight(boxes, i, i-1) + boxes[i].height)\n \n    dp[index] = maximumHeight\n    return maximumHeight\n \n# Returns the height of the tallest stack that can be\n# formed with give type of boxes \ndef maxStackHeight(height, width, length, types):\n \n    # creating a vector of type Box class\n    boxes = []\n \n    # Initialize dp array with -1\n    dp[:] = [-1]*303\n \n    # Create an array of all rotations of given boxes\n    # For example, for a box {1, 2, 3}, we consider three\n    # instances{{1, 2, 3}, {2, 1, 3}, {3, 1, 2}}\n    for i in range(types):\n \n        # copy original box\n        box = Box(length[i], max(length[i], width[i]), min(length[i], width[i]))\n        boxes.append(box)\n \n        # First rotation of box\n        box = Box(width[i], max(length[i], height[i]), min(length[i], height[i]))\n        boxes.append(box)\n \n        # Second rotation of box\n        box = Box(length[i], max(width[i], height[i]), min(width[i], height[i]))\n        boxes.append(box)\n \n    # sort by area in ascending order .. because we will be dealing with this vector in reverse\n    boxes.sort(key=lambda box : (box.length * box.width))\n \n    # Uncomment following two lines to print all rotations\n    #for (int i = boxes.size() - 1; i >= 0; i-- )\n    #   printf('%d x %d x %d\\n', boxes[i].length, boxes[i].width, boxes[i].height);\n \n    return findMaxHeight(boxes, -1, len(boxes)-1)\n \n# where length, width and height of a particular box\n# are at ith index of the following arrays\nlength = [ 4, 1, 4, 10 ]\nwidth = [ 6, 2, 5, 12 ]\nheight = [ 7, 3, 6, 32 ]\n \ntypes = len(length)\n \nprint('The maximum possible height of stack is', maxStackHeight(height, length, width, types))\n \n# This code is contributed b factworx412\n"], "Longest Palindromic Substring using Dynamic Programming -  ": ["# Python program to find the longest palindromic substring in a given string.\n \ndef longest_palin(s):\n    # Initialize variables to keep track \n    # of the longest palindrome and its length.\n    count = -1\n    ans = ''\n \n    # Get the length of the input string.\n    n = len(s)\n     \n    # Create a boolean 2D array to \n    # store palindrome information.\n    dp = [[False] * n for _ in range(n)]\n \n    # Iterate through different substring lengths.\n    for g in range(n):\n        for i in range(n - g):\n            j = i + g\n            # Check if the substring is of length 1 (base case).\n            if g == 0:\n                dp[i][j] = True\n            # Check if the substring is of length 2 (base case).\n            elif g == 1:\n                dp[i][j] = (s[i] == s[j])\n            else:\n                # Check if the current substring is a \n                # palindrome based on its ends.\n                dp[i][j] = (s[i] == s[j] and dp[i + 1][j - 1])\n \n            # Update the longest palindrome and its length if found.\n            if dp[i][j] and count < j - i + 1:\n                ans = s[i:j + 1]\n                count = len(ans)\n    return ans\n \n# Input string\nstr = 'forgeeksskeegfor'\n# Print the longest palindromic substring.\nprint(longest_palin(str))\n", "# A O(n ^ 2) time and O(1) space program to find the\n# longest palindromic substring\n \n# This function prints the longest palindrome substring (LPS)\n# of str[]. It also returns the length of the longest palindrome\n \n \ndef longestPalSubstr(string):\n    n = len(string) # calculating size of string\n    if (n < 2):\n        return n # if string is empty then size will be 0.\n                  # if n==1 then, answer will be 1(single\n                  # character will always palindrome)\n    start=0\n    maxLength = 1\n    for i in range(n):\n        low = i - 1\n        high = i + 1\n        while (high < n and string[high] == string[i] ):                               \n            high=high+1\n       \n        while (low >= 0 and string[low] == string[i] ):                 \n            low=low-1\n       \n        while (low >= 0 and high < n and string[low] == string[high] ):\n          low=low-1\n          high=high+1\n         \n     \n        length = high - low - 1\n        if (maxLength < length):\n            maxLength = length\n            start=low+1\n             \n    print ('Longest palindrome substring is:',end=' ')\n    print (string[start:start + maxLength])\n     \n    return maxLength\n     \n# Driver program to test above functions\nstring = ('forgeeksskeegfor')\nprint('Length is: ' + str(longestPalSubstr(string)))\n", "# Python 3 implementation of O(n^2)\n# time and O(1) space method\n# to find the longest palindromic substring\nclass LongestPalinSubstring :\n    maxLength = 0\n     \n    # variables to store and\n    res = None\n     \n    # update  maxLength and res\n    # A utility function to get the longest palindrome\n    # starting and expanding out from given center indices\n    @staticmethod\n    def cSubUtil( s,  l,  r) :\n       \n        # check if the indices lie in the range of string\n        # and also if it is palindrome\n        while (l >= 0 and r < len(s) and s[l] == s[r]) :\n           \n            # expand the boundary\n            l -= 1\n            r += 1\n             \n        # if it's length is greater than maxLength update\n        # maxLength and res\n        if (r - l - 1 >= LongestPalinSubstring.maxLength) :\n            LongestPalinSubstring.res = s[l + 1:r]\n            LongestPalinSubstring.maxLength = r - l - 1\n        return\n       \n    # A function which takes a string prints the LPS and\n    # returns the length of LPS\n    @staticmethod\n    def  longestPalSubstr( str) :\n        LongestPalinSubstring.res = ''\n        LongestPalinSubstring.maxLength = 1\n         \n        # for every index in the string check palindromes\n        # starting from that index\n        i = 0\n        while (i < len(str)) :\n           \n            # check for odd length palindromes\n            LongestPalinSubstring.cSubUtil(str, i, i)\n             \n            # check for even length palindromes\n            LongestPalinSubstring.cSubUtil(str, i, i + 1)\n            i += 1\n        print('Longest palindrome substring is: ', end ='')\n        print(LongestPalinSubstring.res)\n        return LongestPalinSubstring.maxLength\n       \n    # Driver program to test above function\n    @staticmethod\n    def main( args) :\n        str1 = 'forgeeksskeegfor'\n        print('Length is: ' + str(LongestPalinSubstring.longestPalSubstr(str1)))\n     \nif __name__=='__main__':\n    LongestPalinSubstring.main([])\n     \n    # This code is contributed by phasing17.\n"], "Edit Distance -  ": ["# A Naive recursive Python program to find minimum number\n# operations to convert str1 to str2\n \n \ndef editDistance(str1, str2, m, n):\n \n    # If first string is empty, the only option is to\n    # insert all characters of second string into first\n    if m == 0:\n        return n\n \n    # If second string is empty, the only option is to\n    # remove all characters of first string\n    if n == 0:\n        return m\n \n    # If last characters of two strings are same, nothing\n    # much to do. Ignore last characters and get count for\n    # remaining strings.\n    if str1[m-1] == str2[n-1]:\n        return editDistance(str1, str2, m-1, n-1)\n \n    # If last characters are not same, consider all three\n    # operations on last character of first string, recursively\n    # compute minimum cost for all three operations and take\n    # minimum of three values.\n    return 1 + min(editDistance(str1, str2, m, n-1),    # Insert\n                   editDistance(str1, str2, m-1, n),    # Remove\n                   editDistance(str1, str2, m-1, n-1)    # Replace\n                   )\n \n \n# Driver code\nstr1 = 'sunday'\nstr2 = 'saturday'\nprint (editDistance(str1, str2, len(str1), len(str2)))\n \n# This code is contributed by Bhavya Jain\n", "def minDis(s1, s2, n, m, dp):\n \n    # If any string is empty,\n    # return the remaining characters of other string\n    if(n == 0):\n        return m\n    if(m == 0):\n        return n\n \n    # To check if the recursive tree\n    # for given n & m has already been executed\n    if(dp[n][m] != -1):\n        return dp[n][m]\n \n    # If characters are equal, execute\n    # recursive function for n-1, m-1\n    if(s1[n - 1] == s2[m - 1]):\n        if(dp[n - 1][m - 1] == -1):\n            dp[n][m] = minDis(s1, s2, n - 1, m - 1, dp)\n            return dp[n][m]\n        else:\n            dp[n][m] = dp[n - 1][m - 1]\n            return dp[n][m]\n \n    # If characters are nt equal, we need to\n    # find the minimum cost out of all 3 operations.\n    else:\n        if(dp[n - 1][m] != -1):\n            m1 = dp[n - 1][m]\n        else:\n            m1 = minDis(s1, s2, n - 1, m, dp)\n \n        if(dp[n][m - 1] != -1):\n            m2 = dp[n][m - 1]\n        else:\n            m2 = minDis(s1, s2, n, m - 1, dp)\n        if(dp[n - 1][m - 1] != -1):\n            m3 = dp[n - 1][m - 1]\n        else:\n            m3 = minDis(s1, s2, n - 1, m - 1, dp)\n \n        dp[n][m] = 1 + min(m1, min(m2, m3))\n        return dp[n][m]\n \n \n        # Driver code\nstr1 = 'saturday'\nstr2 = 'sunday'\n \nn = len(str1)\nm = len(str2)\ndp = [[-1 for i in range(m + 1)] for j in range(n + 1)]\n \nprint(minDis(str1, str2, n, m, dp))\n \n# This code is contributed by divyesh072019.\n", "# A Space efficient Dynamic Programming\n# based Python3 program to find minimum\n# number operations to convert str1 to str2\n \n \nclass Solution:\n    def editDistance(self, s: str, t: str) -> int:\n        n = len(s)\n        m = len(t)\n \n        prev = [j for j in range(m+1)]\n        curr = [0] * (m+1)\n \n        for i in range(1, n+1):\n            curr[0] = i\n            for j in range(1, m+1):\n                if s[i-1] == t[j-1]:\n                    curr[j] = prev[j-1]\n                else:\n                    mn = min(1 + prev[j], 1 + curr[j-1])\n                    curr[j] = min(mn, 1 + prev[j-1])\n            prev = curr.copy()\n \n        return prev[m]\n \n \ns = 'saturday'\nt = 'sunday'\n \nob = Solution()\nans = ob.editDistance(s, t)\nprint(ans)\n", "def editDistance(str1, str2):\n    # Get the lengths of the input strings\n    m = len(str1)\n    n = len(str2)\n     \n    # Initialize a list to store the current row\n    curr = [0] * (n + 1)\n     \n    # Initialize the first row with values from 0 to n\n    for j in range(n + 1):\n        curr[j] = j\n     \n    # Initialize a variable to store the previous value\n    previous = 0\n     \n    # Loop through the rows of the dynamic programming matrix\n    for i in range(1, m + 1):\n        # Store the current value at the beginning of the row\n        previous = curr[0]\n        curr[0] = i\n         \n        # Loop through the columns of the dynamic programming matrix\n        for j in range(1, n + 1):\n            # Store the current value in a temporary variable\n            temp = curr[j]\n             \n            # Check if the characters at the current positions in str1 and str2 are the same\n            if str1[i - 1] == str2[j - 1]:\n                curr[j] = previous\n            else:\n                # Update the current cell with the minimum of the three adjacent cells\n                curr[j] = 1 + min(previous, curr[j - 1], curr[j])\n             \n            # Update the previous variable with the temporary value\n            previous = temp\n     \n    # The value in the last cell represents the minimum number of operations\n    return curr[n]\n \n# Driver Code\nif __name__ == '__main__':\n    str1 = 'sit'\n    str2 = 'kiit'\n     \n    ans = editDistance(str1, str2)\n    print(ans)\n"], "Maximum Sum Increasing Subsequence | DP-14 -  ": ["# Dynamic Programming based Python  \n# implementation of Maximum Sum  \n# Increasing Subsequence (MSIS) \n# problem \n  \n# maxSumIS() returns the maximum  \n# sum of increasing subsequence  \n# in arr[] of size n \ndef maxSumIS(arr, n): \n    max = 0\n    msis = [0 for x in range(n)] \n  \n    # Initialize msis values \n    # for all indexes \n    for i in range(n): \n        msis[i] = arr[i] \n  \n    # Compute maximum sum  \n    # values in bottom up manner \n    for i in range(1, n): \n        for j in range(i): \n            if (arr[i] > arr[j] and\n                msis[i] < msis[j] + arr[i]): \n                msis[i] = msis[j] + arr[i] \n  \n    # Pick maximum of \n    # all msis values \n    for i in range(n): \n        if max < msis[i]: \n            max = msis[i] \n  \n    return max\n  \n# Driver Code \narr = [1, 101, 2, 3, 100, 4, 5] \nn = len(arr) \nprint('Sum of maximum sum increasing ' + \n                     'subsequence is ' +\n                  str(maxSumIS(arr, n))) \n  \n# This code is contributed  \n# by Bhavya Jain \n"], "Longest Common Subsequence (LCS) -  ": ["# A Naive recursive Python implementation of LCS problem\n \n \ndef lcs(X, Y, m, n):\n    if m == 0 or n == 0:\n        return 0\n    elif X[m-1] == Y[n-1]:\n        return 1 + lcs(X, Y, m-1, n-1)\n    else:\n        return max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n))\n \n \n# Driver code\nif __name__ == '__main__':\n    S1 = 'AGGTAB'\n    S2 = 'GXTXAYB'\n    print('Length of LCS is', lcs(S1, S2, len(S1), len(S2)))\n", "# A Top-Down DP implementation of LCS problem\n \n# Returns length of LCS for X[0..m-1], Y[0..n-1]\n \n \ndef lcs(X, Y, m, n, dp):\n \n    if (m == 0 or n == 0):\n        return 0\n \n    if (dp[m][n] != -1):\n        return dp[m][n]\n \n    if X[m - 1] == Y[n - 1]:\n        dp[m][n] = 1 + lcs(X, Y, m - 1, n - 1, dp)\n        return dp[m][n]\n \n    dp[m][n] = max(lcs(X, Y, m, n - 1, dp), lcs(X, Y, m - 1, n, dp))\n    return dp[m][n]\n \n# Driver code\n \n \nX = 'AGGTAB'\nY = 'GXTXAYB'\n \nm = len(X)\nn = len(Y)\ndp = [[-1 for i in range(n + 1)]for j in range(m + 1)]\n \nprint(f'Length of LCS is {lcs(X, Y, m, n, dp)}')\n \n# This code is contributed by shinjanpatra\n", "# Dynamic Programming implementation of LCS problem\n \n \ndef lcs(X, Y, m, n):\n \n    # Declaring the array for storing the dp values\n    L = [[None]*(n+1) for i in range(m+1)]\n \n    # Following steps build L[m+1][n+1] in bottom up fashion\n    # Note: L[i][j] contains length of LCS of X[0..i-1]\n    # and Y[0..j-1]\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1]+1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n \n    # L[m][n] contains the length of LCS of X[0..n-1] & Y[0..m-1]\n    return L[m][n]\n \n \n# Driver code\nif __name__ == '__main__':\n    S1 = 'AGGTAB'\n    S2 = 'GXTXAYB'\n    m = len(S1)\n    n = len(S2)\n    print('Length of LCS is', lcs(S1, S2, m, n))\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "def longestCommonSubsequence(text1, text2):\n    n = len(text1)\n    m = len(text2)\n \n    # Initializing two lists of size m\n    prev = [0] * (m + 1)\n    cur = [0] * (m + 1)\n \n    for idx1 in range(1, n + 1):\n        for idx2 in range(1, m + 1):\n            # If characters are matching\n            if text1[idx1 - 1] == text2[idx2 - 1]:\n                cur[idx2] = 1 + prev[idx2 - 1]\n            else:\n                # If characters are not matching\n                cur[idx2] = max(cur[idx2 - 1], prev[idx2])\n \n        prev = cur.copy()\n \n    return cur[m]\n \nif __name__ == '__main__':\n    S1 = 'AGGTAB'\n    S2 = 'GXTXAYB'\n \n    # Function call\n    print('Length of LCS is', longestCommonSubsequence(S1, S2))\n# This code is contributed by Rishabh Mathur\n"], "Longest Increasing Subsequence (LIS) -  ": ["# A naive Python implementation of LIS problem\n \n \n# Global variable to store the maximum\nglobal maximum\n \n \n# To make use of recursive calls, this function must return\n# two things:\n# 1) Length of LIS ending with element arr[n-1]. We use\n# max_ending_here for this purpose\n# 2) Overall maximum as the LIS may end with an element\n# before arr[n-1] max_ref is used this purpose.\n# The value of LIS of full array of size n is stored in\n# *max_ref which is our final result\ndef _lis(arr, n):\n \n    # To allow the access of global variable\n    global maximum\n \n    # Base Case\n    if n == 1:\n        return 1\n \n    # maxEndingHere is the length of LIS ending with arr[n-1]\n    maxEndingHere = 1\n \n    # Recursively get all LIS ending with\n    # arr[0], arr[1]..arr[n-2]\n    # If arr[i-1] is smaller than arr[n-1], and\n    # max ending with arr[n-1] needs to be updated,\n    # then update it\n    for i in range(1, n):\n        res = _lis(arr, i)\n        if arr[i-1] < arr[n-1] and res+1 > maxEndingHere:\n            maxEndingHere = res + 1\n \n    # Compare maxEndingHere with overall maximum. And\n    # update the overall maximum if needed\n    maximum = max(maximum, maxEndingHere)\n \n    return maxEndingHere\n \n \ndef lis(arr):\n \n    # To allow the access of global variable\n    global maximum\n \n    # Length of arr\n    n = len(arr)\n \n    # Maximum variable holds the result\n    maximum = 1\n \n    # The function _lis() stores its result in maximum\n    _lis(arr, n)\n    return maximum\n \n \n# Driver program to test the above function\nif __name__ == '__main__':\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    n = len(arr)\n \n    # Function call\n    print('Length of lis is', lis(arr))\n \n# This code is contributed by NIKHIL KUMAR SINGH\n", "# A Naive Python recursive implementation\n# of LIS problem\n \n \nimport sys\n \n# To make use of recursive calls, this\n# function must return two things:\n# 1) Length of LIS ending with element arr[n-1].\n#     We use max_ending_here for this purpose\n# 2) Overall maximum as the LIS may end with\n#     an element before arr[n-1] max_ref is\n#     used this purpose.\n# The value of LIS of full array of size n\n# is stored in *max_ref which is our final result\n \n \ndef f(idx, prev_idx, n, a, dp):\n \n    if (idx == n):\n        return 0\n \n    if (dp[idx][prev_idx + 1] != -1):\n        return dp[idx][prev_idx + 1]\n \n    notTake = 0 + f(idx + 1, prev_idx, n, a, dp)\n    take = -sys.maxsize - 1\n    if (prev_idx == -1 or a[idx] > a[prev_idx]):\n        take = 1 + f(idx + 1, idx, n, a, dp)\n \n    dp[idx][prev_idx + 1] = max(take, notTake)\n    return dp[idx][prev_idx + 1]\n \n# Function to find length of longest increasing\n# subsequence.\n \n \ndef longestSubsequence(n, a):\n \n    dp = [[-1 for i in range(n + 1)]for j in range(n + 1)]\n    return f(0, -1, n, a, dp)\n \n \n# Driver program to test above function\nif __name__ == '__main__':\n    a = [3, 10, 2, 1, 20]\n    n = len(a)\n \n    # Function call\n    print('Length of lis is', longestSubsequence(n, a))\n \n# This code is contributed by shinjanpatra\n", "# Dynamic programming Python implementation\n# of LIS problem\n \n \n# lis returns length of the longest\n# increasing subsequence in arr of size n\ndef lis(arr):\n    n = len(arr)\n \n    # Declare the list (array) for LIS and\n    # initialize LIS values for all indexes\n    lis = [1]*n\n \n    # Compute optimized LIS values in bottom up manner\n    for i in range(1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j]+1\n \n    # Initialize maximum to 0 to get\n    # the maximum of all LIS\n    maximum = 0\n \n    # Pick maximum of all LIS values\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n \n    return maximum\n \n \n# Driver program to test above function\nif __name__ == '__main__':\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    print('Length of lis is', lis(arr))\n \n \n# This code is contributed by Nikhil Kumar Singh\n"], "Find minimum number of coins to make a given value (Coin Change) -  ": ["# A Naive recursive python program to find minimum of coins\n# to make a given change V\n \nimport sys\n \n# m is size of coins array (number of different coins)\ndef minCoins(coins, m, V):\n \n    # base case\n    if (V == 0):\n        return 0\n \n    # Initialize result\n    res = sys.maxsize\n     \n    # Try every coin that has smaller value than V\n    for i in range(0, m):\n        if (coins[i] <= V):\n            sub_res = minCoins(coins, m, V-coins[i])\n \n            # Check for INT_MAX to avoid overflow and see if\n            # result can minimized\n            if (sub_res != sys.maxsize and sub_res + 1 < res):\n                res = sub_res + 1\n \n    return res\n \n# Driver program to test above function\ncoins = [9, 6, 5, 1]\nm = len(coins)\nV = 11\nprint('Minimum coins required is',minCoins(coins, m, V))\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "import sys\n \n# Utility function for solving the minimum coins problem\n \n \ndef minCoinsUtil(coins, m, V, dp):\n    # Base case: If target value V is 0, no coins are needed\n    if V == 0:\n        return 0\n \n    # If subproblem is already solved, return the result from DP table\n    if dp[V] != -1:\n        return dp[V]\n \n    res = sys.maxsize\n \n    # Iterate over all coins and recursively solve for subproblems\n    for i in range(m):\n        if coins[i] <= V:\n            # Recursive call to solve for remaining value V - coins[i]\n            sub_res = minCoinsUtil(coins, m, V - coins[i], dp)\n \n            # If the subproblem has a valid solution and the total number of coins\n            # is smaller than the current result, update the result\n            if sub_res != sys.maxsize and sub_res + 1 < res:\n                res = sub_res + 1\n \n    # Save the result in the DP table\n    dp[V] = res\n \n    return res\n \n# Function to find the minimum number of coins needed to make a target value\n \n \ndef minCoins(coins, m, V):\n    # Create a DP table to store results of subproblems\n    dp = [-1] * (V + 1)\n \n    # Call the utility function to solve the problem\n    return minCoinsUtil(coins, m, V, dp)\n \n \n# Driver code\nif __name__ == '__main__':\n    coins = [9, 6, 5, 1]\n    m = len(coins)\n    V = 11\n    res = minCoins(coins, m, V)\n \n    if res == sys.maxsize:\n        res = -1\n \n    # Find the minimum number of coins required\n    print('Minimum coins required is', res)\n", "# A Dynamic Programming based Python3 program to \n# find minimum of coins to make a given change V\nimport sys \n \n# m is size of coins array (number of \n# different coins)\ndef minCoins(coins, m, V):\n     \n    # table[i] will be storing the minimum \n    # number of coins required for i value. \n    # So table[V] will have result\n    table = [0 for i in range(V + 1)]\n \n    # Base case (If given value V is 0)\n    table[0] = 0\n \n    # Initialize all table values as Infinite\n    for i in range(1, V + 1):\n        table[i] = sys.maxsize\n \n    # Compute minimum coins required \n    # for all values from 1 to V\n    for i in range(1, V + 1):\n         \n        # Go through all coins smaller than i\n        for j in range(m):\n            if (coins[j] <= i):\n                sub_res = table[i - coins[j]]\n                if (sub_res != sys.maxsize and\n                    sub_res + 1 < table[i]):\n                    table[i] = sub_res + 1\n     \n    if table[V] == sys.maxsize:\n        return -1\n       \n    return table[V]\n \n# Driver Code\nif __name__ == '__main__':\n \n    coins = [9, 6, 5, 1]\n    m = len(coins)\n    V = 11\n    print('Minimum coins required is ', \n                 minCoins(coins, m, V))\n \n# This code is contributed by ita_c\n"], "Huffman Decoding -  ": ["import heapq\nfrom collections import defaultdict\n \n# to map each character its huffman value\ncodes = {}\n \n# To store the frequency of character of the input data\nfreq = defaultdict(int)\n \n# A Huffman tree node\nclass MinHeapNode:\n    def __init__(self, data, freq):\n        self.left = None\n        self.right = None\n        self.data = data\n        self.freq = freq\n \n    def __lt__(self, other):\n        return self.freq < other.freq\n \n# utility function to print characters along with\n# there huffman value\ndef printCodes(root, str):\n    if root is None:\n        return\n    if root.data != '$':\n        print(root.data, ':', str)\n    printCodes(root.left, str + '0')\n    printCodes(root.right, str + '1')\n \n# utility function to store characters along with\n# there huffman value in a hash table\ndef storeCodes(root, str):\n    if root is None:\n        return\n    if root.data != '$':\n        codes[root.data] = str\n    storeCodes(root.left, str + '0')\n    storeCodes(root.right, str + '1')\n \n# function to build the Huffman tree and store it\n# in minHeap\ndef HuffmanCodes(size):\n    global minHeap\n    for key in freq:\n        minHeap.append(MinHeapNode(key, freq[key]))\n    heapq.heapify(minHeap)\n    while len(minHeap) != 1:\n        left = heapq.heappop(minHeap)\n        right = heapq.heappop(minHeap)\n        top = MinHeapNode('$', left.freq + right.freq)\n        top.left = left\n        top.right = right\n        heapq.heappush(minHeap, top)\n    storeCodes(minHeap[0], '')\n \n# utility function to store map each character with its\n# frequency in input string\ndef calcFreq(str, n):\n    for i in range(n):\n        freq[str[i]] += 1\n \n# function iterates through the encoded string s\n# if s[i]=='1' then move to node->right\n# if s[i]=='0' then move to node->left\n# if leaf node append the node->data to our output string\ndef decode_file(root, s):\n    ans = ''\n    curr = root\n    n = len(s)\n    for i in range(n):\n        if s[i] == '0':\n            curr = curr.left\n        else:\n            curr = curr.right\n \n        # reached leaf node\n        if curr.left is None and curr.right is None:\n            ans += curr.data\n            curr = root\n    return ans + '\\0'\n \n# Driver code\nif __name__ == '__main__':\n    minHeap = []\n    str = ' '\n    encodedString, decodedString = '', ''\n    calcFreq(str, len(str))\n    HuffmanCodes(len(str))\n    print('Character With there Frequencies:')\n    for key in sorted(codes):\n        print(key, codes[key])\n \n    for i in str:\n        encodedString += codes[i]\n \n    print('\\nEncoded Huffman data:')\n    print(encodedString)\n \n    # Function call\n    decodedString = decode_file(minHeap[0], encodedString)\n    print('\\nDecoded Huffman Data:')\n    print(decodedString)\n"], "Minimize the sum of product of two arrays with permutations allowed -  ": ["# Python program to calculate minimum sum of product \n# of two arrays. \n  \n# Returns minimum sum of product of two arrays \n# with permutations allowed \n  \n  \ndef minValue(A, B, n): \n  \n    # Sort A and B so that minimum and maximum \n    # value can easily be fetched. \n    A.sort() \n    B.sort() \n  \n    # Multiplying minimum value of A and maximum \n    # value of B \n    result = 0\n    for i in range(n): \n        result += (A[i] * B[n - i - 1]) \n  \n    return result \n  \n  \n# Driven Program \nA = [3, 1, 1] \nB = [6, 5, 4] \nn = len(A) \nprint (minValue(A, B, n)) \n  \n# Contributed by: Afzal Ansari \n"], "Find the Largest number with given number of digits and sum of digits -  ": ["# Python 3 program to find\n# the largest number that \n# can be formed from given\n# sum of digits and number\n# of digits.\n \n \n# Prints the smallest \n# possible number with digit \n# sum 's' and 'm' number of\n# digits.\ndef findLargest( m, s) :\n \n    # If sum of digits is 0,\n    # then a number is possible\n    # only if number of digits\n    # is 1.\n    if (s == 0) :\n     \n        if(m == 1) :\n            print('Largest number is ' , '0',end = '') \n        else :\n            print('Not possible',end = '')\n     \n        return\n \n    # Sum greater than the \n    # maximum possible sum.\n    if (s > 9 * m) :\n        print('Not possible',end = '')\n        return\n     \n    # Create an array to \n    # store digits of\n    # result\n    res = [0] * m\n \n    # Fill from most significant\n    # digit to least significant\n    # digit.\n    for i in range(0, m) :\n         \n        # Fill 9 first to make\n        # the number largest\n        if (s >= 9) :\n            res[i] = 9\n            s = s - 9\n         \n        # If remaining sum \n        # becomes less than \n        # 9, then fill the \n        # remaining sum\n        else :\n            res[i] = s\n            s = 0\n         \n         \n    print( 'Largest number is ',end = '')\n     \n    for i in range(0, m) :\n        print(res[i],end = '')\n \n# Driver code\ns = 9\nm = 2\nfindLargest(m, s)\n \n# This code is contributed by Nikita Tiwari.\n", "def largest_number(s, d):\n    if s == 0:\n        return 0\n    if s > 9 * d:\n        return -1\n    result = ''\n    for i in range(d):\n        if s >= 9:\n            result += '9'\n            s -= 9\n        else:\n            result += str(s)\n            s = 0\n        if s == 0 and i < d-1:\n            result += '0' * (d-i-1)\n            break\n    return int(result)\n \n# Test case 1\nprint(largest_number(9, 2)) # Output: 90\n \n# Test case 2\nprint(largest_number(20, 3)) # Output: 992\n"], "Page Faults in LRU | Implementation -  ": ["# Python program to illustrate\n# page faults in LRU\n \n# Counts no. of page faults\ndef pageFaults(n, c, pages):\n \n    # Initialise count to 0\n    count = 0\n \n    # To store elements in memory of size c\n    v = []\n \n    # Iterate through all elements of pages\n    for i in range(n):\n \n        # Find if element is present in memory or not\n        if pages[i] not in v:\n \n            # If memory is full\n            if len(v) == c:\n \n                # Remove the first element\n                # As it is least recently used\n                v.pop(0)\n \n            # Add the recent element into memory\n            v.append(pages[i])\n \n            # Increment the count\n            count += 1\n        else:\n \n            # If element is present\n            # Remove the element\n            # And add it at the end as it is\n            # the most recent element\n            v.remove(pages[i])\n            v.append(pages[i])\n \n    # Return total page faults\n    return count\n \n \n# Driver program to test pageFaults function\npages = [1, 2, 1, 4, 2, 3, 5]\nn = 7\nc = 3\n \nprint('Page Faults =', pageFaults(n, c, pages))\n \n# This code is contributed by ishankhandelwals.\n"], "Maximise the number of toys that can be purchased with amount K -  ": ["# Python 3 Program to maximize the\n# number of toys with K amount\n \n# This functions returns the required\n# number of toys\ndef maximum_toys(cost, N, K):\n    count = 0\n    sum = 0\n \n    # sort the cost array\n    cost.sort(reverse = False)\n    for i in range(0, N, 1):\n         \n        # Check if we can buy ith toy or not\n        if (sum+cost[i] <= K):\n            sum = sum + cost[i]\n            # Increment the count variable\n            count += 1\n     \n    return count\n \n# Driver Code\nif __name__ == '__main__':\n    K = 50\n    cost = [1, 12, 5, 111, 200, \n            1000, 10, 9, 12, 15]\n    N = len(cost)\n \n    print(maximum_toys(cost, N, K))\n \n# This code is contributed by\n# Sanjit_Prasad\n"], "Remove Minimum coins such that absolute difference between any two piles is less than K -  ": ["# Python implementation of the approach\n \n# Function to return the minimum number\n# of coins that need to be removed\ndef minimumCoins(a, n, k):\n    # To store the coins needed to be removed\n    cnt = 0;\n \n    # Minimum value from the array\n    minVal = min(a);\n \n    # Iterate over the array and remove extra coins\n    for i in range(n):\n        diff = a[i] - minVal;\n \n        # If the difference between the current pile and\n        # the minimum coin pile is greater than k\n        if (diff > k):\n            # Count the extra coins to be removed\n            cnt += (diff - k);\n    # Return the required count\n    return cnt;\n \n# Driver code\na = [1, 5, 1, 2, 5, 1];\nn = len(a);\nk = 3;\nprint(minimumCoins(a, n, k));\n \n     \n# This code is contributed by 29AjayKumar\n"], "Find maximum meetings in one room -  ": ["# Python3 program to find maximum number\n# of meetings\n \n# Custom class for storing starting time,\n# finishing time and position of meeting.\n \n \nclass meeting:\n \n    def __init__(self, start, end, pos):\n \n        self.start = start\n        self.end = end\n        self.pos = pos\n \n# Function for finding maximum\n# meeting in one room\n \n \ndef maxMeeting(l, N):\n \n    # Initialising an arraylist\n    # for storing answer\n    ans = []\n \n    # Sorting of meeting according to\n    # their finish time.\n    l.sort(key=lambda x: x.end)\n \n    # Initially select first meeting\n    ans.append(l[0].pos)\n \n    # time_limit to check whether new\n    # meeting can be conducted or not.\n    time_limit = l[0].end\n \n    # Check for all meeting whether it\n    # can be selected or not.\n    for i in range(1, N):\n        if l[i].start > time_limit:\n            ans.append(l[i].pos)\n            time_limit = l[i].end\n \n    # Print final selected meetings\n    for i in ans:\n        print(i + 1, end=' ')\n \n    print()\n \n \n# Driver's code\nif __name__ == '__main__':\n \n    # Starting time\n    s = [1, 3, 0, 5, 8, 5]\n \n    # Finish time\n    f = [2, 4, 6, 7, 9, 9]\n \n    # Number of meetings.\n    N = len(s)\n \n    l = []\n \n    for i in range(N):\n \n        # Creating object of meeting\n        # and adding in the list\n        l.append(meeting(s[i], f[i], i))\n \n    # Function call\n    maxMeeting(l, N)\n \n# This code is contributed by MuskanKalra1\n"], "Sorted Array to Balanced BST -  ": ["from typing import List\nfrom queue import Queue\n \n# structure of the tree node\n \n \nclass Node:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n \n# function to convert the array to BST\n# and return the root of the created tree\n \n \ndef sortedArrayToBST(nums: List[int]) -> Node:\n    # if the array is empty return None\n    if not nums:\n        return None\n \n    n = len(nums)\n    mid = n // 2\n    root = Node(nums[mid])\n    # initializing queue\n    q = Queue()\n    # push the root and its indices to the queue\n    q.put((root, (0, mid-1)))\n    q.put((root, (mid+1, n-1)))\n \n    while not q.empty():\n        # get the front element from the queue\n        curr = q.get()\n \n        # get the parent node and its indices\n        parent = curr[0]\n        left = curr[1][0]\n        right = curr[1][1]\n \n        # if there are elements to process and parent node is not None\n        if left <= right and parent is not None:\n            mid = (left + right) // 2\n            child = Node(nums[mid])\n \n            # set the child node as left or right child of the parent node\n            if nums[mid] < parent.val:\n                parent.left = child\n            else:\n                parent.right = child\n \n            # push the left and right child and their indices to the queue\n            q.put((child, (left, mid-1)))\n            q.put((child, (mid+1, right)))\n \n    return root\n \n# function to print the preorder traversal\n# of the constructed BST\n \n \ndef printBST(root: Node) -> None:\n    if root is None:\n        return\n \n    print(root.val, end=' ')\n    printBST(root.left)\n    printBST(root.right)\n \n \n# Driver program to test the above function\nif __name__ == '__main__':\n    # create a sorted array\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    root = sortedArrayToBST(nums)\n    printBST(root)\n"], "Merge Two Balanced Binary Search Trees -  ": ["# A binary tree node has data, pointer to left child  \n# and a pointer to right child\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n \n# A utility function to merge two sorted arrays into one\n# Time Complexity of below function: O(m + n)\n# Space Complexity of below function: O(m + n)\ndef merge_sorted_arr(arr1, arr2):\n    arr = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            arr.append(arr1[i])\n            i += 1\n        else:\n            arr.append(arr2[j])\n            j += 1\n    while i < len(arr1):\n        arr.append(arr1[i])\n        i += 1\n    while i < len(arr2):\n        arr.append(arr2[j])\n        j += 1\n    return arr\n \n# A helper function that stores inorder\n# traversal of a tree in arr\ndef inorder(root, arr = []):\n    if root:\n        inorder(root.left, arr)\n        arr.append(root.val)\n        inorder(root.right, arr)\n \n# A utility function to insert the values\n# in the individual Tree\ndef insert(root, val):\n    if not root:\n        return Node(val)\n    if root.val == val:\n        return root\n    elif root.val > val:\n        root.left = insert(root.left, val)\n    else:\n        root.right = insert(root.right, val)\n    return root\n \n# Converts the merged array to a balanced BST\n# Explanation of the below code:\n# https://www. .org/sorted-array-to-balanced-bst/\ndef arr_to_bst(arr):\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = Node(arr[mid])\n    root.left = arr_to_bst(arr[:mid])\n    root.right = arr_to_bst(arr[mid + 1:])\n    return root\n \nif __name__=='__main__':\n    root1 = root2 = None\n     \n    # Inserting values in first tree\n    root1 = insert(root1, 100)\n    root1 = insert(root1, 50)\n    root1 = insert(root1, 300)\n    root1 = insert(root1, 20)\n    root1 = insert(root1, 70)\n     \n    # Inserting values in second tree\n    root2 = insert(root2, 80)\n    root2 = insert(root2, 40)\n    root2 = insert(root2, 120)\n    arr1 = []\n    inorder(root1, arr1)\n    arr2 = []\n    inorder(root2, arr2)\n    arr = merge_sorted_arr(arr1, arr2)\n    root = arr_to_bst(arr)\n    res = []\n    inorder(root, res)\n    print('Following is Inorder traversal of the merged tree')\n    for i in res:\n      print(i, end = ' ')\n       \n# This code is contributed by Flarow4\n"], "Largest BST in a Binary Tree | Set 2 -  ": ["# Python program to find largest \n# BST in a Binary Tree.\n \nINT_MIN = -2147483648\nINT_MAX = 2147483647\n \n# Helper function that allocates a new \n# node with the given data and None left \n# and right pointers. \nclass newNode: \n \n    # Constructor to create a new node \n    def __init__(self, data): \n        self.data = data \n        self.left = None\n        self.right = None\n \n# Returns Information about subtree. The \n# Information also includes size of largest \n# subtree which is a BST\ndef largestBSTBT(root):\n     \n# Base cases : When tree is empty or it has \n    # one child. \n    if (root == None):\n        return 0, INT_MIN, INT_MAX, 0, True\n    if (root.left == None and root.right == None) :\n        return 1, root.data, root.data, 1, True\n \n    # Recur for left subtree and right subtrees \n    l = largestBSTBT(root.left) \n    r = largestBSTBT(root.right) \n \n    # Create a return variable and initialize its \n    # size. \n    ret = [0, 0, 0, 0, 0] \n    ret[0] = (1 + l[0] + r[0]) \n \n    # If whole tree rooted under current root is \n    # BST. \n    if (l[4] and r[4] and l[1] < \n        root.data and r[2] > root.data) :\n     \n        ret[2] = min(l[2], root.data) \n        ret[1] = max(r[1], root.data) \n \n        # Update answer for tree rooted under \n        # current 'root' \n        ret[3] = max(l[3], r[3]) + 1;\n        ret[4] = True\n \n        return ret \n     \n \n    # If whole tree is not BST, return maximum \n    # of left and right subtrees \n    ret[3] = max(l[3], r[3]) \n    ret[4] = False\n \n    return ret\n \n# Driver Code \nif __name__ == '__main__': \n     \n    '''Let us construct the following Tree\n        60 \n        / \\ \n        65 70 \n    / \n    50 '''\n    root = newNode(60) \n    root.left = newNode(65) \n    root.right = newNode(70) \n    root.left.left = newNode(50)\n    print('Size of the largest BST is',\n                    largestBSTBT(root)[3]) \n                             \n# This code is contributed\n# Shubham Singh(SHUBHAMSINGH10)\n# Naman Sharma (NAMANSHARMA1805)\n"], "K'th Largest Element in BST when modification to BST is not allowed -  ": ["# Python3 program to find k'th largest \n# element in BST \n \nclass Node: \n \n    # Constructor to create a new node \n    def __init__(self, data): \n        self.key = data \n        self.left = None\n        self.right = None\n         \n# A function to find k'th largest \n# element in a given tree. \ndef kthLargestUtil(root, k, c):\n     \n    # Base cases, the second condition \n    # is important to avoid unnecessary\n    # recursive calls \n    if root == None or c[0] >= k: \n        return\n \n    # Follow reverse inorder traversal \n    # so that the largest element is \n    # visited first \n    kthLargestUtil(root.right, k, c)\n \n    # Increment count of visited nodes \n    c[0] += 1\n \n    # If c becomes k now, then this is \n    # the k'th largest \n    if c[0] == k:\n        print('K'th largest element is', \n                               root.key) \n        return\n \n    # Recur for left subtree \n    kthLargestUtil(root.left, k, c)\n \n# Function to find k'th largest element \ndef kthLargest(root, k):\n     \n    # Initialize count of nodes\n    # visited as 0 \n    c = [0]\n \n    # Note that c is passed by reference \n    kthLargestUtil(root, k, c)\n \n# A utility function to insert a new \n# node with given key in BST */\ndef insert(node, key): \n     \n    # If the tree is empty, \n    # return a new node \n    if node == None:\n        return Node(key) \n \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key:\n        node.right = insert(node.right, key) \n \n    # return the (unchanged) node pointer \n    return node\n \n# Driver Code\nif __name__ == '__main__':\n     \n    # Let us create following BST \n    #         50 \n    #     /     \\ \n    #     30     70 \n    # / \\ / \\ \n    # 20 40 60 80 */\n    root = None\n    root = insert(root, 50)\n    insert(root, 30)\n    insert(root, 20)\n    insert(root, 40)\n    insert(root, 70)\n    insert(root, 60)\n    insert(root, 80)\n \n    for k in range(1,8):\n        kthLargest(root, k)\n         \n# This code is contributed by PranchalK\n", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n \ndef kthLargest(root: TreeNode, k: int) -> int:\n    st = []\n    curr = root\n    count = 0\n    while curr or st:\n        while curr:\n            st.append(curr)\n            curr = curr.right\n        curr = st.pop()\n        count += 1\n        if count == k:\n            return curr.val\n        curr = curr.left\n    return -1\n \n# create a BST\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(8)\n \n# find the kth largest element\nk = 3\nkth_largest = kthLargest(root, k)\nif kth_largest != -1:\n    print(f'The {k}th largest element is: {kth_largest}')\nelse:\n    print(f'The {k}th largest element does not exist')\n", "import heapq\n \n# Definition of a binary tree node\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n \n# Function to implement maxHeap approach\ndef kthLargest(root, K):\n    maxHeap = []\n    # Traverse the binary search tree and add elements to\n    # the max heap\n    stack = []\n    curr = root\n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.right\n        curr = stack.pop()\n        heapq.heappush(maxHeap, -curr.data)\n        curr = curr.left\n    # Remove K-1 elements from the max heap\n    for i in range(K - 1):\n        heapq.heappop(maxHeap)\n    # The top element of the max heap is the Kth largest\n    # element\n    return -maxHeap[0]\n \n# Driver Code\nif __name__ == '__main__':\n    # Example binary search tree\n    '''\n              4\n            /   \\\n           2     9\n                / \\\n               7  10\n    '''\n    root = Node(4)\n    root.left = Node(2)\n    root.right = Node(9)\n    root.right.left = Node(7)\n    root.right.right = Node(10)\n \n    K = 2\n    kthLargestElement = kthLargest(root, K)\n \n    print(f'The {K}th largest element in the binary search tree is: {kthLargestElement}')\n"], "Floor and Ceil from a BST -  ": ["# Python program to find Floor of a given value in BST\n \n# A Binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.key = data\n        self.left = None\n        self.right = None\n \n# Function to find Floor of a given input in BST. If input\n# is more than the max key in BST, return -1\n \n \ndef Floor(root, inp):\n \n    # Base Case\n    if root == None:\n        return -1\n \n    # We found equal key\n    if root.key == inp:\n        return root.key\n \n    # If root's key is larger, Floor must be in left subtree\n    if root.key > inp:\n        return Floor(root.left, inp)\n \n    # Else, either right subtree or root has the Floor value\n    else:\n        floor = Floor(root.right, inp)\n        # exception for -1 because it is being returned in base case\n        return floor if floor <= inp and floor != -1 else root.key\n \n \n# Driver code\nif __name__ == '__main__':\n    root = Node(8)\n \n    root.left = Node(4)\n    root.right = Node(12)\n \n    root.left.left = Node(2)\n    root.left.right = Node(6)\n \n    root.right.left = Node(10)\n    root.right.right = Node(14)\n \n    for i in range(16):\n        print(i, Floor(root, i))\n \n# This code is contributed by Shubham Singh\n", "# Python3 program to find floor and\n# ceil of a given key in BST\n \n# A binary tree node has key,\n# . left child and right child\n \n \nclass Node:\n \n    def __init__(self, x):\n \n        self.data = x\n        self.left = None\n        self.right = None\n \n# Helper function to find floor and\n# ceil of a given key in BST\n \n \ndef floorCeilBSTHelper(root, key):\n \n    global floor, ceil\n \n    while (root):\n        if (root.data == key):\n            ceil = root.data\n            floor = root.data\n            return\n        if (key > root.data):\n            floor = root.data\n            root = root.right\n        else:\n            ceil = root.data\n            root = root.left\n \n# Display the floor and ceil of a given\n# key in BST. If key is less than the min\n# key in BST, floor will be -1; If key is\n# more than the max key in BST, ceil will be -1;\n \n \ndef floorCeilBST(root, key):\n \n    global floor, ceil\n \n    # Variables 'floor' and 'ceil'\n    # are passed by reference\n    floor = -1\n    ceil = -1\n \n    floorCeilBSTHelper(root, key)\n \n    print(key, floor, ceil)\n \n \n# Driver code\nif __name__ == '__main__':\n \n    floor, ceil = -1, -1\n \n    root = Node(8)\n    root.left = Node(4)\n    root.right = Node(12)\n    root.left.left = Node(2)\n    root.left.right = Node(6)\n    root.right.left = Node(10)\n    root.right.right = Node(14)\n \n    for i in range(16):\n        floorCeilBST(root, i)\n \n# This code is contributed by mohit kumar 29\n"], "Lowest Common Ancestor in a Binary Search Tree. -  ": ["# A recursive python program to find LCA of two nodes\n# n1 and n2\n \n# A Binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Function to find LCA of n1 and n2. The function assumes\n# that both n1 and n2 are present in BST\n \n \ndef lca(root, n1, n2):\n \n    # Base Case\n    if root is None:\n        return None\n \n    # If both n1 and n2 are smaller than root, then LCA\n    # lies in left\n    if(root.data > n1 and root.data > n2):\n        return lca(root.left, n1, n2)\n \n    # If both n1 and n2 are greater than root, then LCA\n    # lies in right\n    if(root.data < n1 and root.data < n2):\n        return lca(root.right, n1, n2)\n \n    return root\n \n# Driver program to test above function\n \n \n# Driver code\nroot = Node(20)\nroot.left = Node(8)\nroot.right = Node(22)\nroot.left.left = Node(4)\nroot.left.right = Node(12)\nroot.left.right.left = Node(10)\nroot.left.right.right = Node(14)\n \n \n# Function calls\nn1 = 10\nn2 = 14\nt = lca(root, n1, n2)\nprint('LCA of %d and %d is %d' % (n1, n2, t.data))\n \nn1 = 14\nn2 = 8\nt = lca(root, n1, n2)\nprint('LCA of %d and %d is %d' % (n1, n2, t.data))\n \nn1 = 10\nn2 = 22\nt = lca(root, n1, n2)\nprint('LCA of %d and %d is %d' % (n1, n2, t.data))\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "# A recursive python program to find LCA of two nodes\n# n1 and n2\n \n# A Binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Function to find LCA of n1 and n2.\n# The function assumes that both\n#   n1 and n2 are present in BST\n \n \ndef lca(root, n1, n2):\n    while root:\n        # If both n1 and n2 are smaller than root,\n        # then LCA lies in left\n        if root.data > n1 and root.data > n2:\n            root = root.left\n \n        # If both n1 and n2 are greater than root,\n        # then LCA lies in right\n        elif root.data < n1 and root.data < n2:\n            root = root.right\n \n        else:\n            break\n \n    return root\n \n \n# Driver code\nif __name__ == '__main__':\n  root = Node(20)\n  root.left = Node(8)\n  root.right = Node(22)\n  root.left.left = Node(4)\n  root.left.right = Node(12)\n  root.left.right.left = Node(10)\n  root.left.right.right = Node(14)\n \n  # Function calls\n  n1 = 10\n  n2 = 14\n  t = lca(root, n1, n2)\n  print('LCA of %d and %d is %d' % (n1, n2, t.data))\n \n  n1 = 14\n  n2 = 8\n  t = lca(root, n1, n2)\n  print('LCA of %d and %d is %d' % (n1, n2, t.data))\n \n  n1 = 10\n  n2 = 22\n  t = lca(root, n1, n2)\n  print('LCA of %d and %d is %d' % (n1, n2, t.data))\n# This Code is Contributed by Sumit Bhardwaj (Timus)\n", "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n \n# Function to find the lowest common ancestor (LCA)\n# of two nodes in a binary tree.\ndef lowestCommonAncestor(root, p, q):\n    curr = root\n    while curr:\n        # If there is no left child, \n        # traverse to the right child.\n        if curr.left is None:\n            # Check if the current node is one of the target nodes.\n            if curr == p or curr == q:\n                return curr\n            curr = curr.right\n        else:\n            # If there is a left child, find the in-order predecessor.\n            pre = curr.left\n            while pre.right and pre.right != curr:\n                pre = pre.right\n            if pre.right is None:\n                # Set the right child of the \n                # in-order predecessor to the current node.\n                pre.right = curr\n                curr = curr.left\n            else:\n                # Remove the link from the in-order\n                # predecessor to the current node.\n                pre.right = None\n                # Check if the current node\n                # is one of the target nodes.\n                if curr == p or curr == q:\n                    return curr\n                curr = curr.right\n    return None\n \n# Driver Code\nif __name__ == '__main__':\n    '''\n    Input Tree:\n              5\n           /    \\\n         4       6\n          \\       \\\n           3       7\n                    \\\n                     8\n    '''\n    root = TreeNode(5)\n    root.left = TreeNode(4)\n    root.left.right = TreeNode(3)\n    root.right = TreeNode(6)\n    root.right.right = TreeNode(7)\n    root.right.right.right = TreeNode(8)\n \n    p = root.left\n    q = root.left.right\n \n    lca1 = lowestCommonAncestor(root, p, q)\n    print(f'LCA of {p.val} and {q.val} is {lca1.val}')\n \n    x = root.right.right\n    y = root.right.right.right\n \n    lca2 = lowestCommonAncestor(root, x, y)\n    print(f'LCA of {x.val} and {y.val} is {lca2.val}')\n"], "A program to check if a Binary Tree is BST or not -  ": ["# Python program to check if a binary tree is bst or not\n# A binary tree node has data, pointer to left child\n# and a pointer to right child\nclass Node:\n \n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \ndef maxValue(node):\n    if node is None:\n        return 0;\n     \n    leftMax = maxValue(node.left)\n    rightMax = maxValue(node.right)\n     \n    value = 0;\n    if leftMax > rightMax:\n        value = leftMax\n    else:\n        value = rightMax\n     \n    if value < node.data:\n        value = node.data\n     \n    return value\n     \ndef minValue(node):\n    if node is None:\n        return 1000000000\n     \n    leftMax = minValue(node.left)\n    rightMax = minValue(node.right)\n     \n    value = 0\n    if leftMax < rightMax:\n        value = leftMax\n    else:\n        value = rightMax\n     \n    if value > node.data:\n        value = node.data\n     \n    return value\n \n# Returns true if a binary tree is a binary search tree\ndef isBST(node):\n    if node is None:\n        return True\n     \n    # false if the max of the left is > than us\n    if(node.left is not None and maxValue(node.left) > node.data):\n        return False\n     \n    # false if the min of the right is <= than us\n    if(node.right is not None and minValue(node.right) < node.data):\n        return False\n     \n    #false if, recursively, the left or right is not a BST\n    if(isBST(node.left) is False or isBST(node.right) is False):\n        return False\n     \n    # passing all that, it's a BST\n    return True\n \n# Driver code\nif __name__ == '__main__':\n  root = Node(4)\n  root.left = Node(2)\n  root.right = Node(5)\n  # root.right.left = Node(7)\n  root.left.left = Node(1)\n  root.left.right = Node(3)\n \n  # Function call\n  if isBST(root) is True:\n      print('Is BST')\n  else:\n      print('Not a BST')\n \n# This code is contributed by Yash Agarwal(yashagarwal2852002)\n", "# Python program to check if a binary tree is bst or not\n \nINT_MAX = 4294967296\nINT_MIN = -4294967296\n \n# A binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n \n# Returns true if the given tree is a binary search tree\n# (efficient version)\ndef isBST(node):\n    return (isBSTUtil(node, INT_MIN, INT_MAX))\n \n# Returns true if the given tree is a BST and its values\n# >= min and <= max\n \n \ndef isBSTUtil(node, mini, maxi):\n \n    # An empty tree is BST\n    if node is None:\n        return True\n \n    # False if this node violates min/max constraint\n    if node.data < mini or node.data > maxi:\n        return False\n \n    # Otherwise check the subtrees recursively\n    # tightening the min or max constraint\n    return (isBSTUtil(node.left, mini, node.data - 1) and\n            isBSTUtil(node.right, node.data+1, maxi))\n \n \n# Driver code\nif __name__ == '__main__':\n  root = Node(4)\n  root.left = Node(2)\n  root.right = Node(5)\n  root.left.left = Node(1)\n  root.left.right = Node(3)\n \n  # Function call\n  if (isBST(root)):\n      print('Is BST')\n  else:\n      print('Not a BST')\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "# Python3 program to check\n# if a given tree is BST.\nimport math\n \n# A binary tree node has data,\n# pointer to left child and\n# a pointer to right child\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n \ndef isBSTUtil(root, prev):\n \n    # traverse the tree in inorder fashion\n    # and keep track of prev node\n    if (root != None):\n        if (isBSTUtil(root.left, prev) == False):\n            return False\n \n        # Allows only distinct valued nodes\n        if (prev != None and\n                root.data <= prev.data):\n            return False\n \n        prev = root\n        return isBSTUtil(root.right, prev)\n \n    return True\n \n \ndef isBST(root):\n    prev = None\n    return isBSTUtil(root, prev)\n \n \n# Driver Code\nif __name__ == '__main__':\n    root = Node(3)\n    root.left = Node(2)\n    root.right = Node(5)\n    root.right.left = Node(1)\n    root.right.right = Node(4)\n \n    # Function call\n    if (isBST(root) == None):\n        print('Is BST')\n    else:\n        print('Not a BST')\n \n# This code is contributed by Srathore\n", "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n \ndef isValidBST(root):\n    curr = root\n    prev = None\n     \n    while curr != None:\n        if curr.left == None: # case 1: no left child\n            # process the current node\n            if prev != None and prev.val >= curr.val:\n                return False\n            prev = curr\n            curr = curr.right\n        else: # case 2: has a left child\n            # find the inorder predecessor\n            pred = curr.left\n            while pred.right != None and pred.right != curr:\n                pred = pred.right\n             \n            if pred.right == None: # make threaded link\n                pred.right = curr\n                curr = curr.left\n            else: # remove threaded link\n                pred.right = None\n                # process the current node\n                if prev != None and prev.val >= curr.val:\n                    return False\n                prev = curr\n                curr = curr.right\n     \n    return True # binary tree is a valid BST\n \n# Driver Code\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(5)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n \n# check if the binary tree is a valid BST\nif isValidBST(root):\n    print('The binary tree is a valid BST.')\nelse:\n    print('The binary tree is not a valid BST.')\n"], "Serialize and Deserialize a Binary Tree -  ": ["class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n \nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n \n    # Encodes a tree to a single string.\n    def serialize(self, root):\n        if not root:\n            return None\n \n        stack = [root]\n        l = []\n \n        while stack:\n            t = stack.pop()\n \n            # If current node is NULL, store marker\n            if not t:\n                l.append('#')\n            else:\n                # Else, store current node\n                # and recur for its children\n                l.append(str(t.val))\n                stack.append(t.right)\n                stack.append(t.left)\n \n        return ','.join(l)\n \n    # Decodes your encoded data to tree.\n    def deserialize(self, data):\n        if not data:\n            return None\n \n        global t\n        t = 0\n        arr = data.split(',')\n        return self.helper(arr)\n \n    def helper(self, arr):\n        global t\n        if arr[t] == '#':\n            return None\n \n        # Create node with this item\n        # and recur for children\n        root = TreeNode(int(arr[t]))\n        t += 1\n        root.left = self.helper(arr)\n        t += 1\n        root.right = self.helper(arr)\n        return root\n \n    # A simple inorder traversal used\n    # for testing the constructed tree\n    def inorder(self, root):\n        if root:\n            self.inorder(root.left)\n            print(root.val, end=' ')\n            self.inorder(root.right)\n \n# Driver code\nif __name__ == '__main__':\n    # Construct a tree shown in the above figure\n    tree = BinaryTree()\n    tree.root = TreeNode(20)\n    tree.root.left = TreeNode(8)\n    tree.root.right = TreeNode(22)\n    tree.root.left.left = TreeNode(4)\n    tree.root.left.right = TreeNode(12)\n    tree.root.left.right.left = TreeNode(10)\n    tree.root.left.right.right = TreeNode(14)\n \n    serialized = tree.serialize(tree.root)\n    print('Serialized view of the tree:')\n    print(serialized)\n    print()\n \n    # Deserialize the stored tree into root1\n    t = tree.deserialize(serialized)\n \n    print('Inorder Traversal of the tree constructed from serialized String:')\n    tree.inorder(t)\n"], "Convert Binary Tree to Doubly Linked List using inorder traversal -  ": ["# Python program to convert  \n# binary tree to doubly linked list \n  \nclass Node(object): \n      \n    '''Binary tree Node class has  \n    data, left and right child'''\n    def __init__(self, item): \n        self.data = item \n        self.left = None\n        self.right = None\n  \ndef BTToDLLUtil(root): \n      \n    '''This is a utility function to  \n    convert the binary tree to doubly  \n    linked list. Most of the core task \n    is done by this function.'''\n    if root is None: \n        return root \n  \n    # Convert left subtree  \n    # and link to root \n    if root.left: \n          \n        # Convert the left subtree \n        left = BTToDLLUtil(root.left) \n  \n        # Find inorder predecessor, After  \n        # this loop, left will point to the  \n        # inorder predecessor of root \n        while left.right: \n            left = left.right \n  \n        # Make root as next of predecessor \n        left.right = root \n          \n        # Make predecessor as  \n        # previous of root \n        root.left = left \n  \n    # Convert the right subtree \n    # and link to root \n    if root.right: \n          \n        # Convert the right subtree \n        right = BTToDLLUtil(root.right) \n  \n        # Find inorder successor, After  \n        # this loop, right will point to  \n        # the inorder successor of root \n        while right.left: \n            right = right.left \n  \n        # Make root as previous  \n        # of successor \n        right.left = root \n          \n        # Make successor as  \n        # next of root \n        root.right = right \n  \n    return root \n  \ndef BTToDLL(root): \n    if root is None: \n        return root \n  \n    # Convert to doubly linked  \n    # list using BLLToDLLUtil \n    root = BTToDLLUtil(root) \n      \n    # We need pointer to left most  \n    # node which is head of the  \n    # constructed Doubly Linked list \n    while root.left: \n        root = root.left \n  \n    return root \n  \ndef print_list(head): \n      \n    '''Function to print the given \n       doubly linked list'''\n    if head is None: \n        return\n    while head: \n        print(head.data, end = ' ') \n        head = head.right \n  \n# Driver Code \nif __name__ == '__main__': \n    root = Node(10) \n    root.left = Node(12) \n    root.right = Node(15) \n    root.left.left = Node(25) \n    root.left.right = Node(30) \n    root.right.left = Node(36) \n  \n    head = BTToDLL(root) \n    print_list(head) \n  \n# This code is contributed  \n# by viveksyngh \n", "# A Python3 program for in-place \n# conversion of Binary Tree to DLL \n  \n# A binary tree node has data, \n# and left and right pointers  \nclass newNode(object): \n    def __init__(self,data): \n        self.data = data \n        self.left = None\n        self.right = None\n  \nhead = None\ntail = None\n# This is the core function to convert Tree to list. \ndef bintree2listUtil(root): \n  \n    if (root == None): \n        return\n  \n    left = root.left \n    right = root.right \n  \n    global head \n    global tail \n      \n    bintree2listUtil(root.left) \n  \n    if (head == None): \n        head = root \n      \n    root.left = tail \n  \n    if (tail != None): \n        tail.right = root \n          \n    tail = root \n      \n    bintree2listUtil(root.right) \n  \n# The main function that first calls \n# bintree2listUtil() \ndef bintree2list(root): \n    # Base case \n    global head \n    if (root == None): \n        head = root \n  \n    bintree2listUtil(root) \n  \n# Function to print nodes in a given doubly linked list  \ndef printList():  \n    global head \n    while head: \n        print(head.data, end = ' ') \n        head = head.right \n  \n# Driver Code \nif __name__ == '__main__': \n    root = newNode(10) \n    root.left = newNode(12) \n    root.right = newNode(15) \n    root.left.left = newNode(25) \n    root.left.right = newNode(30) \n    root.right.left = newNode(36) \n  \n    bintree2list(root) \n    printList() \n  \n# This code is contributed by Abhijeet Kumar(abhijeet19403) \n"], "Level order traversal in spiral form -  ": ["# Python3 program for recursive level order\n# traversal in spiral form\n \n \nclass newNode:\n \n    # Construct to create a newNode\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n \n \n''' Function to print spiral traversal of a tree'''\n \n \ndef printSpiral(root):\n \n    h = height(root)\n \n    '''ltr Left to Right. If this variable \n    is set, then the given level is traversed\n    from left to right. '''\n    ltr = False\n    for i in range(1, h + 1):\n \n        printGivenLevel(root, i, ltr)\n \n        '''Revert ltr to traverse next level\n           in opposite order'''\n        ltr = not ltr\n \n \n''' Print nodes at a given level '''\n \n \ndef printGivenLevel(root, level, ltr):\n \n    if(root == None):\n        return\n    if(level == 1):\n        print(root.data, end=' ')\n    elif (level > 1):\n \n        if(ltr):\n            printGivenLevel(root.left, level - 1, ltr)\n            printGivenLevel(root.right, level - 1, ltr)\n \n        else:\n            printGivenLevel(root.right, level - 1, ltr)\n            printGivenLevel(root.left, level - 1, ltr)\n \n \n''' Compute the 'height' of a tree -- the number of \n    nodes along the longest path from the root node \n    down to the farthest leaf node.'''\n \n \ndef height(node):\n \n    if (node == None):\n        return 0\n    else:\n \n        ''' compute the height of each subtree '''\n        lheight = height(node.left)\n        rheight = height(node.right)\n \n        ''' use the larger one '''\n        if (lheight > rheight):\n            return(lheight + 1)\n        else:\n            return(rheight + 1)\n \n \n# Driver Code\nif __name__ == '__main__':\n    root = newNode(1)\n    root.left = newNode(2)\n    root.right = newNode(3)\n    root.left.left = newNode(7)\n    root.left.right = newNode(6)\n    root.right.left = newNode(5)\n    root.right.right = newNode(4)\n    print('Spiral Order traversal of binary tree is')\n    printSpiral(root)\n \n# This code is contributed\n# by SHUBHAMSINGH10\n", "# Python3 implementation of a O(n) time\n# method for spiral order traversal\n \n# A class to create a new node\n \n \nclass newNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n \ndef printSpiral(root):\n    if (root == None):\n        return  # None check\n \n    # Create two stacks to store\n    # alternate levels\n    s1 = []  # For levels to be printed\n    # from right to left\n    s2 = []  # For levels to be printed\n    # from left to right\n \n    # append first level to first stack 's1'\n    s1.append(root)\n \n    # Keep printing while any of the\n    # stacks has some nodes\n    while not len(s1) == 0 or not len(s2) == 0:\n \n        # Print nodes of current level from s1\n        # and append nodes of next level to s2\n        while not len(s1) == 0:\n            temp = s1[-1]\n            s1.pop()\n            print(temp.data, end=' ')\n \n            # Note that is right is appended\n            # before left\n            if (temp.right):\n                s2.append(temp.right)\n            if (temp.left):\n                s2.append(temp.left)\n \n        # Print nodes of current level from s2\n        # and append nodes of next level to s1\n        while (not len(s2) == 0):\n            temp = s2[-1]\n            s2.pop()\n            print(temp.data, end=' ')\n \n            # Note that is left is appended\n            # before right\n            if (temp.left):\n                s1.append(temp.left)\n            if (temp.right):\n                s1.append(temp.right)\n \n \n# Driver Code\nif __name__ == '__main__':\n    root = newNode(1)\n    root.left = newNode(2)\n    root.right = newNode(3)\n    root.left.left = newNode(7)\n    root.left.right = newNode(6)\n    root.right.left = newNode(5)\n    root.right.right = newNode(4)\n    print('Spiral Order traversal of',\n          'binary tree is ')\n    printSpiral(root)\n \n# This code is contributed by PranchalK\n", "# Python3 implementation of above approach\n \n# A class to create a new node\nfrom collections import deque\n \n \nclass newNode:\n    def __init__(self, data):\n        self.key = data\n        self.left = None\n        self.right = None\n \n \ndef spiralPrint(root):\n    # Declare a deque\n    dq = deque()\n \n    # Insert the root of the tree into the deque\n    dq.append(root)\n \n    # Create a  variable that will switch in each iteration\n    reverse = True\n \n    # Start iteration\n    while (len(dq)):\n \n        # Save the size of the deque here itself, as in further steps the size\n        # of deque will frequently change\n        n = len(dq)\n \n        # If we are printing left to right\n        if(not reverse):\n \n            # Iterate from left to right\n            while (n > 0):\n                n -= 1\n \n                # Insert the child from the back of the deque\n                # Left child first\n                if (dq[0].left != None):\n                    dq.append(dq[0].left)\n \n                if (dq[0].right != None):\n                    dq.append(dq[0].right)\n \n                # Print the current processed element\n                print(dq[0].key, end='  ')\n                dq.popleft()\n \n            # Switch reverse for next traversal\n            reverse = not reverse\n        else:\n \n            # If we are printing right to left\n            # Iterate the deque in reverse order and insert the children\n            # from the front\n            while (n > 0):\n                n -= 1\n                # Insert the child in the front of the deque\n                # Right child first\n                if (dq[-1].right != None):\n                    dq.appendleft(dq[-1].right)\n \n                if (dq[-1].left != None):\n                    dq.appendleft(dq[-1].left)\n \n                # Print the current processed element\n                print(dq[-1].key, end='  ')\n                dq.pop()\n \n            # Switch reverse for next traversal\n            reverse = not reverse\n \n \n# Driver Code\nif __name__ == '__main__':\n    root = newNode(1)\n    root.left = newNode(2)\n    root.right = newNode(3)\n    root.left.left = newNode(7)\n    root.left.right = newNode(6)\n    root.right.left = newNode(5)\n    root.right.right = newNode(4)\n    print('Spiral Order traversal of',\n          'binary tree is :')\n    spiralPrint(root)\n \n# This code is contributed by Abhijeet Kumar(abhijeet19403)\n"], "Diameter of a Binary Tree -  ": ["# Python3 program to find the diameter of binary tree\n \n# A binary tree node\n \n \nclass Node:\n \n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n \n# The function Compute the 'height' of a tree. Height is the\n# number of nodes along the longest path from the root node\n# down to the farthest leaf node.\n \ndef height(node):\n \n    # Base Case : Tree is empty\n    if node is None:\n        return 0\n \n    # If tree is not empty then height = 1 + max of left\n    # height and right heights\n    return 1 + max(height(node.left), height(node.right))\n \n# Function to get the diameter of a binary tree\n \n \ndef diameter(root):\n \n    # Base Case when tree is empty\n    if root is None:\n        return 0\n \n    # Get the height of left and right sub-trees\n    lheight = height(root.left)\n    rheight = height(root.right)\n \n    # Get the diameter of left and right sub-trees\n    ldiameter = diameter(root.left)\n    rdiameter = diameter(root.right)\n \n    # Return max of the following tree:\n    # 1) Diameter of left subtree\n    # 2) Diameter of right subtree\n    # 3) Height of left subtree + height of right subtree +1\n    return max(lheight + rheight + 1, max(ldiameter, rdiameter))\n \n \n# Driver Code\nif __name__ == '__main__':\n    '''\n    Constructed binary tree is \n                1\n              /   \\\n            2      3\n          /  \\\n        4     5\n    '''\n \n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n \n    # Function Call\n    print(diameter(root))\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "# Python3 program to find the diameter of a binary tree\n# A binary tree Node\n \n \nclass Node:\n \n    # Constructor to create a new Node\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None\n \n# utility class to pass height object\n \n \nclass Height:\n    def __init(self):\n        self.h = 0\n \n# Optimised recursive function to find diameter\n# of binary tree\n \n \ndef diameterOpt(root, height):\n \n    # to store height of left and right subtree\n    lh = Height()\n    rh = Height()\n \n    # base condition- when binary tree is empty\n    if root is None:\n        height.h = 0\n        return 0\n \n    # ldiameter --> diameter of left subtree\n    # rdiameter  --> diameter of right subtree\n \n    # height of left subtree and right subtree is obtained from lh and rh\n    # and returned value of function is stored in ldiameter and rdiameter\n \n    ldiameter = diameterOpt(root.left, lh)\n    rdiameter = diameterOpt(root.right, rh)\n \n    # height of tree will be max of left subtree\n    # height and right subtree height plus1\n \n    height.h = max(lh.h, rh.h) + 1\n \n    # return maximum of the following\n    # 1)left diameter\n    # 2)right diameter\n    # 3)left height + right height + 1\n    return max(lh.h + rh.h + 1, max(ldiameter, rdiameter))\n \n# function to calculate diameter of binary tree\n \n \ndef diameter(root):\n    height = Height()\n    return diameterOpt(root, height)\n \n \n# Driver Code\nif __name__ == '__main__':\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n \n    '''\n  Constructed binary tree is \n              1\n          /   \\\n          2      3\n        /  \\\n      4     5\n  '''\n \n    print('The diameter of the binary tree is:', end=' ')\n    # Function Call\n    print(diameter(root))\n \n# This code is contributed by Shweta Singh(shweta44)\n", "# Python3 code to implement the above approach that uses the\n# morris traversal algorithm\n \n# A tree node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Create a new node\ndef newNode(data):\n    node = Node(data)\n    return node\n \n# Morris traversal to find the diameter of the binary tree\ndef findDiameter(root):\n    ans = 0\n    curr = root\n \n    while curr is not None:\n        if curr.left is None:\n            curr = curr.right\n        else:\n            pre = curr.left\n            while pre.right is not None and pre.right != curr:\n                pre = pre.right\n            if pre.right is None:\n                pre.right = curr\n                curr = curr.left\n            else:\n                pre.right = None\n                leftHeight = 0\n                rightHeight = 0\n                temp = curr.left\n                while temp is not None:\n                    leftHeight += 1\n                    temp = temp.right\n                temp = curr.right\n                while temp is not None:\n                    rightHeight += 1\n                    temp = temp.left\n                ans = max(ans, leftHeight + rightHeight + 1)\n                curr = curr.right\n    return ans\n \n \n# Driver code\nif __name__ == '__main__':\n    # Create the given binary tree\n    root = newNode(1)\n    root.left = newNode(2)\n    root.right = newNode(3)\n    root.left.left = newNode(4)\n    root.left.right = newNode(5)\n \n    # Find the diameter of the binary tree using Morris\n    # traversal\n    diameter = findDiameter(root)\n \n    # Print the diameter of the binary tree\n    print('The diameter of given binary tree is', diameter)\n"], "Print a Binary Tree in Vertical Order | Set 1 -  ": ["# Program to print binary tree in vertical order\n \n# A binary tree\nclass Node:\n    # Constructor to create a new node\n    def __init__(self, key):\n        self.data = key \n        self.left = None\n        self.right = None\n \n# A utility function to find min and max distances with\n# respect to root \ndef findMinMax(node, minimum, maximum, hd):\n     \n    # Base Case\n    if node is None:\n        return\n     \n    # Update min and max\n    if hd < minimum[0] :\n        minimum[0] = hd\n    elif hd > maximum[0]:\n        maximum[0] = hd\n \n    # Recur for left and right subtrees\n    findMinMax(node.left, minimum, maximum, hd-1)\n    findMinMax(node.right, minimum, maximum, hd+1)\n \n# A utility function to print all nodes on a given line_no\n# hd is horizontal distance of current node with respect to root\ndef printVerticalLine(node, line_no, hd):\n     \n    # Base Case\n    if node is None:\n        return\n     \n    # If this node is on the given line number\n    if hd == line_no:\n        print (node.data,end=' ')\n \n    # Recur for left and right subtrees\n    printVerticalLine(node.left, line_no, hd-1)\n    printVerticalLine(node.right, line_no, hd+1)\n \ndef verticalOrder(root):\n     \n    # Find min and max distances with respect to root\n    minimum = [0]\n    maximum = [0]\n    findMinMax(root, minimum, maximum, 0)\n \n    # Iterate through all possible lines starting \n    # from the leftmost line and print nodes line by line\n    for line_no in range(minimum[0], maximum[0]+1):\n        printVerticalLine(root, line_no, 0)\n        print()\n          \n \n# Driver program to test above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\nroot.right.left.right = Node(8)\nroot.right.right.right = Node(9)\n \nprint ('Vertical order traversal is')\nverticalOrder(root)\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "from typing import Tuple\nimport queue\nimport heapq\n \n# Tuple class definition\nclass Tuple:\n \n    # Data members\n    def __init__(self, item1, item2):\n        self.first = item1\n        self.second = item2\n     \n    def __lt__(self, other):\n        return (self.first, self.second) < (other.first, other.second)\n \n# Node class definition\nclass Node:\n    def __init__(self):\n        self.data = 0\n        self.left = None\n        self.right = None\n \nclass VerticalOrderTraversal:\n \n    # Driver code\n    @staticmethod\n    def main():\n        # Create binary tree shown in above figure\n        root = VerticalOrderTraversal.newNode(1)\n        root.left = VerticalOrderTraversal.newNode(2)\n        root.right = VerticalOrderTraversal.newNode(3)\n        root.left.left = VerticalOrderTraversal.newNode(4)\n        root.left.right = VerticalOrderTraversal.newNode(5)\n        root.right.left = VerticalOrderTraversal.newNode(6)\n        root.right.right = VerticalOrderTraversal.newNode(7)\n        root.right.left.right = VerticalOrderTraversal.newNode(8)\n        root.right.right.right = VerticalOrderTraversal.newNode(9)\n \n        print('Vertical order traversal is ')\n        VerticalOrderTraversal.verticalOrder(root)\n \n    # A utility function to create a new Binary Tree node\n    @staticmethod\n    def newNode(data):\n        temp = Node()\n        temp.data = data\n        temp.left = temp.right = None\n        return temp\n \n    # Function to find the vertical order traversal of\n    # Binary Tree.\n    @staticmethod\n    def verticalOrder(root):\n        qu = queue.Queue()\n        # node, vertical, level\n        minH = []\n \n        # Vertical, Level, BFSNo, Val\n        v = 0\n        l = 0\n        qu.put(Tuple(root, Tuple(v, l)))\n \n        # LEVEL order traversal\n        while not qu.empty():\n            s = qu.qsize()\n            i = 0\n \n            while i < s:\n                node = qu.queue[0].first\n                v = qu.queue[0].second.first\n                l = qu.queue[0].second.second\n \n                # Vertical indx, Levelindx, BFSNo, Val -\n                # Insertion\n                heapq.heappush(\n                    minH,\n                    Tuple(\n                        Tuple(v, l),\n                        Tuple(i, node.data)\n                    )\n                )\n \n                qu.get()\n                if node.left != None:\n                    qu.put(\n                        Tuple(\n                            node.left,\n                            Tuple(v - 1, l + 1)\n                        )\n                    )\n                if node.right != None:\n                    qu.put(\n                        Tuple(\n                            node.right,\n                            Tuple(v + 1, l + 1)\n                        )\n                    )\n \n                i += 1\n \n        # If the minHeap is not empty\n        while len(minH) > 0:\n            vi = minH[0].first.first\n            print(minH[0].second.second, end=' ')\n            heapq.heappop(minH)\n            if len(minH) > 0 and vi != minH[0].first.first:\n                print()\n \n# Driver code\nif __name__ == '__main__':\n    VerticalOrderTraversal.main()\n"], "Symmetric Tree (Mirror Image of itself) -  ": ["# Python program to check if a \n# given Binary Tree is symmetric or not\n \n# Node structure\n \n \nclass Node:\n \n    # Utility function to create new node\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \n# Returns True if trees \n#with roots as root1 and root 2  are mirror\n \n \ndef isMirror(root1, root2):\n    # If both trees are empty, then they are mirror images\n    if root1 is None and root2 is None:\n        return True\n \n    ''' For two trees to be mirror images, \n        the following three conditions must be true\n        1 - Their root node's key must be same\n        2 - left subtree of left tree and right subtree\n          of the right tree have to be mirror images\n        3 - right subtree of left tree and left subtree\n           of right tree have to be mirror images\n    '''\n    if (root1 is not None and root2 is not None):\n        if root1.key == root2.key:\n            return (isMirror(root1.left, root2.right)and\n                    isMirror(root1.right, root2.left))\n \n    # If none of the above conditions is true then root1\n    # and root2 are not mirror images\n    return False\n \n \ndef isSymmetric(root):\n \n    # Check if tree is mirror of itself\n    return isMirror(root, root)\n \n \n# Driver Code\n# Let's construct the tree show in the above figure\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(2)\nroot.left.left = Node(3)\nroot.left.right = Node(4)\nroot.right.left = Node(4)\nroot.right.right = Node(3)\nprint ('Symmetric' if isSymmetric(root) == True else 'Not symmetric')\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "class Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n \ndef isSymmetric(root):\n    # If the root is null, then the binary tree is symmetric\n    if not root:\n        return True\n     \n    # Create a stack to store the left and right subtrees of the root\n    stack = []\n    stack.append(root.left)\n    stack.append(root.right)\n     \n    # Continue the loop until the stack is empty\n    while stack:\n        # Pop the left and right subtrees from the stack\n        node1 = stack.pop()\n        node2 = stack.pop()\n         \n        # If both nodes are null, continue the loop\n        if not node1 and not node2:\n            continue\n         \n        # If one of the nodes is null, the binary tree is not symmetric\n        if not node1 or not node2:\n            return False\n         \n        # If the values of the nodes are not equal, the binary tree is not symmetric\n        if node1.key != node2.key:\n            return False\n         \n        # Push the left and right subtrees of the left and right nodes onto the stack in the opposite order\n        stack.append(node1.left)\n        stack.append(node2.right)\n        stack.append(node1.right)\n        stack.append(node2.left)\n     \n    # If the loop completes, the binary tree is symmetric\n    return True\n \n# Driver code\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(2)\nroot.left.left = Node(3)\nroot.left.right = Node(4)\nroot.right.left = Node(4)\nroot.right.right = Node(3)\n \nif isSymmetric(root):\n    print('Symmetric')\nelse:\n    print('Not symmetric')\n", "from queue import Queue\n \nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n \ndef isSymmetric(root):\n    if root is None:\n        return True\n \n    q = Queue()\n    q.put(root)\n    q.put(root)\n \n    while not q.empty():\n        leftNode = q.get()\n        rightNode = q.get()\n \n        # If both leftNode and rightNode are None, continue\n        # to the next iteration\n        if leftNode is None and rightNode is None:\n            continue\n \n        # If either leftNode or rightNode is None or their\n        # data is not equal, return False\n        if leftNode is None or rightNode is None or leftNode.data != rightNode.data:\n            return False\n \n        # Pushing the left and right nodes of the current\n        # node into the queue\n        q.put(leftNode.left)\n        q.put(rightNode.right)\n        q.put(leftNode.right)\n        q.put(rightNode.left)\n \n    return True\n \nif __name__ == '__main__':\n    # Creating a binary tree\n    root = Node(5)\n    root.left = Node(1)\n    root.right = Node(1)\n    root.left.left = Node(2)\n    root.right.right = Node(2)\n \n    # Checking if the binary tree is symmetric or not\n    if isSymmetric(root):\n        print('The binary tree is symmetric')\n    else:\n        print('The binary tree is not symmetric')\n"], "Program to Determine if given Two Trees are Identical or not -  ": ["# Python3 program to determine if two trees are identical\n \n# A binary tree node has data, pointer to left child\n# and a pointer to right child\n \n \nclass Node:\n    # Constructor to create a new node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n \n# Given two trees, return true if they are structurally\n# identical\ndef identicalTrees(a, b):\n \n    # 1. Both empty\n    if a is None and b is None:\n        return True\n \n    # 2. Both non-empty -> Compare them\n    if a is not None and b is not None:\n        return ((a.data == b.data) and\n                identicalTrees(a.left, b.left)and\n                identicalTrees(a.right, b.right))\n \n    # 3. one empty, one not -- false\n    return False\n \n \n# Driver code\nroot1 = Node(1)\nroot2 = Node(1)\nroot1.left = Node(2)\nroot1.right = Node(3)\nroot1.left.left = Node(4)\nroot1.left.right = Node(5)\n \nroot2.left = Node(2)\nroot2.right = Node(3)\nroot2.left.left = Node(4)\nroot2.left.right = Node(5)\n \n# Function call\nif __name__ == '__main__':\n  if identicalTrees(root1, root2):\n      print('Both trees are identical')\n  else:\n      print('Trees are not identical')\n \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007)\n", "# Python program to check if two trees are identical\n \n# A binary tree node\nclass Node:\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n \n# Utility function to check inorder traversal      \ndef inOrder(root, sol):\n    if root is None:\n        return\n    inOrder(root.left, sol)\n    sol.append(root.data)\n    inOrder(root.right, sol)\n     \n# Utility function to check preorder traversal\ndef preOrder(root, sol):\n    if root is None:\n        return\n    sol.append(root.data)\n    preOrder(root.left, sol)\n    preOrder(root.right, sol)\n \n# Utility function to check postorder traversal\ndef postOrder(root, sol):\n    if root is None:\n        return\n    postOrder(root.left, sol)\n    postOrder(root.right, sol)\n    sol.append(root.data)\n \n# Function to check if two trees are identical\ndef isIdentical(root1, root2):\n    # Code here\n    # Create two vector to store traversal\n    res1 = []\n    res2 = []\n     \n    #check inorder\n    inOrder(root1, res1)\n    inOrder(root2, res2)\n    if res1 != res2:\n        return False\n     \n    # clear previous result to reuse vector\n    res1.clear()\n    res2.clear()\n    # check PreOrder\n    preOrder(root1, res1)\n    preOrder(root2, res2)\n    if res1 != res2:\n        return False\n     \n    # clear previous result to reuse vector\n    res1.clear()\n    res2.clear()\n    # check PostOrder\n    postOrder(root1, res1)\n    postOrder(root2, res2)\n    if res1 != res2:\n        return False\n     \n    return True\n     \n# Driver code\nif __name__ == '__main__':\n    root1 = Node(1)\n    root1.left = Node(2)\n    root1.right = Node(3)\n    root1.left.left = Node(4)\n    root1.left.right = Node(5)\n     \n    root2 = Node(1)\n    root2.left = Node(2)\n    root2.right = Node(3)\n    root2.left.left = Node(4)\n    root2.left.right = Node(5)\n     \n    # Function Call\n    if isIdentical(root1, root2):\n        print('Both the trees are identical.')\n    else:\n        print('Given trees are not identical')\n     \n# This code is contributed by Yash Agarwal(yashagarwal2852002)\n", "class Node:\n    def __init__(self, d):\n        self.data = d\n        self.left = None\n        self.right = None\n \ndef preorder(root, v):\n    if root == None:\n        return\n    v.append(root.data)\n    if root.left:\n        preorder(root.left, v)\n    else:\n        v.append(0)\n    if root.right:\n        preorder(root.right, v)\n    else:\n        v.append(0)\n \ndef isIdentical(root1, root2):\n    v = []\n    x = []\n    preorder(root1, v)\n    preorder(root2, x)\n    return v == x\n \nroot1 = Node(1)\nroot1.left = Node(2)\nroot1.right = Node(3)\nroot1.left.left = Node(4)\nroot1.left.right = Node(5)\n \nroot2 = Node(1)\nroot2.left = Node(2)\nroot2.right = Node(3)\nroot2.left.left = Node(4)\nroot2.left.right = Node(5)\n \nif isIdentical(root1, root2):\n    print('Both the trees are identical.')\nelse:\n    print('Given trees are not identical.')\n", "# Python code to implement the Level order traversal approach\nfrom queue import Queue\n \n# Definition of a Binary Tree Node\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n \n# Function to check if two trees are identical or not\ndef isIdentical(root1, root2):\n    # Base case: if both roots are None, then trees are\n    # identical\n    if not root1 and not root2:\n        return True\n \n    # If one of the roots is None, then trees are not\n    # identical\n    if not root1 or not root2:\n        return False\n \n    # Create queues to perform level order traversal on\n    # both trees\n    q1 = Queue()\n    q2 = Queue()\n \n    # Add the roots of both trees to their respective\n    # queues\n    q1.put(root1)\n    q2.put(root2)\n \n    # Loop until either of the queues becomes empty\n    while not q1.empty() and not q2.empty():\n        # Get the front node from both queues\n        curr1 = q1.get()\n        curr2 = q2.get()\n \n        # If the data of the current nodes is not equal,\n        # then trees are not identical\n        if curr1.data != curr2.data:\n            return False\n \n        # If the left child of one tree exists and the left\n        # child of the other tree does not exist, then\n        # trees are not identical\n        if (curr1.left and not curr2.left) or (not curr1.left and curr2.left):\n            return False\n \n        # If the right child of one tree exists and the\n        # right child of the other tree does not exist,\n        # then trees are not identical\n        if (curr1.right and not curr2.right) or (not curr1.right and curr2.right):\n            return False\n \n        # If both left and right children of both trees\n        # exist, then add them to their respective queues\n        if curr1.left and curr2.left:\n            q1.put(curr1.left)\n            q2.put(curr2.left)\n        if curr1.right and curr2.right:\n            q1.put(curr1.right)\n            q2.put(curr2.right)\n \n    # If we have reached this point, then trees are\n    # identical\n    return True\n \n# Driver Code\nif __name__ == '__main__':\n    # Create the first tree\n    root1 = Node(1)\n    root1.left = Node(2)\n    root1.right = Node(3)\n    root1.left.left = Node(4)\n    root1.left.right = Node(5)\n \n    # Create the second tree\n    root2 = Node(1)\n    root2.left = Node(2)\n    root2.right = Node(3)\n    root2.left.left = Node(4)\n    root2.left.right = Node(5)\n \n    # Check if the trees are identical or not\n    if isIdentical(root1, root2):\n        print('The trees are identical')\n    else:\n        print('The trees are not identical')\n \n#This code is contributed by shivamsharma215\n", "# A binary tree node\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.left = None\n        self.right = None\n \n# Morris traversal approach to check if two binary trees are identical\n \n \ndef isIdentical(r1, r2):\n    # Base cases\n    if not r1 and not r2:  # both trees are empty\n        return True\n    if not r1 or not r2:  # one of the trees is empty, which means they are not identical\n        return False\n \n    # Morris traversal\n    while r1 and r2:\n        if r1.data != r2.data:  # if the data of the current nodes is not the same, then the trees are not identical\n            return False\n \n        # Morris traversal for r1\n        if not r1.left:  # if the left child is None, move to the right child\n            r1 = r1.right\n        else:  # if the left child is not None, find the predecessor\n            pre = r1.left\n            while pre.right and pre.right != r1:  # find the rightmost node in the left subtree\n                pre = pre.right\n            if not pre.right:  # if the right pointer of the predecessor is None, make it point to the current node\n                pre.right = r1\n                r1 = r1.left\n            else:  # if the right pointer of the predecessor is already pointing to the current node, set it back to None and move to the right child\n                pre.right = None\n                r1 = r1.right\n \n        # Morris traversal for r2, same as for r1\n        if not r2.left:\n            r2 = r2.right\n        else:\n            pre = r2.left\n            while pre.right and pre.right != r2:\n                pre = pre.right\n            if not pre.right:\n                pre.right = r2\n                r2 = r2.left\n            else:\n                pre.right = None\n                r2 = r2.right\n \n    return not r1 and not r2  # if both r1 and r2 are None, then the trees are identical\n \n \n# Driver code\nif __name__ == '__main__':\n    # Construct the first tree\n    root1 = Node(1)\n    root1.left = Node(2)\n    root1.right = Node(3)\n    root1.left.left = Node(4)\n    root1.left.right = Node(5)\n \n    # Construct the second tree\n    root2 = Node(1)\n    root2.left = Node(2)\n    root2.right = Node(3)\n    root2.left.left = Node(4)\n    root2.left.right = Node(5)\n \n    # Check if the trees are identical\n    if isIdentical(root1, root2):\n        print('Both trees are identical')\n    else:\n        print('Both trees are not identical')\n \n# This code is contributed by rambabuguphka\n"], "How to determine if a binary tree is height-balanced? -  ": ["'''\nPython3 program to check if a tree is height-balanced\n'''\n# A binary tree Node\n \n \nclass Node:\n    # Constructor to create a new Node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# function to find height of binary tree\n \n \ndef height(root):\n \n    # base condition when binary tree is empty\n    if root is None:\n        return 0\n    return max(height(root.left), height(root.right)) + 1\n \n# function to check if tree is height-balanced or not\n \n \ndef isBalanced(root):\n \n    # Base condition\n    if root is None:\n        return True\n \n    # for left and right subtree height\n    lh = height(root.left)\n    rh = height(root.right)\n \n    # allowed values for (lh - rh) are 1, -1, 0\n    if (abs(lh - rh) <= 1) and isBalanced(\n            root.left) is True and isBalanced(root.right) is True:\n        return True\n \n    # if we reach here means tree is not\n    # height-balanced tree\n    return False\n \n \n# Driver function to test the above function\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.left.left.left = Node(8)\nif isBalanced(root):\n    print('Tree is balanced')\nelse:\n    print('Tree is not balanced')\n \n# This code is contributed by Shweta Singh\n", "'''\nPython3 program to check if a tree is height-balanced\n'''\n# A binary tree Node\n \n \nclass Node:\n \n    # Constructor to create a new Node\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Function to check if tree is height-balanced or not\n \n \ndef isBalanced(root):\n \n    # Base condition\n    if root is None:\n        return True\n \n    # Compute height of left subtree\n    lh = isBalanced(root.left)\n \n    # If left subtree is not balanced,\n    # return 0\n    if lh == 0:\n        return 0\n \n    # Do same thing for the right subtree\n    rh = isBalanced(root.right)\n    if rh == 0:\n        return 0\n \n    # Allowed values for (lh - rh) are 1, -1, 0\n    if (abs(lh - rh) > 1):\n        return 0\n \n    # If we reach here means tree is\n    # height-balanced tree, return height\n    # in this case\n    else:\n        return max(lh, rh) + 1\n \n \n# Driver code\nif __name__ == '__main__':\n    root = Node(10)\n    root.left = Node(5)\n    root.right = Node(30)\n    root.right.left = Node(15)\n    root.right.right = Node(20)\n    if (isBalanced(root) == 0):\n        print('Not Balanced')\n    else:\n        print('Balanced')\n \n# This code is contributed by Shweta Singh\n", "# defining the structure for tree nodes\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n \n# defining the Solution class to check if a binary tree is\n# balanced\nclass Solution:\n    # helper function to determine if a binary tree is\n    # balanced\n    def isBalancedfast(self, root):\n        # base case: if root is None, the tree is balanced\n        # and has height 0\n        if root is None:\n            return True, 0\n        # recursively call isBalancedfast function on left\n        # and right subtrees\n        left = self.isBalancedfast(root.left)\n        right = self.isBalancedfast(root.right)\n \n        # retrieve whether left and right subtrees are\n        # balanced\n        leftAns = left[0]\n        rightAns = right[0]\n \n        # check the difference in heights of left and right\n        # subtrees\n        diff = abs(left[1] - right[1]) <= 1\n \n        # set the height of the current node\n        height = max(left[1], right[1]) + 1\n        # if both subtrees are balanced and their heights\n        # differ by at most 1, the tree is balanced\n        if leftAns and rightAns and diff:\n            return True, height\n        # otherwise, the tree is not balanced\n        else:\n            return False, height\n \n    # Function to check whether a binary tree is balanced\n    # or not.\n    def isBalanced(self, root):\n        return self.isBalancedfast(root)[0]\n \n# create a binary tree\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.left.left.left = Node(8)\n \n# create an object of the Solution class\nobj = Solution()\n# check if the binary tree is balanced using the\n# isBalanced function\nif obj.isBalanced(root):\n    print('The given binary tree is balanced.')\nelse:\n    print('The given binary tree is not balanced.')\n"], "Given an array of integers A . A represents a histogram i.e A[i] denotes height of the ith histogram's bar. Width of each bar is 1. Find the area of the largest rectangle formed by the histogram. Problem Constraints 1 <= |A| <= 100000 1 <= A[i] <= 1000000000 Input Format The only argument given is the integer array A. Output Format Return the area of largest rectangle in the histogram. Example Input Input 1: A = [2, 1, 5, 6, 2, 3] Input 2: A = [2] Example Output Output 1: 10 Output 2: 2 Example Explanation Explanation 1: The largest rectangle has area = 10 unit. Formed by A[3] to A[4]. Explanation 2: Largest rectangle has area 2.": "class Solution:\n    # @param Height : list of integers\n    # @return an integer\n    def largestRectangleArea(self, height):\n        height.append(0)\n        stack = [-1]\n        ans = 0\n        for i in range(len(height)):\n            while height[i] < height[stack[-1]]:\n                h = height[stack.pop()]\n                w = i - stack[-1] - 1\n                ans = max(ans, h*w)\n            stack.append(i)\n        height.pop()\n        return ans\n            \n\n\n", "Remove minimum number of characters so that two strings become anagram -  ": ["# Python 3 program to find minimum  \n# number of characters \n# to be removed to make two  \n# strings anagram. \n  \nCHARS = 26\n  \n# function to calculate minimum  \n# numbers of characters \n# to be removed to make two  \n# strings anagram \ndef remAnagram(str1, str2): \n  \n    # make hash array for both string  \n    # and calculate \n    # frequency of each character \n    count1 = [0]*CHARS \n    count2 = [0]*CHARS \n  \n    # count frequency of each character  \n    # in first string \n    i = 0\n    while i < len(str1): \n        count1[ord(str1[i])-ord('a')] += 1\n        i += 1\n  \n    # count frequency of each character  \n    # in second string \n    i =0\n    while i < len(str2): \n        count2[ord(str2[i])-ord('a')] += 1\n        i += 1\n  \n    # traverse count arrays to find  \n    # number of characters \n    # to be removed \n    result = 0\n    for i in range(26): \n        result += abs(count1[i] - count2[i]) \n    return result \n  \n# Driver program to run the case \nif __name__ == '__main__': \n    str1 = 'bcadeh'\n    str2 = 'hea'\n    print(remAnagram(str1, str2)) \n      \n# This code is contributed by  \n# ChitraNayal \n", "# Python3 program to find minimum  \n# number of characters to be  \n# removed to make two strings  \n# anagram. \n  \n# function to calculate minimum  \n# numbers of characters to be  \n# removed to make two strings anagram  \ndef makeAnagram(a, b): \n    buffer = [0] * 26\n    for char in a: \n        buffer[ord(char) - ord('a')] += 1\n    for char in b: \n        buffer[ord(char) - ord('a')] -= 1\n    return sum(map(abs, buffer)) \n  \n# Driver Code \nif __name__ == '__main__' :  \n  \n    str1 = 'bcadeh'\n    str2 = 'hea'\n    print(makeAnagram(str1, str2)) \n      \n# This code is contributed  \n# by Raghib Ahsan \n", "from collections import Counter \n  \ndef makeAnagram(a, b): \n    # Initialize a counter object with the characters in string a \n    freq = Counter(a) \n      \n    # Subtract the characters in string b from the counter object \n    freq.subtract(Counter(b)) \n      \n    # Calculate the sum of absolute values of counts in the counter object \n    return sum(abs(count) for count in freq.values()) \n  \nif __name__ == '__main__': \n    str1 = 'bcadeh'\n    str2 = 'hea'\n    print(makeAnagram(str1, str2)) \n"], "Find if an array of strings can be chained to form a circle | Set 2 -  ": ["# Python3 code to check if \n# cyclic order is possible \n# among strings under given \n# constraints\nM = 26\n \n# Utility method for a depth \n# first search among vertices \ndef dfs(g, u, visit):\n    visit[u] = True\n \n    for i in range(len(g[u])):\n        if(not visit[g[u][i]]):\n            dfs(g, g[u][i], visit)\n \n# Returns true if all vertices \n# are strongly connected i.e. \n# can be made as loop \ndef isConnected(g, mark, s):\n \n    # Initialize all vertices \n    # as not visited \n    visit = [False for i in range(M)]\n \n    # Perform a dfs from s\n    dfs(g, s, visit)\n \n    # Now loop through \n    # all characters \n    for i in range(M):\n \n        # I character is marked \n        # (i.e. it was first or last \n        # character of some string) \n        # then it should be visited\n        # in last dfs (as for looping, \n        # graph should be strongly \n        # connected) */\n        if(mark[i] and (not visit[i])):\n            return False\n           \n    # If we reach that means \n    # graph is connected \n    return True\n \n# return true if an order among \n# strings is possible \ndef possibleOrderAmongString(arr, N):\n \n    # Create an empty graph \n    g = {}\n \n    # Initialize all vertices \n    # as not marked \n    mark = [False for i in range(M)]\n \n    # Initialize indegree and \n    # outdegree of every \n    # vertex as 0.\n    In = [0 for i in range(M)]\n    out = [0 for i in range(M)]\n \n    # Process all strings \n    # one by one \n    for i in range(N):\n \n        # Find first and last \n        # characters \n        f = (ord(arr[i][0]) -\n             ord('a'))\n        l = (ord(arr[i][-1]) -\n             ord('a'))\n \n        # Mark the characters \n        mark[f] = True\n        mark[l] = True\n \n        # Increase indegree \n        # and outdegree count \n        In[l] += 1\n        out[f] += 1\n \n        if f not in g:\n            g[f] = []\n \n        # Add an edge in graph \n        g[f].append(l)\n \n    # If for any character \n    # indegree is not equal to \n    # outdegree then ordering \n    # is not possible \n    for i in range(M):\n        if(In[i] != out[i]):\n            return False\n           \n    return isConnected(g, mark, \n                       ord(arr[0][0]) -\n                       ord('a'))\n \n# Driver code\narr = ['ab', 'bc', \n       'cd', 'de', \n       'ed', 'da']\nN = len(arr)\nif(possibleOrderAmongString(arr, N) ==\n   False):\n    print('Ordering not possible')\nelse:\n    print('Ordering is possible')\n \n# This code is contributed by avanitrachhadiya2155\n"], "Minimum rotations required to get the same string -  ": ["# Python 3 program to determine minimum \n# number of rotations required to yield \n# same string.\n \n# Returns count of rotations to get the\n# same string back.\ndef findRotations(str):\n     \n    # tmp is the concatenated string.\n    tmp = str + str\n    n = len(str)\n \n    for i in range(1, n + 1):\n         \n        # substring from i index of \n        # original string size.\n        substring = tmp[i: i+n]\n \n        # if substring matches with \n        # original string then we will \n        # come out of the loop.\n        if (str == substring):\n            return i\n    return n\n \n# Driver code\nif __name__ == '__main__':\n \n    str = 'abc'\n    print(findRotations(str))\n \n# This code is contributed \n# by 29AjayKumar.\n", "# Python program to determine minimum number \n# of rotations required to yield same \n# string. \n \n# Returns count of rotations to get the \n# same string back. \ndef findRotations(Str): \n \n    ans = 0 # to store the answer\n    n = len(Str) # length of the String\n       \n    # All the length where we can partition\n    for i in range(1 , len(Str) - 1):\n \n        # right part + left part = rotated String\n        # we are checking whether the rotated String is equal to \n        # original String\n        if(Str[i: n] + Str[0: i]  == Str):\n            ans = i\n            break\n \n    if(ans == 0):\n        return n\n    return ans\n \n# Driver code \nStr = 'abc'\nprint(findRotations(Str))\n \n# This code is contributed by shinjanpatra\n", "# Python 3 program to determine minimum \n# number of rotations required to yield \n# same string.\n  \n# input\nstring = 'aaaa'\ncheck = ''\n  \nfor r in range(1, len(string)+1):\n  # checking the input after each rotation\n  check = string[r:] + string[:r]\n    \n  # following if statement checks if input is \n  # equals to check , if yes it will print r and \n  # break out of the loop\n  if check == string:\n    print(r)\n    break\n  \n# This code is contributed \n# by nagasowmyanarayanan.\n"], "Count ways to increase LCS length of two strings by one -  ": ["# Python3 program to get number of ways to increase\n# LCS by 1\n \nM = 26\n \n# Method returns total ways to increase LCS length by 1\ndef waysToIncreaseLCSBy1(str1, str2):\n    m = len(str1)\n    n = len(str2)\n \n    # Fill positions of each character in vector\n    # vector<int> position[M];\n    position = [[] for i in range(M)]\n    for i in range(1, n+1, 1):\n        position[ord(str2[i-1])-97].append(i)\n \n    # Initializing 2D array by 0 values\n    lcsl = [[0 for i in range(n+2)] for j in range(m+2)]\n    lcsr = [[0 for i in range(n+2)] for j in range(m+2)]\n \n    # Filling LCS array for prefix substrings\n    for i in range(1, m+1, 1):\n        for j in range(1, n+1,1):\n            if (str1[i-1] == str2[j-1]):\n                lcsl[i][j] = 1 + lcsl[i-1][j-1]\n            else:\n                lcsl[i][j] = max(lcsl[i-1][j],\n                                lcsl[i][j-1])\n \n    # Filling LCS array for suffix substrings\n    for i in range(m, 0, -1):\n        for j in range(n, 0, -1):\n            if (str1[i-1] == str2[j-1]):\n                lcsr[i][j] = 1 + lcsr[i+1][j+1]\n            else:\n                lcsr[i][j] = max(lcsr[i+1][j],\n                                lcsr[i][j+1])\n \n        # Looping for all possible insertion positions\n        # in first string\n    ways = 0\n    for i in range(0, m+1,1):\n        # Trying all possible lower case characters\n        for C in range(0, 26,1):\n            # Now for each character, loop over same\n            # character positions in second string\n            for j in range(0, len(position[C]),1):\n                p = position[C][j]\n \n                # If both, left and right substrings make\n                # total LCS then increase result by 1\n                if (lcsl[i][p-1] + lcsr[i+1][p+1] == lcsl[m][n]):\n                    ways += 1\n    return ways\n \n \n# Driver code to test above methods\nstr1 = 'abcabc'\nstr2 = 'abcd'\nprint(waysToIncreaseLCSBy1(str1, str2))\n \n# This code is contributed by ankush_953\n"], "Mirror characters of a string -  ": ["# python code to find the reverse\n# alphabetical order from a given\n# position\n \n# Function which take the given string and the\n# position from which the reversing shall be\n# done and returns the modified string\ndef compute(st, n):\n     \n    # Creating a string having reversed\n    # alphabetical order\n    reverseAlphabet = 'zyxwvutsrqponmlkjihgfedcba'\n    l = len(st)\n     \n    # The string up to the point specified in the\n    # question, the string remains unchanged and\n    # from the point up to the length of the \n    # string, we reverse the alphabetical order\n    answer = ''\n    for i in range(0, n):\n        answer = answer + st[i];\n             \n    for i in range(n, l):\n        answer = (answer +\n        reverseAlphabet[ord(st[i]) - ord('a')]);\n         \n    return answer;\n \n# Driver function\nst = 'pneumonia'\nn = 4\nanswer = compute(st, n - 1)\nprint(answer)\n \n# This code is contributed by Sam007.\n"], "Print shortest path to print a string on screen -  ": ["# Python 3 program to print shortest possible\n# path to type all characters of given string\n# using a remote\n \n# Function to print shortest possible path \n# to type all characters of given string \n# using a remote\ndef printPath(str):\n    i = 0\n     \n    # start from character 'A' present \n    # at position (0, 0)\n    curX = 0\n    curY = 0\n    while (i < len(str)):\n         \n        # find coordinates of next character\n        nextX = int((ord(str[i]) - ord('A')) / 5)\n        nextY = (ord(str[i]) - ord('B') + 1) % 5\n \n        # Move Up if destination is above\n        while (curX > nextX):\n            print('Move Up')\n            curX -= 1\n \n        # Move Left if destination is to the left\n        while (curY > nextY):\n            print('Move Left')\n            curY -= 1\n \n        # Move down if destination is below\n        while (curX < nextX):\n            print('Move Down')\n            curX += 1\n \n        # Move Right if destination is to the right\n        while (curY < nextY):\n            print('Move Right')\n            curY += 1\n \n        # At this point, destination is reached\n        print('Press OK')\n        i += 1\n \n# Driver code\nif __name__ == '__main__':\n    str = 'COZY'\n \n    printPath(str)\n \n# This code is contributed by\n# Sanjit_Prasad\n"], "Form minimum number from given sequence -  ": ["# Python3 program to print minimum number that \n# can be formed from a given sequence of Is and Ds \n  \n# Prints the minimum number that can be formed from \n# input sequence of I's and D's \ndef PrintMinNumberForPattern(arr): \n  \n    # Initialize current_max (to make sure that \n    # we don't use repeated character \n    curr_max = 0\n  \n    # Initialize last_entry (Keeps track for \n    # last printed digit) \n    last_entry = 0\n    i = 0\n  \n    # Iterate over input array \n    while i < len(arr): \n  \n        # Initialize 'noOfNextD' to get count of \n        # next D's available \n        noOfNextD = 0\n        if arr[i] == 'I': \n  \n            # If letter is 'I' \n  \n            # Calculate number of next consecutive D's \n            # available \n            j = i + 1\n            while j < len(arr) and arr[j] == 'D': \n                noOfNextD += 1\n                j += 1\n            if i == 0: \n                curr_max = noOfNextD + 2\n                last_entry += 1\n  \n                # If 'I' is first letter, print incremented \n                # sequence from 1 \n                print('', last_entry, end = '') \n                print('', curr_max, end = '') \n  \n                # Set max digit reached \n                last_entry = curr_max \n            else: \n  \n                # If not first letter \n  \n                # Get next digit to print \n                curr_max += noOfNextD + 1\n  \n                # Print digit for I \n                last_entry = curr_max \n                print('', last_entry, end = '') \n  \n            # For all next consecutive 'D' print \n            # decremented sequence \n            for k in range(noOfNextD): \n                last_entry -= 1\n                print('', last_entry, end = '') \n                i += 1\n  \n        # If letter is 'D' \n        elif arr[i] == 'D': \n            if i == 0: \n  \n                # If 'D' is first letter in sequence \n                # Find number of Next D's available \n                j = i + 1\n                while j < len(arr) and arr[j] == 'D': \n                    noOfNextD += 1\n                    j += 1\n  \n                # Calculate first digit to print based on \n                # number of consecutive D's \n                curr_max = noOfNextD + 2\n  \n                # Print twice for the first time \n                print('', curr_max, curr_max - 1, end = '') \n  \n                # Store last entry \n                last_entry = curr_max - 1\n            else: \n  \n                # If current 'D' is not first letter \n  \n                # Decrement last_entry \n                print('', last_entry - 1, end = '') \n                last_entry -= 1\n        i += 1\n    print() \n  \n# Driver code \nif __name__ == '__main__': \n    PrintMinNumberForPattern('IDID') \n    PrintMinNumberForPattern('I') \n    PrintMinNumberForPattern('DD') \n    PrintMinNumberForPattern('II') \n    PrintMinNumberForPattern('DIDI') \n    PrintMinNumberForPattern('IIDDD') \n    PrintMinNumberForPattern('DDIDDIID') \n  \n# This code is contributed by \n# sanjeev2552 \n", "# Python3 program to print minimum number \n# that can be formed from a given sequence \n# of Is and Ds  \ndef printLeast(arr): \n  \n    # min_avail represents the minimum  \n    # number which is still available  \n    # for inserting in the output vector.  \n    # pos_of_I keeps track of the most  \n    # recent index where 'I' was  \n    # encountered w.r.t the output vector  \n    min_avail = 1\n    pos_of_I = 0\n  \n    # Vector to store the output  \n    v = [] \n  \n    # Cover the base cases  \n    if (arr[0] == 'I'): \n        v.append(1) \n        v.append(2) \n          \n        min_avail = 3\n        pos_of_I = 1\n    else: \n        v.append(2) \n        v.append(1) \n          \n        min_avail = 3\n        pos_of_I = 0\n  \n    # Traverse rest of the input  \n    for i in range(1, len(arr)): \n        if (arr[i] == 'I'): \n            v.append(min_avail) \n            min_avail += 1\n            pos_of_I = i + 1\n        else: \n            v.append(v[i]) \n            for j in range(pos_of_I, i + 1): \n                v[j] += 1\n            min_avail += 1\n              \n    # Print the number \n    print(*v, sep = ' ') \n  \n# Driver code \nprintLeast('IDID') \nprintLeast('I') \nprintLeast('DD')  \nprintLeast('II')  \nprintLeast('DIDI')  \nprintLeast('IIDDD')  \nprintLeast('DDIDDIID')  \n  \n# This code is contributed by avanitrachhadiya2155\n", "# Python3 program to print minimum  \n# number that can be formed from a \n# given sequence of Is and Ds  \ndef PrintMinNumberForPattern(Strr): \n      \n    # Take a List to work as Stack \n    stack = [] \n  \n    # String for storing result  \n    res = '' \n  \n    # run n+1 times where n is length  \n    # of input sequence, As length of \n    # result string is always 1 greater \n    for i in range(len(Strr) + 1): \n  \n        # Push number i+1 into the stack \n        stack.append(i + 1) \n  \n        # If all characters of the input \n        # sequence are processed or current \n        # character is 'I  \n        if (i == len(Strr) or Strr[i] == 'I'): \n  \n            # Run While Loop Until stack is empty \n            while len(stack) > 0: \n                  \n                # pop the element on top of stack  \n                # And store it in result String \n                res += str(stack.pop()) \n                res += ' '\n                  \n    # Print the result \n    print(res)  \n  \n# Driver Code \nPrintMinNumberForPattern('IDID') \nPrintMinNumberForPattern('I') \nPrintMinNumberForPattern('DD') \nPrintMinNumberForPattern('II') \nPrintMinNumberForPattern('DIDI') \nPrintMinNumberForPattern('IIDDD') \nPrintMinNumberForPattern('DDIDDIID') \n  \n# This code is contributed by AyushManglani \n", "# Python3 program of above approach \n      \n# Returns minimum number made from  \n# given sequence without repeating digits  \ndef getMinNumberForPattern(seq): \n    n = len(seq)  \n  \n    if (n >= 9): \n        return '-1'\n  \n    result = [None] * (n + 1)  \n  \n    count = 1\n  \n    # The loop runs for each input character  \n    # as well as one additional time for  \n    # assigning rank to remaining characters \n    for i in range(n + 1): \n        if (i == n or seq[i] == 'I'): \n            for j in range(i - 1, -2, -1): \n                result[j + 1] = int('0' + str(count)) \n                count += 1\n                if(j >= 0 and seq[j] == 'I'):  \n                    break\n    return result \n      \n# Driver Code  \nif __name__ == '__main__': \n    inputs = ['IDID', 'I', 'DD', 'II',  \n              'DIDI', 'IIDDD', 'DDIDDIID'] \n    for Input in inputs: \n        print(*(getMinNumberForPattern(Input))) \n  \n# This code is contributed by PranchalK \n", "# Python implementation of the above approach \n  \ndef didi_seq_gen(s: str): \n    ''' \n    :param s: a seq consisting only of 'D'  \n    and 'I' chars. D is for decreasing and  \n    I for increasing \n    :return: digits from 1-9 that fit the str.  \n    The number they represent should the min  \n    such number \n    :rtype: str \n    example : for seq DII -> 2134 \n    '''\n    if not s or len(s) <= 0: \n        return '' \n    base_list = ['1'] \n    for i in range(1, len(s) + 1): \n        base_list.append(f'{i + 1}') \n  \n    last_D = -1\n    for i in range(1, len(base_list)): \n        if s[i - 1] == 'D': \n            if last_D < 0: \n                last_D = i - 1\n            v = base_list[i] \n            del base_list[i] \n            base_list.insert(last_D, v) \n        else: \n            last_D = -1\n  \n    return base_list \n  \n# Driver Code \n# Function call \nprint(didi_seq_gen('IDID')) \nprint(didi_seq_gen('I')) \nprint(didi_seq_gen('DD')) \nprint(didi_seq_gen('II')) \nprint(didi_seq_gen('DIDI')) \nprint(didi_seq_gen('IIDDD')) \nprint(didi_seq_gen('DDIDDIID' ))\n", "# This code illustrates to find minimum number following \n# pattern with optimized space and modular code. \n  \n# This function returns minimum number following \n# pattern of increasing or decreasing sequence. \ndef findMinNumberPattern(Str): \n  \n    ans = '' # Minimum number following pattern \n  \n    i = 0\n    cur = 1 # cur val following pattern \n    dCount = 0 # Count of char 'D' \n    while (i < len(Str)) : \n  \n        ch = Str[i] \n  \n        # If 1st ch == 'I', incr and add to ans \n        if (i == 0 and ch == 'I') : \n            ans += str(cur) \n            cur+=1\n  \n        # If cur char == 'D', \n        # incr dCount as well, since we always \n        # start counting for dCount from i+1 \n        if (ch == 'D') : \n            dCount+=1\n          \n  \n        j = i + 1 # Count 'D' from i+1 index \n        while (j < len(Str) and Str[j] == 'D') : \n            dCount+=1\n            j+=1\n          \n  \n        k = dCount  # Store dCount \n        while (dCount >= 0) : \n            ans += str(cur + dCount) \n            dCount-=1\n          \n  \n        cur += (k + 1) # Manages next cur val \n        dCount = 0\n        i = j \n  \n    return ans \n      \nprint(findMinNumberPattern('DIDID')) \nprint(findMinNumberPattern('DIDIII')) \nprint(findMinNumberPattern('DDDIIDI')) \nprint(findMinNumberPattern('IDIDIID')) \nprint(findMinNumberPattern('DIIDIDD')) \nprint(findMinNumberPattern('IIDIDDD')) \n  \n# This code is contributed by mukesh07.\n", "def get_num_seq( str_seq): \n  \n    n= len(str_seq) \n    start = -1\n    end = -1; \n    ans = ''; \n      \n    for i in range(1, n + 2): \n        ans += str(i) \n      \n    for i in range(n): \n  \n        if(str_seq[i] == 'D'): \n          \n            if(start == -1): \n                start=i; \n            end=i; \n          \n        else: \n            if(start != -1): \n                ans = ans[:start] + ans[start:end+2][::-1] + ans[end+2:] \n                start = -1; \n            end = -1; \n          \n    if(start != -1): \n        ans =  ans[:start] + ans[start:end+2][::-1] + ans[end+2:] \n  \n    return ans; \n  \n# driver's code \nstr_seq='DDIDDIID'; \nprint(get_num_seq(str_seq)) \n  \n# this code is contributed by phasing17 \n"], "Burrows - Wheeler Data Transform Algorithm -  ": ["# Python program to find Burrows-Wheeler Transform of a given text\n# Compares the rotations and sorts the rotations alphabetically\n \n \ndef cmp_func(x, y):\n    return (x[1] > y[1]) - (x[1] < y[1])\n \n# Takes text to be transformed and its length as arguments\n# and returns the corresponding suffix array\n \n \ndef compute_suffix_array(input_text, len_text):\n    # Array of structures to store rotations and their indexes\n    suff = [(i, input_text[i:]) for i in range(len_text)]\n \n    # Sorts rotations using comparison function defined above\n    suff.sort(key=lambda x: x[1])\n \n    # Stores the indexes of sorted rotations\n    suffix_arr = [i for i, _ in suff]\n \n    # Returns the computed suffix array\n    return suffix_arr\n \n# Takes suffix array and its size as arguments\n# and returns the Burrows-Wheeler Transform of given text\n \n \ndef find_last_char(input_text, suffix_arr, n):\n    # Iterates over the suffix array to\n    # find the last char of each cyclic rotation\n    bwt_arr = ''\n    for i in range(n):\n        # Computes the last char which is given by \n        # input_text[(suffix_arr[i] + n - 1) % n]\n        j = suffix_arr[i] - 1\n        if j < 0:\n            j = j + n\n        bwt_arr += input_text[j]\n \n    # Returns the computed Burrows-Wheeler Transform\n    return bwt_arr\n \n \n# Driver program to test functions above\ninput_text = 'banana$'\nlen_text = len(input_text)\n \n# Computes the suffix array of our text\nsuffix_arr = compute_suffix_array(input_text, len_text)\n \n# Adds to the output array the last char of each rotation\nbwt_arr = find_last_char(input_text, suffix_arr, len_text)\n \nprint('Input text :', input_text)\nprint('Burrows - Wheeler Transform :', bwt_arr)\n \n# This code is contributed by Susobhan Akhuli\n"], "Minimum Swaps for Bracket Balancing -  ": ["def swap_count(s):\n    # To store the answer\n    ans = 0\n     \n    # To store the count of '['\n    count = 0\n     \n    # Size of the string\n    n = len(s)\n     \n    # Traverse over the string\n    for i in range(n):\n        # When '[' encounters\n        if s[i] == '[':\n            count += 1\n        # When ']' encounters\n        else:\n            count -= 1\n        # When count becomes less than 0\n        if count < 0:\n            # Start searching for '[' from (i+1)th index\n            j = i + 1\n            while j < n:\n                # When jth index contains '['\n                if s[j] == '[':\n                    break\n                j += 1\n            # Increment the answer\n            ans += j - i\n             \n            # Set count to 1 again\n            count = 1\n             \n            # Bring the character at jth position to ith position\n            # and shift all characters from i to j-1 \n            # towards the right\n            ch = s[j]\n            for k in range(j, i, -1):\n                s[k] = s[k - 1]\n            s[i] = ch\n    return ans\n \n# Driver code\nif __name__ == '__main__':\n    s = '[]][]['\n    print(swap_count(list(s)))\n \n    s = '[[][]]'\n    print(swap_count(list(s)))\n", "# Python3 Program to count \n# swaps required to balance \n# string \n \n# Function to calculate \n# swaps required \ndef swapCount(s):\n \n    # Keep track of '[' \n    pos = []\n \n    for i in range(len(s)):\n        if(s[i] == '['):\n            pos.append(i)\n \n    # To count number \n    # of encountered '['         \n    count = 0\n     \n    # To track position \n    # of next '[' in pos \n    p = 0   \n     \n    # To store result \n    sum = 0       \n    s = list(s)\n     \n    for i in range(len(s)):\n \n        # Increment count and \n        # move p to next position \n        if(s[i] == '['):\n            count += 1\n            p += 1\n        elif(s[i] == ']'):\n            count -= 1\n \n        # We have encountered an \n        # unbalanced part of string \n        if(count < 0):\n           \n            # Increment sum by number \n            # of swaps required \n            # i.e. position of next \n            # '[' - current position \n            sum += pos[p] - i\n            s[i], s[pos[p]] = (s[pos[p]], \n                               s[i])\n            p += 1\n \n            # Reset count to 1 \n            count = 1\n    return sum\n \n# Driver code \ns = '[]][]['\nprint(swapCount(s))\n \ns = '[[][]]'\nprint(swapCount(s))\n \n# This code is contributed by avanitrachhadiya2155\n", "# Python3 program to count swaps required to\n# balance string \ndef swapCount(s): \n     \n     \n     \n    # Swap stores the number of swaps  \n    # required imbalance maintains the\n    # number of imbalance pair \n    swap = 0\n    imbalance = 0; \n     \n    for i in s:\n        if i == '[':\n             \n            # Decrement the imbalance\n            imbalance -= 1\n        else:\n             \n            # Increment imbalance \n            imbalance += 1\n             \n            if imbalance > 0:\n                swap += imbalance\n \n    return swap\n \n# Driver code \ns = '[]][]['; \nprint(swapCount(s))\n \ns = '[[][]]'; \nprint(swapCount(s))\n \n# This code is contributed by Prateek Gupta and improved by Anvesh Govind Saxena\n"], "Length of Longest Balanced Subsequence -  ": ["# Python3 program to find length of \n# the longest balanced subsequence \n \ndef maxLength(s, n):\n     \n    dp = [[0 for i in range(n)]\n             for i in range(n)]\n              \n    # Considering all balanced \n    # substrings of length 2 \n    for i in range(n - 1): \n        if (s[i] == '(' and s[i + 1] == ')'): \n            dp[i][i + 1] = 2\n \n    # Considering all other substrings \n    for l in range(2, n):\n        i = -1\n        for j in range(l, n):\n            i += 1\n            if (s[i] == '(' and s[j] == ')'): \n                dp[i][j] = 2 + dp[i + 1][j - 1] \n            for k in range(i, j): \n                dp[i][j] = max(dp[i][j], dp[i][k] +\n                                         dp[k + 1][j])\n    return dp[0][n - 1] \n \n# Driver Code \ns = '()(((((()'\nn = len(s)\nprint(maxLength(s, n)) \n \n# This code is contributed \n# by sahishelangia\n", "# Python3 program to find length of \n# the longest balanced subsequence \n \ndef maxLength(s, n):\n             \n    # As it's subsequence - assuming first\n    # open brace would map to a first close\n    # brace which occurs after the open brace\n    # to make subsequence balanced and second\n    # open brace would map to second close \n    # brace and so on.\n     \n    # Variable to count all the open brace \n    # that does not have the corresponding \n    # closing brace. \n    invalidOpenBraces = 0;\n \n    # To count all the close brace that does\n    # not have the corresponding open brace.\n    invalidCloseBraces = 0;\n     \n    # Iterating over the String\n    for i in range(n):\n        if( s[i] == '(' ):\n                 \n                # Number of open braces that \n                # hasn't been closed yet.\n                invalidOpenBraces += 1\n        else:\n            if(invalidOpenBraces == 0):\n                # Number of close braces that\n                # cannot be mapped to any open\n                # brace.\n                invalidCloseBraces += 1\n            else:\n                # Mapping the ith close brace\n                # to one of the open brace.\n                invalidOpenBraces -= 1\n \n    return (\nn - (\ninvalidOpenBraces + invalidCloseBraces)) \n \n# Driver Code \ns = '()(((((()'\nn = len(s)\nprint(maxLength(s, n))\n"], "Check for balanced parentheses in an expression | O(1) space -  ": ["# Python 3 code to check balanced \n# parentheses with O(1) space. \n \n# Function1 to match closing bracket\ndef matchClosing(X, start, end, \n                   open, close):\n \n    c = 1\n    i = start + 1\n    while (i <= end):\n        if (X[i] == open):\n            c += 1\n        elif (X[i] == close):\n            c -= 1\n        if (c == 0):\n            return i\n        i += 1\n    return i\n \n# Function1 to match opening bracket\ndef matchingOpening(X, start, end, \n                      open, close):\n \n    c = -1\n    i = end - 1\n \n    while (i >= start):\n        if (X[i] == open):\n            c += 1\n        elif (X[i] == close):\n            c -= 1\n        if (c == 0):\n            return i\n        i -= 1\n \n    return -1\n \n# Function to check balanced \n# parentheses\ndef isBalanced(X, n):\n \n    for i in range(n):\n         \n        # Handling case of opening \n        # parentheses\n        if (X[i] == '('):\n            j = matchClosing(X, i, n - 1, '(', ')')\n        elif (X[i] == '{'):\n            j = matchClosing(X, i, n - 1, '{', '}')\n        elif (X[i] == '['):\n            j = matchClosing(X, i, n - 1, '[', ']')\n \n        # Handling case of closing\n        # parentheses\n        else :\n            if (X[i] == ')'):\n                j = matchingOpening(X, 0, i, '(', ')')\n            elif (X[i] == '}'):\n                j = matchingOpening(X, 0, i, '{', '}')\n            elif (X[i] == ']'):\n                j = matchingOpening(X, 0, i, '[', ']')\n \n            # If corresponding matching opening \n            # parentheses doesn't lie in given \n            # interval return 0\n            if (j < 0 or j >= i):\n                return False\n \n            # else continue\n            continue\n \n        # If corresponding closing parentheses\n        # doesn't lie in given interval, return 0\n        if (j >= n or j < 0):\n            return False\n \n        # if found, now check for each opening and \n        # closing parentheses in this interval\n        start = i\n        end = j\n \n        for k in range(start + 1, end) :\n            if (X[k] == '(') :\n                x = matchClosing(X, k, end, '(', ')')\n                if (not(k < x and x < end)):\n                    return False\n             \n            elif (X[k] == ')'):\n                x = matchingOpening(X, start, k, '(', ')')\n                if (not(start < x and x < k)):\n                    return False\n \n            if (X[k] == '{'):\n                x = matchClosing(X, k, end, '{', '}')\n                if (not(k < x and x < end)):\n                    return False\n \n            elif (X[k] == '}'):\n                x = matchingOpening(X, start, k, '{', '}')\n                if (not(start < x and x < k)):\n                    return False\n                 \n            if (X[k] == '['):\n                x = matchClosing(X, k, end, '[', ']')\n                if (not(k < x and x < end)):\n                    return False\n                 \n            elif (X[k] == ']'):\n                x = matchingOpening(X, start, k, '[', ']')\n                if (not(start < x and x < k)):\n                    return False\n \n    return True\n \n# Driver Code\nif __name__ == '__main__':\n     \n    X = '[()]()'\n    n = 6\n    if (isBalanced(X, n)):\n        print('Yes')\n    else:\n        print('No')\n \n    Y = '[[()]])'\n    n = 7\n    if (isBalanced(Y, n)):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed by ita_c\n"], "Word Break Problem | (Trie solution) -  ": ["class Solution(object):\n    def wordBreak(self, s, wordDict):\n        '''\n        Author : @amitrajitbose\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        '''\n        '''CREATING THE TRIE CLASS'''\n \n        class TrieNode(object):\n \n            def __init__(self):\n                self.children = []  # will be of size = 26\n                self.isLeaf = False\n \n            def getNode(self):\n                p = TrieNode()  # new trie node\n                p.children = []\n                for i in range(26):\n                    p.children.append(None)\n                p.isLeaf = False\n                return p\n \n            def insert(self, root, key):\n                key = str(key)\n                pCrawl = root\n                for i in key:\n                    index = ord(i)-97\n                    if(pCrawl.children[index] == None):\n                        # node has to be initialised\n                        pCrawl.children[index] = self.getNode()\n                    pCrawl = pCrawl.children[index]\n                pCrawl.isLeaf = True  # marking end of word\n \n            def search(self, root, key):\n                # print('Searching %s' %key) #DEBUG\n                pCrawl = root\n                for i in key:\n                    index = ord(i)-97\n                    if(pCrawl.children[index] == None):\n                        return False\n                    pCrawl = pCrawl.children[index]\n                if(pCrawl and pCrawl.isLeaf):\n                    return True\n \n        def checkWordBreak(strr, root):\n            n = len(strr)\n            if(n == 0):\n                return True\n            for i in range(1, n+1):\n                if(root.search(root, strr[:i]) and checkWordBreak(strr[i:], root)):\n                    return True\n            return False\n \n        '''IMPLEMENT SOLUTION'''\n        root = TrieNode().getNode()\n        for w in wordDict:\n            root.insert(root, w)\n        out = checkWordBreak(s, root)\n        if(out):\n            return 'Yes'\n        else:\n            return 'No'\n \n \nprint(Solution().wordBreak('thequickbrownfox',\n                           ['the', 'quick', 'fox', 'brown']))\nprint(Solution().wordBreak('bedbathandbeyond', [\n      'bed', 'bath', 'bedbath', 'and', 'beyond']))\nprint(Solution().wordBreak('bedbathandbeyond', [\n      'teddy', 'bath', 'bedbath', 'and', 'beyond']))\nprint(Solution().wordBreak('bedbathandbeyond', [\n      'bed', 'bath', 'bedbath', 'and', 'away']))\n"], "Check if given string can be split into four distinct strings -  ": ["# Python3 program to check if we can \n# break a into four distinct strings. \n \n# Return if the given string can be \n# split or not. \ndef check(s):\n \n    # We can always break a of size 10 or \n    # more into four distinct strings. \n    if (len(s) >= 10):\n        return True\n \n    # Brute Force \n    for i in range(1, len(s)): \n     \n        for j in range(i + 1, len(s)): \n         \n            for k in range(j + 1, len(s)):\n             \n                # Making 4 from the given \n                s1 = s[0:i] \n                s2 = s[i:j - i]\n                s3 = s[j: k - j]\n                s4 = s[k: len(s) - k]\n                 \n                # Checking if they are distinct or not. \n                if (s1 != s2 and s1 != s3 and s1 != s4 and\n                    s2 != s3 and s2 != s4 and s3 != s4): \n                    return True\n             \n    return False\n \n# Driver Code \nif __name__ == '__main__':\n    str = 'aaabb'\n \n    print('Yes') if(check(str)) else print('NO')\n \n# This code is contributed\n# by SHUBHAMSINGH10\n"], "Lexicographically next string -  ": ["# Python 3 program to find lexicographically\n# next string\n \ndef nextWord(s):\n     \n    # If string is empty.\n    if (s == ' '):\n        return 'a'\n \n    # Find first character from right \n    # which is not z.\n    i = len(s) - 1\n    while (s[i] == 'z' and i >= 0):\n        i -= 1\n \n    # If all characters are 'z', append\n    # an 'a' at the end.\n    if (i == -1):\n        s = s + 'a'\n \n    # If there are some non-z characters \n    else:\n        s = s.replace(s[i], chr(ord(s[i]) + 1), 1) \n \n    return s\n \n# Driver code\nif __name__ == '__main__':\n    str = 'samez'\n    print(nextWord(str))\n     \n# This code is contributed by\n# Sanjit_Prasad\n"], "Count number of binary strings without consecutive 1's -  ": ["# Python program to count\n# all distinct binary strings\n# without two consecutive 1's\n \ndef countStrings(n):\n \n    a=[0 for i in range(n)]\n    b=[0 for i in range(n)]\n    a[0] = b[0] = 1\n    for i in range(1,n):\n        a[i] = a[i-1] + b[i-1]\n        b[i] = a[i-1]\n     \n    return a[n-1] + b[n-1]\n \n# Driver program to test\n# above functions\n \nprint(countStrings(3))\n \n# This code is contributed\n# by Anant Agarwal.\n", "class Subset_sum :\n    @staticmethod\n    def  countStrings( n) :\n        a = 1\n        b = 1\n        i = 1\n        while (i < n) :\n            # Here we have used the temp variable because\n            # we want to assign the older value of a to b\n            temp = a + b\n            b = a\n            a = temp\n            i += 1\n        return (a + b)%1000000007\n       \n    # Driver program to test above function\n    @staticmethod\n    def main( args) :\n        print(Subset_sum.countStrings(3))\n     \n \nif __name__=='__main__':\n    Subset_sum.main([])\n     \n    # This code is contributed by aadityaburujwale.\n", "class Solution:\n    def __init__(self):\n        self.mp = {}\n \n    def countStrings(self, N):\n        if N == 0:\n            return 1\n        if N == 1:\n            return 2\n        if N == 2:\n            return 3\n \n        mod = 10**9 + 7\n \n        a = self.mp.get(N//2-1, self.countStrings(N//2-1)) % mod\n        b = self.mp.get(N//2, self.countStrings(N//2)) % mod\n        c = self.mp.get(N//2+1, self.countStrings(N//2+1)) % mod\n \n        if N % 2:\n            return (b*c - (c-b)*(b-a) + mod) % mod\n        return (b*b - (b-a)*(b-a) + mod) % mod\n \n \n# t = int(input())\nt=1\nwhile t > 0:\n    # N = int(input())\n    N=10\n    obj = Solution()\n    print(obj.countStrings(N))\n    t -= 1\n# Code contributed by Chetan Chaudhary\n"], "Count of total anagram substrings -  ": ["# Python3 program to count total anagram\n# substring of a string\ndef countOfAnagramSubstring(s):\n     \n    # Returns total number of anagram\n    # substrings in s\n    n = len(s)\n    mp = dict()\n     \n    # loop for length of substring\n    for i in range(n):\n        sb = ''\n        for j in range(i, n):\n            sb = ''.join(sorted(sb + s[j]))\n            mp[sb] = mp.get(sb, 0)\n             \n            # increase count corresponding\n            # to this dict array\n            mp[sb] += 1\n \n    anas = 0\n     \n    # loop over all different dictionary \n    # items and aggregate substring count\n    for k, v in mp.items():\n        anas += (v*(v-1))//2\n    return anas\n \n# Driver Code\ns = 'xyyx'\nprint(countOfAnagramSubstring(s))\n \n# This code is contributed by fgaim\n"], "URLify a given string (Replace spaces with %20) -  ": ["#Python code for the same approach\ndef replaceSpaces(input):\n    rep = '%20'\n    for i in range(len(input)):\n        if(input[i] == ' '):\n            input = input.replace(input[i],rep)\n    print(input)\n \n# driver code\ninput = 'Mr John Smith'\nreplaceSpaces(input)\n \n# This code is contributed by shinjanpatra\n", "# Maximum length of string after modifications.\nMAX = 1000;\n \n# Replaces spaces with %20 in-place and returns\n# new length of modified string. It returns -1\n# if modified string cannot be stored in str[]\ndef replaceSpaces(string):\n     \n    # Remove remove leading and trailing spaces\n    string = string.strip()\n \n    i = len(string)\n \n    # count spaces and find current length\n    space_count = string.count(' ')\n \n    # Find new length.\n    new_length = i + space_count * 2\n \n    # New length must be smaller than length\n    # of string provided.\n    if new_length > MAX:\n        return -1\n \n    # Start filling character from end\n    index = new_length - 1\n \n    string = list(string)\n \n    # Fill string array\n    for f in range(i - 2, new_length - 2):\n        string.append('0')\n \n    # Fill rest of the string from end\n    for j in range(i - 1, 0, -1):\n \n        # inserts %20 in place of space\n        if string[j] == ' ':\n            string[index] = '0'\n            string[index - 1] = '2'\n            string[index - 2] = '%'\n            index = index - 3\n        else:\n            string[index] = string[j]\n            index -= 1\n \n    return ''.join(string)\n \n# Driver Code\nif __name__ == '__main__':\n    s = 'Mr John Smith '\n    s = replaceSpaces(s)\n    print(s)\n \n# This code is contributed by Vinayak\n", "# Python3 implementation of above approach\n \n# Instantiate the string\ns = 'Mr John Smith '\n \n# Trim the given string\ns = s.strip()\n \n# Replace All space (unicode is \\\\s) to %20\ns = s.replace(' ', '%20')\n \n# Display the result\nprint(s) \n \n# This code is contributed by vinayak\n"], "Queries for characters in a repeated string -  ": ["# Queries for same characters in a repeated\n# string\n \n# Print whether index i and j have same\n# element or not.\ndef query(s, i, j):\n    n = len(s)\n \n    # Finding relative position of index i,j.\n    i %= n\n    j %= n\n \n    # Checking is element are same at index i, j.\n    print('Yes') if s[i] == s[j] else print('No')\n \n# Driver code\nif __name__ == '__main__':\n    X = ' '\n    query(X, 0, 8)\n    query(X, 8, 13)\n    query(X, 6, 15)\n \n# This code is contributed by\n# sanjeev2552\n"], "K'th Non-repeating Character -  ": ["# Define a function to find the kth non-repeating character\n# in a string\ndef kthNonRepeatingChar(s: str, k: int) -> str:\n    # Initialize count and result variables to 0 and null\n    # character, respectively\n    count = 0\n    result = '\\0'\n \n    # Loop through each character in the string\n    for i in range(len(s)):\n        # Assume that the current character does not repeat\n        repeating = False\n \n        # Loop through the rest of the string to check if\n        # the current character repeats\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j]:\n                # If the current character repeats, set the\n                # repeating flag to true and exit the loop\n                repeating = True\n                break\n \n        # If the current character does not repeat,\n        # increment the count of non-repeating characters\n        if not repeating:\n            count += 1\n            # If the count of non-repeating characters\n            # equals k, set the result variable to the\n            # current character and exit the loop\n            if count == k:\n                result = s[i]\n                break\n \n    # Return the result variable\n    return result\n \n# Define the main function to test the kthNonRepeatingChar\n# function\nif __name__ == '__main__':\n    # Define an example string and value of k\n    s = ' '\n    k = 3\n \n    # Call the kthNonRepeatingChar function with the\n    # example string and value of k\n    result = kthNonRepeatingChar(s, k)\n \n    # Check if the result variable contains a non-null\n    # character and print the appropriate message\n    if result == '\\0':\n        print('There is no kth non-repeating character '\n                'in the string.')\n    else:\n        print(f'The {k}th non-repeating character in the string '\n                f'is {result}.')\n \n# This code is contributed by Susobhan Akhuli\n", "# Python code of the above approach\ndef kth_non_repeating_char(string, k):\n    # Create an empty dictionary to store \n    # the counts of each character in the string\n    char_counts = {}\n \n    # Loop through the string and store \n    # the counts of each character in the dictionary\n    for char in string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n \n    # Loop through the string and find the kth non-repeating character\n    non_repeating_count = 0\n    for char in string:\n        if char_counts[char] == 1:\n            non_repeating_count += 1\n            if non_repeating_count == k:\n                # When the count of non-repeating \n                # characters equals k, return the character\n                return char\n \n    # If there is no kth non-repeating character in the string, return None\n    return None\n \n# Main function\nif __name__ == '__main__':\n    string = ' '\n    k = 3\n \n    result = kth_non_repeating_char(string, k)\n \n    if result is None:\n        print('There is no kth non-repeating character in the string.')\n    else:\n        print(f'The {k}th non-repeating character in the string is {result}.')\n \n# This code is contributed by Susobhan Akhuli\n"], "Check if all levels of two trees are anagrams or not -  ": ["# Iterative program to check if two\n# trees are level by level anagram\n \n# A Binary Tree Node\n# Utility function to create a\n# new tree Node\n \n \nclass newNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = self.right = None\n \n# Returns true if trees with root1\n# and root2 are level by level\n# anagram, else returns false.\n \n \ndef areAnagrams(root1, root2):\n \n    # Base Cases\n    if (root1 == None and root2 == None):\n        return True\n    if (root1 == None or root2 == None):\n        return False\n \n    # start level order traversal of\n    # two trees using two queues.\n    q1 = []\n    q2 = []\n    q1.append(root1)\n    q2.append(root2)\n \n    while (1):\n \n        # n1 (queue size) indicates number\n        # of Nodes at current level in first\n        # tree and n2 indicates number of nodes\n        # in current level of second tree.\n        n1 = len(q1)\n        n2 = len(q2)\n \n        # If n1 and n2 are different\n        if (n1 != n2):\n            return False\n \n        # If level order traversal is over\n        if (n1 == 0):\n            break\n \n        # Dequeue all Nodes of current level\n        # and Enqueue all Nodes of next level\n        curr_level1 = []\n        curr_level2 = []\n        while (n1 > 0):\n            node1 = q1[0]\n            q1.pop(0)\n            if (node1.left != None):\n                q1.append(node1.left)\n            if (node1.right != None):\n                q1.append(node1.right)\n            n1 -= 1\n \n            node2 = q2[0]\n            q2.pop(0)\n            if (node2.left != None):\n                q2.append(node2.left)\n            if (node2.right != None):\n                q2.append(node2.right)\n \n            curr_level1.append(node1.data)\n            curr_level2.append(node2.data)\n \n        # Check if nodes of current levels\n        # are anagrams or not.\n        curr_level1.sort()\n        curr_level2.sort()\n        if (curr_level1 != curr_level2):\n            return False\n \n    return True\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # Constructing both the trees.\n    root1 = newNode(1)\n    root1.left = newNode(3)\n    root1.right = newNode(2)\n    root1.right.left = newNode(5)\n    root1.right.right = newNode(4)\n \n    root2 = newNode(1)\n    root2.left = newNode(2)\n    root2.right = newNode(3)\n    root2.left.left = newNode(4)\n    root2.left.right = newNode(5)\n    if areAnagrams(root1, root2):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed\n# by SHUBHAMSINGH10\n", "# Python code for above approach\n \n# A Binary Tree Node\n \n \nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n \n# Returns true if trees with root1 and root2\n# are level by level anagram, else returns false.\n \n \ndef areAnagrams(root1, root2):\n    # Base Cases\n    if (root1 == None and root2 == None):\n        return True\n    if (root1 == None or root2 == None):\n        return False\n \n    # start level order traversal of two trees\n    # using two queues.\n    q1 = []\n    q2 = []\n    q1.append(root1)\n    q2.append(root2)\n \n    # Hashmap to store the elements that occur in each\n    # level.\n    m = {}\n \n    while (len(q1) > 0 and len(q2) > 0):\n        # n1 (queue size) indicates number of Nodes\n        # at current level in first tree and n2 indicates\n        # number of nodes in current level of second tree.\n        n1 = len(q1)\n        n2 = len(q2)\n \n        # If n1 and n2 are different\n        if (n1 != n2):\n            return False\n \n        # If level order traversal is over\n        if (n1 == 0):\n            break\n \n        # Dequeue all Nodes of current level and\n        # Enqueue all Nodes of next level\n        while (n1 > 0):\n            node1 = q1.pop(0)\n \n            # Insert element into hashmap\n            m[node1.data] = m.get(node1.data, 0) + 1\n \n            # Insert left and right nodes into queue if\n            # exists.\n            if (node1.left != None):\n                q1.append(node1.left)\n            if (node1.right != None):\n                q1.append(node1.right)\n            n1 -= 1\n \n        while (n2 > 0):\n            node2 = q2.pop(0)\n \n            # if element from second tree isn't present in\n            # the first tree of same level then it can't be\n            # an anagram.\n            if (m.get(node2.data, 0) == 0):\n                return False\n \n            # Reduce frequency of element if present else\n            # adds it element to hash map with negative\n            # frequency.\n            m[node2.data] = m.get(node2.data, 0) - 1\n \n            # If frequency of the element becomes zero then\n            # remove the element from hashmap.\n            if (m[node2.data] == 0):\n                m.pop(node2.data)\n \n            # Insert left and right nodes into queue if\n            # exists.\n            if (node2.left != None):\n                q2.append(node2.left)\n            if (node2.right != None):\n                q2.append(node2.right)\n            n2 -= 1\n \n        # If nodes of current levels are anagrams the\n        # hashmap wouldn't contain any elements.\n        if (len(m) > 0):\n            return False\n \n    if(len(q1) == 0 and len(q2) == 0):\n        return True\n    return False\n \n# Utility function to create a new tree Node\n \n \ndef newNode(data):\n    temp = Node(data)\n    temp.left = None\n    temp.right = None\n    return temp\n \n \n# Driver program to test above functions\nif __name__ == '__main__':\n \n    # Constructing both the trees.\n    root1 = newNode(1)\n    root1.left = newNode(3)\n    root1.right = newNode(2)\n    root1.right.left = newNode(5)\n    root1.right.right = newNode(4)\n \n    root2 = newNode(1)\n    root2.left = newNode(2)\n    root2.right = newNode(3)\n    root2.left.left = newNode(4)\n    root2.left.right = newNode(5)\n \n    if (areAnagrams(root1, root2)):\n        print('Yes')\n    else:\n        print('No')\n \n# This code is contributed by adityamaharshi21\n"], "Second most repeated word in a sequence -  ": ["from collections import Counter \n  \ndef secFrequent(arr): \n    # Counting frequency of each element \n    freq = Counter(arr) \n  \n    max_freq = max(freq.values()) \n    a = [x for x in freq.values() if x != max_freq] \n    a.sort() \n  \n    # Returning second most frequent element \n    for x in freq: \n        if freq[x] == a[-1]: \n            return x \n  \n    return '-1'\n  \narr = ['ccc', 'aaa', 'ccc', 'ddd', 'aaa', 'aaa'] \nans = secFrequent(arr) \nprint(ans) \n", "# Python3 program to find out the second \n# most repeated word \n  \n# Function to find the word \ndef secMostRepeated(seq): \n      \n    # Store all the words with its occurrence \n    occ = {} \n    for i in range(len(seq)): \n        occ[seq[i]] = occ.get(seq[i], 0) + 1\n  \n    # Find the second largest occurrence \n    first_max = -10**8\n    sec_max = -10**8\n  \n    for it in occ: \n        if (occ[it] > first_max): \n            sec_max = first_max \n            first_max = occ[it] \n              \n        elif (occ[it] > sec_max and \n              occ[it] != first_max): \n            sec_max = occ[it] \n  \n    # Return with occurrence equals \n    # to sec_max \n    for it in occ: \n        if (occ[it] == sec_max): \n            return it \n  \n# Driver code \nif __name__ == '__main__': \n      \n    seq = [ 'ccc', 'aaa', 'ccc', \n            'ddd', 'aaa', 'aaa' ] \n    print(secMostRepeated(seq)) \n  \n# This code is contributed by mohit kumar 29\n"], "Camel case of a given sentence -  ": ["# Python3 program to convert given sentence\n# to camel case.\n \n# Function to remove spaces and convert\n# into camel case\ndef convert(string):\n    while True:\n        i = 0\n        while i < len(string):\n            if string[i] == ' ':\n                string = string[:i] + string[i+1:].capitalize()\n                # Terminate inner loop after removing a space and making character next to it as capital\n                break\n            i += 1\n        # Terminate outer loop when we reach to the end of string\n        if i == len(string):\n            break\n    return string\n \n \n# Driver program\nif __name__ == '__main__':\n    string = 'I get intern at  '\n    print(convert(string))\n"], "Count number of equal pairs in a string -  ": ["# Python3 program to count the \n# number of pairs \nMAX = 256\n \n# Function to count the number \n# of equal pairs\ndef countPairs(s):\n     \n    # Hash table \n    cnt = [0 for i in range(0, MAX)]\n \n    # Traverse the string and count \n    # occurrence \n    for i in range(len(s)):\n        cnt[ord(s[i]) - 97] += 1\n \n    # Stores the answer \n    ans = 0\n \n    # Traverse and check the occurrence \n    # of every character \n    for i in range(0, MAX):\n        ans += cnt[i] * cnt[i]\n \n    return ans\n \n# Driver code \nif __name__=='__main__':\n    s = ' '\n    print(countPairs(s))\n \n# This code is contributed \n# by Sairahul099         \n"], "Program to find Smallest and Largest Word in a String -  ": ["# Python3 program to find Smallest and \n# Largest Word in a String\n \n# defining the method to find the longest \n# word and the shortest word\ndef minMaxLengthWords(inp):\n    length = len(inp)\n    si = ei = 0\n    min_length = length\n    min_start_index = max_length = max_start_index = 0\n     \n    # loop to find the length and stating index\n    # of both longest and shortest words\n    while ei <= length:\n        if (ei < length) and (inp[ei] != ' '):\n            ei += 1\n        else:\n            curr_length = ei - si\n             \n            # condition checking for the shortest word\n            if curr_length < min_length:\n                min_length = curr_length\n                min_start_index = si\n                 \n            # condition for the longest word \n            if curr_length > max_length:\n                max_length = curr_length\n                max_start_index = si\n            ei += 1\n            si = ei\n             \n    # extracting the shortest word using \n    # it's starting index and length     \n    minWord = inp[min_start_index : \n                  min_start_index + min_length]\n     \n    # extracting the longest word using \n    # it's starting index and length     \n    maxWord = inp[max_start_index : max_length]\n     \n    # printing the final result\n    print('Minimum length word: ', minWord)\n    print ('Maximum length word: ', maxWord)\n     \n# Driver Code\n \n# Using this string to test our code\na = '  A Computer Science portal for Geeks'\nminMaxLengthWords(a)\n \n# This code is contributed by Animesh_Gupta\n"], "Divide large number represented as string -  ": ["# Python3 program to implement division  \n# with large number  \nimport math \n  \n# A function to perform division of  \n# large numbers  \ndef longDivision(number, divisor):  \n  \n    # As result can be very large  \n    # store it in string  \n    ans = '';  \n      \n    # Find prefix of number that  \n    # is larger than divisor.  \n    idx = 0;  \n    temp = ord(number[idx]) - ord('0'); \n    while (temp < divisor): \n        temp = (temp * 10 + ord(number[idx + 1]) -\n                            ord('0')); \n        idx += 1; \n      \n    idx += 1; \n  \n    # Repeatedly divide divisor with temp.  \n    # After every division, update temp to  \n    # include one more digit.  \n    while ((len(number)) > idx):  \n          \n        # Store result in answer i.e. temp / divisor  \n        ans += chr(math.floor(temp // divisor) + ord('0'));  \n          \n        # Take next digit of number \n        temp = ((temp % divisor) * 10 + ord(number[idx]) -\n                                        ord('0')); \n        idx += 1; \n  \n    ans += chr(math.floor(temp // divisor) + ord('0')); \n      \n    # If divisor is greater than number  \n    if (len(ans) == 0):  \n        return '0';  \n      \n    # else return ans  \n    return ans;  \n  \n# Driver Code \nnumber = '1248163264128256512';  \ndivisor = 125;  \nprint(longDivision(number, divisor));  \n      \n# This code is contributed by mits \n"], "Add n binary strings -  ": ["# Python3 program to add n binary strings\n \n# This function adds two binary strings and \n# return result as a third string\ndef addBinaryUtil(a, b):\n     \n    result = ''; # Initialize result\n    s = 0;       # Initialize digit sum\n \n    # Traverse both strings \n    # starting from last characters\n    i = len(a) - 1;\n    j = len(b) - 1;\n    while (i >= 0 or j >= 0 or s == 1):\n \n        # Compute sum of last digits and carry\n        s += (ord(a[i]) - ord('0')) if(i >= 0) else 0;\n        s += (ord(b[j]) - ord('0')) if(j >= 0) else 0;\n \n        # If current digit sum is 1 or 3, \n        # add 1 to result\n        result = chr(s % 2 + ord('0')) + result;\n \n        # Compute carry\n        s //= 2;\n \n        # Move to next digits\n        i -= 1;\n        j -= 1;\n \n    return result;\n \n# function to add n binary strings\ndef addBinary(arr, n):\n    result = '';\n    for i in range(n):\n        result = addBinaryUtil(result, arr[i]);\n    return result;\n \n# Driver code\narr = ['1', '10', '11'];\nn = len(arr);\nprint(addBinary(arr, n));\n     \n# This code is contributed by mits\n", "def addBinary(arr):\n    # Initialize a variable to store the sum of binary numbers\n    sum = 0\n \n    # Loop through each binary number in the input array\n    for i in range(len(arr)):\n        # Initialize a variable to store the decimal value of the binary number\n        num = 0\n \n        # Convert the binary number to its decimal equivalent\n        for j in range(len(arr[i]) - 1, -1, -1):\n            if arr[i][j] == '1':\n                num += 2**(len(arr[i]) - j - 1)\n \n        # Add the decimal value of the binary number to the total sum\n        sum += num\n \n    # Initialize an empty string to store the final result\n    result = ''\n \n    # Convert the sum to a binary string representation\n    while sum > 0:\n        result = ('0' if sum % 2 == 0 else '1') + result\n        sum = sum // 2\n \n    # Return the final binary string representation\n    return result\n \n \n# Driver code\narr = ['1', '10', '11']\nprint(addBinary(arr))\n# THIS CODE IS CONTRIBUTED CHANDAN AGARWAL\n"], "Generate all binary strings from given pattern -  ": ["# Recursive Python program to generate all\n# binary strings formed by replacing\n# each wildcard character by 0 or 1\n \n# Recursive function to generate all binary\n# strings formed by replacing each wildcard\n# character by 0 or 1\ndef _print(string, index):\n    if index == len(string):\n        print(''.join(string))\n        return\n \n    if string[index] == '?':\n \n        # replace '?' by '0' and recurse\n        string[index] = '0'\n        _print(string, index + 1)\n \n        # replace '?' by '1' and recurse\n        string[index] = '1'\n        _print(string, index + 1)\n \n        # NOTE: Need to backtrack as string\n        # is passed by reference to the\n        # function\n        string[index] = '?'\n    else:\n        _print(string, index + 1)\n \n# Driver code\nif __name__ == '__main__':\n \n    string = '1??0?101'\n    string = list(string)\n    _print(string, 0)\n \n    # This code is contributed by\n    # sanjeev2552\n \n# Note: function name _print is used because\n# print is already a predefined function in Python\n", "# Iterative Python program to generate all binary\n# strings formed by replacing each wildcard\n# character by 0 or 1\n  \n# Iterative function to generate all binary strings\n# formed by replacing each wildcard character by 0\n# or 1\ndef Print(Str):\n    q = []\n    q.append(Str)\n    while(len(q) > 0):\n        Str = q[0]\n         \n        # find position of first occurrence of wildcard\n        try:\n            index = Str.index('?')\n        except ValueError:\n            index = -1\n             \n        # If no matches were found,\n        # find returns -1\n        if(index != -1):\n            \n            # replace '?' by '0' and push string into queue\n            s1=Str.replace('?','0',1)\n            q.append(s1)\n             \n            # replace '?' by '1' and push string into queue\n            s2=Str.replace('?','1',1)\n            q.append(s2)\n        else:\n            # If no wildcard characters are left,\n            # print the string.\n            print(Str)\n        q.pop(0)\n             \n# Driver code\nStr = '1??0?101'\nPrint(Str)\n \n# This code is contributed by Pushpesh Raj\n", "#we store processed strings in all (array)\n#we see if string as '?', if so, replace it with 0 and 1\n#and send it back to recursive func until base case is reached\n#which is no wildcard left\n \nres = []\ndef genBin(s):\n    if '?' in s:\n        s1 = s.replace('?','0',1) #only replace once\n        s2 = s.replace('?','1',1) #only replace once\n        genBin(s1)\n        genBin(s2)\n    else: res.append(s)\n \n# Driver code\ngenBin('1??0?101')\nprint(res)\n \n# This code is contributed by\n# divay pandey\n"], "Count strings with consecutive 1's -  ": ["# Python program to count all distinct\n# binary strings with two consecutive 1's\n \n# Gives count of n length binary\n# strings with consecutive 1's\ndef countStrings(n, ind, s, ans):\n    if ind == n:\n        count = 0\n        temp = 0\n        for i in range(n):\n            if s[i] == '1':\n                temp += 1\n            else:\n                temp = 0\n            count = max(count, temp)\n        if count >= 2:\n            ans[0] += 1\n        return\n     \n    countStrings(n, ind + 1, s + '0', ans)\n    countStrings(n, ind + 1, s + '1', ans)\n \n# Driver code\nif __name__ == '__main__':\n    ans = [0]\n    countStrings(3, 0, '', ans)\n    print(ans[0])\n \n# This code is contributed by Susobhan Akhuli\n", "# Python 3 program to count all\n# distinct binary strings with\n# two consecutive 1's\n \n \n# Returns count of n length\n# binary strings with\n# consecutive 1's\ndef countStrings(n):\n \n    # Count binary strings without\n    # consecutive 1's.\n    # See the approach discussed on be\n    # ( http://goo.gl/p8A3sW )\n    a = [0] * n\n    b = [0] * n\n    a[0] = b[0] = 1\n    for i in range(1, n):\n        a[i] = a[i - 1] + b[i - 1]\n        b[i] = a[i - 1]\n \n    # Subtract a[n-1]+b[n-1] from 2^n\n    return (1 << n) - a[n - 1] - b[n - 1]\n \n \n# Driver code\nprint(countStrings(5))\n \n \n# This code is contributed\n# by Nikita tiwari.\n"], "Minimum insertions to form a palindrome with permutations allowed -  ": ["# Python3 program to find minimum number \n# of insertions to make a string \n# palindrome \nimport math as mt \n  \n# Function will return number of \n# characters to be added \ndef minInsertion(tr1): \n  \n    # To store string length \n    n = len(str1) \n  \n    # To store number of characters \n    # occurring odd number of times \n    res = 0\n  \n    # To store count of each \n    # character \n    count = [0 for i in range(26)] \n  \n    # To store occurrence of each \n    # character \n    for i in range(n): \n        count[ord(str1[i]) - ord('a')] += 1\n  \n    # To count characters with odd \n    # occurrence \n    for i in range(26): \n        if (count[i] % 2 == 1): \n            res += 1\n  \n    # As one character can be odd return \n    # res - 1 but if string is already \n    # palindrome return 0 \n    if (res == 0): \n        return 0\n    else: \n        return res - 1\n  \n# Driver Code \nstr1 = ' '\nprint(minInsertion(str1)) \n  \n# This code is contributed by  \n# Mohit kumar 29 \n", "# Python program to find minimum number \n# of insertions to make a string \n# palindrome \n  \n# Function will return number of \n# characters to be added \ndef minInsertion(str): \n    mask = 0\n  \n    for c in str: \n        mask ^= (1 << (ord(c) - ord('a'))) \n  \n    if mask == 0: \n        return 0\n    count = 0\n  \n    while mask: \n        count += mask & 1\n        mask = mask >> 1\n  \n    return count - 1\n  \nstr = ' '\nprint(minInsertion(str)) \n  \n# This code is contributed by ishankhandelwals.\n"], "Make largest palindrome by changing at most K-digits -  ": ["# Python3 program to get largest palindrome changing\n# atmost K digits\n \n# Returns maximum possible \n# palindrome using k changes\ndef maximumPalinUsingKChanges(strr, k):\n    palin = strr[::]\n \n    # Initialize l and r by leftmost and\n    # rightmost ends\n    l = 0\n    r = len(strr) - 1\n \n    # first try to make palindrome\n    while (l <= r):\n \n        # Replace left and right character by\n        # maximum of both\n        if (strr[l] != strr[r]):\n            palin[l] = palin[r] =\n                   max(strr[l], strr[r])\n \n            # print(strr[l],strr[r])\n            k -= 1\n        l += 1\n        r -= 1\n \n    # If k is negative then we can't make\n    # palindrome\n    if (k < 0):\n        return 'Not possible'\n \n    l = 0\n    r = len(strr) - 1\n \n    while (l <= r):\n \n        # At mid character, if K>0 then change\n        # it to 9\n        if (l == r):\n            if (k > 0):\n                palin[l] = '9'\n \n        # If character at lth (same as rth) is\n        # less than 9\n        if (palin[l] < '9'):\n \n            # If none of them is changed in the\n            # previous loop then subtract 2 from K\n            # and convert both to 9 \n            if (k >= 2 and palin[l] == strr[l] and\n                           palin[r] == strr[r]):\n                k -= 2\n                palin[l] = palin[r] = '9'\n \n            # If one of them is changed in the previous\n            # loop then subtract 1 from K (1 more is\n            # subtracted already) and make them 9 \n            elif (k >= 1 and (palin[l] != strr[l] or\n                              palin[r] != strr[r])):\n                k -= 1\n                palin[l] = palin[r] = '9'\n \n        l += 1\n        r -= 1\n \n    return palin\n \n \n# Driver code\nst = '43435'\nstrr = [i for i in st]\nk = 3\na = maximumPalinUsingKChanges(strr, k)\nprint(''.join(a))\n \n# This code is contributed by mohit kumar 29\n", "# Python program for the above approach\n \n# Function to make the string palindromic\n# by atmost K operations\ndef make_palindrome(s, k):\n    n = len(s)\n    replacements = 0\n    s = list(s)\n \n    # Iterate over the range [0, N/2]\n    for i in range(n//2):\n        j = n - i - 1\n        if s[i] != s[j]:\n            if s[i] > s[j]:\n                s[j] = s[i]\n            else:\n                s[i] = s[j]\n            replacements += 1\n \n            # If replacement is not possible\n            if replacements > k:\n                return '-1'\n \n    for i in range(n//2):\n        j = n - i - 1\n        if s[i] != '9':\n            if replacements < k and (i == 0 or i == j):\n                s[i] = s[j] = '9'\n                replacements += 1\n            elif replacements <= k - 2:\n                s[i] = s[j] = '9'\n                replacements += 2\n    if n % 2 != 0 and replacements < k:\n        s[n//2] = '9'\n \n    # Return the resultant string\n    return ''.join(s)\n \n \n# Driver Code\nS = '43435'\nK = 3\n \nprint(make_palindrome(S, K))\n"], "Minimum characters to be added at front to make string palindrome -  ": ["# Python 3 program for getting minimum character\n# to be added at front to make string palindrome\n \n# function for checking string is \n# palindrome or not\ndef ispalindrome(s):\n \n    l = len(s)\n     \n    i = 0\n    j = l - 1\n    while i <= j:\n     \n        if(s[i] != s[j]):\n            return False\n        i += 1\n        j -= 1\n     \n    return True\n \n# Driver code\nif __name__ == '__main__':\n     \n    s = 'BABABAA'\n    cnt = 0\n    flag = 0\n     \n    while(len(s) > 0):\n     \n        # if string becomes palindrome then break\n        if(ispalindrome(s)):\n            flag = 1\n            break\n         \n        else:\n            cnt += 1\n         \n            # erase the last element of the string\n            s = s[:-1]\n     \n    # print the number of insertion at front\n    if(flag):\n        print(cnt)\n \n# This code is contributed by ita_c\n", "# Python3 program for getting minimum \n# character to be added at the front\n# to make string palindrome \n \n# Returns vector lps for given string str \ndef computeLPSArray(string): \n \n    M = len(string) \n    lps = [None] * M \n \n    length = 0\n    lps[0] = 0 # lps[0] is always 0 \n \n    # the loop calculates lps[i] \n    # for i = 1 to M-1 \n    i = 1\n    while i < M: \n     \n        if string[i] == string[length]: \n         \n            length += 1\n            lps[i] = length \n            i += 1\n         \n        else: # (str[i] != str[len]) \n         \n            # This is tricky. Consider the example. \n            # AAACAAAA and i = 7. The idea is \n            # similar to search step. \n            if length != 0:\n             \n                length = lps[length - 1] \n \n                # Also, note that we do not \n                # increment i here \n             \n            else: # if (len == 0) \n             \n                lps[i] = 0\n                i += 1\n \n    return lps \n \n# Method returns minimum character \n# to be added at front to make \n# string palindrome \ndef getMinCharToAddedToMakeStringPalin(string): \n \n    revStr = string[::-1]\n \n    # Get concatenation of string, \n    # special character and reverse string \n    concat = string + '$' + revStr \n \n    # Get LPS array of this\n    # concatenated string \n    lps = computeLPSArray(concat) \n \n    # By subtracting last entry of lps \n    # vector from string length, we\n    # will get our result \n    return len(string) - lps[-1] \n \n# Driver Code\nif __name__ == '__main__': \n \n    string = 'AACECAAAA'\n    print(getMinCharToAddedToMakeStringPalin(string)) \n     \n# This code is contributed by Rituraj Jain\n", "class Solution:\n    def addMinChar(self, str1):\n        n = len(str1)\n        start = 0\n        end = n - 1\n        res = 0\n        while start < end:  # While the pointers have not met in the middle of the string\n            if str1[start] == str1[end]:  # If the characters at the start and end pointers are equal\n                start += 1  # Move the start pointer to the right\n                end -= 1  # Move the end pointer to the left\n            else:\n                res += 1  # Increment the count of characters to be added\n                start = 0  # Reset the start pointer to the beginning of the string\n                end = n - res - 1  # Reset the end pointer to the end of the string with a reduced number of characters\n        return res  # Return the count of characters to be added\n \nif __name__ == '__main__':\n    string = 'AACECAAAA'\n    print(addMinChar(string))\n", "# Python3 program for getting minimum character to be\n# added at front to make string palindrome\ndef compute_z_array(string):\n    n = len(string)\n    Z = [0] * n\n    l = 0\n    r = 0\n \n    for i in range(1, n):\n        if i <= r:\n            # Calculate the Z value as Z[i - l].\n            # It means the value of Z from its prefix.\n            # The Z value is the maximum range which is \n            # currently equal starting from i, i.e. r - i + 1.\n            # Take the minimum of the two.\n            Z[i] = min(Z[i - l], r - i + 1)\n \n        # Check the prefix value and current value of Z.\n        while i + Z[i] < n and string[Z[i]] == string[i + Z[i]]:\n            Z[i] += 1\n \n        # Update l and r if a better range is found.\n        if i + Z[i] - 1 > r:\n            l = i\n            r = i + Z[i] - 1\n \n    return Z\n \n \ndef get_min_char_to_make_string_palindrome(string):\n    n = len(string)\n    rev_str = string[::-1]  # Reverse the string\n    concat = string + '$' + rev_str  # Concatenate the original string, a special character '$', and the reversed string\n    characters_to_remove = float('-inf')  # Count of characters to remove from the string\n \n    # Compute the Z array using the Z-Algorithm\n    Z = compute_z_array(concat)\n \n    # Add them to the result if the Z value at index i touches the last character of the string.\n    for i in range(len(Z)):\n        if Z[i] == len(concat) - i:\n            characters_to_remove = max(characters_to_remove, Z[i])\n \n    return n - characters_to_remove\n \n \n# Driver code\nstr = 'AACECAAAA'\nprint(get_min_char_to_make_string_palindrome(str))\n"], "Print all Palindromic Partitions of a String using Bit Manipulation -  ": ["class PalindromePartition:\n    def __init__(self):\n        self.ans = []\n \n    def check_palindrome(self, curr_partition):\n        for s in curr_partition:\n            n = len(s)\n            i, j = 0, n - 1\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n        return True\n \n    def generate_partition(self, s, bit_string):\n        curr_partition = []\n        sub_string = s[0]\n        for i in range(len(bit_string)):\n            # If current character of bitString is '0', no cut will be made,\n            # and the next character will be included in the current subString.\n            if bit_string[i] == '0':\n                # No cut is made, so the next character is added to the substring.\n                sub_string += s[i + 1]\n            # If the current character of bitString is '1', then a cut will be made,\n            # and the current subString will be appended in the current partition,\n            # and a new subString will start from the next position.\n            else:\n                # SubString is added to the current partition.\n                curr_partition.append(sub_string)\n \n                # New substring is created starting from the next position of the string s.\n                sub_string = s[i + 1]\n \n        curr_partition.append(sub_string)\n        if self.check_palindrome(curr_partition):\n            self.ans.append(curr_partition)\n \n    def bit_manipulation(self, s, bit_string):\n        # When a bitString is generated, generate_partition() will be called\n        # to partition the string accordingly.\n        if len(bit_string) == len(s) - 1:\n            self.generate_partition(s, bit_string)\n            return\n        bit_string += '1'\n        self.bit_manipulation(s, bit_string)\n        bit_string = bit_string[:-1]  # Pop the last character\n        bit_string += '0'\n        self.bit_manipulation(s, bit_string)\n \n    def partition(self, s):\n        bit_string = ''\n        self.bit_manipulation(s, bit_string)\n        return self.ans\n \n \nif __name__ == '__main__':\n    ob = PalindromePartition()\n    s = 'geeks'\n    ans = ob.partition(s)\n    for v in ans:\n        print(' '.join(v))\n"], "Online algorithm for checking palindrome in a stream -  ": [], "Check if characters of a given string can be rearranged to form a palindrome -  ": ["# Python3 implementation to check if\n# characters of a given string can\n# be rearranged to form a palindrome\n \nNO_OF_CHARS = 256\n \n# function to check whether characters\n# of a string can form a palindrome\n \n \ndef canFormPalindrome(st):\n \n    # Create a count array and initialize\n    # all values as 0\n    count = [0] * (NO_OF_CHARS)\n \n    # For each character in input strings,\n    # increment count in the corresponding\n    # count array\n    for i in range(0, len(st)):\n        count[ord(st[i])] = count[ord(st[i])] + 1\n \n    # Count odd occurring characters\n    odd = 0\n \n    for i in range(0, NO_OF_CHARS):\n        if (count[i] & 1):\n            odd = odd + 1\n \n        if (odd > 1):\n            return False\n \n    # Return true if odd count is 0 or 1,\n    return True\n \n \n# Driver code\nif(canFormPalindrome(' ')):\n    print('Yes')\nelse:\n    print('No')\n \nif(canFormPalindrome('geeksogeeks')):\n    print('Yes')\nelse:\n    print('No')\n \n# This code is contributed by Nikita Tiwari.\n", "''' \n* function to check whether characters of \na string can form a palindrome \n'''\n \n \ndef canFormPalindrome(strr):\n \n    # Create a list\n    listt = []\n \n    # For each character in input strings,\n    # remove character if list contains\n    # else add character to list\n    for i in range(len(strr)):\n        if (strr[i] in listt):\n            listt.remove(strr[i])\n        else:\n            listt.append(strr[i])\n \n    # if character length is even \n    # list is expected to be empty\n    # or if character length is odd \n    # list size is expected to be 1\n    if (len(strr) % 2 == 0 and len(listt) == 0 or\n            (len(strr) % 2 == 1 and len(listt) == 1)):\n        return True\n    else:\n        return False\n \n \n# Driver code\nif (canFormPalindrome(' ')):\n    print('Yes')\nelse:\n    print('No')\n \nif (canFormPalindrome('geeksogeeks')):\n    print('Yes')\nelse:\n    print('No')\n \n# This code is contributed by SHUBHAMSINGH10\n", "# Python3 implementation of above approach.\ndef canFormPalindrome(s):\n    bitvector = 0\n    for str in s:\n        bitvector ^= 1 << ord(str)\n    return bitvector == 0 or bitvector & (bitvector - 1) == 0\n \n \n#s = input()  \nif canFormPalindrome(' '):\n    print('Yes')\nelse:\n    print('No')\n \n    # This code is contributed by sahilmahale0\n"], "Check if a given string is a rotation of a palindrome -  ": ["# Python program to check if a given string is a rotation\n# of a palindrome\n \n# A utility function to check if a string str is palindrome\ndef isPalindrome(string):\n \n    # Start from leftmost and rightmost corners of str\n    l = 0\n    h = len(string) - 1\n \n    # Keep comparing characters while they are same\n    while h > l:\n        l+= 1\n        h-= 1\n        if string[l-1] != string[h + 1]:\n            return False\n \n    # If we reach here, then all characters were matching    \n    return True\n \n# Function to check if a given string is a rotation of a\n# palindrome.\ndef isRotationOfPalindrome(string):\n \n    # If string itself is palindrome\n    if isPalindrome(string):\n        return True\n \n    # Now try all rotations one by one\n    n = len(string)\n    for i in range(n-1):\n        string1 = string[i + 1:n]\n        string2 = string[0:i + 1]\n \n        # Check if this rotation is palindrome\n        string1+=(string2)\n        if isPalindrome(string1):\n            return True\n \n    return False\n \n# Driver program\nprint ('1' if isRotationOfPalindrome('aab') == True else '0')\nprint ('1' if isRotationOfPalindrome('abcde') == True else '0')\nprint ('1' if isRotationOfPalindrome('aaaad') == True else '0')\n \n# This code is contributed by BHAVYA JAIN\n", "# Python implementation of the approach \n \n# Function to check if we have found \n# a palindrome of same length as the input \n# which is a rotation of the input string \ndef checkPal (x, Len):\n \n    if (x == Len):\n        return True\n    elif (x > Len):\n        if ((x % 2 == 0 and Len % 2 == 0) or (x % 2 != 0 and Len % 2 != 0)):\n            return True\n \n    return False\n \n# Function to preprocess the string \n# for Manacher's Algorithm \ndef reform (s):\n \n    s1 = '$#'\n \n    # Adding '#' between the characters\n    for i in range(len(s)):\n        s1 += s[i]\n        s1 += '#'\n \n    s1 += '@'\n    return s1\n \n# Function to find the longest palindromic \n# substring using Manacher's Algorithm \ndef longestPal (s, Len):\n \n    # Current Left Position \n    mirror = 0\n   \n    # Center Right Position \n    R = 0\n   \n    # Center Position \n    C = 0\n   \n    # LPS Length Array \n    P = [0] * len(s)\n    x = 0\n   \n    # Get currentLeftPosition Mirror \n    # for currentRightPosition i \n    for i in range(1, len(s) - 1):\n        mirror = 2 * C - i \n \n        # If currentRightPosition i is \n        # within centerRightPosition R \n        if (i < R):\n            P[i] = min((R-i), P[mirror])\n \n        # Attempt to expand palindrome centered \n        # at currentRightPosition i\n        while (s[i + (1 + P[i])] == s[i - (1 + P[i])]):\n            P[i] += 1\n \n        # Check for palindrome\n        ans = checkPal(P[i], Len)\n        if (ans):\n            return True\n         \n        # If palindrome centered at current\n        # RightPosition i expand beyond \n        # centerRightPosition R, adjust centerPosition\n        # C based on expanded palindrome\n        if (i + P[i] > R):\n            C = i \n            R = i + P[i]\n \n    return False\n \n# Driver Code\nif __name__ == '__main__':\n     \n    s = 'aaaad'\n    Len = len(s)\n    s += s\n    s = reform(s)\n    print(longestPal(s, Len))\n \n# This code is contributed by himanshu77\n"], "Longest Palindromic Subsequence (LPS) -  ": ["# Python 3 program of above approach\n \n# A utility function to get max\n# of two integers\n \n \ndef max(x, y):\n    if(x > y):\n        return x\n    return y\n \n# Returns the length of the longest\n# palindromic subsequence in seq\n \n \ndef lps(seq, i, j):\n \n    # Base Case 1: If there is\n    # only 1 character\n    if (i == j):\n        return 1\n \n    # Base Case 2: If there are only 2\n    # characters and both are same\n    if (seq[i] == seq[j] and i + 1 == j):\n        return 2\n \n    # If the first and last characters match\n    if (seq[i] == seq[j]):\n        return lps(seq, i + 1, j - 1) + 2\n \n    # If the first and last characters\n    # do not match\n    return max(lps(seq, i, j - 1),\n               lps(seq, i + 1, j))\n \n \n# Driver Code\nif __name__ == '__main__':\n    seq = ' '\n    n = len(seq)\n    print('The length of the LPS is',\n          lps(seq, 0, n - 1))\n \n# This code contributed by Rajput-Ji\n", "# A Dynamic Programming based Python program for LPS problem\n# Returns the length of the longest palindromic subsequence\n# in seq\n \ndp = [[-1 for i in range(1001)]for j in range(1001)]\n \n# Returns the length of the longest palindromic subsequence\n# in seq\n \n \ndef lps(s1, s2, n1, n2):\n \n    if (n1 == 0 or n2 == 0):\n        return 0\n \n    if (dp[n1][n2] != -1):\n        return dp[n1][n2]\n \n    if (s1[n1 - 1] == s2[n2 - 1]):\n        dp[n1][n2] = 1 + lps(s1, s2, n1 - 1, n2 - 1)\n        return dp[n1][n2]\n    else:\n        dp[n1][n2] = max(lps(s1, s2, n1 - 1, n2), lps(s1, s2, n1, n2 - 1))\n        return dp[n1][n2]\n \n# Driver program to test above functions\n \n \nseq = ' '\nn = len(seq)\n \ns2 = seq\ns2 = s2[::-1]\nprint(f'The length of the LPS is {lps(s2, seq, n, n)}')\n \n# This code is contributed by shinjanpatra\n", "def longestPalinSubseq(S):\n    R = S[::-1]\n \n    # dp[i][j] will store the length of the longest\n    # palindromic subsequence for the substring\n    # starting at index i and ending at index j\n    dp = [[0] * (len(R) + 1) for _ in range(len(S) + 1)]\n \n    # Filling up DP table based on conditions discussed\n    # in the above approach\n    for i in range(1, len(S) + 1):\n        for j in range(1, len(R) + 1):\n            if S[i - 1] == R[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n \n    # At the end, DP table will contain the LPS\n    # So just return the length of LPS\n    return dp[len(S)][len(R)]\n \n \n# Driver code\ns = ' '\nprint('The length of the LPS is', longestPalinSubseq(s))\n \n# This code is contributed by shivamgupta310570\n"], "Shortest Common Supersequence -  ": ["# Python program to find length \n# of the shortest supersequence \n  \n# Function to find length of the \n# shortest supersequence of X and Y. \n  \n  \ndef shortestSuperSequence(X, Y): \n    m = len(X) \n    n = len(Y) \n    l = lcs(X, Y, m, n) \n  \n    # Result is sum of input string \n    # lengths - length of lcs \n    return (m + n - l) \n  \n# Returns length of LCS for \n# X[0..m - 1], Y[0..n - 1] \n  \n  \ndef lcs(X, Y, m, n): \n    L = [[0] * (n + 2) for i in\n         range(m + 2)] \n  \n    # Following steps build L[m + 1][n + 1] \n    # in bottom up fashion. Note that L[i][j] \n    # contains length of LCS of X[0..i - 1] \n    # and Y[0..j - 1] \n    for i in range(m + 1): \n  \n        for j in range(n + 1): \n  \n            if (i == 0 or j == 0): \n                L[i][j] = 0\n  \n            elif (X[i - 1] == Y[j - 1]): \n                L[i][j] = L[i - 1][j - 1] + 1\n  \n            else: \n                L[i][j] = max(L[i - 1][j], \n                              L[i][j - 1]) \n  \n    # L[m][n] contains length of \n    # LCS for X[0..n - 1] and Y[0..m - 1] \n    return L[m][n] \n  \n  \n# Driver code \nX = 'AGGTAB'\nY = 'GXTXAYB'\n  \nprint('Length of the shortest supersequence is %d'\n      % shortestSuperSequence(X, Y)) \n  \n# This code is contributed by Ansu Kumari \n", "# A Naive recursive python program to find \n# length of the shortest supersequence \n  \n  \ndef superSeq(X, Y, m, n): \n    if (not m): \n        return n \n    if (not n): \n        return m \n  \n    if (X[m - 1] == Y[n - 1]): \n        return 1 + superSeq(X, Y, m - 1, n - 1) \n  \n    return 1 + min(superSeq(X, Y, m - 1, n), \n                   superSeq(X, Y, m, n - 1)) \n  \n  \n# Driver Code \nX = 'AGGTAB'\nY = 'GXTXAYB'\nprint('Length of the shortest supersequence is %d'\n      % superSeq(X, Y, len(X), len(Y))) \n  \n# This code is contributed by Ansu Kumari \n", "# A dynamic programming based python program \n# to find length of the shortest supersequence \n  \n# Returns length of the shortest supersequence of X and Y \n  \n  \ndef superSeq(X, Y, m, n): \n    dp = [[0] * (n + 2) for i in range(m + 2)] \n  \n    # Fill table in bottom up manner \n    for i in range(m + 1): \n        for j in range(n + 1): \n  \n            # Below steps follow above recurrence \n            if (not i): \n                dp[i][j] = j \n            elif (not j): \n                dp[i][j] = i \n  \n            elif (X[i - 1] == Y[j - 1]): \n                dp[i][j] = 1 + dp[i - 1][j - 1] \n  \n            else: \n                dp[i][j] = 1 + min(dp[i - 1][j], \n                                   dp[i][j - 1]) \n  \n    return dp[m][n] \n  \n  \n# Driver Code \nX = 'AGGTAB'\nY = 'GXTXAYB'\nprint('Length of the shortest supersequence is %d'\n      % superSeq(X, Y, len(X), len(Y))) \n  \n# This code is contributed by Ansu Kumari \n", "# A dynamic programming based python program  \n# to find length of the shortest supersequence \n  \n# Returns length of the  \n# shortest supersequence of X and Y \n  \ndef superSeq(X,Y,n,m,lookup): \n      \n    if m==0 or n==0: \n        lookup[n][m] = n+m \n  \n    if (lookup[n][m] == 0):      \n        if X[n-1]==Y[m-1]: \n            lookup[n][m] = superSeq(X,Y,n-1,m-1,lookup)+1\n      \n        else: \n            lookup[n][m] = min(superSeq(X,Y,n-1,m,lookup)+1, \n                               superSeq(X,Y,n,m-1,lookup)+1) \n      \n    return lookup[n][m] \n      \n  \n  \n# Driver Code \nX = 'AGGTAB'\nY = 'GXTXAYB'\n  \nlookup = [[0 for j in range(len(Y)+1)]for i in range(len(X)+1)] \nprint('Length of the shortest supersequence is {}'\n      .format(superSeq(X,Y,len(X),len(Y),lookup))) \n  \n# This code is contributed by Tanmay Ambadkar \n"], "Printing Shortest Common Supersequence -  ": ["# A dynamic programming based Python3 program print\n# shortest supersequence of two strings\n \n# returns shortest supersequence of X and Y\ndef printShortestSuperSeq(m, n, x, y):\n \n    # dp[i][j] contains length of shortest \n    # supersequence for X[0..i-1] and Y[0..j-1]\n    dp = [[0 for i in range(n + 1)] \n             for j in range(m + 1)]\n \n    # Fill table in bottom up manner\n    for i in range(m + 1):\n        for j in range(n + 1):\n \n            # Below steps follow recurrence relation\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif x[i - 1] == y[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j],\n                                   dp[i][j - 1])\n \n    # Following code is used to print\n    # shortest supersequence\n \n    # dp[m][n] stores the length of the \n    # shortest supersequence of X and Y\n \n    # string to store the shortest supersequence\n    string = ''\n \n    # Start from the bottom right corner and \n    # add the characters to the output string\n    i = m\n    j = n\n    while i * j > 0:\n \n        # If current character in X and Y are same, \n        # then current character is part of\n        # shortest supersequence\n        if x[i - 1] == y[j - 1]:\n \n            # Put current character in result\n            string = x[i - 1] + string\n \n            # reduce values of i, j and index\n            i -= 1\n            j -= 1\n \n        # If current character in X and Y are different\n        elif dp[i - 1][j] > dp[i][j - 1]:\n \n            # Put current character of Y in result\n            string = y[j - 1] + string\n \n            # reduce values of j and index\n            j -= 1\n        else:\n \n            # Put current character of X in result\n            string = x[i - 1] + string\n \n            # reduce values of i and index\n            i -= 1\n \n    # If Y reaches its end, put remaining characters\n    # of X in the result string\n    while i > 0:\n        string = x[i - 1] + string\n        i -= 1\n \n    # If X reaches its end, put remaining characters\n    # of Y in the result string\n    while j > 0:\n        string = y[j - 1] + string\n        j -= 1\n \n    return string\n \n# Driver Code\nif __name__ == '__main__':\n    x = 'GXTXAYB'\n    y = 'AGGTAB'\n    m = len(x)\n    n = len(y)\n     \n    # Take the smaller string as x and larger one as y\n    if m > n:\n      x, y = y, x\n      m, n = n, m\n     \n    print(*printShortestSuperSeq(m, n, x, y))\n \n# This code is contributed by\n# sanjeev2552\n"], "Shortest Superstring Problem -  ": ["# Python program for the above approach\n \ndef shortestSuperstring(A):\n    n = len(A)\n    graph = [[0 for i in range(n)] for j in range(n)]\n \n    # Build the graph\n    for i in range(n):\n        for j in range(n):\n            graph[i][j] = calc(A[i], A[j])\n            graph[j][i] = calc(A[j], A[i])\n \n    # Creating dp array\n    dp = [[0 for i in range(n)] for j in range(1 << n)]\n \n    # Creating path array\n    path = [[0 for i in range(n)] for j in range(1 << n)]\n    last = -1\n    min_val = float('inf')\n \n    # start TSP DP\n    for i in range(1, (1 << n)):\n        for j in range(n):\n            dp[i][j] = float('inf')\n \n        for j in range(n):\n            if (i & (1 << j)) > 0:\n                prev = i - (1 << j)\n \n                # Check if prev is zero\n                if prev == 0:\n                    dp[i][j] = len(A[j])\n                else:\n                    # Iterate k from 0 to n - 1\n                    for k in range(n):\n                        if dp[prev][k] < float('inf') and dp[prev][k] + graph[k][j] < dp[i][j]:\n                            dp[i][j] = dp[prev][k] + graph[k][j]\n                            path[i][j] = k\n \n                if i == (1 << n) - 1 and dp[i][j] < min_val:\n                    min_val = dp[i][j]\n                    last = j\n \n    # Build the path\n    sb = ''\n    cur = (1 << n) - 1\n \n    # Creating a stack\n    stack = []\n \n    # Until cur is zero\n    # push last\n    while cur > 0:\n        stack.append(last)\n        temp = cur\n        cur -= (1 << last)\n        last = path[temp][last]\n \n    # Build the result\n    i = stack.pop()\n    sb += A[i]\n \n    # Until stack is empty\n    while len(stack) > 0:\n        j = stack.pop()\n        sb += A[j][len(A[j]) - graph[i][j]:]\n        i = j\n \n    return sb\n \n# Function to check \ndef calc(a, b):\n    for i in range(1, len(a)):\n        if b.startswith(a[i:]):\n            return len(b) - len(a) + i\n     \n    # Return size of b\n    return len(b)\n \n# Driver Code\nif __name__ == '__main__':\n    arr = [ 'catgc', 'ctaagt', 'gcta', 'ttca', 'atgcatc' ]\n     \n    # Function Call\n    print('The Shortest Superstring is ' + shortestSuperstring(arr))\n"], "Count distinct occurrences as a subsequence -  ": ["# Python program to count number of times S appears\n# as a subsequence in T \ndef f(i, j, s, t):\n   \n  # base case\n       # if second string completed then we found the\n        # matching pattern\n    if(j >= len(t)):\n        return 1\n       \n      # if first string is completed we can not find any\n      #  matching pattern.\n    if(i >= len(s)):\n        return 0\n       \n      # if character at i'th place is equal to character\n      # at j'th place then\n      # we can either take it or not take it.\n    if(s[i] == t[j]):\n        return f(i + 1, j + 1, s, t) + f(i + 1, j, s, t)\n       \n      # if characters are not equal then we will increase\n      # only first string\n    return f(i + 1, j, s, t)\n \ndef findSubsequenceCount(s, t):\n    return f(0, 0, s, t)\n \n# Driver code to check above method\nT = 'ge'\nS = ' '\nprint(findSubsequenceCount(S,T))\n \n# This code is contributed by Aman Kumar.\n", "# Python3 program to count number of times \n# S appears as a subsequence in T\ndef findSubsequenceCount(S, T):\n \n    m = len(T)\n    n = len(S)\n \n    # T can't appear as a subsequence in S\n    if m > n:\n        return 0\n \n    # mat[i][j] stores the count of \n    # occurrences of T(1..i) in S(1..j).\n    mat = [[0 for _ in range(n + 1)]\n              for __ in range(m + 1)]\n \n    # Initializing first column with all 0s. x\n    # An empty string can't have another\n    # string as subsequence\n    for i in range(1, m + 1):\n        mat[i][0] = 0\n \n    # Initializing first row with all 1s. \n    # An empty string is subsequence of all.\n    for j in range(n + 1):\n        mat[0][j] = 1\n \n    # Fill mat[][] in bottom up manner\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n \n            # If last characters don't match, \n            # then value is same as the value \n            # without last character in S.\n            if T[i - 1] != S[j - 1]:\n                mat[i][j] = mat[i][j - 1]\n                 \n            # Else value is obtained considering two cases.\n            # a) All substrings without last character in S\n            # b) All substrings without last characters in\n            # both.\n            else:\n                mat[i][j] = (mat[i][j - 1] +\n                             mat[i - 1][j - 1])\n \n    return mat[m][n]\n \n# Driver Code\nif __name__ == '__main__':\n    T = 'ge'\n    S = ' '\n    print(findSubsequenceCount(S, T))\n \n# This code is contributed \n# by vibhu4agarwal\n", "# Python program to count number of times S appears\n# as a subsequence in T\n \ndef f(i, j, s, t, dp):\n    # if remaining characters in T are less than remaining characters in S\n    if len(t) - j > len(s) - i:\n        return 0\n \n    # if we have reached the end of T\n    if j == len(t):\n        return 1\n \n    # if we have reached the end of S\n    if i == len(s):\n        return 0\n \n    # if we have already solved this subproblem\n    if dp[i][j] != -1:\n        return dp[i][j]\n \n    if s[i] == t[j]:\n        # count of S as subsequence in T where S and T are both\n        # considering the current character\n        count1 = f(i + 1, j + 1, s, t, dp)\n \n        # count of S as subsequence in T where T is considering\n        # the current character but S is not\n        count2 = f(i + 1, j, s, t, dp)\n        dp[i][j] = count1 + count2\n        return dp[i][j]\n \n    # if current characters of S and T don't match\n    dp[i][j] = f(i + 1, j, s, t, dp)\n    return  dp[i][j] \n \ndef findSubsequenceCount(s, t):\n    # create a 2D array to store the subproblem solutions\n    dp = [[-1 for j in range(len(t))] for i in range(len(s))]\n    return f(0, 0, s, t, dp)\n \n# Driver code to check above method\nif __name__ == '__main__':\n    T = 'ge'\n    S = ' '\n    print(findSubsequenceCount(S, T))\n"], "Count Distinct Subsequences -  ": ["# Python3 program to print\n# distinct subsequences of\n# a given string\nimport math\n \n# Create an empty set\n# to store the subsequences\nsn = []\nglobal m\nm = 0\n \n# Function for generating\n# the subsequences\n \n \ndef subsequences(s, op, i, j):\n \n    # Base Case\n    if(i == m):\n        op[j] = None\n        temp = ''.join([i for i in op if i])\n \n        # Insert each generated\n        # subsequence into the set\n        sn.append(temp)\n        return\n \n    # Recursive Case\n    else:\n \n        # When a particular\n        # character is taken\n        op[j] = s[i]\n \n        subsequences(s, op,\n                     i + 1, j + 1)\n \n        # When a particular\n        # character isn't taken\n        subsequences(s, op,\n                     i + 1, j)\n        return\n \n \n# Driver Code\nstr = 'ggg'\nm = len(str)\nn = int(math.pow(2, m) + 1)\n \n# Output array for storing\n# the generating subsequences\n# in each call\nop = [None for i in range(n)]\n \n# Function Call\nsubsequences(str, op, 0, 0)\n \n# Output will be the number\n# of elements in the set\nprint(len(set(sn)))\n \n# This code is contributed by avanitrachhadiya2155\n", "# Python3 program to count number of \n# distinct subsequences of a given string\n \nMAX_CHAR = 256\n \ndef countSub(ss):\n \n    # create an array to store index of last\n    last = [-1 for i in range(MAX_CHAR + 1)]\n     \n    # length of input string\n    n = len(ss)\n     \n    # dp[i] is going to store count of \n    # discount subsequence of length of i\n    dp = [-2 for i in range(n + 1)]\n      \n    # empty substring has only \n    # one subsequence\n    dp[0] = 1\n     \n    # Traverse through all lengths\n    # from 1 to n \n    for i in range(1, n + 1):\n         \n        # number of subsequence with \n        # substring str[0...i-1]\n        dp[i] = 2 * dp[i - 1]\n \n        # if current character has appeared\n        # before, then remove all subsequences\n        # ending with previous occurrence.\n        if last[ord(ss[i - 1])] != -1:\n            dp[i] = dp[i] - dp[last[ord(ss[i - 1])]]\n        last[ord(ss[i - 1])] = i - 1\n     \n    return dp[n]\n     \n# Driver code\nprint(countSub('gfg'))\n \n# This code is contributed \n# by mohit kumar 29\n", "# Python3 program for above approach \n \n# Returns count of distinct  \n# subsequences of str. \ndef countSub(s):\n     \n    Map = {}\n \n    # Iterate from 0 to length of s \n    for i in range(len(s)):\n        Map[s[i]] = -1\n \n    allCount = 0\n    levelCount = 0\n \n    # Iterate from 0 to length of s \n    for i in range(len(s)):\n        c = s[i]\n \n        # Check if i equal to 0 \n        if (i == 0):\n            allCount = 1\n            Map = 1\n            levelCount = 1\n            continue\n \n        # Replace levelCount with \n          # allCount + 1 \n        levelCount = allCount + 1\n \n        # If map is less than 0 \n        if (Map < 0):\n            allCount = allCount + levelCount\n        else:\n            allCount = allCount + levelCount - Map\n \n        Map = levelCount\n \n    # Return answer\n    return allCount\n \n# Driver Code\nList = [ 'abab', 'gfg' ]\n \nfor s in List:\n    cnt = countSub(s)\n    withEmptyString = cnt + 1\n \n    print('With empty string count for',\n          s, 'is', withEmptyString)\n    print('Without empty string count for',\n          s, 'is', cnt)\n \n# This code is contributed by rag2127\n"], "Print all subsequences of a string -  ": ["# Below is the implementation of the above approach\ndef printSubsequence(input, output):\n \n    # Base Case\n    # if the input is empty print the output string\n    if len(input) == 0:\n        print(output, end=' ')\n        return\n \n    # output is passed with including the\n    # 1st character of input string\n    printSubsequence(input[1:], output+input[0])\n \n    # output is passed without including the\n    # 1st character of input string\n    printSubsequence(input[1:], output)\n \n \n# Driver code\n# output is set to null before passing in\n# as a parameter\noutput = ''\ninput = 'abcd'\n \nprintSubsequence(input, output)\n \n# This code is contributed by Tharun Reddy\n", "# Python program to print all subsequence of a\n# given string.\n \n# set to store all the subsequences\nst = set()\n \n# Function computes all the subsequence of an string\ndef subsequence(str):\n \n    # Iterate over the entire string\n    for i in range(len(str)):\n \n        # Iterate from the end of the string\n        # to generate substrings\n        for j in range(len(str),i,-1):\n            sub_str = str[i: i+j]\n            st.add(sub_str)\n \n            # Drop kth character in the substring\n            # and if its not in the set then recur\n            for k in range(1,len(sub_str)):\n                sb = sub_str\n \n                # Drop character from the string\n                sb = sb.replace(sb[k],'')\n                subsequence(sb)\n \n# Driver Code\n \ns = 'aabc'\nsubsequence(s)\nfor i in st:\n    print(i,end = ' ')\nprint()\n \n# This code is contributed by shinjanpatra\n", "# Python program to generate power set in lexicographic order.\n \n # str: Stores input string\n # n: Length of str.\n # curr: Stores current permutation\n # index: Index in current permutation, curr\ndef printSubSeqRec(str, n, index = -1, curr = ''):\n   \n  # base case\n     if (index == n):\n       return\n     if (len(curr) > 0):\n       print(curr)\n \n     i = index + 1\n \n     while(i < n):\n        curr = curr + str[i]\n        printSubSeqRec(str, n, i, curr)\n        curr = curr[0:-1]\n        i = i + 1\n        \n#  Generates power set in lexicographic order.\n#  function\ndef printSubSeq(str):\n   printSubSeqRec(str, len(str))\n \n# // Driver code\nstr = 'cab'\nprintSubSeq(str)\n \n# This code is contributed by shinjanpatra\n", "def print_subset(s, i):\n    j = 0\n    sub = ''\n    #finding where the bit is set\n    while i > 0:\n        if i & 1:\n            sub += s[j] #pushing only when bit is set \n        j += 1 #always incrementing the index pointer\n        i = i >> 1\n    return sub\n \ndef createsubsets(s):\n    res = []\n    for i in range(1, (1 << len(s))):\n        #each time we create a subsequence for corresponding binary representation\n        res.append(print_subset(s, i))\n    return res\n \nif __name__ == '__main__':\n    s = 'abc'\n    #vector of strings to store all sub-sequences\n    subsets = createsubsets(s)\n     \n    #print function\n    for subset in subsets:\n        for c in subset:\n            print(c, end=' ')\n        print()\n \n# This code is contributed Shivam Tiwari\n"], "Find i'th Index character in a binary string obtained after n iterations -  ": ["# Python3 Program to find ith character in \n# a binary string.\n \n# Function to store binary Representation\ndef binary_conversion(s, m):\n    while(m):\n        temp = m % 2\n        s += str(temp)\n        m = m // 2\n     \n    return s[::-1]\n \n# Function to find ith character\ndef find_character(n, m, i):\n    s = ''\n \n \n# Function to change decimal to binary\n    s = binary_conversion(s, m)\n    s1 = ''\n \n    for x in range(n):\n        for j in range(len(s)):\n            if s[j] == '1':\n                s1 += '10'\n            else:\n                s1 += '01'\n \n    # Assign s1 string in s string     \n        s = s1\n        s1 = ''\n    e = ord(s[i])\n    r = ord('0')\n \n    return e-r\n \n# Driver code\nm, n, i = 5, 2, 8\n \nprint(find_character(n,m,i))\n \n# This code is contributed by mohit kumar 29\n"], "Generate all binary strings without consecutive 1's -  ": ["# Python3 program to Generate all binary string \n# without consecutive 1's of size K\n \n# A utility function generate all string without\n# consecutive 1'sof size K\ndef generateAllStringsUtil(K, str, n):\n     \n    # print binary string without consecutive 1's\n    if (n == K):\n         \n        # terminate binary string\n        print(*str[:n], sep = '', end = ' ')\n        return\n     \n    # if previous character is '1' then we put\n    # only 0 at end of string\n    # example str = '01' then new string be '000'\n    if (str[n-1] == '1'):\n        str[n] = '0'\n        generateAllStringsUtil (K, str, n + 1)\n         \n    # if previous character is '0' than we put\n    # both '1' and '0' at end of string\n    # example str = '00' then new string '001' and '000'\n    if (str[n-1] == '0'):\n        str[n] = '0'\n        generateAllStringsUtil(K, str, n + 1)\n        str[n] = '1'\n        generateAllStringsUtil(K, str, n + 1) \n         \n# function generate all binary string without\n# consecutive 1's\ndef generateAllStrings(K):\n     \n    # Base case\n    if (K <= 0):\n        return\n     \n    # One by one stores every \n    # binary string of length K\n    str = [0] * K\n     \n    # Generate all Binary string starts with '0'\n    str[0] = '0'\n    generateAllStringsUtil (K, str, 1) \n     \n    # Generate all Binary string starts with '1'\n    str[0] = '1'\n    generateAllStringsUtil (K, str, 1)\n \n# Driver code\nK = 3\ngenerateAllStrings (K) \n \n# This code is contributed by SHUBHAMSINGH10\n", "def All_Binary_Strings(arr,num,r):\n \n    if(r == num):\n \n        for i in range(num):\n            print(arr[i],end='')\n        print(end=' ')\n        return\n     \n    elif(arr[r-1]):\n \n        arr[r] = 0\n        All_Binary_Strings(arr, num, r + 1)\n \n    else:\n     \n        arr[r] = 0\n        All_Binary_Strings(arr,num,r+1)\n        arr[r] = 1\n        All_Binary_Strings(arr,num,r+1)\n \n \ndef Print(a,num):\n    a[0] = 0\n    All_Binary_Strings(a,num,1)\n    a[0] = 1\n    All_Binary_Strings(a,num,1)\n \n \n# driver's code\n \nn = 2\na = [False for i in range(n)]\nPrint(a,n)\n \n# This code is contributed by shinjanpatra\n", "def All_Binary_Strings(str,num):\n \n    Len = len(str)\n    if(Len == num):\n        print(str,end = ' ')\n        return\n \n    elif(str[Len - 1]=='1'):\n        All_Binary_Strings(str+'0',num)\n    else:\n        All_Binary_Strings(str+'0',num)\n        All_Binary_Strings(str+'1',num)\n \ndef Print(num):\n \n    word = ''\n    word += '0'\n    All_Binary_Strings(word,num)\n    word = '1'\n    All_Binary_Strings(word,num)\n \n# Driver's code\nn = 4\nPrint(n)\n \n# This code is contributed by shinjanpatra.\n", "def generate_binary_strings(n: int):\n    if n == 0:\n        return ['']\n    if n == 1:\n        return ['0', '1']\n    result = []\n    for s in generate_binary_strings(n-1):\n        result.append(s + '0')\n        if s[-1] != '1':\n            result.append(s + '1')\n    return result\n \n# Example usage\narr = generate_binary_strings(4)\nfor i in arr:\n      print(i,end=' ')\n \n# This code is contributed by Susobhan Akhuli\n"], "Min flips of continuous characters to make all characters same in a string -  ": ["# Python 3 program to find min flips in \n# binary string to make all characters equal\n \n# To find min number of flips in\n# binary string\ndef findFlips(str, n):\n \n    last = ' '\n    res = 0\n \n    for i in range( n) :\n \n        # If last character is not equal\n        # to str[i] increase res\n        if (last != str[i]):\n            res += 1\n        last = str[i]\n \n    # To return min flips\n    return res // 2\n \n# Driver Code\nif __name__ == '__main__':\n     \n    str = '00011110001110'\n    n = len(str)\n \n    print(findFlips(str, n))\n \n# This code is contributed by ita_c\n"], "Binary representation of next number -  ": ["# Python3 implementation to find the binary\n# representation of next greater integer\n \n# function to find the required\n# binary representation\ndef nextGreater(num1):\n \n    l = len(num1);\n    num = list(num1);\n \n    # examine bits from the right\n    i = l-1;\n    while(i >= 0):\n        # if '0' is encountered, convert\n        # it to '1' and then break\n        if (num[i] == '0'):\n            num[i] = '1';\n            break;\n \n        # else convert '1' to '0'\n        else:\n            num[i] = '0';\n        i-=1;\n \n    # if the binary representation\n    # contains only the set bits\n    num1 = ''.join(num);\n    if (i < 0):\n        num1 = '1' + num1;\n \n    # final binary representation\n    # of the required integer\n    return num1;\n \n# Driver Code\nnum = '10011';\nprint('Binary representation of next number = ',nextGreater(num));\n \n# This code is contributed by mits\n", "def nextGreater(num):\n    # Convert binary string to integer\n    n = int(num, 2)\n     \n    # Increment integer by 1\n    n += 1\n     \n    # Convert integer back to binary string\n    result = bin(n)[2:]\n     \n    # Remove leading zeros\n    result = result.lstrip('0')\n     \n    return result\n \ndef main():\n    num = '10011'\n    print('Binary representation of next number =', nextGreater(num))\n \nif __name__ == '__main__':\n    main()\n"], "Number of flips to make binary string alternate | Set 1 -  ": ["# Python 3 program to find minimum number of\n# flip to make binary string alternate\n \n# Utility method to flip a character\ndef flip( ch):\n    return '1' if (ch == '0') else '0'\n \n# Utility method to get minimum flips when\n# alternate string starts with expected char\ndef getFlipWithStartingCharcter(str, expected):\n \n    flipCount = 0\n    for i in range(len( str)):\n         \n        # if current character is not expected,\n        # increase flip count\n        if (str[i] != expected):\n            flipCount += 1\n \n        # flip expected character each time\n        expected = flip(expected)\n    return flipCount\n \n# method return minimum flip to make binary\n# string alternate\ndef minFlipToMakeStringAlternate(str):\n \n    # return minimum of following two\n    # 1) flips when alternate string starts with 0\n    # 2) flips when alternate string starts with 1\n    return min(getFlipWithStartingCharcter(str, '0'),\n            getFlipWithStartingCharcter(str, '1'))\n \n# Driver code to test above method\nif __name__ == '__main__':\n     \n    str = '0001010111'\n    print(minFlipToMakeStringAlternate(str))\n"], "Check if all bits can be made same by single flip -  ": ["# python program to check if a single\n# bit can be flipped tp make all ones\n \n# This function returns true if we can\n# bits same in given binary string str.\ndef canMakeAllSame(str):\n    zeros = 0\n    ones = 0\n \n    # Traverse through given string and\n    # count numbers of 0's and 1's\n    for i in range(0, len(str)):\n        ch = str[i];\n        if (ch == '0'):\n            zeros = zeros + 1\n        else:\n            ones = ones + 1\n \n    # Return true if any of the two\n    # counts is 1\n    return (zeros == 1 or ones == 1);\n \n# Driver code\nif(canMakeAllSame('101')):\n    print('Yes\\n')\nelse:\n    print('No\\n')\n \n# This code is contributed by Sam007.\n"], "Remove all occurrences of a character in a string -  ": ["# Python3 program to remove\n# a particular character\n# from a string.\n \n# function for removing the \n# occurrence of character\ndef removeChar(s, c) :\n     \n    # find total no. of \n    # occurrence of character\n    counts = s.count(c)\n \n    # convert into list \n    # of characters\n    s = list(s)\n \n    # keep looping until \n    # counts become 0\n    while counts :\n         \n        # remove character\n        # from the list\n        s.remove(c)\n \n        # decremented by one\n        counts -= 1\n \n    # join all remaining characters\n    # of the list with empty string \n    s = '' . join(s)\n     \n    print(s)\n \n# Driver code\nif __name__ == '__main__' :\n     \n    s = ' '\n    removeChar(s,'g')\n     \n# This code is contributed \n# by Ankit Rai\n", "# Python3 code for above approach\ndef removechar(word, ch):\n    i = 0\n    while(i < len(word)):\n     \n        if(word[i] == ch):\n            word = word[:i] + word[i+1:]\n            i -= 1\n        i += 1\n     \n    return word\n \n# driver's code\nword=' '\nch='e'\nprint(removechar(word,ch))\n \n# This code is contributed by Akshay Tripathi\n", "# Python3 program to remove a particular character\n \n# function for removing the \n# occurrence of character using replace() function\ndef removeChar(word, ch) :\n  word = word.replace(ch,'')\n  print(word)\n \n# Driver code\nif __name__ == '__main__' :\n   \n  word = ' '\n  removeChar(word,'k')\n \n# This Code is contributed by Pratik Gupta\n", "# Function to remove all occurrences\n# of a character in the string\n \n \ndef removeChar(str, ch):\n    # Base Case\n    if len(str) == 0:\n        return ''\n \n    # Check the first character\n    # of the given string\n    if str[0] == ch:\n \n        # Pass the rest of the string\n        # to recursion Function call\n        return removeChar(str[1:], ch)\n \n    # Add the first character of str\n    # and string from recursion\n    return str[0] + removeChar(str[1:], ch)\n \n \n# Driver Code\nif __name__ == '__main__':\n    # Given String\n    str = ' '\n \n    # Function Call\n    str = removeChar(str, 'g')\n    print(str)\n"], "Concatenating Two Strings in C -  ": [], "Program to check if two strings are same or not -  ": ["# Python3 program to check 2 strings are identical or not\n \nif __name__ == '__main__':\n   \n  #first string.\n  string1 = ' '\n  #second string.\n  string2 = 'Geeks for geeks'\n \n  #check condition\n  if (string1 is string2):\n    print('Strings Are Equal')\n  else:\n    print('Strings Are Not Equal')\n \n   \n  # This Code is contributed by Pratik Gupta\n", "# Python program to check if\n# two strings are identical\n \nif __name__ == '__main__':\n \n    # Get the strings which\n    # is to be checked\n    string1 = input('Enter the first string: ')\n    print(string1, end='\\n')\n \n    # Get the strings which\n    # is to be checked\n    string2 = input('Enter the second string: ')\n    print(string2, end='\\n')\n \n    # Check if both strings are equal\n    print('Are both strings same: ', end=' ')\n \n    if (string1 == string2):\n        print('Yes')\n \n    else:\n        print('No')\n \n# This code is contributed by Ryuga\n", "# Python Program to check\n# if two strings are same or not\n# using != operator\n \n \ndef is_string_same(str1, str2):\n \n    if str1 != str2:\n        return 0\n    else:\n        return 1\n \n# Driver Code\n \n \n# First String\ns1 = ' '\n \n# Second String\ns2 = 'Geeks for geeks'\n \n# Storing the Result\nresult = is_string_same(s1, s2)\n \n# Checking the value stored in result\n# if returned 0 then Strings are not same\n# Else returned 1 then strings are same\n \nif result == 0:\n    print('Strings are Not Equal')\nelse:\n    print('Strings are Equal')\n"], "How to insert characters in a string at a certain position? -  ": ["# Python3 code to implement the above approach\n \n# Function to add stars\ndef addStars(s, stars) :\n \n    # Create a string ans for storing\n    # resultant string\n    ans = '';\n    j = 0;\n \n    for i in range(len(s)) :\n \n        # If the count of characters\n        # become equal to the stars[j],\n        # append star\n        if (j < len(stars) and i == stars[j]) :\n            ans += '*';\n            j += 1;\n        ans += s[i];\n    return ans;\n \n# Driver code\nif __name__ == '__main__' :\n    string = ' ';\n    chars = [ 1, 5, 7, 9 ];\n    ans = addStars(string, chars);\n \n    # Printing the resultant string\n    print(ans);\n     \n    # This code is contributed by AnkThon\n", "# Function to add stars\ndef addStars(s, stars):\n   \n    # Iterate through the vector of positions\n    k = 0\n    for i in range(len(stars)):\n       \n        # Insert a star at the specified position\n        s = s[:stars[i]+k] + '*' + s[stars[i]+k:]\n        k += 1\n    return s\n \n \n# Driver code\nstr = ' '\nchars = [1, 5, 7, 9]\nans = addStars(str, chars)\n \n# Printing the resultant string\nprint(ans)\n"], "C program to find the length of a string -  ": [], "Swap characters in a String -  ": ["# Python Program to Swap characters in a String\ndef swapCharacters(s, B, C):\n    N = len(s)\n    # If c is greater than n\n    C = C % N\n    # loop to swap ith element with (i + C) % n th element\n    s = list(s)\n    for i in range(B):\n        s[i], s[(i + C) % N] = s[(i + C) % N], s[i]\n    return ''.join(s)\n \n# Driver code\ns = 'ABCDEFGH'\nB = 4\nC = 3\ns = swapCharacters(s, B, C)\nprint(s)\n \n# This code is contributed by Susobhan Akhuli\n", "# Python3 program to find new after swapping \n# characters at position i and i + c \n# b times, each time advancing one \n# position ahead \n \n# Method to find the required string \ndef swapChars(s, c, b):\n     \n    # Get string length \n    n = len(s)\n     \n    # If c is larger or equal to the length of \n    # the string is effectively the remainder of \n    # c divided by the length of the string \n    c = c % n\n     \n    if (c == 0):\n         \n        # No change will happen \n        return s\n         \n    f = int(b / n)\n    r = b % n\n     \n    # Rotate first c characters by (n % c) \n    # places f times \n    p1 = rotateLeft(s[0 : c], ((c * f) % (n - c)))\n     \n    # Rotate remaining character by \n    # (n * f) places \n    p2 = rotateLeft(s[c:], ((c * f) % (n - c)))\n     \n    # Concatenate the two parts and convert the \n    # resultant string formed after f full \n    # iterations to a character array \n    # (for final swaps) \n    a = p1 + p2\n    a = list(a)\n     \n    # Remaining swaps \n    for i in range(r):\n         \n        # Swap ith character with \n        # (i + c)th character \n        temp = a[i]\n        a[i] = a[(i + c) % n]\n        a[(i + c) % n] = temp\n \n    # Return final string \n    return str(''.join(a))\n \ndef rotateLeft(s, p):\n     \n    # Rotating a string p times left is \n    # effectively cutting the first p \n    # characters and placing them at the end \n    return s[p:] + s[0 : p]\n \n# Driver code \n \n# Given values \ns1 = 'ABCDEFGHIJK'\nb = 1000\nc = 3\n \n# Get final string \ns2 = swapChars(s1, c, b)\n \n# Print final string \nprint(s2)\n \n# This code is contributed by avanitrachhadiya2155\n"], "Print the frequency of each character in Alphabetical order -  ": ["# Python3 implementation of the approach \nMAX = 26; \n \n# Function to print the frequency \n# of each of the characters of \n# s in alphabetical order \ndef compressString(s, n) :\n \n    # To store the frequency \n    # of the characters \n    freq = [ 0 ] * MAX; \n \n    # Update the frequency array \n    for i in range(n) :\n        freq[ord(s[i]) - ord('a')] += 1; \n \n    # Print the frequency in alphatecial order \n    for i in range(MAX) : \n \n        # If the current alphabet doesn't \n        # appear in the string \n        if (freq[i] == 0) :\n            continue; \n \n        print((chr)(i + ord('a')),freq[i],end = ' '); \n \n# Driver code \nif __name__ == '__main__' : \n \n    s = ' '; \n    n = len(s); \n \n    compressString(s, n); \n \n# This code is contributed by AnkitRai01\n", "# Python program for the above approach\ns = ' '\n# map of char-int pair\nmp = {}\n \n# map over string\nfor i in range(len(s)):\n    if(mp.get(s[i]) != None):\n        mp[s[i]] = mp.get(s[i])+1\n    else:\n        mp[s[i]] = 1\n     \n# printing the char with frequency\nmyKeys = list(mp.keys())\nmyKeys.sort()\nmp = {i : mp[i] for i in myKeys}\nfor i in mp:\n    print(i, end='')\n    print(mp[i], end='')\n", "# Recursive function to compress a string\ndef compressString(s, n, i, letter, count):\n    # Base case: if i>size of string then return\n    if i > n - 1:\n        return\n \n    # If the letter is equal to the s[i], then increment count by 1\n    if s[i] == letter:\n        count += 1\n \n    # Call the recursive function again with i+1\n    compressString(s, n, i + 1, letter, count)\n \n    return count\n \n# Driver code\nif __name__ == '__main__':\n    s = ' ' # input string\n    n = len(s) # size of string\n \n    for letter in range(ord('a'), ord('z') + 1):\n        letter = chr(letter)\n        count = compressString(s, n, 0, letter, 0)\n \n        if count == 0: # if count equal to 0 continue\n            continue\n \n        print(letter, count, end = '') # Print the letter with count\n"], "Left Rotation and Right Rotation of a String -  ": ["# Python3 program for Left \n# Rotation and Right\n# Rotation of a String\n \n# In-place rotates s towards left by d\ndef leftrotate(s, d):\n    tmp = s[d : ] + s[0 : d]\n    return tmp\n   \n# In-place rotates s \n# towards right by d\ndef rightrotate(s, d):\n   \n   return leftrotate(s, len(s) - d)\n \n# Driver code\nif __name__=='__main__':\n     \n    str1 = ' '\n    print(leftrotate(str1, 2))\n  \n    str2 = ' '\n    print(rightrotate(str2, 2))\n \n# This code is contributed by Rutvik_56\n", "# Python3 program for Left\n# Rotation and Right\n# Rotation of a String\n \ndef leftrotate(str1, n):\n    # extended string \n    temp = str1 + str1\n    l = len(str1)\n    # Return string \n    return temp[n :l+n]\ndef rightrotate(str1, n):\n    return leftrotate(str1, len(str1)-n)\n     \n    return temp[l-n : l1-n  ]\n# Driver code\nif __name__=='__main__':\n     \n    str1 = ' '\n    print(leftrotate(str1, 2))\n \n    str2 = ' '\n    print(rightrotate(str2, 2))\n \n# This code is contributed by sam snehil\n", "from collections import deque\n \ndef left_rotate_string(s, d):\n    char_deque = deque(s)\n    char_deque.rotate(-d)\n    return ''.join(char_deque)\n \ndef right_rotate_string(s, d):\n    char_deque = deque(s)\n    char_deque.rotate(d)\n    return ''.join(char_deque)\n \ns = ' '\nd = 2\nprint('Left Rotation:', left_rotate_string(s, d))\nprint('Right Rotation:', right_rotate_string(s, d))\n \ns = 'qwertyu'\nd = 2\nprint('Left Rotation:', left_rotate_string(s, d))\nprint('Right Rotation:', right_rotate_string(s, d))\n"], "Reverse a String -  ": ["# Python program to reverse a string using stack\n \ndef reversebyStack(str):\n     \n    # using as stack\n    stack = []\n \n    for i in range(len(str)):\n      # Push the charcters into stack\n        stack.append(str[i])\n     \n    for i in range(len(str)):\n       # Pop the charcters of stack into the original string.\n        str[i] = stack.pop()\n \nif __name__ == '__main__':\n    str = ' '\n \n    # converting string to list\n    # because strings do not support\n    # item assignment\n    str = list(str)\n    reversebyStack(str)\n \n    # converting list to string\n    str = ''.join(str)\n    print(str)\n     \n# This code is contributed by\n# sanjeev2552\n", "# A Simple Iterative Python program to \n# reverse a string\n \n# Function to reverse a string\ndef reverseStr(str):\n    n = len(str)\n \n    i, j = 0, n-1\n \n    # Swap character starting from\n    # two corners\n    # i is the left pointer and j is the right pointer\n    while i < j:\n        str[i], str[j] = str[j], str[i]\n \n        i += 1\n        j -= 1\n \n \n# Driver code\nif __name__ == '__main__':\n    str = ' '\n \n    # converting string to list\n    # because strings do not support\n    # item assignment\n    str = list(str)\n    reverseStr(str)\n \n    # converting list to string\n    str = ''.join(str)\n \n    print(str)\n \n# This code is contributed by\n# sanjeev2552\n", "# Recursive Python program to reverse a string\n \ndef recursiveReverse(str, i = 0):\n    n = len(str)\n \n    if i == n // 2:\n        return\n    # Swap the i and n-i-1 character\n    str[i], str[n-i-1] = str[n-i-1], str[i]\n     \n    # Call Recursive function after incrementing i.\n    recursiveReverse(str, i+1)\n \nif __name__ == '__main__':\n    str = ' '\n \n    # converting string to list\n    # because strings do not support\n    # item assignment\n    str = list(str)\n    recursiveReverse(str)\n \n    # converting list to string\n    str = ''.join(str)\n    print(str)\n \n# This code is contributed by \n# sanjeev2552\n", "# Driver Code\nif __name__ == '__main__':\n    str = ' ' # Input String\n \n    # Step 1: Initialise an object of StringBuffer class\n    sb = str[::-1]\n \n    # Step 2: Invoke the .reverse() method (not applicable in Python)\n \n    # Step 3: Print the reversed string\n    print(sb)\n"], "Searching For Characters and Substring in a String in Java -  ": [], "PHP | Strings -  ": [], "JavaScript String Methods -  ": [], "C# | String -  ": []}